
## TODO

- [ ] Sítio
    - [ ] Ativar plugin bibtex

- [x] Tipos
    - [x] Fortemente tipada: sem conversão automática
    - [x] Statically typed: em tempo de compilação.
    - [x] Exemplo python e tipos mutantes
    - [x] Inferência de tipos.
    - [x] Tipos explícitos
    - [ ] Tipos especificados pelo usuário
    - [ ] Tipos algébricos
          ```hs
          data  Maybe a     =  Nothing | Just a  deriving (Eq, Ord, Read, Show)  https://www.youtube.com/watch?v=b9FagOVqxmI
          data  Either a b  =  Left a | Right b  deriving (Eq, Ord, Read, Show)  
          data  Ordering    =  LT | EQ | GT deriving  
                                  (Eq, Ord, Bounded, Enum, Read, Show)
          ```
          - Árvores



- [ ] Listas
    - [ ] sao homogeneas
    - [ ] range operator [1..10]
    - [ ] : cons
    - [ ] ++ append
    - [ ] !! get at index

- [ ] Tuplas

- [ ] Funções
     - [x] Guarda
     - [ ] case
     - [ ] Pattern matching
     - [ ] Recursão: # de calda?
     - [ ] Currying:
     - [ ] Funções de Alta Ordem:
        na intro

        There are a number of concepts which are the main corner stones of functional programming, such as first-class and higher-order functions, pure functions, recursion, strict versus non-strict evaluation, and type systems. Higher-order functions can take other functions as arguments or return them as results. An example of a higherorder functions is an integrator or differential operator as it returns a function. Pure functions have no side effects (memory or I/O). This means that pure functions are very useful to optimize code. For example, if the result of a pure expression is not used, it can be removed without affecting the other expressions. If there is no data dependency between two pure expressions, then their order can be reversed or they can be performed in parallel and not interfere with each other. This means pure expressions are thread safe. To allow compilers to optimize code more easily in other languages, there is usually keywords you can add to tell the compiler the function is pure. Recursion functions invoke themselves, performing an operation multiple times unit the base case is reached. Common patterns of recursion can be re-factored using higher order functions. Some recursions require maintaining a stack but tail recursions can be optimized into the same code used to implement iteration in imperative languages. Functional programming that is limited to well-founded recursion with a few other constraints is called total functional programming [24].
        Strict versus non-strict evaluation is a concept that divides functional languages by whether they use strict (eager) or nonstrict (lazy) evaluation. Figure 8 presents an example. Under strict evaluation the entire term and function and evaluated, meaning if any term of the expression would fail, the whole expression would fail. Under non-strict evaluation, the length function will return the value 4 since evaluation it will not attempt to evaluate the terms making p the list. The usual implementation strategy for non-strict evaluation in functional languages is graph reduction [25].

     - where
     - let in 

- [ ] Mais Haskell
     - [ ] Comunicação entre linguagens
     - [ ] Paralelismo e Distribuição:
        - actors
     - [ ] Entrada e saída:
     - [ ] Mônadas:

- Cálculo Lambda:
    - transparência referencial
    - idempotência
- Algoritmos de Ordenação:

- quickcheck
- Encapsulamento, herança, polimorfismo
- lazy
- camelCase



to import code

```hs
--8<--
docs/code/fstsnd.hs
--8<--
```
