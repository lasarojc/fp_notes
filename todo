
## TODO

- [ ] Sítio
    - [ ] Ativar plugin bibtex

- [x] Tipos
    - [x] Fortemente tipada: sem conversão automática
    - [x] Statically typed: em tempo de compilação.
    - [x] Exemplo python e tipos mutantes
    - [x] Inferência de tipos.
    - [x] Tipos explícitos
    - [x] Tipos especificados pelo usuário
    - [ ] Tipos algébricos
        *
          ```hs
          data  Maybe a     =  Nothing | Just a  deriving (Eq, Ord, Read, Show)  https://www.youtube.com/watch?v=b9FagOVqxmI
          data  Either a b  =  Left a | Right b  deriving (Eq, Ord, Read, Show)  
          data  Ordering    =  LT | EQ | GT deriving  
                                  (Eq, Ord, Bounded, Enum, Read, Show)
          ```
        * Casamento de padrões          
        - Árvores
    - [ ] Polimorfismo - funções que se aplicam a vários tipos - generics
            - type variables
            - `head :: [a] -> a`
            - `swap :: (a,b) -> (b,a)
    - [ ] Type classes
        - data
        - `(==) :: (Eq a) => a -> a -> Bool ` -- O tipo a está restrito à classe Eq, isto é, a pertence à classe Eq, que define a interface para teste de igualdade.
        - `(>) :: (Ord a) => a -> a -> Bool ` --  Ord > < >= <=
        - `compare` retorna um Ordering, que pode ser GT LT ou EQ
        - Ord está contido em Eq
        - http://learnyouahaskell.com/types-and-typeclasses#believe-the-type



- [ ] Listas
    - [ ] sao homogêneas
    - [ ] range operator [1..10]
    - [ ] : cons
    - [ ] ++ append
    - [ ] !! get at index
    - [ ] lazy - mostrar com listas infinitas
    - [ ] Pattern matching
    - [ ] Compreensão de listas

- [x] Tuplas

- [ ] Funções
    - [x] Equações simples
    - [x] Guarda
    - [ ] where 
    - [ ] let in 

    - [ ] Recursão
        - [x] funções recursivas
        - [ ] de calda
        - [ ] de estruturas
    - [ ] Currying:
    - [ ] Funções de Alta Ordem:
        - There are a number of concepts which are the main corner stones of functional programming, such as first-class and higher-order functions, pure functions, recursion, strict versus non-strict evaluation, and type systems. Higher-order functions can take other functions as arguments or return them as results. An example of a higherorder functions is an integrator or differential operator as it returns a function. Pure functions have no side effects (memory or I/O). This means that pure functions are very useful to optimize code. For example, if the result of a pure expression is not used, it can be removed without affecting the other expressions. If there is no data dependency between two pure expressions, then their order can be reversed or they can be performed in parallel and not interfere with each other. This means pure expressions are thread safe. To allow compilers to optimize code more easily in other languages, there is usually keywords you can add to tell the compiler the function is pure. Recursion functions invoke themselves, performing an operation multiple times unit the base case is reached. Common patterns of recursion can be re-factored using higher order functions. Some recursions require maintaining a stack but tail recursions can be optimized into the same code used to implement iteration in imperative languages. Functional programming that is limited to well-founded recursion with a few other constraints is called total functional programming [24]. Strict versus non-strict evaluation is a concept that divides functional languages by whether they use strict (eager) or nonstrict (lazy) evaluation. Figure 8 presents an example. Under strict evaluation the entire term and function and evaluated, meaning if any term of the expression would fail, the whole expression would fail. Under non-strict evaluation, the length function will return the value 4 since evaluation it will not attempt to evaluate the terms making p the list. The usual implementation strategy for non-strict evaluation in functional languages is graph reduction [25].
        - .
        - $


- [ ] Pattern matching
    - [x] case-of
    - [x] Declaração de funções
    - [ ] as pattern - `@`
        ```hs
        takeWhere _ [] = []
        takeWhere w list@(x:xs)
            | w < 0 = drop 1 (reverse list)
            | w == 0 = list
            | otherwise = xs
        ```

- [ ] Entrada e saída:
    - [ ] Show
    - [ ] Read
    - [ ] Monads

- [ ] Mais Haskell
    - [ ] Comunicação entre linguagens
    - [ ] Paralelismo e Distribuição:
        - [ ] actors

- [ ] Cálculo Lambda: 
    - https://crypto.stanford.edu/~blynn/lambda/
    - https://youtu.be/3VQ382QG-y4
    - [ ] transparência referencial
    - [ ] idempotência

- [ ] Algoritmos de Ordenação:
    - [ ] Ord e Eq
    - [ ] quick-sort
    - [ ] Merge-sort

- [ ] Test
    - [ ] HSpec
    - [ ] quickcheck
    - [ ] quickcheck + Hspec https://hspec.github.io/quickcheck.html

- Encapsulamento, herança




Exercícios/Provas

- Fontes 
    * https://www.cantab.net/users/antoni.diller/haskell/questions/quest07.pdf
    * Exercism
    * https://www.cse.chalmers.se/edu/year/2018/course/TDA555/exam.html
    * https://www.cse.chalmers.se/edu/year/2018/course/TDA555/ex-week2.html
    * https://haskell.mooc.fi/part1#sidenote-the-.-and-operators

- [x] Tipos
    - [x] Pedra tesoura papel - usando strings
    - [x] Pedra tesoura papel - usando tipos definidos pelo usuário

- Tipos algébricos
    - Pedra tesoura papel - usando tipos algébricos
    - cartas
        - teste se bateu em algum jogo
        - ordene as cartas

Trabalho

- Tabuleiro
    - Versão 1, tuplas e strings
        - Tabuleiro é uma tupla com 8 Linha.  type Tabuleiro = (Linha,Linha,...., Linha)
        - Linha é uma tupla com 8 Célula.     type Linha = (Celula, ..., Celula)
        - Célula é uma tupla com 4 Item
            - Interprete a célula como uma pilha em que o primeiro elemento está na base.
            - Na célula, "sobre" quer dizer imediatamente subsequente na pilha.
            - Na célula, "acima" quer dizer em qualquer posição subsequente na pilha.
        - Item é uma string com um dos seguintes valores 
            - "" (nada) - se presente na tupla, só pode estar sobre outros nada
            - "grama" - se presente na tupla, deve ser o primeiro elemento
            - "presente" - se presente na tupla, deve estar sobre "grama"
            - "pedra" - se presente na tupla, pode ser o primeiro elemento, estar sobre grama ou sobre um presente.
            - "bomba" - se presente na tupla, deve estar sobre grama
            - "jogador X" - se presente na tupla, deve estar sobre grama; X identifica o jogador
- Jogador é uma tupla com os seguintes elementos
    - identificador - Char
    - localização - é uma tupla com coordenadas X e Y do tipo Int
    - direção - é um caractere que indica para onde on jogador está olhando. Pode assumir um dos valores 'N', 'S', 'L' e 'O'
    - capacidades - é uma tupla com 3 elementos com um dos seguintes valores
        - "" (nada)
        - "patins"
        - "bomba"
        - "arremesso"
- Funções de manipulação
    - Criação de um tabuleiro
    - Movimentação de um jogador em qualquer dos sentidos
        - Deslocamento
        - Coleta de presente - teste de capacidade
        - Queda em buraco
        - Impossibilidade de movimento
    - Arremesso
        - Teste de capacidade
        - Teste de direção
    - Explosão
        - Direção
        - Capacidade
        - Eliminação de presentes
        - Eliminação de pedra
        - Eliminação de jogador
    - Detecção de fim de jogo