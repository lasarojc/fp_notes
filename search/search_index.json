{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Notas de Aula em Programa\u00e7\u00e3o Funcional","title":"Notas de Aula em <br> Programa\u00e7\u00e3o Funcional"},{"location":"#notas-de-aula-em-programacao-funcional","text":"","title":"Notas de Aula em  Programa\u00e7\u00e3o Funcional"},{"location":"haskell/","text":"Introdu\u00e7\u00e3o A primeira vers\u00e3o da linguagem Haskell, cujo nome \u00e9 uma homenagem ao matem\u00e1tico e l\u00f3gico Haskell B. Curry , apareceu em 1987 do esfor\u00e7o para se consolidar v\u00e1rios avan\u00e7os propostos no paradigma funcional, sendo famosa por ser uma linguagem funcional pura , de prop\u00f3sito geral e por ter caracter\u00edsticas marcantes como avalia\u00e7\u00e3o pregui\u00e7osa , e tipagem est\u00e1tica , forte e por infer\u00eancia , como discutiremos mais adiante. Mais do que uma linguagem, Haskell era uma especifica\u00e7\u00e3o, ou s\u00e9rie de especifica\u00e7\u00f5es, tendo tido v\u00e1rias implementa\u00e7\u00f5es distintas. A vers\u00e3o de 98 foi um marco da linguagem, sendo uma vers\u00e3o considerada est\u00e1vel. Nesta \u00e9poca surgiu o Glasgow Haskell Compiler (GHC), que se tornou o compilador Haskell \"padr\u00e3o\". A vers\u00e3o seguinte da linguagem come\u00e7ou a ser especificada em 2006 e anunciada em 2009, a Haskell 2010. Dentre os principais avan\u00e7os desta vers\u00e3o est\u00e1 a possibilidade de interagir com c\u00f3digo escrito em outras linguagens, via the foreign function interface (FFI). Mas chega de hist\u00f3ria e vamos colocar a m\u00e3o na massa vendo alguns exemplos extremamente simples da linguagem. Para exemplos mais complexos, voc\u00ea dever\u00e1 instalar o compilador Haskell na sua m\u00e1quina, seguindo as instru\u00e7\u00f5es espec\u00edficas 2 , mas para pequenos experimentos e exerc\u00edcios, podendo usar o Repl.It 1 Do lado direito do s\u00edtio, na \u00e1rea marcada em vermelho, digite ghci seguido de Enter . Agora digite as express\u00f5es a seguir. 1 2 3 4 5 6 7 8 9 10 11 1 + 1 True && True 100 / 10 ( 10 + 4 ) * 50 3 * ( - 2 ) 2 * - 1 Estas express\u00f5es fazem uso de operadores comuns e se comportam exatamente como voc\u00ea esperaria, depois de ter aprendido a programar em qualquer linguagem, em qualquer paradigma. Operadores s\u00e3o a\u00e7\u00facar sint\u00e1tico para fun\u00e7\u00f5es, a alma da programa\u00e7\u00e3o funcional. REPL \u00e9 o acr\u00f4nimo para Read, Evaluate, Print, Loop. \u21a9 Instru\u00e7\u00f5es de como instalar o GHC s\u00e3o espec\u00edficas para cada sistema operacional. Por isso, consulte o s\u00edtio https://www.haskell.org/platform/ para instalar o Haskell na sua m\u00e1quina. \u21a9","title":"Introdu\u00e7\u00e3o"},{"location":"haskell/#introducao","text":"A primeira vers\u00e3o da linguagem Haskell, cujo nome \u00e9 uma homenagem ao matem\u00e1tico e l\u00f3gico Haskell B. Curry , apareceu em 1987 do esfor\u00e7o para se consolidar v\u00e1rios avan\u00e7os propostos no paradigma funcional, sendo famosa por ser uma linguagem funcional pura , de prop\u00f3sito geral e por ter caracter\u00edsticas marcantes como avalia\u00e7\u00e3o pregui\u00e7osa , e tipagem est\u00e1tica , forte e por infer\u00eancia , como discutiremos mais adiante. Mais do que uma linguagem, Haskell era uma especifica\u00e7\u00e3o, ou s\u00e9rie de especifica\u00e7\u00f5es, tendo tido v\u00e1rias implementa\u00e7\u00f5es distintas. A vers\u00e3o de 98 foi um marco da linguagem, sendo uma vers\u00e3o considerada est\u00e1vel. Nesta \u00e9poca surgiu o Glasgow Haskell Compiler (GHC), que se tornou o compilador Haskell \"padr\u00e3o\". A vers\u00e3o seguinte da linguagem come\u00e7ou a ser especificada em 2006 e anunciada em 2009, a Haskell 2010. Dentre os principais avan\u00e7os desta vers\u00e3o est\u00e1 a possibilidade de interagir com c\u00f3digo escrito em outras linguagens, via the foreign function interface (FFI). Mas chega de hist\u00f3ria e vamos colocar a m\u00e3o na massa vendo alguns exemplos extremamente simples da linguagem. Para exemplos mais complexos, voc\u00ea dever\u00e1 instalar o compilador Haskell na sua m\u00e1quina, seguindo as instru\u00e7\u00f5es espec\u00edficas 2 , mas para pequenos experimentos e exerc\u00edcios, podendo usar o Repl.It 1 Do lado direito do s\u00edtio, na \u00e1rea marcada em vermelho, digite ghci seguido de Enter . Agora digite as express\u00f5es a seguir. 1 2 3 4 5 6 7 8 9 10 11 1 + 1 True && True 100 / 10 ( 10 + 4 ) * 50 3 * ( - 2 ) 2 * - 1 Estas express\u00f5es fazem uso de operadores comuns e se comportam exatamente como voc\u00ea esperaria, depois de ter aprendido a programar em qualquer linguagem, em qualquer paradigma. Operadores s\u00e3o a\u00e7\u00facar sint\u00e1tico para fun\u00e7\u00f5es, a alma da programa\u00e7\u00e3o funcional. REPL \u00e9 o acr\u00f4nimo para Read, Evaluate, Print, Loop. \u21a9 Instru\u00e7\u00f5es de como instalar o GHC s\u00e3o espec\u00edficas para cada sistema operacional. Por isso, consulte o s\u00edtio https://www.haskell.org/platform/ para instalar o Haskell na sua m\u00e1quina. \u21a9","title":"Introdu\u00e7\u00e3o"},{"location":"haskell_functions/","text":"Fun\u00e7\u00f5es Agora que j\u00e1 vimos exemplos extremamente simples, vejamos alguns um pouco mais interessantes, como uma fun\u00e7\u00e3o que soma os n\u00fameros de x a y , inclusive. A t\u00edtulo de compara\u00e7\u00e3o, vejamos primeiro a fun\u00e7\u00e3o em linguagem C. 1 2 3 4 5 6 7 8 int soma ( int x , int y ) { int total = 0 ; for ( int i = x ; i <= y ; i ++ ) total = total + i ; return total ; } soma ( 1 , 10 ); Em Haskell, temos diversas op\u00e7\u00f5es para obter o mesmo resultado, por exemplo, usando uma fun\u00e7\u00e3o recursiva... 1 2 3 4 5 somadeate x y = if x < y then x + somadeate ( x + 1 ) y else x somadeate 1 10 ... ou a fun\u00e7\u00e3o j\u00e1 existente sum , que recebe uma lista de n\u00fameros, neste caso criada pelo operador .. 1 sum [ 1 .. 10 ] Em ambos os casos, estamos usando fun\u00e7\u00f5es que resolvem o problema sem se basear em nada al\u00e9m dos par\u00e2metros passados e sem efeitos colaterais, inclusive no exemplo em C. Estes s\u00e3o exemplos de fun\u00e7\u00f5es puras , frequentemente representadas como as seguintes \"caixinhas\", que recebem algumas entradas e calcula, exatamente , uma sa\u00edda. Uso Observe que a sintaxe do uso das fun\u00e7\u00f5es, contudo, \u00e9 diferente; em Haskell, usa-se o nome da fun\u00e7\u00e3o, seguido dos par\u00e2metros, com espa\u00e7o os separando. Defini\u00e7\u00e3o A defini\u00e7\u00e3o de fun\u00e7\u00f5es segue algumas estruturas b\u00e1sicas, sendo a mais simples a defini\u00e7\u00e3o via equa\u00e7\u00e3o . Por exemplo, consideremos uma fun\u00e7\u00e3o que soma dois n\u00fameros. Em Haskell, ela \u00e9 definida simplesmente como soma x y = x + y e usada como soma 3 5 . Exerc\u00edcio: Soma Defina a fun\u00e7\u00e3o soma e a use, de acordo com a imagem. Como outro exemplo, definamos uma fun\u00e7\u00e3o que retorna o sucessor de um inteiro como sucessor x = x + 1 . Com estas duas fun\u00e7\u00f5es, podemos inclusive compor fun\u00e7\u00f5es, no melhor estilo \\(g(f(x))\\) , por exemplo: sucessor ( soma 3 4 ) ou sucessor ( sucessor ( sucessor 4 )) . Exerc\u00edcio: Composi\u00e7\u00e3o Defina uma fun\u00e7\u00e3o que multiplique 3 n\u00fameros, isto \u00e9, dados \\(x\\) , \\(y\\) e \\(z\\) , calcule \\(x*y*z\\) . Calcule \\((1 + (3 * 2 * 3)) + (5 * 3 * 2)\\) usando as fun\u00e7\u00f5es de soma e multiplica\u00e7\u00e3o definidas. Resolu\u00e7\u00e3o Defina as fun\u00e7\u00f5es 1 2 3 soma x y = x + y mult3 x y z = x + y + z Invoque soma ( soma 1 ( mult3 3 2 3 )) ( mult 5 3 2 ) . Observe que os par\u00eanteses s\u00e3o necess\u00e1rios para delimitar os par\u00e2metros de cada uma das invoca\u00e7\u00f5es. Exerc\u00edcio: m\u00e9dia de 3 n\u00fameros Defina uma fun\u00e7\u00e3o que calcule a m\u00e9dia de 3 n\u00fameros Resolu\u00e7\u00e3o media x y z = ( x + y + z ) / 3 Exerc\u00edcio: \u00e1rea das figuras Defina uma fun\u00e7\u00e3o o c\u00e1lculo da \u00e1rea de cada figura geom\u00e9trica. Resolu\u00e7\u00e3o 1 2 3 4 5 areaQuad a = a * a areaRet a b = a * b areaCirc r = pi * r * r areaTri a h = ( a * h ) / 2 areaTra a b h = ( a + b ) / 2 * h Note que voc\u00ea pode usar n\u00fameros inteiros, reais, ou uma mistura deles nas invoca\u00e7\u00f5es destas fun\u00e7\u00f5es, o que nos leva a perguntar como funcionam tipos no Haskell.","title":"Fun\u00e7\u00f5es"},{"location":"haskell_functions/#funcoes","text":"Agora que j\u00e1 vimos exemplos extremamente simples, vejamos alguns um pouco mais interessantes, como uma fun\u00e7\u00e3o que soma os n\u00fameros de x a y , inclusive. A t\u00edtulo de compara\u00e7\u00e3o, vejamos primeiro a fun\u00e7\u00e3o em linguagem C. 1 2 3 4 5 6 7 8 int soma ( int x , int y ) { int total = 0 ; for ( int i = x ; i <= y ; i ++ ) total = total + i ; return total ; } soma ( 1 , 10 ); Em Haskell, temos diversas op\u00e7\u00f5es para obter o mesmo resultado, por exemplo, usando uma fun\u00e7\u00e3o recursiva... 1 2 3 4 5 somadeate x y = if x < y then x + somadeate ( x + 1 ) y else x somadeate 1 10 ... ou a fun\u00e7\u00e3o j\u00e1 existente sum , que recebe uma lista de n\u00fameros, neste caso criada pelo operador .. 1 sum [ 1 .. 10 ] Em ambos os casos, estamos usando fun\u00e7\u00f5es que resolvem o problema sem se basear em nada al\u00e9m dos par\u00e2metros passados e sem efeitos colaterais, inclusive no exemplo em C. Estes s\u00e3o exemplos de fun\u00e7\u00f5es puras , frequentemente representadas como as seguintes \"caixinhas\", que recebem algumas entradas e calcula, exatamente , uma sa\u00edda.","title":"Fun\u00e7\u00f5es"},{"location":"haskell_types/","text":"Tipos Em linguagens de programa\u00e7\u00e3o, um tipo \u00e9 um nome dado a uma cole\u00e7\u00e3o de valores que s\u00e3o tem um mesmo comportamento na linguagem. Na linguagem C, por exemplo, temos os tipos int e short , ambos associados a valores inteiros mas n\u00famero de bits diferentes usados para represent\u00e1-los. Algumas linguagens s\u00e3o denominadas fracamente tipadas, o que quer dizer que o uso de tipos \u00e9 relaxado e pode at\u00e9 ser alterado em tempo de execu\u00e7\u00e3o. Por exemplo, no seguinte c\u00f3digo em Python a vari\u00e1vel x assume tr\u00eas tipos diferentes. 1 2 3 4 5 6 7 8 x = \"lala\" print ( type ( x )) x = 10 print ( type ( x )) x = 10.0 print ( type ( x )) 1 2 3 <class 'str' > <class 'int' > <class 'float' > J\u00e1 a linguagem Haskell \u00e9 o que chamamos de fortemente tipada , o que quer dizer que toda vari\u00e1vel, constante ou fun\u00e7\u00e3o tem apenas um tipo e este sempre pode ser determinado. Al\u00e9m disso, Haskell \u00e9 estaticamente tipada , ou seja, os tipos s\u00e3o determinados em tempo de compila\u00e7\u00e3o, em oposi\u00e7\u00e3o a linguagens que determinam o tipo durante a execu\u00e7\u00e3o do programa, denominadas dinamicamente tipadas. Finalmente, se olharmos novamente para os exemplos de fun\u00e7\u00f5es anteriores, veremos que n\u00e3o foram definidos tipos em suas declara\u00e7\u00f5es; isto \u00e9 poss\u00edvel porqu\u00ea Haskell consegue inferir os tipos dos dados de forma muito eficiente, obrigando voc\u00ea a explicit\u00e1-los apenas em casos muito espec\u00edficos. Haskell tem um n\u00famero imenso de tipos pre-definidos, organizados hierarquicamente, e que podem ser usados para definir novos tipos pelo programador. Mas por enquanto, nos foquemos nos tipos mais simples. Tipos Primitivos e Operadores Como toda linguagem de programa\u00e7\u00e3o, Haskell tem tipos pr\u00e9-definidos para representar n\u00fameros e caracteres, como mostra a seguinte tabela. Tipo Descri\u00e7\u00e3o Valores Int Inteiro de precis\u00e3o finita Integer Inteiro de precis\u00e3o arbitr\u00e1ria Float Ponto flutuante de precis\u00e3o simples Double Ponto flutuante de precis\u00e3o dupla Char Caractere Al\u00e9m do tipo Char , Haskell define tamb\u00e9m o tipo String como uma lista de Char . Como lista n\u00e3o \u00e9 um tipo primitivo, ou melhor, mesmo que em Haskell listas sejam um tipo b\u00e1sicos, n\u00e3o as estudaremos agora. Ainda assim, usaremos String em alguns exemplos, de forma bem descomplicada. Dados os tipos prim\u00e1rios, o pr\u00f3ximo passo \u00e9 ver os operadores que os manipulam. Operador Opera\u00e7\u00e3o + Adi\u00e7\u00e3o - Subtra\u00e7\u00e3o * Multiplica\u00e7\u00e3o / Divis\u00e3o ^ Exponencia\u00e7\u00e3o, e.g, 2^4 == 16 - Invers\u00e3o de sinal, e.g, - (-10) == 10 1 negate Invers\u00e3o de sinal, e.g, negate (-10) == 10 1 quot Divis\u00e3o inteira, truncado pro 0 rem Resto da divis\u00e3o inteira, tal que (x `quot` y)*y + (x `rem` y) == x div Resto da divis\u00e3o, truncado para baixo mod M\u00f3dulo do inteiro, tal que (x `div` y)*y + (x `mod` y) == x Observe que alguns destes operadores s\u00e3o naturalmente infixos, e.g., + , e outros prefixos, e.g., rem . Contudo, ambos podem ser usados da outras forma, como mostrado nos seguintes exemplos. 1 2 3 4 10 + 20 ( + ) 10 20 quot 10 3 10 ` quot ` 3 Tipo Descri\u00e7\u00e3o Valores Bool Booleano True ou False Operador Opera\u00e7\u00e3o && E l\u00f3gico || OU l\u00f3gico not Nega\u00e7\u00e3o == Igualdade /= Diferen\u00e7a Exerc\u00edcios Usar todos os operadores Evidenciar diferen\u00e7as entrem quot e div. A fun\u00e7\u00e3o :type Prot\u00f3tipo de fun\u00e7\u00f5es 1 2 nome_funcao :: tipo_arg1 -> ... -> tipo_argN -> tipo_saida nome_funcao arg1 ... argN = < definicao > Exerc\u00edcio Defina o prot\u00f3tipo da fun\u00e7\u00e3o de convers\u00e3o de Fahrenheit para Celsius f2c x = ( x - 32 ) / 1.8 Resolu\u00e7\u00e3o f2c :: Float -> Float Defina o prot\u00f3tipo da fun\u00e7\u00e3o de media de dois n\u00fameros reais m2n a b = ( a + b ) / 2 Resolu\u00e7\u00e3o :: Float -> Float -> Float Observe que o o -10 est\u00e1 entre par\u00eanteses n\u00e3o porque o operador demanda, mas para deixar claro que o - faz parte do n\u00famero. \u21a9 \u21a9","title":"Tipos"},{"location":"haskell_types/#tipos","text":"Em linguagens de programa\u00e7\u00e3o, um tipo \u00e9 um nome dado a uma cole\u00e7\u00e3o de valores que s\u00e3o tem um mesmo comportamento na linguagem. Na linguagem C, por exemplo, temos os tipos int e short , ambos associados a valores inteiros mas n\u00famero de bits diferentes usados para represent\u00e1-los. Algumas linguagens s\u00e3o denominadas fracamente tipadas, o que quer dizer que o uso de tipos \u00e9 relaxado e pode at\u00e9 ser alterado em tempo de execu\u00e7\u00e3o. Por exemplo, no seguinte c\u00f3digo em Python a vari\u00e1vel x assume tr\u00eas tipos diferentes. 1 2 3 4 5 6 7 8 x = \"lala\" print ( type ( x )) x = 10 print ( type ( x )) x = 10.0 print ( type ( x )) 1 2 3 <class 'str' > <class 'int' > <class 'float' > J\u00e1 a linguagem Haskell \u00e9 o que chamamos de fortemente tipada , o que quer dizer que toda vari\u00e1vel, constante ou fun\u00e7\u00e3o tem apenas um tipo e este sempre pode ser determinado. Al\u00e9m disso, Haskell \u00e9 estaticamente tipada , ou seja, os tipos s\u00e3o determinados em tempo de compila\u00e7\u00e3o, em oposi\u00e7\u00e3o a linguagens que determinam o tipo durante a execu\u00e7\u00e3o do programa, denominadas dinamicamente tipadas. Finalmente, se olharmos novamente para os exemplos de fun\u00e7\u00f5es anteriores, veremos que n\u00e3o foram definidos tipos em suas declara\u00e7\u00f5es; isto \u00e9 poss\u00edvel porqu\u00ea Haskell consegue inferir os tipos dos dados de forma muito eficiente, obrigando voc\u00ea a explicit\u00e1-los apenas em casos muito espec\u00edficos. Haskell tem um n\u00famero imenso de tipos pre-definidos, organizados hierarquicamente, e que podem ser usados para definir novos tipos pelo programador. Mas por enquanto, nos foquemos nos tipos mais simples.","title":"Tipos"},{"location":"haskell_types/#tipos-primitivos-e-operadores","text":"Como toda linguagem de programa\u00e7\u00e3o, Haskell tem tipos pr\u00e9-definidos para representar n\u00fameros e caracteres, como mostra a seguinte tabela. Tipo Descri\u00e7\u00e3o Valores Int Inteiro de precis\u00e3o finita Integer Inteiro de precis\u00e3o arbitr\u00e1ria Float Ponto flutuante de precis\u00e3o simples Double Ponto flutuante de precis\u00e3o dupla Char Caractere Al\u00e9m do tipo Char , Haskell define tamb\u00e9m o tipo String como uma lista de Char . Como lista n\u00e3o \u00e9 um tipo primitivo, ou melhor, mesmo que em Haskell listas sejam um tipo b\u00e1sicos, n\u00e3o as estudaremos agora. Ainda assim, usaremos String em alguns exemplos, de forma bem descomplicada. Dados os tipos prim\u00e1rios, o pr\u00f3ximo passo \u00e9 ver os operadores que os manipulam. Operador Opera\u00e7\u00e3o + Adi\u00e7\u00e3o - Subtra\u00e7\u00e3o * Multiplica\u00e7\u00e3o / Divis\u00e3o ^ Exponencia\u00e7\u00e3o, e.g, 2^4 == 16 - Invers\u00e3o de sinal, e.g, - (-10) == 10 1 negate Invers\u00e3o de sinal, e.g, negate (-10) == 10 1 quot Divis\u00e3o inteira, truncado pro 0 rem Resto da divis\u00e3o inteira, tal que (x `quot` y)*y + (x `rem` y) == x div Resto da divis\u00e3o, truncado para baixo mod M\u00f3dulo do inteiro, tal que (x `div` y)*y + (x `mod` y) == x Observe que alguns destes operadores s\u00e3o naturalmente infixos, e.g., + , e outros prefixos, e.g., rem . Contudo, ambos podem ser usados da outras forma, como mostrado nos seguintes exemplos. 1 2 3 4 10 + 20 ( + ) 10 20 quot 10 3 10 ` quot ` 3 Tipo Descri\u00e7\u00e3o Valores Bool Booleano True ou False Operador Opera\u00e7\u00e3o && E l\u00f3gico || OU l\u00f3gico not Nega\u00e7\u00e3o == Igualdade /= Diferen\u00e7a Exerc\u00edcios Usar todos os operadores Evidenciar diferen\u00e7as entrem quot e div.","title":"Tipos Primitivos e Operadores"},{"location":"haskell_types/#a-funcao-type","text":"","title":"A fun\u00e7\u00e3o :type"},{"location":"haskell_types/#prototipo-de-funcoes","text":"1 2 nome_funcao :: tipo_arg1 -> ... -> tipo_argN -> tipo_saida nome_funcao arg1 ... argN = < definicao > Exerc\u00edcio Defina o prot\u00f3tipo da fun\u00e7\u00e3o de convers\u00e3o de Fahrenheit para Celsius f2c x = ( x - 32 ) / 1.8 Resolu\u00e7\u00e3o f2c :: Float -> Float Defina o prot\u00f3tipo da fun\u00e7\u00e3o de media de dois n\u00fameros reais m2n a b = ( a + b ) / 2 Resolu\u00e7\u00e3o :: Float -> Float -> Float Observe que o o -10 est\u00e1 entre par\u00eanteses n\u00e3o porque o operador demanda, mas para deixar claro que o - faz parte do n\u00famero. \u21a9 \u21a9","title":"Prot\u00f3tipo de fun\u00e7\u00f5es"},{"location":"intro/","text":"Introdu\u00e7\u00e3o Embora este curso assuma que voc\u00ea j\u00e1 saiba programar em alguma linguagem, ou exatamente por isso, \u00e9 importante que fa\u00e7amos uma revis\u00e3o de algumas ideias b\u00e1sicas de programa\u00e7\u00e3o antes de mergulharmos no paradigma funcional, para que possamos melhor posicionar este paradigma com em rela\u00e7\u00e3o aos demais. Paradigmas de Programa\u00e7\u00e3o Programar um computador consiste em comunicar ao computador instru\u00e7\u00f5es para que ele resolva problemas. E a comunica\u00e7\u00e3o entre duas entidades s\u00f3 \u00e9 poss\u00edvel se usarem uma linguagem em comum, isto \u00e9, dominada pelas duas partes. Comunica\u00e7\u00e3o A\u00e7\u00e3o ou efeito de comunicar, de transmitir ou de receber ideias, conhecimento, mensagens etc., buscando compartilhar informa\u00e7\u00f5es. 1 Comunica\u00e7\u00e3o Linguagens naturais Linguagens de programa\u00e7\u00e3o Quando humanos se comunicam, usam uma linguagens naturais , como o portugu\u00eas, libras, ou canton\u00eas. Linguagens naturais s\u00e3o altamente expressivas, cheias de nuances e depend\u00eancias do contexto, o que lhes confere grande poder, mas tamb\u00e9m a grande fraqueza de permitirem a constru\u00e7\u00e3o de mensagens amb\u00edguas. A comunica\u00e7\u00e3o entre computadores ou computares e humanos, contudo, precisa ser feita de forma precisa, e por isso linguagens naturais n\u00e3o s\u00e3o boas neste contexto, apesar do grande esfor\u00e7o dispendido e da evolu\u00e7\u00e3o do processamento de linguagens naturais, como as alexas e siris do mundo podem provar. A comunica\u00e7\u00e3o entre computadores \u00e9 feita por um protocolo de comunica\u00e7\u00e3o, assunto para outro curso. J\u00e1 a comunica\u00e7\u00e3o entre humanos e computadores, na programa\u00e7\u00e3o do computador, \u00e9 feita por meio de linguagens de programa\u00e7\u00e3o , que s\u00e3o muito mais restritas que as linguagens naturais e, por isso, n\u00e3o amb\u00edguas. Linguagem de Programa\u00e7\u00e3o A linguagem de programa\u00e7\u00e3o \u00e9 um m\u00e9todo padronizado, formado por um conjunto de regras sint\u00e1ticas e sem\u00e2nticas, de implementa\u00e7\u00e3o de um c\u00f3digo fonte - que pode ser compilado e transformado em um programa de computador, ou usado como script interpretado - que informar\u00e1 instru\u00e7\u00f5es de processamento ao computador. 2 A n\u00e3o ambiguidade das linguagens de programa\u00e7\u00e3o do fato de terem uma sintaxe e sem\u00e2nticas precisas, descritas por uma gram\u00e1tica tamb\u00e9m precisa. Sintaxe A sintaxe de uma linguagem descreve o que constitui um programa estruturalmente correto e \u00e9 definida por uma gram\u00e1tica. Sem\u00e2ntica O significado de um programa \u00e9 definido por sua sem\u00e2ntica, ou seja, por regras que definem como as instru\u00e7\u00f5es especificado devem ser interpretadas. Serem precisas n\u00e3o quer dizer que as linguagens sejam simples, como demonstra claramente a seguinte imagem, que \u00e9 um programa \u00e9 um \"hello world\" na linguagem Piet . Tamb\u00e9m n\u00e3o quer dizer que sejam limitadas. De fato, h\u00e1 milhares linguagens de programa\u00e7\u00e3o por a\u00ed, e contando, com diferentes caracter\u00edsticas que as tornam mais mais ou menos apropriadas para resolver diferentes problemas. Mas mesmo apesar de t\u00e3o grande n\u00famero, as linguagens podem ser classificadas em grandes fam\u00edlias ou paradigmas. Imperativo x Descritivo Imperativo x Descritivo Imperativo: como Descritivo: o qu\u00ea Os primeiros \"computadores\" eram m\u00e1quinas que computavam mecanicamente seus resultados. Uma segunda gera\u00e7\u00e3o, da qual destacamos o ENIAC (circa 1955), eram computadores sem parte mec\u00e2nicas, programados por conex\u00f5es el\u00e9tricas de suas diversas partes. O pr\u00f3ximo passo, foram computadores que interpretavam c\u00f3digo escrito em uma linguagem de programa\u00e7\u00e3o. Estas primeiras linguagens eram todas imperativas , no sentido de que ditavam ao computador uma sequ\u00eancia de instru\u00e7\u00f5es a serem seguidas para se chegar a um resultado. Isto \u00e9, estas linguagens permitiam ao programador dizer como realizar uma computa\u00e7\u00e3o. Imperativo leia a linha 1 do arquivo separe a linha por espa\u00e7os pegue a segunda parte da linha converta a parte para n\u00famero se o n\u00famero for maior que 15, escreva na tela leia a pr\u00f3xima linha do arquivo volte para o passo 2 Este paradigma tem suas ra\u00edzes no modelo computacional cl\u00e1ssico de von Neumann e na m\u00e1quina de Turing Em contrapartida a este modelo, surgiram mais tarde linguagens declarativas , em que o programado diz o qu\u00ea deve ser computado e o computador se encarrega de achar um \"como\". Descritivo selecione todas as linhas em que a segunda parte \u00e9 maior que 15 Com uma an\u00e1lise r\u00e1pida das linguagens mais conhecidas, voce deve reconhecer a maior parte como imperativas, por exemplo, C, Java, e Python. J\u00e1 dentre as linguagens declarativas, se destacam SQL, LINQ, e Prolog. Ortogonalmente ao foco em no \"como x o qu\u00ea\", podemos nos focar em como as estas instru\u00e7\u00f5es s\u00e3o organizadas mais em um n\u00edvel mais alto, de onde se destacam quatro paradigmas principais: procedimental , orientado a objetos , l\u00f3gico e funcional . 3 Procedimental Linguagens que usam o paradigma procedimental organizam instru\u00e7\u00f5es em blocos, denominados procedimentos, de onde vem o nome, ou fun\u00e7\u00f5es. A ideia \u00e9 que o c\u00f3digo seja modularizado para separar funcionalidades e tornar o c\u00f3digo mais compreens\u00edvel e manuten\u00edvel. Cada fun\u00e7\u00e3o deve executar uma opera\u00e7\u00e3o bem espec\u00edfica, fun\u00e7\u00f5es associadas s\u00e3o colocadas em um mesmo arquivo, e arquivos associados s\u00e3o colocados em um mesmo namespace . O c\u00f3digo seguinte, em C, mostra a fun\u00e7\u00e3o main , ponto de entrada do programa e de onde a fun\u00e7\u00e3o printf , importada de stdio.h , \u00e9 invocada. 1 2 3 4 5 #include <stdio.h> int main () { printf ( \"Hello, World!\" ); return 0 ; } Al\u00e9m da linguagem C, outros exemplos \u00f3bvios deste paradigma s\u00e3o as linguagens Pascal, Fortran e Python. Contudo, mesmo linguagens como Java e C++ podem ser consideradas procedurais, uma vez que organizam a computa\u00e7\u00e3o em m\u00e9todos, que s\u00e3o nada mais que fun\u00e7\u00f5es. Mas como m\u00e9todos est\u00e3o fortemente associados a classes e suas inst\u00e2ncias, os objetos, estas linguagens s\u00e3o melhor classificadas como orientadas a objetos. Orientado a Objetos Na orienta\u00e7\u00e3o a objetos, o foco est\u00e1 n\u00e3o na execu\u00e7\u00e3o passo a passo de fun\u00e7\u00f5es, mas na organiza\u00e7\u00e3o de dados e fun\u00e7\u00f5es associadas em objetos. Embora esta organiza\u00e7\u00e3o possa ser feita em qualquer qualquer linguagem estruturada, a sintaxe das linguagens orientadas a objeto facilita e tornam mais natural este trabalho. Dois conceitos b\u00e1sicos na orienta\u00e7\u00e3o a objetos s\u00e3o as classes e os objetos . Classes s\u00e3o abstra\u00e7\u00f5es de tipos de coisas encontrados no mundo real, ou seja, receitas de estruturas de dados e definem quais os dados devem ser considerados em conjunto para representar um objeto e quais as a\u00e7\u00f5es associadas a este objeto. Por exemplo, se no mundo real cachorros tem uma data de nascimento e um nome, e s\u00e3o capazes de latir, uma classe que represente cachorros pode ser definida assim em Java. 1 2 3 4 5 6 7 8 9 10 11 class Cachorro { int diaNascimento ; int mesNascimento ; int anoNascimento ; String nome ; void latir ( int quantidade ) { for ( int i = 0 ; i < quantidade ; i ++ ) System . out . println ( nome + \": Au!\" ); } } J\u00e1 um objeto \u00e9 uma inst\u00e2ncia de uma classe, uma representa\u00e7\u00e3o de um tipo mas de uma coisa em si. Um c\u00e3o qualquer poderia ser representado assim 1 2 Cachorro cachorro1 = new Cachorro ( 25 , 12 , 2020 , \"Napole\u00e3o\" ); cachorro1 . latir ( 3 ); e a execu\u00e7\u00e3o deste c\u00f3digo resultaria em 1 2 3 Napole\u00e3o: Au! Napole\u00e3o: Au! Napole\u00e3o: Au! Observe que o \".\" em cachorro1.latir(3) quer dizer \"executar a fun\u00e7\u00e3o latir no objeto cachorro1 \", o que leva \u00e0 string Napole\u00e3o a aparecer antes de cada latido. Duas coisas poder ser ditas sobre este \".\". Primeiro, que ele n\u00e3o \u00e9 necess\u00e1rio, o objeto em si poderia ser passado como par\u00e2metro para uma fun\u00e7\u00e3o latir que recebesse o objeto al\u00e9m da quantidade de latidos; de fato, em Python, a classe seria definida como a seguir 1 2 3 4 5 6 7 8 9 class Cachorro : diaNascimento mesNascimento anoNascimento nome def latir ( self , quantidade ): for i in range ( 0 , quantidade ): print ( self . nome + \": Au!\" ) o que implica que o \".\" \u00e9 o s\u00f3 a\u00e7\u00facar sint\u00e1tico para a execu\u00e7\u00e3o de uma fun\u00e7\u00e3o, o que nos leva ao segundo ponto. Na orienta\u00e7\u00e3o a objetos conceitual, n\u00e3o se fala em invoca\u00e7\u00e3o de fun\u00e7\u00f5es mas de sinais sendo transmitidos entre objetos: envie mensagem para o 2 \"somar-se com 3\", ao que o objeto 2 responderia com uma mensagem \"refer\u00eancia ao objeto 4\". Em Smalltalk, esta intera\u00e7\u00e3o seria escrita assim: 1 x := 2 + 3 . Grande parte do poder da orienta\u00e7\u00e3o objetos est\u00e1 no encapsulamento do como opera\u00e7\u00f5es s\u00e3o executadas, nos m\u00e9todos. Uma outra ordem de encapsulamento, de outro tipo, \u00e9 encontrada no paradigma l\u00f3gico. L\u00f3gico No paradigma l\u00f3gico, voc\u00ea declara-se fatos b\u00e1sicos e regras sobre como os fatos se relacionam e pergunta ao programa se certos fatos s\u00e3o ou n\u00e3o s\u00e3o verdade. Por exemplo, como fatos, podemos declarar 1 2 3 4 5 eh_maior_que ( gato , rato ). eh_maior_que ( leao , gato ). eh_maior_que ( elefante , leao ). eh_maior_que ( elefante , moto ). eh_maior_que ( legal , cachorro ). que vale a transitividade 1 2 3 eh_maior_que ( A , B ) :- eh_maior_que ( A , C ), eh_maior_que ( C , B ). e, finalmente, perguntar se elefante \u00e9 maior rato 1 eh_maior_que ( elefante , rato ). ao que seremos respondidos com um \"sim\". Voc\u00ea consegue imaginar quantas linhas de c\u00f3digo voc\u00ea precisaria para expressar a mesma l\u00f3gica acima em uma linguagem como C ou Java? Apesar do claro poder deste paradigma, o mesmo tem poucos representantes, como Prolog e Mercury, e mesmo que exista v\u00e1rios compiladores do primeiro, o uso comercial do paradigma \u00e9 bem limitado. Funcional A programa\u00e7\u00e3o, como indicado pelo nome, \u00e9 focada na organiza\u00e7\u00e3o do processamento em termos de fun\u00e7\u00f5es, mas de uma forma diferente da programa\u00e7\u00e3o procedimental. De forma geral, fun\u00e7\u00f5es s\u00e3o blocos de c\u00f3digo criadas essencialmente para se obter reusabilidade : uma vez definidas, as fun\u00e7\u00f5es podem ser invocadas repetidas vezes para executar a mesma tarefa sobre diferentes par\u00e2metros , sempre retornando um resultado. 4 Mas enquanto na programa\u00e7\u00e3o procedimental a invoca\u00e7\u00e3o de uma fun\u00e7\u00e3o pode retornar diferentes resultados mesmo quando os par\u00e2metros s\u00e3o os mesmos, na programa\u00e7\u00e3o funcional, fun\u00e7\u00f5es s\u00e3o como na matem\u00e1tica, isto \u00e9, mapeiam uma entrada para uma sa\u00edda, sempre. N\u00e3o \u00e9 a toa que outro nome usado para definir os blocos de c\u00f3digo \u00e9 procedimento em vez de fun\u00e7\u00e3o. Vejamos alguns exemplos. As fun\u00e7\u00f5es seguintes, definidas em Erlang, calculam A+B , A*C e (A+B)*(A+B) ; independentemente de quantas vezes voc\u00ea o fizer, add(2,3) sempre retornar\u00e1 5 . 1 2 3 4 5 6 7 8 add ( A , B ) -> A + B . mult ( A , B ) -> A * B . mult_add ( A , B ) -> mult ( add ( A , B ), add ( A , B )). Agora observe a fun\u00e7\u00e3o seguinte, escritas em Python; a cada invoca\u00e7\u00e3o, a vari\u00e1vel acc tem seu valor alterado e mesmo que invocada com a mesma entrada, o resultado da fun\u00e7\u00e3o \u00e9 sempre diferente. Os efeitos externos \u00e0 fun\u00e7\u00e3o, e.g., a altera\u00e7\u00e3o da vari\u00e1vel acc , \u00e9 conhecido efeito colateral . Programa\u00e7\u00e3o funcional n\u00e3o tem tem efeitos colaterais por que trata vari\u00e1veis n\u00e3o como \u00e1reas de mem\u00f3ria alter\u00e1veis, mas como inc\u00f3gnitas, como na matem\u00e1tica. Pelo menos esta \u00e9 a ideia de programa\u00e7\u00e3o funcional pura, que \u00e9 essencialmente a escrita de longu\u00edssimas equa\u00e7\u00f5es. Acontece que devido \u00e0 complexidade inerente do uso de programa\u00e7\u00e3o funcional pura, sem efeitos colaterais, i.e., sem muta\u00e7\u00e3o de estados, muitas linguagens n\u00e3o s\u00e3o puramente funcionais. A raz\u00e3o mais comum para efeitos colaterais \u00e9 a realiza\u00e7\u00e3o de Entrada/Sa\u00edda. Por exemplo, ao invocar print no Python, o terminal tem seu estado alterado, e cada nova invoca\u00e7\u00e3o altera mais o estado. Assim, podemos dividir as linguagens e funcionais puras, funcionais n\u00e3o puras e n\u00e3o funcionais, mas mesmo dentro das n\u00e3o funcionais, h\u00e1 aquelas com elementos de programa\u00e7\u00e3o funcional. \"Funcionalidades\" Muitas linguagens modernas, como Python e JavaScript, embora n\u00e3o estritamente funcionais, tem diversos elementos de programa\u00e7\u00e3o funcional, eu diretamente na linguagem ou via frameworks . Python, por exemplo, v\u00e1rias funcionalidades caracter\u00edsticas do paradigma funcional, embora seja poss\u00edvel ignor\u00e1-las por completo. Por exemplo, imagine que voc\u00ea queira criar uma lista com o quadrado de todos os n\u00fameros de 1 a x . Voc\u00ea pode optar por um for cl\u00e1ssico ... 1 2 3 4 5 def quads ( x ): lista = [] for i in range ( 1 , 10 ): lista . append ( i * i ) return lista ... ou uma compreens\u00e3o de listas , como nos exemplos a seguir. 1 2 def quads2 ( x ): return [ x ** 2 for x in range ( x )] Al\u00e9m disso, h\u00e1 linguagens funcionais que tamb\u00e9m se enquadram em outros paradigmas e que podem ser consideradas h\u00edbridas, ou multi-paradigma. Multi-paradigmas Muitas linguagens modernas podem ser classificadas ao mesmo tempo em muitos paradigmas, por exemplo, a linguagem Scala \u00e9 ao mesmo tempo funcional e orientada a objetos, sendo muito dif\u00edcil us\u00e1-la sem fazer uso desta caracter\u00edstica. 1 2 3 4 5 object HelloWorld { def main ( args : Array [ String ]) : Unit = { println ( \"Hello, world!\" ) } } Para cada servi\u00e7o, uma ferramenta! Em cada paradigma, encontramos vantagens e desvantagens. Como desenvolvedores de tecnologia, nada mais justo que voc\u00eas conhe\u00e7am todos os paradigmas e que possam, assim, escolher aquele paradigma e, dentro dele, aquela linguagem que permite resolver o seu problema da forma mais eficiente, isto \u00e9, rapidamente, com menor custo e com melhor qualidade. Mas quanto ao paradigma funciona, em especial, \u00e9 importante compreend\u00ea-lo pois muitas de suas funcionalidades tem sido incorporadas a outras linguagens, como compreens\u00e3o de listas em Python, fun\u00e7\u00f5es lambda em Java e C++, e processamento ass\u00edncrono pode ser visto como uma forma de avalia\u00e7\u00e3o pregui\u00e7osa em diversas linguagens. Vejamos estes outras pontos importantes do paradigma: Sem efeitos colaterais: executando um programa, de repente voc\u00ea percebe que uma certa vari\u00e1vel tem um valor estranho e fica se perguntando quem foi que atribuiu tal valor; efeitos colaterais s\u00e3o a origem de boa parte dos bugs e elimin\u00e1-los, ou ao menos reduz\u00ed-los, permite que voc\u00ea identifique rapidamente onde altera\u00e7\u00f5es poderiam ter acontecido. Camadas de abstra\u00e7\u00e3o: fun\u00e7\u00f5es podem ser compostas levando a programas verdadeiramente complexos, permitindo que abstra\u00e7\u00f5es sejam definidas em diversas camadas. Al\u00e9m disso, \u00e9 poss\u00edvel, em teoria, ser provar a corretude de fun\u00e7\u00f5es e, mesmo que na pr\u00e1tica isso n\u00e3o se realize, h\u00e1 ferramentas que conseguem usar esta ideia para lhe ajudar a encontrar bugs. Processamento paralelo eficiente: a aus\u00eancia de efeitos colaterais tamb\u00e9m implica que fun\u00e7\u00f5es sem depend\u00eancias podem ser executadas em paralelo, sem se preocupar com qualquer sincroniza\u00e7\u00e3o, isto \u00e9, sem mutexes e vari\u00e1veis de condi\u00e7\u00e3o, etc. Avalia\u00e7\u00e3o pregui\u00e7osa: fun\u00e7\u00f5es s\u00f3 precisam realmente ser executadas se seus resultados s\u00e3o necess\u00e1rios e o compilador consegue atrasar a execu\u00e7\u00e3o de fun\u00e7\u00f5es enquanto poss\u00edvel. Recurs\u00e3o de calda: alguns problemas podem ser descritos muito facilmente como uma recurs\u00e3o que com uma itera\u00e7\u00e3o, mas linguagens tradicionais tem um limite no tamanho das pilhas de fun\u00e7\u00e3o; linguagens funcionais conseguem, em certas condi\u00e7\u00f5es, usar recurs\u00e3o infinita, contornando esta limita\u00e7\u00e3o. Fun\u00e7\u00f5es de alta ordem: Escolha o seu veneno Como j\u00e1 ficou \u00f3bvio, h\u00e1 muitas, muitas linguagens de programa\u00e7\u00e3o por a\u00ed e \u00e9 poss\u00edvel escrever c\u00f3digo bom em cada um delas, assim como \u00e9 poss\u00edvel escrever c\u00f3digo ruim em cada uma delas. Tamb\u00e9m \u00e9 poss\u00edvel escrever usando orienta\u00e7\u00e3o a objetos ou funcionalmente em cada uma delas, mas embora seja poss\u00edvel , h\u00e1 aquelas linguagens que suportam melhor cada um dos paradigmas. Dentre estas, h\u00e1 diversas op\u00e7\u00f5es de linguagens que podemos usar para estudar o paradigma funcional, por exemplo: Scheme Lisp ML F# Erlang Elixir Haskell Clojure Neste curso, veremos princ\u00edpios gerais e que, em teoria, poderiam ser aplicados em qualquer destas linguagens. Contudo, como a sintaxe pode variar muito de uma linguagem para outra, precisaremos nos focar em uma \u00fanica linguagem, mesmo que, frequentemente, apresente exemplos em outras. Assim, nosso foco aqui ser\u00e1 em Haskell, uma linguagem funcional madura e est\u00e1vel. Recomenda\u00e7\u00f5es Sobre a hist\u00f3ria das linguagens de programa\u00e7\u00e3o Sobre porqu\u00ea PF n\u00e3o \u00e9 mais comum Comunica\u00e7\u00e3o \u21a9 Linguagem de Programa\u00e7\u00e3o \u21a9 Programming Language Families \u21a9 void \u00e9 simplesmente um resultado que diz que o resultado n\u00e3o importa. \u21a9","title":"Introdu\u00e7\u00e3o"},{"location":"intro/#introducao","text":"Embora este curso assuma que voc\u00ea j\u00e1 saiba programar em alguma linguagem, ou exatamente por isso, \u00e9 importante que fa\u00e7amos uma revis\u00e3o de algumas ideias b\u00e1sicas de programa\u00e7\u00e3o antes de mergulharmos no paradigma funcional, para que possamos melhor posicionar este paradigma com em rela\u00e7\u00e3o aos demais.","title":"Introdu\u00e7\u00e3o"},{"location":"intro/#paradigmas-de-programacao","text":"Programar um computador consiste em comunicar ao computador instru\u00e7\u00f5es para que ele resolva problemas. E a comunica\u00e7\u00e3o entre duas entidades s\u00f3 \u00e9 poss\u00edvel se usarem uma linguagem em comum, isto \u00e9, dominada pelas duas partes. Comunica\u00e7\u00e3o A\u00e7\u00e3o ou efeito de comunicar, de transmitir ou de receber ideias, conhecimento, mensagens etc., buscando compartilhar informa\u00e7\u00f5es. 1 Comunica\u00e7\u00e3o Linguagens naturais Linguagens de programa\u00e7\u00e3o Quando humanos se comunicam, usam uma linguagens naturais , como o portugu\u00eas, libras, ou canton\u00eas. Linguagens naturais s\u00e3o altamente expressivas, cheias de nuances e depend\u00eancias do contexto, o que lhes confere grande poder, mas tamb\u00e9m a grande fraqueza de permitirem a constru\u00e7\u00e3o de mensagens amb\u00edguas. A comunica\u00e7\u00e3o entre computadores ou computares e humanos, contudo, precisa ser feita de forma precisa, e por isso linguagens naturais n\u00e3o s\u00e3o boas neste contexto, apesar do grande esfor\u00e7o dispendido e da evolu\u00e7\u00e3o do processamento de linguagens naturais, como as alexas e siris do mundo podem provar. A comunica\u00e7\u00e3o entre computadores \u00e9 feita por um protocolo de comunica\u00e7\u00e3o, assunto para outro curso. J\u00e1 a comunica\u00e7\u00e3o entre humanos e computadores, na programa\u00e7\u00e3o do computador, \u00e9 feita por meio de linguagens de programa\u00e7\u00e3o , que s\u00e3o muito mais restritas que as linguagens naturais e, por isso, n\u00e3o amb\u00edguas. Linguagem de Programa\u00e7\u00e3o A linguagem de programa\u00e7\u00e3o \u00e9 um m\u00e9todo padronizado, formado por um conjunto de regras sint\u00e1ticas e sem\u00e2nticas, de implementa\u00e7\u00e3o de um c\u00f3digo fonte - que pode ser compilado e transformado em um programa de computador, ou usado como script interpretado - que informar\u00e1 instru\u00e7\u00f5es de processamento ao computador. 2 A n\u00e3o ambiguidade das linguagens de programa\u00e7\u00e3o do fato de terem uma sintaxe e sem\u00e2nticas precisas, descritas por uma gram\u00e1tica tamb\u00e9m precisa. Sintaxe A sintaxe de uma linguagem descreve o que constitui um programa estruturalmente correto e \u00e9 definida por uma gram\u00e1tica. Sem\u00e2ntica O significado de um programa \u00e9 definido por sua sem\u00e2ntica, ou seja, por regras que definem como as instru\u00e7\u00f5es especificado devem ser interpretadas. Serem precisas n\u00e3o quer dizer que as linguagens sejam simples, como demonstra claramente a seguinte imagem, que \u00e9 um programa \u00e9 um \"hello world\" na linguagem Piet . Tamb\u00e9m n\u00e3o quer dizer que sejam limitadas. De fato, h\u00e1 milhares linguagens de programa\u00e7\u00e3o por a\u00ed, e contando, com diferentes caracter\u00edsticas que as tornam mais mais ou menos apropriadas para resolver diferentes problemas. Mas mesmo apesar de t\u00e3o grande n\u00famero, as linguagens podem ser classificadas em grandes fam\u00edlias ou paradigmas.","title":"Paradigmas de Programa\u00e7\u00e3o"},{"location":"intro/#imperativo-x-descritivo","text":"Imperativo x Descritivo Imperativo: como Descritivo: o qu\u00ea Os primeiros \"computadores\" eram m\u00e1quinas que computavam mecanicamente seus resultados. Uma segunda gera\u00e7\u00e3o, da qual destacamos o ENIAC (circa 1955), eram computadores sem parte mec\u00e2nicas, programados por conex\u00f5es el\u00e9tricas de suas diversas partes. O pr\u00f3ximo passo, foram computadores que interpretavam c\u00f3digo escrito em uma linguagem de programa\u00e7\u00e3o. Estas primeiras linguagens eram todas imperativas , no sentido de que ditavam ao computador uma sequ\u00eancia de instru\u00e7\u00f5es a serem seguidas para se chegar a um resultado. Isto \u00e9, estas linguagens permitiam ao programador dizer como realizar uma computa\u00e7\u00e3o. Imperativo leia a linha 1 do arquivo separe a linha por espa\u00e7os pegue a segunda parte da linha converta a parte para n\u00famero se o n\u00famero for maior que 15, escreva na tela leia a pr\u00f3xima linha do arquivo volte para o passo 2 Este paradigma tem suas ra\u00edzes no modelo computacional cl\u00e1ssico de von Neumann e na m\u00e1quina de Turing Em contrapartida a este modelo, surgiram mais tarde linguagens declarativas , em que o programado diz o qu\u00ea deve ser computado e o computador se encarrega de achar um \"como\". Descritivo selecione todas as linhas em que a segunda parte \u00e9 maior que 15 Com uma an\u00e1lise r\u00e1pida das linguagens mais conhecidas, voce deve reconhecer a maior parte como imperativas, por exemplo, C, Java, e Python. J\u00e1 dentre as linguagens declarativas, se destacam SQL, LINQ, e Prolog. Ortogonalmente ao foco em no \"como x o qu\u00ea\", podemos nos focar em como as estas instru\u00e7\u00f5es s\u00e3o organizadas mais em um n\u00edvel mais alto, de onde se destacam quatro paradigmas principais: procedimental , orientado a objetos , l\u00f3gico e funcional . 3","title":"Imperativo x Descritivo"},{"location":"intro/#procedimental","text":"Linguagens que usam o paradigma procedimental organizam instru\u00e7\u00f5es em blocos, denominados procedimentos, de onde vem o nome, ou fun\u00e7\u00f5es. A ideia \u00e9 que o c\u00f3digo seja modularizado para separar funcionalidades e tornar o c\u00f3digo mais compreens\u00edvel e manuten\u00edvel. Cada fun\u00e7\u00e3o deve executar uma opera\u00e7\u00e3o bem espec\u00edfica, fun\u00e7\u00f5es associadas s\u00e3o colocadas em um mesmo arquivo, e arquivos associados s\u00e3o colocados em um mesmo namespace . O c\u00f3digo seguinte, em C, mostra a fun\u00e7\u00e3o main , ponto de entrada do programa e de onde a fun\u00e7\u00e3o printf , importada de stdio.h , \u00e9 invocada. 1 2 3 4 5 #include <stdio.h> int main () { printf ( \"Hello, World!\" ); return 0 ; } Al\u00e9m da linguagem C, outros exemplos \u00f3bvios deste paradigma s\u00e3o as linguagens Pascal, Fortran e Python. Contudo, mesmo linguagens como Java e C++ podem ser consideradas procedurais, uma vez que organizam a computa\u00e7\u00e3o em m\u00e9todos, que s\u00e3o nada mais que fun\u00e7\u00f5es. Mas como m\u00e9todos est\u00e3o fortemente associados a classes e suas inst\u00e2ncias, os objetos, estas linguagens s\u00e3o melhor classificadas como orientadas a objetos.","title":"Procedimental"},{"location":"intro/#orientado-a-objetos","text":"Na orienta\u00e7\u00e3o a objetos, o foco est\u00e1 n\u00e3o na execu\u00e7\u00e3o passo a passo de fun\u00e7\u00f5es, mas na organiza\u00e7\u00e3o de dados e fun\u00e7\u00f5es associadas em objetos. Embora esta organiza\u00e7\u00e3o possa ser feita em qualquer qualquer linguagem estruturada, a sintaxe das linguagens orientadas a objeto facilita e tornam mais natural este trabalho. Dois conceitos b\u00e1sicos na orienta\u00e7\u00e3o a objetos s\u00e3o as classes e os objetos . Classes s\u00e3o abstra\u00e7\u00f5es de tipos de coisas encontrados no mundo real, ou seja, receitas de estruturas de dados e definem quais os dados devem ser considerados em conjunto para representar um objeto e quais as a\u00e7\u00f5es associadas a este objeto. Por exemplo, se no mundo real cachorros tem uma data de nascimento e um nome, e s\u00e3o capazes de latir, uma classe que represente cachorros pode ser definida assim em Java. 1 2 3 4 5 6 7 8 9 10 11 class Cachorro { int diaNascimento ; int mesNascimento ; int anoNascimento ; String nome ; void latir ( int quantidade ) { for ( int i = 0 ; i < quantidade ; i ++ ) System . out . println ( nome + \": Au!\" ); } } J\u00e1 um objeto \u00e9 uma inst\u00e2ncia de uma classe, uma representa\u00e7\u00e3o de um tipo mas de uma coisa em si. Um c\u00e3o qualquer poderia ser representado assim 1 2 Cachorro cachorro1 = new Cachorro ( 25 , 12 , 2020 , \"Napole\u00e3o\" ); cachorro1 . latir ( 3 ); e a execu\u00e7\u00e3o deste c\u00f3digo resultaria em 1 2 3 Napole\u00e3o: Au! Napole\u00e3o: Au! Napole\u00e3o: Au! Observe que o \".\" em cachorro1.latir(3) quer dizer \"executar a fun\u00e7\u00e3o latir no objeto cachorro1 \", o que leva \u00e0 string Napole\u00e3o a aparecer antes de cada latido. Duas coisas poder ser ditas sobre este \".\". Primeiro, que ele n\u00e3o \u00e9 necess\u00e1rio, o objeto em si poderia ser passado como par\u00e2metro para uma fun\u00e7\u00e3o latir que recebesse o objeto al\u00e9m da quantidade de latidos; de fato, em Python, a classe seria definida como a seguir 1 2 3 4 5 6 7 8 9 class Cachorro : diaNascimento mesNascimento anoNascimento nome def latir ( self , quantidade ): for i in range ( 0 , quantidade ): print ( self . nome + \": Au!\" ) o que implica que o \".\" \u00e9 o s\u00f3 a\u00e7\u00facar sint\u00e1tico para a execu\u00e7\u00e3o de uma fun\u00e7\u00e3o, o que nos leva ao segundo ponto. Na orienta\u00e7\u00e3o a objetos conceitual, n\u00e3o se fala em invoca\u00e7\u00e3o de fun\u00e7\u00f5es mas de sinais sendo transmitidos entre objetos: envie mensagem para o 2 \"somar-se com 3\", ao que o objeto 2 responderia com uma mensagem \"refer\u00eancia ao objeto 4\". Em Smalltalk, esta intera\u00e7\u00e3o seria escrita assim: 1 x := 2 + 3 . Grande parte do poder da orienta\u00e7\u00e3o objetos est\u00e1 no encapsulamento do como opera\u00e7\u00f5es s\u00e3o executadas, nos m\u00e9todos. Uma outra ordem de encapsulamento, de outro tipo, \u00e9 encontrada no paradigma l\u00f3gico.","title":"Orientado a Objetos"},{"location":"intro/#logico","text":"No paradigma l\u00f3gico, voc\u00ea declara-se fatos b\u00e1sicos e regras sobre como os fatos se relacionam e pergunta ao programa se certos fatos s\u00e3o ou n\u00e3o s\u00e3o verdade. Por exemplo, como fatos, podemos declarar 1 2 3 4 5 eh_maior_que ( gato , rato ). eh_maior_que ( leao , gato ). eh_maior_que ( elefante , leao ). eh_maior_que ( elefante , moto ). eh_maior_que ( legal , cachorro ). que vale a transitividade 1 2 3 eh_maior_que ( A , B ) :- eh_maior_que ( A , C ), eh_maior_que ( C , B ). e, finalmente, perguntar se elefante \u00e9 maior rato 1 eh_maior_que ( elefante , rato ). ao que seremos respondidos com um \"sim\". Voc\u00ea consegue imaginar quantas linhas de c\u00f3digo voc\u00ea precisaria para expressar a mesma l\u00f3gica acima em uma linguagem como C ou Java? Apesar do claro poder deste paradigma, o mesmo tem poucos representantes, como Prolog e Mercury, e mesmo que exista v\u00e1rios compiladores do primeiro, o uso comercial do paradigma \u00e9 bem limitado.","title":"L\u00f3gico"},{"location":"intro/#funcional","text":"A programa\u00e7\u00e3o, como indicado pelo nome, \u00e9 focada na organiza\u00e7\u00e3o do processamento em termos de fun\u00e7\u00f5es, mas de uma forma diferente da programa\u00e7\u00e3o procedimental. De forma geral, fun\u00e7\u00f5es s\u00e3o blocos de c\u00f3digo criadas essencialmente para se obter reusabilidade : uma vez definidas, as fun\u00e7\u00f5es podem ser invocadas repetidas vezes para executar a mesma tarefa sobre diferentes par\u00e2metros , sempre retornando um resultado. 4 Mas enquanto na programa\u00e7\u00e3o procedimental a invoca\u00e7\u00e3o de uma fun\u00e7\u00e3o pode retornar diferentes resultados mesmo quando os par\u00e2metros s\u00e3o os mesmos, na programa\u00e7\u00e3o funcional, fun\u00e7\u00f5es s\u00e3o como na matem\u00e1tica, isto \u00e9, mapeiam uma entrada para uma sa\u00edda, sempre. N\u00e3o \u00e9 a toa que outro nome usado para definir os blocos de c\u00f3digo \u00e9 procedimento em vez de fun\u00e7\u00e3o. Vejamos alguns exemplos. As fun\u00e7\u00f5es seguintes, definidas em Erlang, calculam A+B , A*C e (A+B)*(A+B) ; independentemente de quantas vezes voc\u00ea o fizer, add(2,3) sempre retornar\u00e1 5 . 1 2 3 4 5 6 7 8 add ( A , B ) -> A + B . mult ( A , B ) -> A * B . mult_add ( A , B ) -> mult ( add ( A , B ), add ( A , B )). Agora observe a fun\u00e7\u00e3o seguinte, escritas em Python; a cada invoca\u00e7\u00e3o, a vari\u00e1vel acc tem seu valor alterado e mesmo que invocada com a mesma entrada, o resultado da fun\u00e7\u00e3o \u00e9 sempre diferente. Os efeitos externos \u00e0 fun\u00e7\u00e3o, e.g., a altera\u00e7\u00e3o da vari\u00e1vel acc , \u00e9 conhecido efeito colateral . Programa\u00e7\u00e3o funcional n\u00e3o tem tem efeitos colaterais por que trata vari\u00e1veis n\u00e3o como \u00e1reas de mem\u00f3ria alter\u00e1veis, mas como inc\u00f3gnitas, como na matem\u00e1tica. Pelo menos esta \u00e9 a ideia de programa\u00e7\u00e3o funcional pura, que \u00e9 essencialmente a escrita de longu\u00edssimas equa\u00e7\u00f5es. Acontece que devido \u00e0 complexidade inerente do uso de programa\u00e7\u00e3o funcional pura, sem efeitos colaterais, i.e., sem muta\u00e7\u00e3o de estados, muitas linguagens n\u00e3o s\u00e3o puramente funcionais. A raz\u00e3o mais comum para efeitos colaterais \u00e9 a realiza\u00e7\u00e3o de Entrada/Sa\u00edda. Por exemplo, ao invocar print no Python, o terminal tem seu estado alterado, e cada nova invoca\u00e7\u00e3o altera mais o estado. Assim, podemos dividir as linguagens e funcionais puras, funcionais n\u00e3o puras e n\u00e3o funcionais, mas mesmo dentro das n\u00e3o funcionais, h\u00e1 aquelas com elementos de programa\u00e7\u00e3o funcional.","title":"Funcional"},{"location":"intro/#funcionalidades","text":"Muitas linguagens modernas, como Python e JavaScript, embora n\u00e3o estritamente funcionais, tem diversos elementos de programa\u00e7\u00e3o funcional, eu diretamente na linguagem ou via frameworks . Python, por exemplo, v\u00e1rias funcionalidades caracter\u00edsticas do paradigma funcional, embora seja poss\u00edvel ignor\u00e1-las por completo. Por exemplo, imagine que voc\u00ea queira criar uma lista com o quadrado de todos os n\u00fameros de 1 a x . Voc\u00ea pode optar por um for cl\u00e1ssico ... 1 2 3 4 5 def quads ( x ): lista = [] for i in range ( 1 , 10 ): lista . append ( i * i ) return lista ... ou uma compreens\u00e3o de listas , como nos exemplos a seguir. 1 2 def quads2 ( x ): return [ x ** 2 for x in range ( x )] Al\u00e9m disso, h\u00e1 linguagens funcionais que tamb\u00e9m se enquadram em outros paradigmas e que podem ser consideradas h\u00edbridas, ou multi-paradigma.","title":"\"Funcionalidades\""},{"location":"intro/#multi-paradigmas","text":"Muitas linguagens modernas podem ser classificadas ao mesmo tempo em muitos paradigmas, por exemplo, a linguagem Scala \u00e9 ao mesmo tempo funcional e orientada a objetos, sendo muito dif\u00edcil us\u00e1-la sem fazer uso desta caracter\u00edstica. 1 2 3 4 5 object HelloWorld { def main ( args : Array [ String ]) : Unit = { println ( \"Hello, world!\" ) } }","title":"Multi-paradigmas"},{"location":"intro/#para-cada-servico-uma-ferramenta","text":"Em cada paradigma, encontramos vantagens e desvantagens. Como desenvolvedores de tecnologia, nada mais justo que voc\u00eas conhe\u00e7am todos os paradigmas e que possam, assim, escolher aquele paradigma e, dentro dele, aquela linguagem que permite resolver o seu problema da forma mais eficiente, isto \u00e9, rapidamente, com menor custo e com melhor qualidade. Mas quanto ao paradigma funciona, em especial, \u00e9 importante compreend\u00ea-lo pois muitas de suas funcionalidades tem sido incorporadas a outras linguagens, como compreens\u00e3o de listas em Python, fun\u00e7\u00f5es lambda em Java e C++, e processamento ass\u00edncrono pode ser visto como uma forma de avalia\u00e7\u00e3o pregui\u00e7osa em diversas linguagens. Vejamos estes outras pontos importantes do paradigma: Sem efeitos colaterais: executando um programa, de repente voc\u00ea percebe que uma certa vari\u00e1vel tem um valor estranho e fica se perguntando quem foi que atribuiu tal valor; efeitos colaterais s\u00e3o a origem de boa parte dos bugs e elimin\u00e1-los, ou ao menos reduz\u00ed-los, permite que voc\u00ea identifique rapidamente onde altera\u00e7\u00f5es poderiam ter acontecido. Camadas de abstra\u00e7\u00e3o: fun\u00e7\u00f5es podem ser compostas levando a programas verdadeiramente complexos, permitindo que abstra\u00e7\u00f5es sejam definidas em diversas camadas. Al\u00e9m disso, \u00e9 poss\u00edvel, em teoria, ser provar a corretude de fun\u00e7\u00f5es e, mesmo que na pr\u00e1tica isso n\u00e3o se realize, h\u00e1 ferramentas que conseguem usar esta ideia para lhe ajudar a encontrar bugs. Processamento paralelo eficiente: a aus\u00eancia de efeitos colaterais tamb\u00e9m implica que fun\u00e7\u00f5es sem depend\u00eancias podem ser executadas em paralelo, sem se preocupar com qualquer sincroniza\u00e7\u00e3o, isto \u00e9, sem mutexes e vari\u00e1veis de condi\u00e7\u00e3o, etc. Avalia\u00e7\u00e3o pregui\u00e7osa: fun\u00e7\u00f5es s\u00f3 precisam realmente ser executadas se seus resultados s\u00e3o necess\u00e1rios e o compilador consegue atrasar a execu\u00e7\u00e3o de fun\u00e7\u00f5es enquanto poss\u00edvel. Recurs\u00e3o de calda: alguns problemas podem ser descritos muito facilmente como uma recurs\u00e3o que com uma itera\u00e7\u00e3o, mas linguagens tradicionais tem um limite no tamanho das pilhas de fun\u00e7\u00e3o; linguagens funcionais conseguem, em certas condi\u00e7\u00f5es, usar recurs\u00e3o infinita, contornando esta limita\u00e7\u00e3o. Fun\u00e7\u00f5es de alta ordem:","title":"Para cada servi\u00e7o, uma ferramenta!"},{"location":"intro/#escolha-o-seu-veneno","text":"Como j\u00e1 ficou \u00f3bvio, h\u00e1 muitas, muitas linguagens de programa\u00e7\u00e3o por a\u00ed e \u00e9 poss\u00edvel escrever c\u00f3digo bom em cada um delas, assim como \u00e9 poss\u00edvel escrever c\u00f3digo ruim em cada uma delas. Tamb\u00e9m \u00e9 poss\u00edvel escrever usando orienta\u00e7\u00e3o a objetos ou funcionalmente em cada uma delas, mas embora seja poss\u00edvel , h\u00e1 aquelas linguagens que suportam melhor cada um dos paradigmas. Dentre estas, h\u00e1 diversas op\u00e7\u00f5es de linguagens que podemos usar para estudar o paradigma funcional, por exemplo: Scheme Lisp ML F# Erlang Elixir Haskell Clojure Neste curso, veremos princ\u00edpios gerais e que, em teoria, poderiam ser aplicados em qualquer destas linguagens. Contudo, como a sintaxe pode variar muito de uma linguagem para outra, precisaremos nos focar em uma \u00fanica linguagem, mesmo que, frequentemente, apresente exemplos em outras. Assim, nosso foco aqui ser\u00e1 em Haskell, uma linguagem funcional madura e est\u00e1vel.","title":"Escolha o seu veneno"},{"location":"intro/#recomendacoes","text":"Sobre a hist\u00f3ria das linguagens de programa\u00e7\u00e3o Sobre porqu\u00ea PF n\u00e3o \u00e9 mais comum Comunica\u00e7\u00e3o \u21a9 Linguagem de Programa\u00e7\u00e3o \u21a9 Programming Language Families \u21a9 void \u00e9 simplesmente um resultado que diz que o resultado n\u00e3o importa. \u21a9","title":"Recomenda\u00e7\u00f5es"},{"location":"preface/","text":"Pref\u00e1cio O paradigma de funcional \u00e9 um dos muitos paradigmas de programa\u00e7\u00e3o dispon\u00edveis e, uma vez que voc\u00ea tenha sido \"contaminado\" pelos outros, certamente n\u00e3o \u00e9 o mais simples de se entender. Ainda assim, \u00e9 um paradigma que deve ser estudado pois seus pontos fortes tem sido incorporados cada vez mais frequentemente em frameworks e linguagens n\u00e3o necessariamente reconhecidos como funcionais. Por isso, neste curso estudaremos o paradigma funcional de uma forma pr\u00e1tica, tentando sempre que poss\u00edvel mostrar diversas aplica\u00e7\u00f5es das ideias apresentadas no mundo da programa\u00e7\u00e3o moderna. Tamb\u00e9m ser\u00e1 foco deste curso, destacar e demonstrar como o uso do paradigma funcional traz vantagens no desenvolvimento de sistemas paralelos e distribu\u00eddos. Agradecimentos Antes de come\u00e7armos nosso estudo, deixo aqui o meu agradecimento aos professores que forneceram o material sobre o qual estas notas de aula s\u00e3o baseadas, Profa. Gina Maira B. Oliveira, Profa. Maria Adriana Vidigal de Lima, e Prof. Henrique Fernandes, da Faculdade de Computa\u00e7\u00e3o da UFU. Conven\u00e7\u00f5es Neste documento, usamos diversos recursos visuais com diferentes prop\u00f3sitos. it\u00e1lico indica termos em outras l\u00ednguas, como framework ou middleware . Alguns termos, contudo, s\u00e3o t\u00e3o corriqueiramente usados que me escapam quando escrevendo e acabam n\u00e3o grafados corretamente. negrito indica a introdu\u00e7\u00e3o de termos e conceitos importantes, como escalabilidade e falha . Apontadores indicam um s\u00edtio relacionado ao termo, por exemplo, como criar um reposit\u00f3rio no Github , e cuja leitura \u00e9 sugerida ao final da aula. Notas de rodap\u00e9, indicam uma observa\u00e7\u00e3o importante sobre o que est\u00e1 sendo apresentado, cuja leitura \u00e9 sugerida ao final do par\u00e1grafo. 1 Estas notas incluem referenciais te\u00f3ricos importantes, com detalhes da publica\u00e7\u00e3o e apontadores para onde a publica\u00e7\u00e3o pode ser lida. Imagens n\u00e3o autorais s\u00e3o tamb\u00e9m apontadores para onde s\u00e3o encontradas e tem como texto alternativo as informa\u00e7\u00f5es da autoria. Caixas alinhadas \u00e0 esquerda s\u00e3o usadas para v\u00e1rias finalidades. Por exemplo, para apresentar exerc\u00edcios, destacar especifica\u00e7\u00f5es, apontar tarefas a serem executas por mim. Os diversos usos s\u00e3o indicados nos \u00edcones e cores das caixas. Exerc\u00edcio Isso \u00e9 um exerc\u00edcio! Resposta Esta \u00e9 a resposta do exerc\u00edcio. Resumo Elementos visuais Aviso! Este material est\u00e1 em constante evolu\u00e7\u00e3o. Caixas alinhadas \u00e0 direita podem ser vistas como um sum\u00e1rio executivo do que est\u00e1 sendo apresentado no texto adjacente. Exemplo de nota de rodap\u00e9. \u21a9","title":"Pref\u00e1cio"},{"location":"preface/#prefacio","text":"O paradigma de funcional \u00e9 um dos muitos paradigmas de programa\u00e7\u00e3o dispon\u00edveis e, uma vez que voc\u00ea tenha sido \"contaminado\" pelos outros, certamente n\u00e3o \u00e9 o mais simples de se entender. Ainda assim, \u00e9 um paradigma que deve ser estudado pois seus pontos fortes tem sido incorporados cada vez mais frequentemente em frameworks e linguagens n\u00e3o necessariamente reconhecidos como funcionais. Por isso, neste curso estudaremos o paradigma funcional de uma forma pr\u00e1tica, tentando sempre que poss\u00edvel mostrar diversas aplica\u00e7\u00f5es das ideias apresentadas no mundo da programa\u00e7\u00e3o moderna. Tamb\u00e9m ser\u00e1 foco deste curso, destacar e demonstrar como o uso do paradigma funcional traz vantagens no desenvolvimento de sistemas paralelos e distribu\u00eddos.","title":"Pref\u00e1cio"},{"location":"preface/#agradecimentos","text":"Antes de come\u00e7armos nosso estudo, deixo aqui o meu agradecimento aos professores que forneceram o material sobre o qual estas notas de aula s\u00e3o baseadas, Profa. Gina Maira B. Oliveira, Profa. Maria Adriana Vidigal de Lima, e Prof. Henrique Fernandes, da Faculdade de Computa\u00e7\u00e3o da UFU.","title":"Agradecimentos"},{"location":"preface/#convencoes","text":"Neste documento, usamos diversos recursos visuais com diferentes prop\u00f3sitos. it\u00e1lico indica termos em outras l\u00ednguas, como framework ou middleware . Alguns termos, contudo, s\u00e3o t\u00e3o corriqueiramente usados que me escapam quando escrevendo e acabam n\u00e3o grafados corretamente. negrito indica a introdu\u00e7\u00e3o de termos e conceitos importantes, como escalabilidade e falha . Apontadores indicam um s\u00edtio relacionado ao termo, por exemplo, como criar um reposit\u00f3rio no Github , e cuja leitura \u00e9 sugerida ao final da aula. Notas de rodap\u00e9, indicam uma observa\u00e7\u00e3o importante sobre o que est\u00e1 sendo apresentado, cuja leitura \u00e9 sugerida ao final do par\u00e1grafo. 1 Estas notas incluem referenciais te\u00f3ricos importantes, com detalhes da publica\u00e7\u00e3o e apontadores para onde a publica\u00e7\u00e3o pode ser lida. Imagens n\u00e3o autorais s\u00e3o tamb\u00e9m apontadores para onde s\u00e3o encontradas e tem como texto alternativo as informa\u00e7\u00f5es da autoria. Caixas alinhadas \u00e0 esquerda s\u00e3o usadas para v\u00e1rias finalidades. Por exemplo, para apresentar exerc\u00edcios, destacar especifica\u00e7\u00f5es, apontar tarefas a serem executas por mim. Os diversos usos s\u00e3o indicados nos \u00edcones e cores das caixas. Exerc\u00edcio Isso \u00e9 um exerc\u00edcio! Resposta Esta \u00e9 a resposta do exerc\u00edcio. Resumo Elementos visuais Aviso! Este material est\u00e1 em constante evolu\u00e7\u00e3o. Caixas alinhadas \u00e0 direita podem ser vistas como um sum\u00e1rio executivo do que est\u00e1 sendo apresentado no texto adjacente. Exemplo de nota de rodap\u00e9. \u21a9","title":"Conven\u00e7\u00f5es"},{"location":"refs/","text":"Tutorial completo de PF https://www.tutorialspoint.com/functional_programming/functional_programming_introduction.htm","title":"Refs"}]}