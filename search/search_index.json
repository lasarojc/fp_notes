{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Notas de Aula em Programa\u00e7\u00e3o Funcional Uma abordagem pr\u00e1tica e em permanente constru\u00e7\u00e3o.","title":"Notas de Aula em <br> Programa\u00e7\u00e3o Funcional"},{"location":"#notas-de-aula-em-programacao-funcional","text":"Uma abordagem pr\u00e1tica e em permanente constru\u00e7\u00e3o.","title":"Notas de Aula em  Programa\u00e7\u00e3o Funcional"},{"location":"postface/","text":"Observa\u00e7\u00f5es Cheat sheet https://hackage.haskell.org/package/CheatSheet-1.7/src/CheatSheet.pdf Todo if tem um then e um else Diferentemente de outras linguagens, onde o if \u00e9 usado para determinar se uma computa\u00e7\u00e3o deve acontecer e o else \u00e9 um atalho para quando h\u00e1 duas op\u00e7\u00f5es, e portanto o else n\u00e3o \u00e9 necess\u00e1rio, em Haskell o if \u00e9 usado para determinar qual computa\u00e7\u00e3o deve acontecer, ou seja, sempre h\u00e1 duas op\u00e7\u00f5es . C if ( x > 3 ) //If sem else: compila. y = \"maior\" ; //Se x <= 3, y continua com o valor anterior, seja qual for. Haskell let y = if x > 3 then \"maior\" -- If sem else: n\u00e3o compila! Qual o valor de `y` se `x <= 3`? Por isso o if do Haskell deve ser comparado ao operador tern\u00e1rio do C, n\u00e3o com o if . C y = x > 3 ? \"maior\" : \"menor\" ; Haskell let y = if x > 3 then \"maior\" else \"menor\" Linha do erro As vezes o compilador aponta uma linha como tendo um erro e voc\u00ea olha para a tal linha por horas sem entender o que h\u00e1 de errado. Talvez ela n\u00e3o esteja errada! Acontece que o compilador tenta ao m\u00e1ximo usar o seu c\u00f3digo, e por isso \u00e0s vezes passa por cima de erros e s\u00f3 para quando n\u00e3o d\u00e1 mais para interpretar o arquivo. Por isso, quando o compilador apontar um erro em uma linha, sempre considere as linhas anteriores tamb\u00e9m como potencialmente problem\u00e1ticas. Falta de par\u00eanteses Prelude > 4 / 2 * 2 4.0 Prelude > 4 / ( 2 * 2 ) 1.0 Par\u00eanteses desnecess\u00e1rios ((b1+b2)/2) * h -> (b1+b2)/2 * h n\u00e3o h\u00e1 d\u00favida para o compilador que a divis\u00e3o deve ocorrer primeiro, pois os operadores tem a mesma preced\u00eancia e ambos s\u00e3o associativos \u00e0 esquerda. sqrt ((b*b)+ (c*c)) -> sqrt (b*b + c*c) n\u00e3o h\u00e1 d\u00favida para o compilador que a divis\u00e3o deve ocorrer primeiro, pois os operadores tem preced\u00eancias diferentes. Informa\u00e7\u00e3o sobre preced\u00eancia e associatividade pode ser derivadas via : info . Prelude > : info * type Num :: * -> Constraint class Num a where ... ( * ) :: a -> a -> a ... infixl 7 * -- Infixo com associatividade a esquerda (l) e Preced\u00eancia 7. Prelude > : info / type Fractional :: * -> Constraint class Num a => Fractional a where ( / ) :: a -> a -> a ... infixl 7 / -- Infixo com associatividade a esquerda (l) e Preced\u00eancia 7. Prelude > : info + type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ... infixl 6 + -- Infixo com associatividade a esquerda (l) e Preced\u00eancia 6. Quebra de linha e indenta\u00e7\u00e3o maiorDeTres a b c = if a > b && a > c then a else if b > a && b > c then b else c Dif\u00edcil leitura. Quebrar linhas. estaoOrdenados a b c = if ( a > b && b > c ) then True else False if < cond > then True else False -> < cond > estaoOrdenados a b c = a > b && b > c sqrt (( a ^ 2 ) + ( b ^ 2 )) Par\u00eanteses s\u00f3 s\u00e3o necess\u00e1rios para deixar expl\u00edcito o que \u00e9 par\u00e2metro. sqrt (( a ^ 2 ) + ( b ^ 2 )) Fun\u00e7\u00f5es e par\u00e2metros s\u00e3o separados por espa\u00e7o. sqrt (( a ^ 2 ) + ( b ^ 2 )) sqrt (( a ^ 2 ) + ( b ^ 2 )) Operadores tem preced\u00eancias; pot\u00eancia tem preced\u00eancia maior que adi\u00e7\u00e3o sqrt ( a ^ 2 + b ^ 2 ) sqrt a ^ 2 + b ^ 2 Fun\u00e7\u00f5es tem preced\u00eancia sobre operadores. sqrt a ^ 2 + b ^ 2 == ( sqrt a ^ 2 ) + b ^ 2 Exce\u00e7\u00f5es Para indicar uma condi\u00e7\u00e3o de erro, use \"error\". Por exemplo, em uma solu\u00e7\u00e3o eu encontrei o seguinte | otherwise = ( 99 , \"error\" ) mas o ideal seria | otherwise = error \"mensagem de erro\" . Caso base na recurs\u00e3o Toda recurs\u00e3o deve ter um caso base, sen\u00e3o a recurs\u00e3o n\u00e3o para. No seguinte trecho, s\u00f3 temos dois casos. Um if-then-else me parece mais leg\u00edvel. m\u00e1ximo ( x : xs ) | ( x > m\u00e1ximo xs ) = x | otherwise = m\u00e1ximo xs","title":"Erros comuns"},{"location":"postface/#observacoes","text":"","title":"Observa\u00e7\u00f5es"},{"location":"postface/#cheat-sheet","text":"https://hackage.haskell.org/package/CheatSheet-1.7/src/CheatSheet.pdf","title":"Cheat sheet"},{"location":"postface/#todo-if-tem-um-then-e-um-else","text":"Diferentemente de outras linguagens, onde o if \u00e9 usado para determinar se uma computa\u00e7\u00e3o deve acontecer e o else \u00e9 um atalho para quando h\u00e1 duas op\u00e7\u00f5es, e portanto o else n\u00e3o \u00e9 necess\u00e1rio, em Haskell o if \u00e9 usado para determinar qual computa\u00e7\u00e3o deve acontecer, ou seja, sempre h\u00e1 duas op\u00e7\u00f5es . C if ( x > 3 ) //If sem else: compila. y = \"maior\" ; //Se x <= 3, y continua com o valor anterior, seja qual for. Haskell let y = if x > 3 then \"maior\" -- If sem else: n\u00e3o compila! Qual o valor de `y` se `x <= 3`? Por isso o if do Haskell deve ser comparado ao operador tern\u00e1rio do C, n\u00e3o com o if . C y = x > 3 ? \"maior\" : \"menor\" ; Haskell let y = if x > 3 then \"maior\" else \"menor\"","title":"Todo if tem um then e um else"},{"location":"postface/#linha-do-erro","text":"As vezes o compilador aponta uma linha como tendo um erro e voc\u00ea olha para a tal linha por horas sem entender o que h\u00e1 de errado. Talvez ela n\u00e3o esteja errada! Acontece que o compilador tenta ao m\u00e1ximo usar o seu c\u00f3digo, e por isso \u00e0s vezes passa por cima de erros e s\u00f3 para quando n\u00e3o d\u00e1 mais para interpretar o arquivo. Por isso, quando o compilador apontar um erro em uma linha, sempre considere as linhas anteriores tamb\u00e9m como potencialmente problem\u00e1ticas.","title":"Linha do erro"},{"location":"postface/#falta-de-parenteses","text":"Prelude > 4 / 2 * 2 4.0 Prelude > 4 / ( 2 * 2 ) 1.0","title":"Falta de par\u00eanteses"},{"location":"postface/#parenteses-desnecessarios","text":"((b1+b2)/2) * h -> (b1+b2)/2 * h n\u00e3o h\u00e1 d\u00favida para o compilador que a divis\u00e3o deve ocorrer primeiro, pois os operadores tem a mesma preced\u00eancia e ambos s\u00e3o associativos \u00e0 esquerda. sqrt ((b*b)+ (c*c)) -> sqrt (b*b + c*c) n\u00e3o h\u00e1 d\u00favida para o compilador que a divis\u00e3o deve ocorrer primeiro, pois os operadores tem preced\u00eancias diferentes. Informa\u00e7\u00e3o sobre preced\u00eancia e associatividade pode ser derivadas via : info . Prelude > : info * type Num :: * -> Constraint class Num a where ... ( * ) :: a -> a -> a ... infixl 7 * -- Infixo com associatividade a esquerda (l) e Preced\u00eancia 7. Prelude > : info / type Fractional :: * -> Constraint class Num a => Fractional a where ( / ) :: a -> a -> a ... infixl 7 / -- Infixo com associatividade a esquerda (l) e Preced\u00eancia 7. Prelude > : info + type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ... infixl 6 + -- Infixo com associatividade a esquerda (l) e Preced\u00eancia 6.","title":"Par\u00eanteses desnecess\u00e1rios"},{"location":"postface/#quebra-de-linha-e-indentacao","text":"maiorDeTres a b c = if a > b && a > c then a else if b > a && b > c then b else c Dif\u00edcil leitura. Quebrar linhas. estaoOrdenados a b c = if ( a > b && b > c ) then True else False if < cond > then True else False -> < cond > estaoOrdenados a b c = a > b && b > c sqrt (( a ^ 2 ) + ( b ^ 2 )) Par\u00eanteses s\u00f3 s\u00e3o necess\u00e1rios para deixar expl\u00edcito o que \u00e9 par\u00e2metro. sqrt (( a ^ 2 ) + ( b ^ 2 )) Fun\u00e7\u00f5es e par\u00e2metros s\u00e3o separados por espa\u00e7o. sqrt (( a ^ 2 ) + ( b ^ 2 )) sqrt (( a ^ 2 ) + ( b ^ 2 )) Operadores tem preced\u00eancias; pot\u00eancia tem preced\u00eancia maior que adi\u00e7\u00e3o sqrt ( a ^ 2 + b ^ 2 ) sqrt a ^ 2 + b ^ 2 Fun\u00e7\u00f5es tem preced\u00eancia sobre operadores. sqrt a ^ 2 + b ^ 2 == ( sqrt a ^ 2 ) + b ^ 2","title":"Quebra de linha e indenta\u00e7\u00e3o"},{"location":"postface/#excecoes","text":"Para indicar uma condi\u00e7\u00e3o de erro, use \"error\". Por exemplo, em uma solu\u00e7\u00e3o eu encontrei o seguinte | otherwise = ( 99 , \"error\" ) mas o ideal seria | otherwise = error \"mensagem de erro\" .","title":"Exce\u00e7\u00f5es"},{"location":"postface/#caso-base-na-recursao","text":"Toda recurs\u00e3o deve ter um caso base, sen\u00e3o a recurs\u00e3o n\u00e3o para. No seguinte trecho, s\u00f3 temos dois casos. Um if-then-else me parece mais leg\u00edvel. m\u00e1ximo ( x : xs ) | ( x > m\u00e1ximo xs ) = x | otherwise = m\u00e1ximo xs","title":"Caso base na recurs\u00e3o"},{"location":"preface/","text":"Apresenta\u00e7\u00e3o O paradigma de funcional \u00e9 um dos muitos paradigmas de programa\u00e7\u00e3o dispon\u00edveis e, uma vez que voc\u00ea tenha sido \"contaminado\" pelos outros, certamente n\u00e3o \u00e9 o mais simples de se entender. Ainda assim, \u00e9 um paradigma que deve ser estudado pois seus pontos fortes tem sido incorporados cada vez mais frequentemente em frameworks e linguagens n\u00e3o necessariamente reconhecidos como funcionais. Por isso, neste curso estudaremos o paradigma funcional de uma forma pr\u00e1tica, tentando sempre que poss\u00edvel mostrar diversas aplica\u00e7\u00f5es das ideias apresentadas no mundo da programa\u00e7\u00e3o moderna. Agradecimentos Antes de come\u00e7armos nosso estudo, deixo aqui o meu agradecimento aos professores da Faculdade de Computa\u00e7\u00e3o da UFU que forneceram o material sobre o qual a primeira vers\u00e3o destas notas de aula foram baseadas: Profa. Gina Maira B. Oliveira, Profa. Maria Adriana Vidigal de Lima, e Prof. Henrique Fernandes. Conven\u00e7\u00f5es Neste documento, usamos diversos recursos visuais com diferentes prop\u00f3sitos. it\u00e1lico indica termos em outras l\u00ednguas, como framework ou middleware . Alguns termos, contudo, s\u00e3o t\u00e3o corriqueiramente usados que me escapam quando escrevendo e acabam n\u00e3o grafados corretamente. negrito indica a introdu\u00e7\u00e3o de termos e conceitos importantes, como m\u00f4nada e fun\u00e7\u00e3o de ordem superior . Apontadores indicam um s\u00edtio relacionado ao termo, por exemplo, como criar um reposit\u00f3rio no Github . A leitura dos conte\u00fados apontados \u00e9 sugerida ao final da aula. Notas de rodap\u00e9 1 indicam referenciais te\u00f3ricos importantes, com detalhes da publica\u00e7\u00e3o e apontadores para onde a publica\u00e7\u00e3o pode ser lida. Elas ser\u00e3o, em algum momento, substitu\u00eddas por refer\u00eancias formais. Imagens n\u00e3o autorais s\u00e3o tamb\u00e9m apontadores para a fonte e tem como texto alternativo as informa\u00e7\u00f5es da autoria. Caixas alinhadas \u00e0 esquerda s\u00e3o usadas para v\u00e1rias finalidades. Por exemplo, para apresentar exerc\u00edcios, destacar especifica\u00e7\u00f5es, apontar tarefas a serem executas por mim. Os diversos usos s\u00e3o indicados nos \u00edcones e cores das caixas. Exerc\u00edcio Isso \u00e9 um exerc\u00edcio! Resposta Esta \u00e9 a resposta do exerc\u00edcio. Aviso! Este material est\u00e1 em constante evolu\u00e7\u00e3o. Resumo Elementos visuais Caixas alinhadas \u00e0 direita podem ser vistas como um sum\u00e1rio executivo do que est\u00e1 sendo apresentado no texto adjacente. Exemplos de c\u00f3digo s\u00e3o colocados tanto diretamente dentro de linhas, como em somar x y = x + y quando em blocos separados, se mais longos. somar :: Int -> Int -> Int somar x y = x + y Exemplos de invoca\u00e7\u00f5es de fun\u00e7\u00f5es s\u00e3o apresentados tamb\u00e9m como blocos, em que entradas s\u00e3o precedidas por > mas n\u00e3o as sa\u00eddas. > somar 3 4 7 > 3 + 4 7 O resultado da computa\u00e7\u00e3o de uma fun\u00e7\u00e3o \u00e9 apontado por \u2b46 , por exemplo, 1+1 \u2b46 2 . Refer\u00eancias Esta \u00e9 uma lista n\u00e3o exaustiva de referencial te\u00f3rico. Esta lista ser\u00e1 aumentada com o ponteiro de entrada para o material. Refer\u00eancias a t\u00f3picos espec\u00edficos s\u00e3o apresentadas nas se\u00e7\u00f5es onde s\u00e3o usadas, como notas de rodap\u00e9. Haskell - Divide o estudo da linguagem em \"trilhas\" de diversos n\u00edveis. Learn you a Haskell for a greater good - Vis\u00e3o geral e de alto n\u00edvel da linguagem. Learn Haskell Programming - Tutorial para iniciantes. Haskell in Depth Hoogle - Haskell search engine. TODO Esta sess\u00e3o documenta o conte\u00fado presente e a ser adicionado nestas notas de aula, sendo principalmente para a minha pr\u00f3pria refer\u00eancia. A ordem n\u00e3o reflete a ordem de apresenta\u00e7\u00e3o. Organiza\u00e7\u00e3o Ativar plugin bibtex e organizar refer\u00eancias. Reorganizar e agrupar t\u00f3picos. Tipos Tipagem em Haskell Forte - sem convers\u00e3o autom\u00e1tica Est\u00e1tica - em tempo de compila\u00e7\u00e3o. Infer\u00eancia - dedu\u00e7\u00e3o de tipos n\u00e3o especificados - : t aplicado a vari\u00e1veis Tipos simples N\u00fameros Strings Tipos compostos Tuplas - Heterog\u00eaneos Listas - Homog\u00eaneos range operator [1..10] : cons ++ append !! get at index Pattern matching Compreens\u00e3o de listas (Zermello-Frankel) Listas infinitas ordena\u00e7\u00e3o selection-sort quick-sort Merge-sort Type classes Classes comuns Eq Ord Enum Show Read Bounded deriving instance Novas type classes - http://learnyouahaskell.com/making-our-own-types-and-typeclasses#algebraic-data-types Tipos especificados pelo usu\u00e1rio Defini\u00e7\u00e3o - type - apelidos para tipos n\u00e3o parametrizado parametrizado - Vari\u00e1veis de tipo Tipos alg\u00e9bricos Defini\u00e7\u00e3o - data https://mmhaskell.com/blog/2017/12/24/haskell-data-types-in-5-steps https://en.wikibooks.org/wiki/Haskell/GADT#Extending_the_language produto x soma n\u00e3o parametrizado parametrizado - Vari\u00e1veis de tipo Record Casamento de padr\u00f5es as pattern - @ Tipos recursivos Listas \u00c1rvores Tipos abstratos de dados Fila Mapa Pilha Fun\u00e7\u00f5es Equa\u00e7\u00f5es simples Guardas Casamento de padr\u00f5es where let in operadores Prot\u00f3tipos Infer\u00eancia - : t Especifica\u00e7\u00e3o manual Polimorfismo type variables http://www.decom.ufop.br/romildo/2014-1/bcc222/practices/p06-polimorfismo.pdf head :: [ a ] -> a swap :: ( a , b ) -> ( b , a ) Recurs\u00e3o simples em listas de cauda Ordem superior fold filter map . $ Currying Controle de fluxo if-then-else case-of Avalia\u00e7\u00e3o pregui\u00e7osa mostrar com listas infinitas a fun\u00e7\u00e3o cycle Where - let in https://takenobu-hs.github.io/downloads/haskell_lazy_evaluation.pdf https://stackoverflow.com/questions/32562614/is-something-in-the-where-clause-in-haskell-only-calculated-once Entrada e sa\u00edda: Show Read Monads (men\u00e7\u00e3o) IO GUI (e.g., GLOSS) M\u00f4nadas https://www.youtube.com/watch?v=t1e8gqXLbsU control monad Maybe - https://www.youtube.com/watch?v=b9FagOVqxmI Either Haskell em produ\u00e7\u00e3o Comunica\u00e7\u00e3o entre linguagens Paralelismo e Distribui\u00e7\u00e3o: actors C\u00e1lculo Lambda: Vis\u00e3o geral Lambda Calculus - Computerphile https://crypto.stanford.edu/~blynn/lambda/ https://youtu.be/3VQ382QG-y4 transpar\u00eancia referencial - https://takenobu-hs.github.io/downloads/haskell_lazy_evaluation.pdf idempot\u00eancia Test HSpec quickcheck - https://www.cs.umd.edu/class/spring2019/cmsc388F/lectures/randomized-testing.html quickcheck + Hspec https://hspec.github.io/quickcheck.html Test com IO Exerc\u00edcios/Provas https://www.cantab.net/users/antoni.diller/haskell/questions/quest07.pdf https://exercism.io https://www.cse.chalmers.se/edu/year/2018/course/TDA555/exam.html https://www.cse.chalmers.se/edu/year/2018/course/TDA555/ex-week2.html https://haskell.mooc.fi/part1#sidenote-the-.-and-operators https://cs.anu.edu.au/courses/comp1100/lectures/ Pequenos projetos jogo da forca para demonstrar IO jogo da velha para demonstrar IO e um pouquinho de IA torres de hanoi bomberman Exemplo de nota de rodap\u00e9. \u21a9","title":"Apresenta\u00e7\u00e3o"},{"location":"preface/#apresentacao","text":"O paradigma de funcional \u00e9 um dos muitos paradigmas de programa\u00e7\u00e3o dispon\u00edveis e, uma vez que voc\u00ea tenha sido \"contaminado\" pelos outros, certamente n\u00e3o \u00e9 o mais simples de se entender. Ainda assim, \u00e9 um paradigma que deve ser estudado pois seus pontos fortes tem sido incorporados cada vez mais frequentemente em frameworks e linguagens n\u00e3o necessariamente reconhecidos como funcionais. Por isso, neste curso estudaremos o paradigma funcional de uma forma pr\u00e1tica, tentando sempre que poss\u00edvel mostrar diversas aplica\u00e7\u00f5es das ideias apresentadas no mundo da programa\u00e7\u00e3o moderna.","title":"Apresenta\u00e7\u00e3o"},{"location":"preface/#agradecimentos","text":"Antes de come\u00e7armos nosso estudo, deixo aqui o meu agradecimento aos professores da Faculdade de Computa\u00e7\u00e3o da UFU que forneceram o material sobre o qual a primeira vers\u00e3o destas notas de aula foram baseadas: Profa. Gina Maira B. Oliveira, Profa. Maria Adriana Vidigal de Lima, e Prof. Henrique Fernandes.","title":"Agradecimentos"},{"location":"preface/#convencoes","text":"Neste documento, usamos diversos recursos visuais com diferentes prop\u00f3sitos. it\u00e1lico indica termos em outras l\u00ednguas, como framework ou middleware . Alguns termos, contudo, s\u00e3o t\u00e3o corriqueiramente usados que me escapam quando escrevendo e acabam n\u00e3o grafados corretamente. negrito indica a introdu\u00e7\u00e3o de termos e conceitos importantes, como m\u00f4nada e fun\u00e7\u00e3o de ordem superior . Apontadores indicam um s\u00edtio relacionado ao termo, por exemplo, como criar um reposit\u00f3rio no Github . A leitura dos conte\u00fados apontados \u00e9 sugerida ao final da aula. Notas de rodap\u00e9 1 indicam referenciais te\u00f3ricos importantes, com detalhes da publica\u00e7\u00e3o e apontadores para onde a publica\u00e7\u00e3o pode ser lida. Elas ser\u00e3o, em algum momento, substitu\u00eddas por refer\u00eancias formais. Imagens n\u00e3o autorais s\u00e3o tamb\u00e9m apontadores para a fonte e tem como texto alternativo as informa\u00e7\u00f5es da autoria. Caixas alinhadas \u00e0 esquerda s\u00e3o usadas para v\u00e1rias finalidades. Por exemplo, para apresentar exerc\u00edcios, destacar especifica\u00e7\u00f5es, apontar tarefas a serem executas por mim. Os diversos usos s\u00e3o indicados nos \u00edcones e cores das caixas. Exerc\u00edcio Isso \u00e9 um exerc\u00edcio! Resposta Esta \u00e9 a resposta do exerc\u00edcio. Aviso! Este material est\u00e1 em constante evolu\u00e7\u00e3o. Resumo Elementos visuais Caixas alinhadas \u00e0 direita podem ser vistas como um sum\u00e1rio executivo do que est\u00e1 sendo apresentado no texto adjacente. Exemplos de c\u00f3digo s\u00e3o colocados tanto diretamente dentro de linhas, como em somar x y = x + y quando em blocos separados, se mais longos. somar :: Int -> Int -> Int somar x y = x + y Exemplos de invoca\u00e7\u00f5es de fun\u00e7\u00f5es s\u00e3o apresentados tamb\u00e9m como blocos, em que entradas s\u00e3o precedidas por > mas n\u00e3o as sa\u00eddas. > somar 3 4 7 > 3 + 4 7 O resultado da computa\u00e7\u00e3o de uma fun\u00e7\u00e3o \u00e9 apontado por \u2b46 , por exemplo, 1+1 \u2b46 2 .","title":"Conven\u00e7\u00f5es"},{"location":"preface/#referencias","text":"Esta \u00e9 uma lista n\u00e3o exaustiva de referencial te\u00f3rico. Esta lista ser\u00e1 aumentada com o ponteiro de entrada para o material. Refer\u00eancias a t\u00f3picos espec\u00edficos s\u00e3o apresentadas nas se\u00e7\u00f5es onde s\u00e3o usadas, como notas de rodap\u00e9. Haskell - Divide o estudo da linguagem em \"trilhas\" de diversos n\u00edveis. Learn you a Haskell for a greater good - Vis\u00e3o geral e de alto n\u00edvel da linguagem. Learn Haskell Programming - Tutorial para iniciantes. Haskell in Depth Hoogle - Haskell search engine.","title":"Refer\u00eancias"},{"location":"preface/#todo","text":"Esta sess\u00e3o documenta o conte\u00fado presente e a ser adicionado nestas notas de aula, sendo principalmente para a minha pr\u00f3pria refer\u00eancia. A ordem n\u00e3o reflete a ordem de apresenta\u00e7\u00e3o. Organiza\u00e7\u00e3o Ativar plugin bibtex e organizar refer\u00eancias. Reorganizar e agrupar t\u00f3picos. Tipos Tipagem em Haskell Forte - sem convers\u00e3o autom\u00e1tica Est\u00e1tica - em tempo de compila\u00e7\u00e3o. Infer\u00eancia - dedu\u00e7\u00e3o de tipos n\u00e3o especificados - : t aplicado a vari\u00e1veis Tipos simples N\u00fameros Strings Tipos compostos Tuplas - Heterog\u00eaneos Listas - Homog\u00eaneos range operator [1..10] : cons ++ append !! get at index Pattern matching Compreens\u00e3o de listas (Zermello-Frankel) Listas infinitas ordena\u00e7\u00e3o selection-sort quick-sort Merge-sort Type classes Classes comuns Eq Ord Enum Show Read Bounded deriving instance Novas type classes - http://learnyouahaskell.com/making-our-own-types-and-typeclasses#algebraic-data-types Tipos especificados pelo usu\u00e1rio Defini\u00e7\u00e3o - type - apelidos para tipos n\u00e3o parametrizado parametrizado - Vari\u00e1veis de tipo Tipos alg\u00e9bricos Defini\u00e7\u00e3o - data https://mmhaskell.com/blog/2017/12/24/haskell-data-types-in-5-steps https://en.wikibooks.org/wiki/Haskell/GADT#Extending_the_language produto x soma n\u00e3o parametrizado parametrizado - Vari\u00e1veis de tipo Record Casamento de padr\u00f5es as pattern - @ Tipos recursivos Listas \u00c1rvores Tipos abstratos de dados Fila Mapa Pilha Fun\u00e7\u00f5es Equa\u00e7\u00f5es simples Guardas Casamento de padr\u00f5es where let in operadores Prot\u00f3tipos Infer\u00eancia - : t Especifica\u00e7\u00e3o manual Polimorfismo type variables http://www.decom.ufop.br/romildo/2014-1/bcc222/practices/p06-polimorfismo.pdf head :: [ a ] -> a swap :: ( a , b ) -> ( b , a ) Recurs\u00e3o simples em listas de cauda Ordem superior fold filter map . $ Currying Controle de fluxo if-then-else case-of Avalia\u00e7\u00e3o pregui\u00e7osa mostrar com listas infinitas a fun\u00e7\u00e3o cycle Where - let in https://takenobu-hs.github.io/downloads/haskell_lazy_evaluation.pdf https://stackoverflow.com/questions/32562614/is-something-in-the-where-clause-in-haskell-only-calculated-once Entrada e sa\u00edda: Show Read Monads (men\u00e7\u00e3o) IO GUI (e.g., GLOSS) M\u00f4nadas https://www.youtube.com/watch?v=t1e8gqXLbsU control monad Maybe - https://www.youtube.com/watch?v=b9FagOVqxmI Either Haskell em produ\u00e7\u00e3o Comunica\u00e7\u00e3o entre linguagens Paralelismo e Distribui\u00e7\u00e3o: actors C\u00e1lculo Lambda: Vis\u00e3o geral Lambda Calculus - Computerphile https://crypto.stanford.edu/~blynn/lambda/ https://youtu.be/3VQ382QG-y4 transpar\u00eancia referencial - https://takenobu-hs.github.io/downloads/haskell_lazy_evaluation.pdf idempot\u00eancia Test HSpec quickcheck - https://www.cs.umd.edu/class/spring2019/cmsc388F/lectures/randomized-testing.html quickcheck + Hspec https://hspec.github.io/quickcheck.html Test com IO Exerc\u00edcios/Provas https://www.cantab.net/users/antoni.diller/haskell/questions/quest07.pdf https://exercism.io https://www.cse.chalmers.se/edu/year/2018/course/TDA555/exam.html https://www.cse.chalmers.se/edu/year/2018/course/TDA555/ex-week2.html https://haskell.mooc.fi/part1#sidenote-the-.-and-operators https://cs.anu.edu.au/courses/comp1100/lectures/ Pequenos projetos jogo da forca para demonstrar IO jogo da velha para demonstrar IO e um pouquinho de IA torres de hanoi bomberman Exemplo de nota de rodap\u00e9. \u21a9","title":"TODO"},{"location":"development/","text":"Desenvolvimento de Software em Haskell O desenvolvimento de software, em qualquer paradigma e usando qualquer linguagem, requer organiza\u00e7\u00e3o para que tarefa n\u00e3o gere artefatos de dif\u00edcil uso e manuten\u00e7\u00e3o. Um dos pontos principais desta organiza\u00e7\u00e3o \u00e9 a divis\u00e3o do c\u00f3digo em m\u00f3dulos contendo partes do c\u00f3digo com forte associa\u00e7\u00e3o, como classes que descrevem um dom\u00ednio de problema, quer fornecem uma funcionalidade, ou que podem, ao menos em teoria, ser usados independentemente de outros m\u00f3dulos. Assim, m\u00f3dulos facilitam o gerenciamento da complexidade inerente dos artefatos de software. A modulariza\u00e7\u00e3o pode acontecer em v\u00e1rios n\u00edveis. Por exemplo, um m\u00f3dulo que fornece funcionalidades de manipula\u00e7\u00e3o de interfaces gr\u00e1ficas, pode ter um subm\u00f3dulos espec\u00edficos para diferentes placas gr\u00e1ficas, ou uma biblioteca para comunica\u00e7\u00e3o entre processos via rede de computadores pode ser dividida em comunica\u00e7\u00e3o segura e n\u00e3o segura. Embora os softwares que desenvolveremos neste curso sejam pequenos e de baixa complexidade, precisamos pensar em modulariza\u00e7\u00e3o tanto para a cria\u00e7\u00e3o de bons h\u00e1bitos mas tamb\u00e9m para usarmos a vasta biblioteca dispon\u00edvel para projetos nesta linguagem. Outro aspecto importante do desenvolvimento s\u00e3o os testes, que aumentam a confian\u00e7a na corretude do c\u00f3digo. Novamente temos op\u00e7\u00f5es para o desenvolvimento de testes.","title":"Desenvolvimento de Software em Haskell"},{"location":"development/#desenvolvimento-de-software-em-haskell","text":"O desenvolvimento de software, em qualquer paradigma e usando qualquer linguagem, requer organiza\u00e7\u00e3o para que tarefa n\u00e3o gere artefatos de dif\u00edcil uso e manuten\u00e7\u00e3o. Um dos pontos principais desta organiza\u00e7\u00e3o \u00e9 a divis\u00e3o do c\u00f3digo em m\u00f3dulos contendo partes do c\u00f3digo com forte associa\u00e7\u00e3o, como classes que descrevem um dom\u00ednio de problema, quer fornecem uma funcionalidade, ou que podem, ao menos em teoria, ser usados independentemente de outros m\u00f3dulos. Assim, m\u00f3dulos facilitam o gerenciamento da complexidade inerente dos artefatos de software. A modulariza\u00e7\u00e3o pode acontecer em v\u00e1rios n\u00edveis. Por exemplo, um m\u00f3dulo que fornece funcionalidades de manipula\u00e7\u00e3o de interfaces gr\u00e1ficas, pode ter um subm\u00f3dulos espec\u00edficos para diferentes placas gr\u00e1ficas, ou uma biblioteca para comunica\u00e7\u00e3o entre processos via rede de computadores pode ser dividida em comunica\u00e7\u00e3o segura e n\u00e3o segura. Embora os softwares que desenvolveremos neste curso sejam pequenos e de baixa complexidade, precisamos pensar em modulariza\u00e7\u00e3o tanto para a cria\u00e7\u00e3o de bons h\u00e1bitos mas tamb\u00e9m para usarmos a vasta biblioteca dispon\u00edvel para projetos nesta linguagem. Outro aspecto importante do desenvolvimento s\u00e3o os testes, que aumentam a confian\u00e7a na corretude do c\u00f3digo. Novamente temos op\u00e7\u00f5es para o desenvolvimento de testes.","title":"Desenvolvimento de Software em Haskell"},{"location":"development/hspec/","text":"HSpec 1 Quando desenvolvemos software, \u00e9 imprescind\u00edvel que criemos testes para verificar a corretude de nosso c\u00f3digo, ou pelo menos ganhar confian\u00e7a em sua corretude. HSpec \u00e9 um framework que possibilita escrever e executar testes unit\u00e1rios de fun\u00e7\u00f5es; o framework prov\u00ea uma linguagem de dom\u00ednio espec\u00edfico para escrever os testes tamb\u00e9m em Haskell. Usaremos seguinte arquivo test/Tests.hs como exemplo para descrever a linguagem em (muito) alto n\u00edvel. import Test.Hspec ( Spec , it , shouldBe , describe ) import Test.Hspec.Runner ( configFastFail , defaultConfig , hspecWith ) import Exercise ( hello , ol\u00e1 , soma ) main :: IO () main = hspecWith defaultConfig { configFastFail = False } specs specs :: Spec specs = do describe \"hello\" $ do it \"retorna a string `Hello, Haskell!`\" $ hello ` shouldBe ` \"Hello, Haskell!\" describe \"ol\u00e1\" $ do it \"retorna a string `Ol\u00e1, Haskell!\" $ hello ` shouldBe ` \"Ol\u00e1, Haskell!\" describe \"soma\" $ do it \"soma n\u00fameros positivos\" $ soma 1 2 ` shouldBe ` 3 it \"soma n\u00fameros negativos\" $ soma ( - 1 ) ( - 2 ) ` shouldBe ` ( - 3 ) it \"soma n\u00fameros zeros\" $ soma 0 0 ` shouldBe ` 0 import Para testar algum m\u00f3dulo, no exemplo, Exercise , \u00e9 necess\u00e1rio import\u00e1-lo; observe que tr\u00eas fun\u00e7\u00f5es foram especificadas na importa\u00e7\u00e3o, e ser\u00e3o o alvo dos testes. Para usar o framework , voc\u00ea tamb\u00e9m precisa importar os m\u00f3dulos que o comp\u00f5em, ou pelo menos algumas de suas fun\u00e7\u00f5es. Duas das fun\u00e7\u00f5es importadas na primeira linha s\u00e3o it e describe . main A fun\u00e7\u00e3o main ser\u00e1 executada quando os testes forem disparados e, como pode ser visto no final de sua defini\u00e7\u00e3o, main invoca specs . do specs \u00e9 iniciada com um do ; por enquanto voc\u00ea pode entender esta palavra chave como criando um bloco em que v\u00e1rios describe s\u00e3o especificados. It describes Cada describe inicia uma bateria de teste relacionados, especificados em seu proprio bloco do . A primeira parte do describe \u00e9 uma string que identifica o grupo de testes, por exemplo pelo nome da fun\u00e7\u00e3o a ser testada. Cada it define um teste individual. A string na defini\u00e7\u00e3o do it descreve o caso de teste espec\u00edfico, por exemplo, se a entrada \u00e9 negativa ou inv\u00e1lida. A segunda parte do it faz a invoca\u00e7\u00e3o da fun\u00e7\u00e3o sendo testada, com os par\u00e2metros para o teste. A \u00faltima parte define o resultado esperado para a invoca\u00e7\u00e3o, por meio de um shouldBe . Por exemplo, o resultado da soma de 1 e 1 should be 2. Outras funcionalidades. HSpec permite testes muito mais complexos do que estes exemplos acima, por exemplo testando se erros foram emitidos pela fun\u00e7\u00e3o quando par\u00e2metros inv\u00e1lidos s\u00e3o passados. https://hspec.github.io \u21a9","title":"HSpec"},{"location":"development/hspec/#hspec-1","text":"Quando desenvolvemos software, \u00e9 imprescind\u00edvel que criemos testes para verificar a corretude de nosso c\u00f3digo, ou pelo menos ganhar confian\u00e7a em sua corretude. HSpec \u00e9 um framework que possibilita escrever e executar testes unit\u00e1rios de fun\u00e7\u00f5es; o framework prov\u00ea uma linguagem de dom\u00ednio espec\u00edfico para escrever os testes tamb\u00e9m em Haskell. Usaremos seguinte arquivo test/Tests.hs como exemplo para descrever a linguagem em (muito) alto n\u00edvel. import Test.Hspec ( Spec , it , shouldBe , describe ) import Test.Hspec.Runner ( configFastFail , defaultConfig , hspecWith ) import Exercise ( hello , ol\u00e1 , soma ) main :: IO () main = hspecWith defaultConfig { configFastFail = False } specs specs :: Spec specs = do describe \"hello\" $ do it \"retorna a string `Hello, Haskell!`\" $ hello ` shouldBe ` \"Hello, Haskell!\" describe \"ol\u00e1\" $ do it \"retorna a string `Ol\u00e1, Haskell!\" $ hello ` shouldBe ` \"Ol\u00e1, Haskell!\" describe \"soma\" $ do it \"soma n\u00fameros positivos\" $ soma 1 2 ` shouldBe ` 3 it \"soma n\u00fameros negativos\" $ soma ( - 1 ) ( - 2 ) ` shouldBe ` ( - 3 ) it \"soma n\u00fameros zeros\" $ soma 0 0 ` shouldBe ` 0","title":"HSpec 1"},{"location":"development/modules/","text":"Modulariza\u00e7\u00e3o A modulariza\u00e7\u00e3o em Haskell acontece em dois n\u00edveis, m\u00f3dulos e pacotes. M\u00f3dulos No primeiro n\u00edvel de modulariza\u00e7\u00e3o, o c\u00f3digo \u00e9 organizado em m\u00f3dulos, que cont\u00e9m fun\u00e7\u00f5es e tipos associados. Um programa em Haskell \u00e9 uma cole\u00e7\u00e3o de m\u00f3dulos, dentre os quais deve haver um m\u00f3dulo Main , que deve conter uma fun\u00e7\u00e3o main e que servir\u00e1 de ponto de entrada para a execu\u00e7\u00e3o do programa. Se o c\u00f3digo for apenas interpretado, n\u00e3o h\u00e1 a necessidade da presen\u00e7a de uma fun\u00e7\u00e3o main . Cada m\u00f3dulo corresponde a um arquivo; o m\u00f3dulo pode exportar defini\u00e7\u00f5es e importar defini\u00e7\u00f5es de outros m\u00f3dulos, do mesmo time ou de bibliotecas de terceiros. Todo m\u00f3dulo tem a seguinte estrutura, onde o nome do m\u00f3dulo deve necessariamente come\u00e7ar com uma letra mai\u00fascula. module NomeDoM\u00f3dulo {( lista de fun\u00e7\u00f5es exportadas )} where -- imports: Nome do m\u00f3dulo, seguido pelas fun\u00e7\u00f5es a serem importadas. import Data.Char ( toLower ) -- Defini\u00e7\u00f5es de tipos e fun\u00e7\u00f5es. M\u00f3dulos podem ter nomes hierarquizados, como N\u00fameros . Complexos . Opera\u00e7\u00f5es , o que \u00e9 interpretado pelo GHC como uma organiza\u00e7\u00e3o em subdiret\u00f3rios. Por exemplo, veja os seguinte m\u00f3dulos e organiza\u00e7\u00e3o correspondente dos arquivos. Main.hs module Main where import Database import Database.Transaction import Server import Server.WebUI -- C\u00f3digo Database.hs module Database where import Database.InputOutput import Database.Cache import Database.Transaction --- C\u00f3digo Cache.hs module Database.Cache where import Database.InputOutput --- c\u00f3digo / | +---+-- Main.hs | | | +-- Database.hs | | | +-- Server.hs +--- Database | | | +-- InputOutput.hs | | | +-- Cache.hs | | | +-- Transaction.hs +--- Server | +-- WebUI.hs | +-- REST.hs Exportando fun\u00e7\u00f5es espec\u00edficas Importando fun\u00e7\u00f5es espec\u00edficas Prelude Por padr\u00e3o, o m\u00f3dulo prelude 2 \u00e9 carregado toda vez que executa o ghci ou compila um programa, a n\u00e3o ser que seja explicitamente indicado em contr\u00e1rio. Este m\u00f3dulo cont\u00e9m a defini\u00e7\u00e3o dos tipos e operadores b\u00e1sicos vistos anteriormente, al\u00e9m de muitos outros, e o GHC.Num \u00e9 parte do Prelude. Uma pequena mas interessante amostra de outros tipos e fun\u00e7\u00f5es. Nome Defini\u00e7\u00e3o min Menor de 2 elementos orden\u00e1veis max Maior de 2 elementos orden\u00e1veis Semigroup Uma classe em que vale a associatividade Monoid Mon\u00f3ide em que h\u00e1 um elemento identidade putChar Escreve um caractere na saida padr\u00e3o getString L\u00ea uma string da entrada padr\u00e3o Estes exemplos servem para mostrar como o m\u00f3dulo mais b\u00e1sico do Haskell \u00e9 diverso e como a sua biblioteca \u00e9 mais diversa ainda. Al\u00e9m do Prelude, centenas de outros m\u00f3dulos est\u00e3o dispon\u00edveis na Web, de compiladores a geradores de gr\u00e1ficos 3D, de transformadas r\u00e1pidas de Fourier a message brokers , em reposit\u00f3rios como o Hackage. 1 Contudo, \u00e9 preciso ter cuidado com os m\u00f3dulos que baixa. Caso voc\u00ea encontre um m\u00f3dulo que queira usar, de nome X , bastar baix\u00e1-lo e usar o import . Por exemplo, para trabalhar com n\u00fameros complexos, voce pode usar o m\u00f3dulo Data . Complex assim: Prelude > import Data.Complex Prelude Data . Complex > let x = 1.0 :+ 0.0 Prelude Data . Complex > x 1.0 :+ 0.0 Packages M\u00f3dulos podem ser agrupados em pacotes e disponibilizados como bibliotecas para outros desenvolvedores. Isto \u00e9 feito para as bibliotecas padr\u00e3o da linguagem mas tamb\u00e9m para contribui\u00e7\u00f5es de desenvolvedores independentes. Dificilmente voc\u00ea escrever\u00e1 algo de \u00fatil sem importar ao menos alguns m\u00f3dulos da biblioteca padr\u00e3o e para importar os m\u00f3dulos de algum pacote n\u00e3o padr\u00e3o, voc\u00ea precisa primeiro instalar o pacote e configur\u00e1-o para que seja acess\u00edvel ao compilador ou interpretador, uma tarefa ingrata. Considerando que h\u00e1 tamb\u00e9m diversas vers\u00f5es do compilador que usaremos, o Haskell, e que certos pacotes dependem de vers\u00f5es espec\u00edficas do Haskell e de outros pacotes, configura\u00e7\u00f5es manuais se tornam muito trabalhosas. Em vez disso, pode-se usar ferramentas como Cabal e Stack , que permitem descrever os pacotes as serem instalados e suas respectivas vers\u00f5es, por projeto, e estas gerenciar\u00e3o as depend\u00eancias automaticamente em tempo de compila\u00e7\u00e3o. H\u00e1 uma certa disputa entre as duas ferramentas, bem como formas de se traduzir as informa\u00e7\u00f5es de uma ferramenta para outra, mas isto est\u00e1 fora do escopo deste material. O escopo se resume a simplesmente prover um esqueleto para uso do Stack, que permite a execu\u00e7\u00e3o de testes automatizados tanto na sua m\u00e1quina quando nos servidores em que far\u00e1 a submiss\u00e3o dos seus exerc\u00edcios. Esqueleto de Projeto As listas de exerc\u00edcios s\u00e3o disponibilizadas via GithubClassroom, o que efetivamente cria um reposit\u00f3rio para cada lista, para cada um dos alunos. O reposit\u00f3rio tem uma estrutura similar ao seguinte template . | +---+-- stack.yaml | | | +-- package.yml +--- src | | | +-- Exercise.hs +--- test | +-- Tests.hs Depois de clonar este reposit\u00f3rio, da raiz do mesmo, digite stack test . A defini\u00e7\u00e3o do ambiente no arquivo stack.yml ser\u00e1 usada para iniciar a execu\u00e7\u00e3o dos testes especificados em test/Tests.hs , que executam fun\u00e7\u00f5es em src/Exercise.hs . Use este template para criar novos projetos e seus testes; adicione novas depend\u00eancias no arquivo stack.yml . https://hackage.haskell.org/packages/browse \u21a9 Prelude: https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html [^typeconversion] https://andrew.gibiansky.com/blog/haskell/haskell-typeclasses/#_read \u21a9","title":"M\u00f3dulos"},{"location":"development/modules/#modularizacao","text":"A modulariza\u00e7\u00e3o em Haskell acontece em dois n\u00edveis, m\u00f3dulos e pacotes.","title":"Modulariza\u00e7\u00e3o"},{"location":"development/modules/#modulos","text":"No primeiro n\u00edvel de modulariza\u00e7\u00e3o, o c\u00f3digo \u00e9 organizado em m\u00f3dulos, que cont\u00e9m fun\u00e7\u00f5es e tipos associados. Um programa em Haskell \u00e9 uma cole\u00e7\u00e3o de m\u00f3dulos, dentre os quais deve haver um m\u00f3dulo Main , que deve conter uma fun\u00e7\u00e3o main e que servir\u00e1 de ponto de entrada para a execu\u00e7\u00e3o do programa. Se o c\u00f3digo for apenas interpretado, n\u00e3o h\u00e1 a necessidade da presen\u00e7a de uma fun\u00e7\u00e3o main . Cada m\u00f3dulo corresponde a um arquivo; o m\u00f3dulo pode exportar defini\u00e7\u00f5es e importar defini\u00e7\u00f5es de outros m\u00f3dulos, do mesmo time ou de bibliotecas de terceiros. Todo m\u00f3dulo tem a seguinte estrutura, onde o nome do m\u00f3dulo deve necessariamente come\u00e7ar com uma letra mai\u00fascula. module NomeDoM\u00f3dulo {( lista de fun\u00e7\u00f5es exportadas )} where -- imports: Nome do m\u00f3dulo, seguido pelas fun\u00e7\u00f5es a serem importadas. import Data.Char ( toLower ) -- Defini\u00e7\u00f5es de tipos e fun\u00e7\u00f5es. M\u00f3dulos podem ter nomes hierarquizados, como N\u00fameros . Complexos . Opera\u00e7\u00f5es , o que \u00e9 interpretado pelo GHC como uma organiza\u00e7\u00e3o em subdiret\u00f3rios. Por exemplo, veja os seguinte m\u00f3dulos e organiza\u00e7\u00e3o correspondente dos arquivos. Main.hs module Main where import Database import Database.Transaction import Server import Server.WebUI -- C\u00f3digo Database.hs module Database where import Database.InputOutput import Database.Cache import Database.Transaction --- C\u00f3digo Cache.hs module Database.Cache where import Database.InputOutput --- c\u00f3digo / | +---+-- Main.hs | | | +-- Database.hs | | | +-- Server.hs +--- Database | | | +-- InputOutput.hs | | | +-- Cache.hs | | | +-- Transaction.hs +--- Server | +-- WebUI.hs | +-- REST.hs","title":"M\u00f3dulos"},{"location":"development/modules/#packages","text":"M\u00f3dulos podem ser agrupados em pacotes e disponibilizados como bibliotecas para outros desenvolvedores. Isto \u00e9 feito para as bibliotecas padr\u00e3o da linguagem mas tamb\u00e9m para contribui\u00e7\u00f5es de desenvolvedores independentes. Dificilmente voc\u00ea escrever\u00e1 algo de \u00fatil sem importar ao menos alguns m\u00f3dulos da biblioteca padr\u00e3o e para importar os m\u00f3dulos de algum pacote n\u00e3o padr\u00e3o, voc\u00ea precisa primeiro instalar o pacote e configur\u00e1-o para que seja acess\u00edvel ao compilador ou interpretador, uma tarefa ingrata. Considerando que h\u00e1 tamb\u00e9m diversas vers\u00f5es do compilador que usaremos, o Haskell, e que certos pacotes dependem de vers\u00f5es espec\u00edficas do Haskell e de outros pacotes, configura\u00e7\u00f5es manuais se tornam muito trabalhosas. Em vez disso, pode-se usar ferramentas como Cabal e Stack , que permitem descrever os pacotes as serem instalados e suas respectivas vers\u00f5es, por projeto, e estas gerenciar\u00e3o as depend\u00eancias automaticamente em tempo de compila\u00e7\u00e3o. H\u00e1 uma certa disputa entre as duas ferramentas, bem como formas de se traduzir as informa\u00e7\u00f5es de uma ferramenta para outra, mas isto est\u00e1 fora do escopo deste material. O escopo se resume a simplesmente prover um esqueleto para uso do Stack, que permite a execu\u00e7\u00e3o de testes automatizados tanto na sua m\u00e1quina quando nos servidores em que far\u00e1 a submiss\u00e3o dos seus exerc\u00edcios.","title":"Packages"},{"location":"development/modules/#esqueleto-de-projeto","text":"As listas de exerc\u00edcios s\u00e3o disponibilizadas via GithubClassroom, o que efetivamente cria um reposit\u00f3rio para cada lista, para cada um dos alunos. O reposit\u00f3rio tem uma estrutura similar ao seguinte template . | +---+-- stack.yaml | | | +-- package.yml +--- src | | | +-- Exercise.hs +--- test | +-- Tests.hs Depois de clonar este reposit\u00f3rio, da raiz do mesmo, digite stack test . A defini\u00e7\u00e3o do ambiente no arquivo stack.yml ser\u00e1 usada para iniciar a execu\u00e7\u00e3o dos testes especificados em test/Tests.hs , que executam fun\u00e7\u00f5es em src/Exercise.hs . Use este template para criar novos projetos e seus testes; adicione novas depend\u00eancias no arquivo stack.yml . https://hackage.haskell.org/packages/browse \u21a9 Prelude: https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html [^typeconversion] https://andrew.gibiansky.com/blog/haskell/haskell-typeclasses/#_read \u21a9","title":"Esqueleto de Projeto"},{"location":"development/quickcheck/","text":"Escrever casos de teste individuais \u00e9 uma tarefa tediosa e \u00e0 medida que nossas fun\u00e7\u00f5es ficam mais complexas, gastar\u00edamos mais e mais tempo escrevendo testes. Uma ferramenta que nos ajuda a fazer isso \u00e9 a biblioteca QuickCheck . Para entender como usar a QuickCheck, considere as duas seguintes fun\u00e7\u00f5es. celsius2fahrenheit c = c * 9 / 5 + 32 fahrenheit2celsius f = ( f - 32 ) * 5 / 9 Elas s\u00e3o obviamente inversas uma da outra, o que quer dizer que se eu aplicar um valor qualquer \u00e0 primeira fun\u00e7\u00e3o e ent\u00e3o aplicar o resultado na segunda, eu deveria recuperar o valor original. Por exemplo, se o valor qualquer \u00e9 100, 100 == fahrenheit2celsius ( celsius2fahrenheit 100 ) . Pois a QuickCheck nos permite escrever exatamente este tipo de afirma\u00e7\u00e3o e t\u00ea-la testada automaticamente para um conjunto de valores aleat\u00f3rios. Obviamente, mesmo se o c\u00f3digo passar nos testes gerados pelo QuickCheck, n\u00e3o quer dizer que outros valores n\u00e3o resultariam em erros. Contudo, nossa confian\u00e7a na corretude aumentaria. Para testar as fun\u00e7\u00f5es acima escrever\u00edamos ent\u00e3o a propriedade como uma fun\u00e7\u00e3o que retorna um booleano. A propriedade tem um nome iniciado em prop_ , mas isso \u00e9 apenas uma conven\u00e7\u00e3o. A defini\u00e7\u00e3o recebe como par\u00e2metro um valor c , converte para Celsius e de volta para Fahrenheit, e confere se o valor resultante \u00e9 igual ao valor de entrada. Observe que o resultado da fun\u00e7\u00e3o \u00e9 o resultado da compara\u00e7\u00e3o com o valor inicial, o que \u00e9 equivalente mas muito mais limpo do que fazer um teste do tipo if Condi\u00e7\u00e3o then True else False . prop_C2f2C c = fahrenheit2celsius ( celsius2fahrenheit c ) == c Para usar a biblioteca, precisamos import\u00e1-la, no in\u00edcio do arquivo, com um import Test.QuickCheck . Assim, o arquivo ficar\u00e1 assim. import Test.QuickCheck celsius2fahrenheit c = c * 9 / 5 + 32 fahrenheit2celsius f = ( f - 32 ) * 5 / 9 prop_C2f2C c = fahrenheit2celsius ( celsius2fahrenheit c ) == c Para testar o c\u00f3digo, execute o ghci carregando o QuickCheck. A forma mais simples de faz\u00ea-lo \u00e9 usando stack: stack ghci --package QuickCheck . Agora carregue seu programa, usando :l f2c2f no meu caso e execute o teste > quickCheck prop_C2f2C *** Failed ! Falsified ( after 2 tests and 4 shrinks ) : - 0.1 Ooops! O teste falhou para o valor -0.1. Mas por qu\u00ea? Vejamos cada fun\u00e7\u00e3o isoladamente. > celsius2fahrenheit (-0.1) 31.82 > fahrenheit2celsius 31.82 -9.999999999999984e-2 Os valores s\u00e3o pr\u00f3ximos, mas n\u00e3o s\u00e3o iguais, por causa de problemas de arredondamento causados pela imprecis\u00e3o dos tipos utilizados. O problema est\u00e1 no teste, pois \u00e9 imposs\u00edvel para o computador representar certos valores e estes erros de aproxima\u00e7\u00e3o ocorrer\u00e3o. Assim, uma estrat\u00e9gia melhor \u00e9 definir um operador quase igual , para comparar valores com pequenos erros. import Test.QuickCheck celsius2fahrenheit c = c * 9 / 5 + 32 fahrenheit2celsius f = ( f - 32 ) * 5 / 9 prop_C2f2C c = fahrenheit2celsius ( celsius2fahrenheit c ) ~== c l ~== r = abs ( l - r ) < \u03b5 where \u03b5 = 10e-10 Com esta nova defini\u00e7\u00e3o, nosso teste agora passa com sucesso. > quickCheck prop_C2f2C +++ OK, passed 100 tests.","title":"Quick, Check!"},{"location":"development/quickcheck_hspec/","text":"HSpec + Quickcheck 1 A combina\u00e7\u00e3o de HSpec com Quickcheck \u00e9 uma ferramenta poderosa na identifica\u00e7\u00e3o de erros. Enquanto o primeiro automatiza os testes, o segundo multiplica a cobertura dos testes. Para entender exatamente como estes testes funcionam, voc\u00ea precisa entender fun\u00e7\u00f5es de ordem superior, que veremos mais adiante. Mas mesmo sem entender a especifica\u00e7\u00e3o a fundo, \u00e9 poss\u00edvel usar o seguinte c\u00f3digo como modelo para implementar seus testes. No caso em espec\u00edfico, a fun\u00e7\u00e3o soma ser\u00e1 testada com uma centena de combina\u00e7\u00f5es de valores para #hs x e y . import Test.Hspec ( Spec , it , shouldBe , describe ) import Test.Hspec.Runner ( configFastFail , defaultConfig , hspecWith ) import Test.QuickCheck import Exercise ( hello , ol\u00e1 , soma ) main :: IO () main = hspecWith defaultConfig { configFastFail = False } specs specs :: Spec specs = do describe \"soma\" $ do prop \"soma n\u00fameros\" $ \\ x y -> soma x y ` shouldBe ` x + y https://hspec.github.io/quickcheck.html \u21a9","title":"HSpec + Quickcheck[^hspec_quickcheck]"},{"location":"development/quickcheck_hspec/#hspec-quickcheck1","text":"A combina\u00e7\u00e3o de HSpec com Quickcheck \u00e9 uma ferramenta poderosa na identifica\u00e7\u00e3o de erros. Enquanto o primeiro automatiza os testes, o segundo multiplica a cobertura dos testes. Para entender exatamente como estes testes funcionam, voc\u00ea precisa entender fun\u00e7\u00f5es de ordem superior, que veremos mais adiante. Mas mesmo sem entender a especifica\u00e7\u00e3o a fundo, \u00e9 poss\u00edvel usar o seguinte c\u00f3digo como modelo para implementar seus testes. No caso em espec\u00edfico, a fun\u00e7\u00e3o soma ser\u00e1 testada com uma centena de combina\u00e7\u00f5es de valores para #hs x e y . import Test.Hspec ( Spec , it , shouldBe , describe ) import Test.Hspec.Runner ( configFastFail , defaultConfig , hspecWith ) import Test.QuickCheck import Exercise ( hello , ol\u00e1 , soma ) main :: IO () main = hspecWith defaultConfig { configFastFail = False } specs specs :: Spec specs = do describe \"soma\" $ do prop \"soma n\u00fameros\" $ \\ x y -> soma x y ` shouldBe ` x + y https://hspec.github.io/quickcheck.html \u21a9","title":"HSpec + Quickcheck1"},{"location":"development3/app/","text":"Tudo junto e misturado TODO Escrever module Main where import Text.Read ( readMaybe ) import Data.Maybe ( fromMaybe , isNothing , fromJust ) -- Defini\u00e7\u00e3o de novos tipos data Dire\u00e7\u00e3o = Norte | Sul | Leste | Oeste deriving ( Show , Eq ) data A\u00e7\u00e3o = ColocarBomba | Agir | Mover Dire\u00e7\u00e3o | NO_OP | Sair deriving ( Show , Eq ) data Item = Presente | Jogador Int | Parede | Grama data DadosDoJogador = DadosDoJogador Int ( Int , Int ) String type Tabuleiro = [[ Item ]] -- Mapeamento de teclas para a\u00e7\u00f5es de cada um dos poss\u00edveis jogadores. -- Cada linha corresponde a um jogador. keyMaps = [( 1 ,[( 'e' , ColocarBomba ),( 'r' , Agir ),( 'a' , Mover Oeste ),( 's' , Mover Sul ),( 'd' , Mover Leste ),( 'w' , Mover Norte ),( 'Q' , Sair )]), ( 2 ,[( 'o' , ColocarBomba ),( 'p' , Agir ),( 'j' , Mover Oeste ),( 'k' , Mover Sul ),( 'l' , Mover Leste ),( 'i' , Mover Norte ),( 'Q' , Sair )])] -- Dado uma tecla e um mapa, retorna o jogador e a a\u00e7\u00e3o a ser executada para ele. -- Se a tecla \u00e9 inv\u00e1lida, retorna Nothing. mapKey :: Char -> [( Int , [( Char , A\u00e7\u00e3o )])] -> Maybe ( Int , A\u00e7\u00e3o ) mapKey c [] = Nothing mapKey c (( j , as ) : jas ) = case mapKey' c as of Nothing -> mapKey c jas Just a -> Just ( j , a ) where mapKey' c [] = Nothing mapKey' c (( c' , a ) : ms ) | c == c' = Just a | otherwise = mapKey' c ms -- Retorna IO id do jogador e a\u00e7\u00e3o a ser executada. -- js \u00e9 a lista dos jogadores ainda no jogo. pegaMov :: [ Int ] -> IO ( Maybe ( Int , A\u00e7\u00e3o )) pegaMov js = do movChar <- getChar let mapped = mapKey movChar keyMaps -- Observe a aus\u00eancia do `in` quando estamos dentro de um bloco IO. case mapped of Nothing -> return Nothing Just ( j , a ) -> if j ` elem ` js then return mapped else return Nothing main :: IO () main = do loopPrincipal tabuleiro jogadores where ( tabuleiro , jogadores ) = iniciarTabuleiro tabuleiroExemplo = [[ Grama , Presente , Jogador 1 ],[ Grama ],[ Grama ],[ Grama , Presente , Jogador 2 ]] dadosDoJogadorExemplo = [ DadosDoJogador 1 ( 0 , 0 ) \"BP\" , DadosDoJogador 2 ( 1 , 1 ) \"BP\" ] iniciarTabuleiro :: ( Tabuleiro ,[ DadosDoJogador ]) iniciarTabuleiro = ( tabuleiroExemplo , -- O tabuleiro deveria ser lido de um arquivo com a descri\u00e7\u00e3o de uma fase. dadosDoJogadorExemplo ) -- A lista de jogadores deveria ser lida de um menu que permitisse a escolha e configura\u00e7\u00e3o dos jogadores. loopPrincipal :: Tabuleiro -> [ DadosDoJogador ] -> IO () loopPrincipal t js = do let ids = [ i | DadosDoJogador i _ _ <- js ] move <- pegaMov ids let ( j , op ) = fromMaybe ( - 1 , NO_OP ) move print $ \"(Jogador,A\u00e7\u00e3o)\" ++ show ( j , op ) case op of ColocarBomba -> let ( t' , js' ) = colocarBomba t js j in loopPrincipal t' js' -- poderia ser simplificado com uso da fun\u00e7\u00e3o uncurry Agir -> let ( t' , js' ) = agir t js j in loopPrincipal t' js' Mover d -> let ( t' , js' ) = mover d t js j in loopPrincipal t' js' NO_OP -> loopPrincipal t js Sair -> return () -- Tenta movimentar o jogador na direcao especificada. mover :: Dire\u00e7\u00e3o -> Tabuleiro -> [ DadosDoJogador ] -> Int -> ( Tabuleiro , [ DadosDoJogador ]) mover d t js j = ( t , js ) -- Descobre se alguma a\u00e7\u00e3o \u00e9 poss\u00edvel para o jogador e executa. agir :: Tabuleiro -> [ DadosDoJogador ] -> Int -> ( Tabuleiro , [ DadosDoJogador ]) agir t js j = ( t , js ) -- Verifica se \u00e9 poss\u00edvel colocar a boma e coloca. colocarBomba :: Tabuleiro -> [ DadosDoJogador ] -> Int -> ( Tabuleiro , [ DadosDoJogador ]) colocarBomba t js i = ( t , js ) --- >>> filter (\\x -> x > 5) [1..23] -- [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]","title":"Uma aplica\u00e7\u00e3o"},{"location":"development3/app/#tudo-junto-e-misturado","text":"TODO Escrever module Main where import Text.Read ( readMaybe ) import Data.Maybe ( fromMaybe , isNothing , fromJust ) -- Defini\u00e7\u00e3o de novos tipos data Dire\u00e7\u00e3o = Norte | Sul | Leste | Oeste deriving ( Show , Eq ) data A\u00e7\u00e3o = ColocarBomba | Agir | Mover Dire\u00e7\u00e3o | NO_OP | Sair deriving ( Show , Eq ) data Item = Presente | Jogador Int | Parede | Grama data DadosDoJogador = DadosDoJogador Int ( Int , Int ) String type Tabuleiro = [[ Item ]] -- Mapeamento de teclas para a\u00e7\u00f5es de cada um dos poss\u00edveis jogadores. -- Cada linha corresponde a um jogador. keyMaps = [( 1 ,[( 'e' , ColocarBomba ),( 'r' , Agir ),( 'a' , Mover Oeste ),( 's' , Mover Sul ),( 'd' , Mover Leste ),( 'w' , Mover Norte ),( 'Q' , Sair )]), ( 2 ,[( 'o' , ColocarBomba ),( 'p' , Agir ),( 'j' , Mover Oeste ),( 'k' , Mover Sul ),( 'l' , Mover Leste ),( 'i' , Mover Norte ),( 'Q' , Sair )])] -- Dado uma tecla e um mapa, retorna o jogador e a a\u00e7\u00e3o a ser executada para ele. -- Se a tecla \u00e9 inv\u00e1lida, retorna Nothing. mapKey :: Char -> [( Int , [( Char , A\u00e7\u00e3o )])] -> Maybe ( Int , A\u00e7\u00e3o ) mapKey c [] = Nothing mapKey c (( j , as ) : jas ) = case mapKey' c as of Nothing -> mapKey c jas Just a -> Just ( j , a ) where mapKey' c [] = Nothing mapKey' c (( c' , a ) : ms ) | c == c' = Just a | otherwise = mapKey' c ms -- Retorna IO id do jogador e a\u00e7\u00e3o a ser executada. -- js \u00e9 a lista dos jogadores ainda no jogo. pegaMov :: [ Int ] -> IO ( Maybe ( Int , A\u00e7\u00e3o )) pegaMov js = do movChar <- getChar let mapped = mapKey movChar keyMaps -- Observe a aus\u00eancia do `in` quando estamos dentro de um bloco IO. case mapped of Nothing -> return Nothing Just ( j , a ) -> if j ` elem ` js then return mapped else return Nothing main :: IO () main = do loopPrincipal tabuleiro jogadores where ( tabuleiro , jogadores ) = iniciarTabuleiro tabuleiroExemplo = [[ Grama , Presente , Jogador 1 ],[ Grama ],[ Grama ],[ Grama , Presente , Jogador 2 ]] dadosDoJogadorExemplo = [ DadosDoJogador 1 ( 0 , 0 ) \"BP\" , DadosDoJogador 2 ( 1 , 1 ) \"BP\" ] iniciarTabuleiro :: ( Tabuleiro ,[ DadosDoJogador ]) iniciarTabuleiro = ( tabuleiroExemplo , -- O tabuleiro deveria ser lido de um arquivo com a descri\u00e7\u00e3o de uma fase. dadosDoJogadorExemplo ) -- A lista de jogadores deveria ser lida de um menu que permitisse a escolha e configura\u00e7\u00e3o dos jogadores. loopPrincipal :: Tabuleiro -> [ DadosDoJogador ] -> IO () loopPrincipal t js = do let ids = [ i | DadosDoJogador i _ _ <- js ] move <- pegaMov ids let ( j , op ) = fromMaybe ( - 1 , NO_OP ) move print $ \"(Jogador,A\u00e7\u00e3o)\" ++ show ( j , op ) case op of ColocarBomba -> let ( t' , js' ) = colocarBomba t js j in loopPrincipal t' js' -- poderia ser simplificado com uso da fun\u00e7\u00e3o uncurry Agir -> let ( t' , js' ) = agir t js j in loopPrincipal t' js' Mover d -> let ( t' , js' ) = mover d t js j in loopPrincipal t' js' NO_OP -> loopPrincipal t js Sair -> return () -- Tenta movimentar o jogador na direcao especificada. mover :: Dire\u00e7\u00e3o -> Tabuleiro -> [ DadosDoJogador ] -> Int -> ( Tabuleiro , [ DadosDoJogador ]) mover d t js j = ( t , js ) -- Descobre se alguma a\u00e7\u00e3o \u00e9 poss\u00edvel para o jogador e executa. agir :: Tabuleiro -> [ DadosDoJogador ] -> Int -> ( Tabuleiro , [ DadosDoJogador ]) agir t js j = ( t , js ) -- Verifica se \u00e9 poss\u00edvel colocar a boma e coloca. colocarBomba :: Tabuleiro -> [ DadosDoJogador ] -> Int -> ( Tabuleiro , [ DadosDoJogador ]) colocarBomba t js i = ( t , js ) --- >>> filter (\\x -> x > 5) [1..23] -- [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]","title":"Tudo junto e misturado"},{"location":"development3/project/","text":"Nada melhor que um bom projeto para fixar e colocar \u00e0 prova o que estamos aprendendo, e nada melhor que unir o \u00fatil ao agrad\u00e1vel na hora de escolher um projeto. Neste semestre, o projeto que desenvolver\u00e3o \u00e9 um clone de um cl\u00e1ssico dos jogos de computadores, Bomberman ! Bom, n\u00e3o exatamente um clone, mas os rudimentos de um clone. Ainda assim, o projeto n\u00e3o \u00e9 trivial e por isso vamos divid\u00ed-lo em etapas para gerenciar a complexidade. De forma geral, podemos dividir o projeto em duas etapas: Etapa 1 Estruturas de dados para representa\u00e7\u00e3o dos elementos do jogo usando listas Uso de tipos primitivos para representa\u00e7\u00e3o do estado e dos elementos do jogo. Uso de type Fun\u00e7\u00f5es de manipula\u00e7\u00e3o das estruturas Etapa 2 Uso de tipos definidos pelo usu\u00e1rio para representa\u00e7\u00e3o do estado e dos elementos do jogo. Uso de data Tipos alg\u00e9bricos Fun\u00e7\u00f5es de manipula\u00e7\u00e3o das estruturas Visualiza\u00e7\u00e3o do tabuleiro Movimenta\u00e7\u00e3o de (pelo menos) um bomberman pelo tabuleiro usando o teclado Etapa 1 O jogo bomberman acontece em um \"tabuleiro\" onde os v\u00e1rios jogadores, bombermen de diversas cores, tentam explodir os seus competidores at\u00e9 serem os \u00fanicos restantes no jogo. No processo, os competidores se movimentam pelo tabuleiro explodindo barreiras e coletando presentes que lhes conferem habilidades, como aumentar a quantidade de bombas que cada um pode colocar no tabuleiro concorrentemente, aumentar a velocidade de deslocamento, arremessar bombas em posi\u00e7\u00f5es adjacentes no mapa, ou aumentar o alcance das explos\u00f5es. Uma explos\u00e3o segue em linha reta nas quatro dire\u00e7\u00f5es (norte, sul, leste e oeste) at\u00e9 que encontre algum obst\u00e1culo, que pode ou n\u00e3o ser destru\u00eddo pela explos\u00e3o. Tabuleiro Um tabuleiro de pode ser visto como uma matriz em que cada c\u00e9lula \u00e9 uma pilha de elementos. Para representar a matriz do tabuleiro, usaremos uma tupla de tuplas. Assim, defina as seguintes estruturas de dados. Tabuleiro \u00e9 uma tupla com 8 Linha. Linha \u00e9 uma tupla com 8 C\u00e9lula. C\u00e9lula \u00e9 uma pilha com 4 Item C\u00e9lula e Items Cada posi\u00e7\u00e3o do tabuleiro \u00e9 uma c\u00e9lula e contem uma pilha de itens. Use uma lista para representar a pilha. Em nosso prot\u00f3tipo, os seguintes items podem estar presentes na c\u00e9lula: grama presente_patins presente_arremesso bomba jogador_X Algumas regras devem ser respeitadas pela pilha, onde \"sobre\" quer dizer imediatamente subsequente acima na pilha. uma pilha vazia \u00e9 um buraco no tabuleiro grama s\u00f3 pode estar na base da pilha presente s\u00f3 pode estar sobre grama parede s\u00f3 pode estar na base da pilha, sobre grama ou sobre presente pedra s\u00f3 pode estar na base da pilha bomba s\u00f3 pode estar sobre grama jogador s\u00f3 pode estar sobre grama Jogador Para cada jogador, voc\u00ea precisa manter algumas informa\u00e7\u00f5es extra como: identificador (o X que aparece no Item jogador_X) localiza\u00e7\u00e3o - \u00e9 uma tupla com coordenadas X e Y do tipo Int que representam a linha e coluna em o item jogador_X correspondente est\u00e1. dire\u00e7\u00e3o - \u00e9 um caractere que indica para onde on jogador est\u00e1 olhando. 'N', 'S', 'L' e 'O' capacidades - \u00e9 uma tupla com 3 elementos com um dos seguintes valores, onde a, b e c s\u00e3o Int (Patins,a) (Bomba,b) (Arremesso,c) Fun\u00e7\u00f5es O jogo s\u00f3 tem gra\u00e7a se tiver alguma coisa acontecendo nele. Nesta primeira etapa, voc\u00ea desenvolver\u00e1 as fun\u00e7\u00f5es que permitir\u00e3o criar e manipular os elementos do jogo, de acordo com algumas regras, para as seguintes funcionalidades: Cria\u00e7\u00e3o de um tabuleiro Fun\u00e7\u00e3o receba uma lista de listas de items e constr\u00f3i um tabuleiro v\u00e1lido. Movimenta\u00e7\u00e3o de um jogador em qualquer dos sentidos Fun\u00e7\u00e3o que receba um tabuleiro e uma instru\u00e7\u00e3o de movimenta\u00e7\u00e3o de um jogador e retorne um novo tabuleiro, com o jogador na nova posi\u00e7\u00e3o. Jogador s\u00f3 pode se deslocar para c\u00e9lula adjacente que n\u00e3o tenha pedra ou bomba Pode ser imposs\u00edvel ao jogador se deslocar Ao se deslocar para uma c\u00e9lula vazia, cai no buraco Ao se deslocar para uma c\u00e9lula com um presente, o coleta Coleta de presente Ao coletar um presente, incrementa a posi\u00e7\u00e3o correspondente ao presente nas suas capacidades Arremesso Se estiver adjacente, olhando para uma bomba, e tiver a capacidade \"arremesso\", o jogador arremessa a bomba uma dist\u00e2ncia proporcional \u00e0 capacidade. Teste de dire\u00e7\u00e3o Explos\u00e3o Dire\u00e7\u00e3o Capacidade Elimina\u00e7\u00e3o de presentes Elimina\u00e7\u00e3o de pedra Elimina\u00e7\u00e3o de jogador Detec\u00e7\u00e3o de fim de jogo Voc\u00eas s\u00e3o livres para preencher as lacunas da especifica\u00e7\u00e3o de forma razo\u00e1vel. Na d\u00favida, me pergunte. Etapa 2 Escrever um programa que leia os dados de movimenta\u00e7\u00f5es de jogadores e use estes dados como entrada nas fun\u00e7\u00f5es de manipula\u00e7\u00e3o do tabuleiro. A cada movimenta\u00e7\u00e3o, imprimir o tabuleiro na tela, na forma de uma matriz, mostrando apenas o elemento superior de cada c\u00e9lula.","title":"Projetos de exemplo"},{"location":"development3/project/#etapa-1","text":"O jogo bomberman acontece em um \"tabuleiro\" onde os v\u00e1rios jogadores, bombermen de diversas cores, tentam explodir os seus competidores at\u00e9 serem os \u00fanicos restantes no jogo. No processo, os competidores se movimentam pelo tabuleiro explodindo barreiras e coletando presentes que lhes conferem habilidades, como aumentar a quantidade de bombas que cada um pode colocar no tabuleiro concorrentemente, aumentar a velocidade de deslocamento, arremessar bombas em posi\u00e7\u00f5es adjacentes no mapa, ou aumentar o alcance das explos\u00f5es. Uma explos\u00e3o segue em linha reta nas quatro dire\u00e7\u00f5es (norte, sul, leste e oeste) at\u00e9 que encontre algum obst\u00e1culo, que pode ou n\u00e3o ser destru\u00eddo pela explos\u00e3o.","title":"Etapa 1"},{"location":"development3/project/#etapa-2","text":"Escrever um programa que leia os dados de movimenta\u00e7\u00f5es de jogadores e use estes dados como entrada nas fun\u00e7\u00f5es de manipula\u00e7\u00e3o do tabuleiro. A cada movimenta\u00e7\u00e3o, imprimir o tabuleiro na tela, na forma de uma matriz, mostrando apenas o elemento superior de cada c\u00e9lula.","title":"Etapa 2"},{"location":"functions/","text":"Fun\u00e7\u00f5es No cerne da programa\u00e7\u00e3o funcional est\u00e3o as fun\u00e7\u00f5es. Vejamos ent\u00e3o como algumas fun\u00e7\u00f5es bem simples, como uma fun\u00e7\u00e3o que soma os n\u00fameros de x a y , podem ser definidas. A t\u00edtulo de compara\u00e7\u00e3o, vejamos primeiro a fun\u00e7\u00e3o em linguagem C. int soma ( int x , int y ) { int total = 0 ; for ( int i = x ; i <= y ; i ++ ) total = total + i ; return total ; } Em Haskell, temos diversas op\u00e7\u00f5es para obter o mesmo resultado, por exemplo, usando uma fun\u00e7\u00e3o recursiva, cuja defini\u00e7\u00e3o deve ser clara para voc\u00ea, mesmo se esta for a primeira vez que v\u00ea um c\u00f3digo em Haskell. somaDeAte x y = if x < y then x + somaDeAte ( x + 1 ) y else x Observe que a sintaxe do uso das fun\u00e7\u00f5es, contudo, \u00e9 at\u00edpica. Enquanto a fun\u00e7\u00e3o em C \u00e9 invocada como soma ( 1 , 10 ); , em Haskell, usa-se o nome da fun\u00e7\u00e3o, seguido dos par\u00e2metros, com espa\u00e7o os separando, isto \u00e9: 2 > somaDeAte 1 10 55 A defini\u00e7\u00e3o de fun\u00e7\u00f5es em Haskell \u00e9 feita pela especifica\u00e7\u00e3o de uma ou mais equa\u00e7\u00f5es . Na forma mais comum de defini\u00e7\u00e3o, do lado esquerdo da equa\u00e7\u00e3o temos o nome da fun\u00e7\u00e3o, iniciado sempre uma letra min\u00fascula , e seguido por um ou mais par\u00e2metros formais, todos iniciados tamb\u00e9m por letras min\u00fasculas . A conven\u00e7\u00e3o \u00e9 que fun\u00e7\u00f5es e par\u00e2metros sejam nomeados usando Camel Casing . J\u00e1 do lado direito temos defini\u00e7\u00e3o do c\u00e1lculo do resultado. nomeDaFun\u00e7\u00e3o [ par1 [ par2 [ par2 ]]] = defini\u00e7\u00e3o Por exemplo, consideremos uma fun\u00e7\u00e3o que soma dois n\u00fameros. Em Haskell, ela \u00e9 definida simplesmente como soma x y = x + y e usada como soma 3 5 . De forma semelhante, uma fun\u00e7\u00e3o que multiplica tr\u00eas n\u00fameros \u00e9 definida como mult3 x y z = x * y * z e invocada como a seguir. > mult3 2 3 4 24 Exerc\u00edcio: Soma Defina a fun\u00e7\u00e3o soma e use-a, de acordo com a imagem. 1 Como outro exemplo, definamos uma fun\u00e7\u00e3o que retorna o sucessor de um inteiro como sucessor x = x + 1 . Com estas fun\u00e7\u00f5es podemos, inclusive, compor fun\u00e7\u00f5es no melhor estilo \\(g(f(x))\\) , por exemplo: > sucessor ( soma 3 4 ) 8 > sucessor ( sucessor ( sucessor 4 )) 7 Exerc\u00edcio: Composi\u00e7\u00e3o Defina uma fun\u00e7\u00e3o que multiplique 3 n\u00fameros, isto \u00e9, dados \\(x\\) , \\(y\\) e \\(z\\) , calcule \\(x*y*z\\) . Calcule \\((1 + (3 * 2 * 3)) + (5 * 3 * 2)\\) usando as fun\u00e7\u00f5es de soma e multiplica\u00e7\u00e3o definidas. Resolu\u00e7\u00e3o Defina as fun\u00e7\u00f5es soma x y = x + y mult3 x y z = x * y * z Invoque soma ( soma 1 ( mult3 3 2 3 )) ( mult3 5 3 2 ) . Observe que os par\u00eanteses s\u00e3o necess\u00e1rios para delimitar os par\u00e2metros de cada uma das invoca\u00e7\u00f5es. Exerc\u00edcio: m\u00e9dia de 3 n\u00fameros Defina uma fun\u00e7\u00e3o que calcule a m\u00e9dia de 3 n\u00fameros Resolu\u00e7\u00e3o media x y z = ( x + y + z ) / 3 Exerc\u00edcio: \u00e1rea das figuras Defina uma fun\u00e7\u00e3o o c\u00e1lculo da \u00e1rea de cada figura geom\u00e9trica. Resolu\u00e7\u00e3o areaQuad a = a * a areaRet a b = a * b areaCirc r = pi * r * r areaTri a h = ( a * h ) / 2 areaTra a b h = ( a + b ) / 2 * h Se voc\u00ea se logar no Repl.it, poder\u00e1 salvar seus arquivos online e edit\u00e1-los de qualquer lugar, como no exemplo dado no exerc\u00edcio. \u21a9 No REPL do Haskell, ghci, o prompt \u00e9 terminado por > e a linha sem prompt tem o resultado da invoca\u00e7\u00e3o anterior. \u21a9","title":"Fun\u00e7\u00f5es"},{"location":"functions/#funcoes","text":"No cerne da programa\u00e7\u00e3o funcional est\u00e3o as fun\u00e7\u00f5es. Vejamos ent\u00e3o como algumas fun\u00e7\u00f5es bem simples, como uma fun\u00e7\u00e3o que soma os n\u00fameros de x a y , podem ser definidas. A t\u00edtulo de compara\u00e7\u00e3o, vejamos primeiro a fun\u00e7\u00e3o em linguagem C. int soma ( int x , int y ) { int total = 0 ; for ( int i = x ; i <= y ; i ++ ) total = total + i ; return total ; } Em Haskell, temos diversas op\u00e7\u00f5es para obter o mesmo resultado, por exemplo, usando uma fun\u00e7\u00e3o recursiva, cuja defini\u00e7\u00e3o deve ser clara para voc\u00ea, mesmo se esta for a primeira vez que v\u00ea um c\u00f3digo em Haskell. somaDeAte x y = if x < y then x + somaDeAte ( x + 1 ) y else x Observe que a sintaxe do uso das fun\u00e7\u00f5es, contudo, \u00e9 at\u00edpica. Enquanto a fun\u00e7\u00e3o em C \u00e9 invocada como soma ( 1 , 10 ); , em Haskell, usa-se o nome da fun\u00e7\u00e3o, seguido dos par\u00e2metros, com espa\u00e7o os separando, isto \u00e9: 2 > somaDeAte 1 10 55 A defini\u00e7\u00e3o de fun\u00e7\u00f5es em Haskell \u00e9 feita pela especifica\u00e7\u00e3o de uma ou mais equa\u00e7\u00f5es . Na forma mais comum de defini\u00e7\u00e3o, do lado esquerdo da equa\u00e7\u00e3o temos o nome da fun\u00e7\u00e3o, iniciado sempre uma letra min\u00fascula , e seguido por um ou mais par\u00e2metros formais, todos iniciados tamb\u00e9m por letras min\u00fasculas . A conven\u00e7\u00e3o \u00e9 que fun\u00e7\u00f5es e par\u00e2metros sejam nomeados usando Camel Casing . J\u00e1 do lado direito temos defini\u00e7\u00e3o do c\u00e1lculo do resultado. nomeDaFun\u00e7\u00e3o [ par1 [ par2 [ par2 ]]] = defini\u00e7\u00e3o Por exemplo, consideremos uma fun\u00e7\u00e3o que soma dois n\u00fameros. Em Haskell, ela \u00e9 definida simplesmente como soma x y = x + y e usada como soma 3 5 . De forma semelhante, uma fun\u00e7\u00e3o que multiplica tr\u00eas n\u00fameros \u00e9 definida como mult3 x y z = x * y * z e invocada como a seguir. > mult3 2 3 4 24 Exerc\u00edcio: Soma Defina a fun\u00e7\u00e3o soma e use-a, de acordo com a imagem. 1 Como outro exemplo, definamos uma fun\u00e7\u00e3o que retorna o sucessor de um inteiro como sucessor x = x + 1 . Com estas fun\u00e7\u00f5es podemos, inclusive, compor fun\u00e7\u00f5es no melhor estilo \\(g(f(x))\\) , por exemplo: > sucessor ( soma 3 4 ) 8 > sucessor ( sucessor ( sucessor 4 )) 7 Exerc\u00edcio: Composi\u00e7\u00e3o Defina uma fun\u00e7\u00e3o que multiplique 3 n\u00fameros, isto \u00e9, dados \\(x\\) , \\(y\\) e \\(z\\) , calcule \\(x*y*z\\) . Calcule \\((1 + (3 * 2 * 3)) + (5 * 3 * 2)\\) usando as fun\u00e7\u00f5es de soma e multiplica\u00e7\u00e3o definidas. Resolu\u00e7\u00e3o Defina as fun\u00e7\u00f5es soma x y = x + y mult3 x y z = x * y * z Invoque soma ( soma 1 ( mult3 3 2 3 )) ( mult3 5 3 2 ) . Observe que os par\u00eanteses s\u00e3o necess\u00e1rios para delimitar os par\u00e2metros de cada uma das invoca\u00e7\u00f5es. Exerc\u00edcio: m\u00e9dia de 3 n\u00fameros Defina uma fun\u00e7\u00e3o que calcule a m\u00e9dia de 3 n\u00fameros Resolu\u00e7\u00e3o media x y z = ( x + y + z ) / 3 Exerc\u00edcio: \u00e1rea das figuras Defina uma fun\u00e7\u00e3o o c\u00e1lculo da \u00e1rea de cada figura geom\u00e9trica. Resolu\u00e7\u00e3o areaQuad a = a * a areaRet a b = a * b areaCirc r = pi * r * r areaTri a h = ( a * h ) / 2 areaTra a b h = ( a + b ) / 2 * h Se voc\u00ea se logar no Repl.it, poder\u00e1 salvar seus arquivos online e edit\u00e1-los de qualquer lugar, como no exemplo dado no exerc\u00edcio. \u21a9 No REPL do Haskell, ghci, o prompt \u00e9 terminado por > e a linha sem prompt tem o resultado da invoca\u00e7\u00e3o anterior. \u21a9","title":"Fun\u00e7\u00f5es"},{"location":"functions/guards/","text":"Vamos definir uma fun\u00e7\u00e3o que retorne o nome do m\u00eas, dado o seu n\u00famero. Seria poss\u00edvel escreve esta fun\u00e7\u00e3o com if aninhados, assim. nomeMes m = if m == 1 then \"JAN\" else if m == 2 then \"FEB\" else if m == 3 then \"MAR\" ... else if m == 11 then \"NOV\" else \"DEZ\" Esta estrutura, contudo, pode ser simplificada com o uso guardas , uma op\u00e7\u00e3o que faz sentido quando os par\u00e2metros de uma fun\u00e7\u00e3o podem ser classificados em grupos. Guardas tem a seguinte sintaxe. nomeFuncao arg1 ... argN | < condicao1 > = < definicao1 > | < condicao2 > = < definicao2 > ... | < condicaoM > = < definicaoM > Especificamente, o exemplo do c\u00e1lculo do nome dos meses ficaria como a seguir. nomeMes m | m == 1 = \"JAN\" | m == 2 = \"FEV\" | m == 3 = \"MAR\" | m == 4 = \"ABR\" | m == 5 = \"MAI\" | m == 6 = \"JUN\" | m == 7 = \"JUL\" | m == 8 = \"AGO\" | m == 9 = \"SET\" | m == 10 = \"OUT\" | m == 11 = \"NOV\" | m == 12 = \"DEZ\" | m == 13 = \"ONZ\" Embora no exemplo anterior cada condi\u00e7\u00e3o seja muito simples, apenas um teste de igualdade, condi\u00e7\u00f5es podem ser mais complexas, podendo incluir m\u00faltiplos testes e computa\u00e7\u00f5es; a \u00fanica condi\u00e7\u00e3o \u00e9 que resulte em um valor booleano. Por exemplo, vejamos uma fun\u00e7\u00e3o que calcula o maior entre tr\u00eas n\u00fameros. maiorDeTres a b c | a >= b && a >= c = a | b >= c = b | True = c Avalia\u00e7\u00e3o de cima para baixo Observe que a avalia\u00e7\u00e3o das condi\u00e7\u00f5es \u00e9 feita na ordem de suas defini\u00e7\u00f5es, ou seja, de cima para baixo , e isso \u00e9 importante porqu\u00ea alguns par\u00e2metros podem satisfazer mais de uma condi\u00e7\u00e3o. Vejamos novamente o caso do c\u00e1lculo de anos bissextos. Nesta defini\u00e7\u00e3o, se a terceira e segunda guardas fossem invertidas, o ano 1900 seria considerado bissexto, quando na verdade ele n\u00e3o \u00e9. bissexto x | mod x 4 /= 0 = False -- N\u00e3o divis\u00edveis por 4 | mod x 400 == 0 = True -- Divis\u00edveis por 4 e por 400 | mod x 100 == 0 = False -- Divis\u00edveis por 4, n\u00e3o por 400, e por 100 | otherwise = True -- Divis\u00edveis por 4, e n\u00e3o por 100 {- >>>bissexto 5 False >>>bissexto 200 False >>>bissexto 2000 True >>>bissexto 1996 True >>>bissexto 1900 False -} Exerc\u00edcio Escreva uma fun\u00e7\u00e3o que receba um n\u00famero representando um m\u00eas, um n\u00famero de 1 a 12, e retorne a quantidade de dias no m\u00eas. Assuma que fevereiro sempre tem 28 dias. Resolu\u00e7\u00e3o diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | True = 30 \u00cdndice de massa corporal O \u00edndice de massa corporal, IMC, \u00e9 calculado como o peso dividido pelo quadrado da altura. Um IMC abaixo de 18,5, inclusive, \u00e9 considerado baixo e acima de 30 \u00e9 considerado alto; aqueles no intervalo s\u00e3o considerados normais. Defina uma fun\u00e7\u00e3o que, dados peso e altura, decida se o IMC correspondente \u00e9 Baixo, Normal ou Alto. Resolu\u00e7\u00e3o imc p a | p / a ^ 2 <= 18.5 = \"Baixo\" | p / a ^ 2 <= 25.0 = \"Normal\" | p / a ^ 2 <= 30.0 = \"Alto\" | True = error \"N\u00e3o sei o que dizer\" otherwise \u00e9 verdade Em alguns dos exemplos acima, a \u00faltima condi\u00e7\u00e3o foi simplesmente True , que cobre todos os outros casos . Embora correta, esta defini\u00e7\u00e3o pode parecer estranha. Uma alternativa \u00e9 usar otherwise no lugar de True , com exatamente os mesmos efeitos, como no seguinte exemplo. maiorDeTres a b c | a >= b && a >= c = a | b >= c = b | otherwise = c De fato, se usarmos o GHCi para obtermos mais informa\u00e7\u00f5es sobre otherwise , veremos que \u00e9 uma constante, cujo valor \u00e9 True . Isso serve para ilustrar o poder da linguagem, que tem um conjunto reduzido de palavras reservadas e que \u00e9 estendida usando suas funcionalidades b\u00e1sicas. Prelude> otherwise True","title":"Guardas!"},{"location":"functions/ifthenelse/","text":"Voc\u00ea saberia calcular o maior de dois n\u00fameros \\(a\\) e \\(b\\) sem usar um teste do tipo se ent\u00e3o sen\u00e3o ? \u00c9 bem interessante; assuma \\(M\\) maior e \\(m\\) menor entre \\(a\\) e \\(b\\) . \\[\\begin{eqnarray} M &=& \\frac{M + M}{2} \\nonumber \\\\ &=& \\frac{M + m + M - m}{2} \\nonumber \\\\ &=& \\frac{M + m + (M-m)}{2} \\nonumber \\\\ &=& \\frac{M + n + \\|M-m\\|}{2} \\nonumber \\\\ &=& \\frac{a + b + \\|a - b\\|}{2} \\nonumber \\\\ &=& \\frac{a + b}{2} + \\frac{\\|a - b\\|}{2} \\nonumber \\\\ \\end{eqnarray}\\] Em outras palavras, o maior entre dois n\u00fameros \\(a\\) e \\(b\\) \u00e9 igual \u00e0 m\u00e9dia dos n\u00fameros \\(a\\) e \\(b\\) , mais a metade da diferen\u00e7a entre \\(a\\) e \\(b\\) . Logo, em Haskell, temos maior x y = ( x + y + ( abs ( x - y ))) / 2 Estou certo de que voc\u00ea concordar\u00e1 que calcular o maior entre dois n\u00fameros deveria ser muito mais simples que isso, especialmente porqu\u00ea naquele abs provavelmente h\u00e1 um se-ent\u00e3o-sen\u00e3o escondido. \\[ abs(a,b)= \\begin{cases} a,& \\text{if } a\\geq b\\\\ b, & \\text{otherwise} \\end{cases} \\] Mas como faz\u00ea-lo em Haskell, isto \u00e9, como testar uma condi\u00e7\u00e3o sobre os valores para decidir a forma correta de computar o resultado? Usando uma express\u00e3o de sele\u00e7\u00e3o, isto \u00e9, if ... then ... else ... Esta estrutura tem a seguinte sintaxe, em que a defini\u00e7\u00e3o True \u00e9 usada caso a condi\u00e7\u00e3o avalie para True e condi\u00e7\u00e3o False \u00e9 usada caso contr\u00e1rio. if < condi\u00e7\u00e3o > then < defini\u00e7\u00e3o True > else < defini\u00e7\u00e3o False > Por exemplo, veja podemos calcular o maior de dois n\u00fameros com a seguinte defini\u00e7\u00e3o. maior x y = if x > y then x else y Observe que, diferentemente de outras linguagens em que se pode usar o if para decidir entre fazer ou n\u00e3o uma computa\u00e7\u00e3o, o if do Haskell serve para decidir entre duas computa\u00e7\u00f5es. Isto \u00e9, o if deve sempre ser seguido do then e do else . Observe tamb\u00e9m que o if pode estar em qualquer parte da express\u00e3o, porqu\u00ea este construto \u00e9 tamb\u00e9m uma express\u00e3o. Por exemplo, imagine que queira somar um n\u00famero inteiro com o valor absoluto de outro n\u00famero, sem usar o abs . somaEstranha x y = x + ( if y < 0 then - y else y ) Com esta defini\u00e7\u00e3o, tanto somaEstranha 1 2 quanto somaEstranha 1 ( - 2 ) resultam em 3. Mas este exemplo \u00e9 muito estranho, ent\u00e3o pensemos em um mais \"\u00fatil\", como determinar se um ano \u00e9 bissexto. Se o ano n\u00e3o \u00e9 m\u00faltiplo de 4, n\u00e3o \u00e9 bissexto. Se \u00e9 m\u00faltiplo de 4 e n\u00e3o \u00e9 m\u00faltiplo de 100, ent\u00e3o \u00e9 bissexto. Se \u00e9 m\u00faltiplo de 100 e n\u00e3o \u00e9 m\u00faltiplo de 400, ent\u00e3o n\u00e3o \u00e9 bissexto. Se \u00e9 m\u00faltiplo de 400, ent\u00e3o \u00e9 bissexto. bissexto x = if mod x 4 /= 0 then False else if mod x 100 /= 0 then True else if mod x 400 == 0 then True else False Aninhar if assim pode funcionar, mas leva a estruturas complexas e dif\u00edceis de serem lidas. H\u00e1 formas melhores de se lidar com m\u00faltiplas possibilidades de computa\u00e7\u00e3o, como veremos adiante.","title":"Se ent\u00e3o, sen\u00e3o"},{"location":"functions/pattern_matching/","text":"Casamento de Padr\u00f5es Quando especificamos uma fun\u00e7\u00e3o, definimos sua lista de par\u00e2metros formais, isto \u00e9, dizemos ao compilador a quais vari\u00e1veis os par\u00e2metros passados na invoca\u00e7\u00e3o da fun\u00e7\u00e3o devem ser associados. Por exemplo, considere a seguinte defini\u00e7\u00e3o de uma fun\u00e7\u00e3o que soma dois n\u00fameros. soma2n x y = x + y Quando a seguinte invoca\u00e7\u00e3o acontece, o valor 3 \u00e9 associado a x e 4 a y . > soma2n 3 4 7 Em Haskell, contudo, \u00e9 poss\u00edvel especificar mais do que uma lista de vari\u00e1veis como par\u00e2metros formais; \u00e9 poss\u00edvel especificar padr\u00f5es a serem casados com os par\u00e2metros passados na invoca\u00e7\u00e3o. Veremos mais adiante como esse casamento de padr\u00f5es \u00e9 poderoso; por enquanto o usaremos apenas como forma de testar a igualdade dos par\u00e2metros a constantes, como uma alternativa \u00e0 defini\u00e7\u00e3o de fun\u00e7\u00f5es usando guardas. Neste caso, a fun\u00e7\u00e3o \u00e9 definida como uma sequ\u00eancia de equa\u00e7\u00f5es em que s\u00e3o feitas tentativas sucessivas de casar (igualar) os argumentos passados com os par\u00e2metros formais, na ordem das defini\u00e7\u00f5es. O resultado da invoca\u00e7\u00e3o da fun\u00e7\u00e3o \u00e9 dado pela primeira equa\u00e7\u00e3o em que houver um casamento bem sucedido e todas as guardas forem satisfeitas. Se ao final n\u00e3o houver casamento ou se as guardas n\u00e3o forem satisfeitas, ocorre um erro de execu\u00e7\u00e3o . Para come\u00e7ar, revisitemos a fun\u00e7\u00e3o nomeMes . Usando casamento de padr\u00f5es, ela ficaria assim: nomeMes 1 = \"JAN\" nomeMes 2 = \"FEB\" nomeMes 3 = \"ABR\" nomeMes 4 = \"MAR\" nomeMes 5 = \"MAI\" nomeMes 6 = \"JUN\" nomeMes 7 = \"JUL\" nomeMes 8 = \"AGO\" nomeMes 9 = \"SET\" nomeMes 10 = \"OUT\" nomeMes 11 = \"NOV\" nomeMes 12 = \"DEZ\" Esta fun\u00e7\u00e3o funciona para exatamente os valores na faixa [1,12] e retornar\u00e1 um erro para qualquer valor fora da mesma. > nomeMes 13 \"*** Exception: scratch.hs:(112,1)-(123,18): Non-exhaustive patterns in function nomeMes Para evitar o erro caso n\u00e3o haja um casamento, \u00e9 poss\u00edvel usar uma defini\u00e7\u00e3o gen\u00e9rica catch-all para casar com valores n\u00e3o espec\u00edficos. Por exemplo, a seguinte defini\u00e7\u00e3o da fun\u00e7\u00e3o fatorial tem um tratamento especial para 0 e um caso gen\u00e9rico para qualquer outro n\u00famero. fatorial 0 = 1 fatorial n = n * fatorial ( n - 1 ) Esta retornar\u00e1 imediatamente o valor 1 caso seja invocada como fatorial 0 e recursivamente calcular\u00e1 o valor do fatorial caso invocada com algum valor maior que 0, por exemplo fatorial 1 . Mas esta defini\u00e7\u00e3o de fatorial tem um problema, que aparece ao se tentar calcular o fatorial de n\u00fameros negativos, que s\u00e3o indefinidos. Neste caso, precisamos impedir que n\u00fameros negativos sejam aceitos pela fun\u00e7\u00e3o, e podemos fazer isso combinando o casamento de padr\u00f5es com outra forma de testar os valores dos par\u00e2metros, como if then else e guardas, por exemplo. fatorial 0 = 1 fatorial n | n > 0 = n * fatorial ( n - 1 ) | otherwise = error \"Indefinido\" Na execu\u00e7\u00e3o, temos os seguintes resultados. > fatorial 1 1 > fatorial ( - 1 ) *** Exception: Indefinido","title":"Padr\u00f5es"},{"location":"functions/pattern_matching/#casamento-de-padroes","text":"Quando especificamos uma fun\u00e7\u00e3o, definimos sua lista de par\u00e2metros formais, isto \u00e9, dizemos ao compilador a quais vari\u00e1veis os par\u00e2metros passados na invoca\u00e7\u00e3o da fun\u00e7\u00e3o devem ser associados. Por exemplo, considere a seguinte defini\u00e7\u00e3o de uma fun\u00e7\u00e3o que soma dois n\u00fameros. soma2n x y = x + y Quando a seguinte invoca\u00e7\u00e3o acontece, o valor 3 \u00e9 associado a x e 4 a y . > soma2n 3 4 7 Em Haskell, contudo, \u00e9 poss\u00edvel especificar mais do que uma lista de vari\u00e1veis como par\u00e2metros formais; \u00e9 poss\u00edvel especificar padr\u00f5es a serem casados com os par\u00e2metros passados na invoca\u00e7\u00e3o. Veremos mais adiante como esse casamento de padr\u00f5es \u00e9 poderoso; por enquanto o usaremos apenas como forma de testar a igualdade dos par\u00e2metros a constantes, como uma alternativa \u00e0 defini\u00e7\u00e3o de fun\u00e7\u00f5es usando guardas. Neste caso, a fun\u00e7\u00e3o \u00e9 definida como uma sequ\u00eancia de equa\u00e7\u00f5es em que s\u00e3o feitas tentativas sucessivas de casar (igualar) os argumentos passados com os par\u00e2metros formais, na ordem das defini\u00e7\u00f5es. O resultado da invoca\u00e7\u00e3o da fun\u00e7\u00e3o \u00e9 dado pela primeira equa\u00e7\u00e3o em que houver um casamento bem sucedido e todas as guardas forem satisfeitas. Se ao final n\u00e3o houver casamento ou se as guardas n\u00e3o forem satisfeitas, ocorre um erro de execu\u00e7\u00e3o . Para come\u00e7ar, revisitemos a fun\u00e7\u00e3o nomeMes . Usando casamento de padr\u00f5es, ela ficaria assim: nomeMes 1 = \"JAN\" nomeMes 2 = \"FEB\" nomeMes 3 = \"ABR\" nomeMes 4 = \"MAR\" nomeMes 5 = \"MAI\" nomeMes 6 = \"JUN\" nomeMes 7 = \"JUL\" nomeMes 8 = \"AGO\" nomeMes 9 = \"SET\" nomeMes 10 = \"OUT\" nomeMes 11 = \"NOV\" nomeMes 12 = \"DEZ\" Esta fun\u00e7\u00e3o funciona para exatamente os valores na faixa [1,12] e retornar\u00e1 um erro para qualquer valor fora da mesma. > nomeMes 13 \"*** Exception: scratch.hs:(112,1)-(123,18): Non-exhaustive patterns in function nomeMes Para evitar o erro caso n\u00e3o haja um casamento, \u00e9 poss\u00edvel usar uma defini\u00e7\u00e3o gen\u00e9rica catch-all para casar com valores n\u00e3o espec\u00edficos. Por exemplo, a seguinte defini\u00e7\u00e3o da fun\u00e7\u00e3o fatorial tem um tratamento especial para 0 e um caso gen\u00e9rico para qualquer outro n\u00famero. fatorial 0 = 1 fatorial n = n * fatorial ( n - 1 ) Esta retornar\u00e1 imediatamente o valor 1 caso seja invocada como fatorial 0 e recursivamente calcular\u00e1 o valor do fatorial caso invocada com algum valor maior que 0, por exemplo fatorial 1 . Mas esta defini\u00e7\u00e3o de fatorial tem um problema, que aparece ao se tentar calcular o fatorial de n\u00fameros negativos, que s\u00e3o indefinidos. Neste caso, precisamos impedir que n\u00fameros negativos sejam aceitos pela fun\u00e7\u00e3o, e podemos fazer isso combinando o casamento de padr\u00f5es com outra forma de testar os valores dos par\u00e2metros, como if then else e guardas, por exemplo. fatorial 0 = 1 fatorial n | n > 0 = n * fatorial ( n - 1 ) | otherwise = error \"Indefinido\" Na execu\u00e7\u00e3o, temos os seguintes resultados. > fatorial 1 1 > fatorial ( - 1 ) *** Exception: Indefinido","title":"Casamento de Padr\u00f5es"},{"location":"functions/where_let_in/","text":"Defini\u00e7\u00e3o Local de Fun\u00e7\u00f5es Frequentemente em nossas fun\u00e7\u00f5es precisamos usar mais de uma vez um valor calculado. Na fun\u00e7\u00e3o a seguir, por exemplo, que indica o n\u00edvel do \u00edndice de massa corporal, o c\u00e1lculo do \u00edndice p / a ^ 2 \u00e9 feito em tr\u00eas locais diferentes. imc p a | p / a ^ 2 <= 18.5 = \"Baixo\" | p / a ^ 2 <= 25.0 = \"Normal\" | p / a ^ 2 <= 30.0 = \"Alto\" Uma alternativa que tornaria o c\u00f3digo mais manuten\u00edvel seria especificar o c\u00e1lculo em uma fun\u00e7\u00e3o auxiliar, como no seguinte c\u00f3digo. aux p a = p / a ^ 2 imc p a | aux p a <= 18.5 = \"Baixo\" | aux p a <= 25.0 = \"Normal\" | aux p a <= 30.0 = \"Alto\" Entretanto, a aux \u00e9 vis\u00edvel para todas as outras fun\u00e7\u00f5es especificadas no mesmo arquivo, mesmo que n\u00e3o tenham nenhum interesse na mesma. Al\u00e9m disso, se outras fun\u00e7\u00f5es auxiliares forem necess\u00e1rias, ter\u00e3o cada uma que usar um nome \u00fanico. Para estes casos, Haskell nos permite fazer defini\u00e7\u00f5es \"locais\" das fun\u00e7\u00f5es auxiliares, isto \u00e9, que ser\u00e3o vis\u00edveis apenas dentro do escopo da fun\u00e7\u00e3o em que s\u00e3o definidas. Isso pode ser feito usando-se where e let in . where As defini\u00e7\u00f5es usando where s\u00e3o feitas ap\u00f3s o bloco em que estas defini\u00e7\u00f5es s\u00e3o usadas, como no seguinte exemplo. imc p a | imc' p a <= 18.5 = \"Baixo\" | imc' p a <= 25.0 = \"Normal\" | imc' p a <= 30.0 = \"Alto\" where imc' p' a' = p' / a' ^ 2 Esta defini\u00e7\u00e3o pode ser simplificada usando o fato de que todos os par\u00e2metros formais da fun\u00e7\u00e3o externa s\u00e3o tamb\u00e9m vis\u00edveis dentro da fun\u00e7\u00e3o interna . imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" where imc' = p / a ^ 2 Outro aspecto importante do uso de where \u00e9 que v\u00e1rias defini\u00e7\u00f5es podem ser feitas, bastando que todas estejam perfeitamente indentadas. No exemplo a seguir, fica f\u00e1cil localizar e modificar as defini\u00e7\u00f5es dos v\u00e1rios n\u00edveis de IMC. Ponto para a manutenabilidade! imc p a | imc' <= baixo = \"Baixo\" | imc' <= normal = \"Normal\" | imc' <= alto = \"Alto\" where imc' = p / a ^ 2 baixo = 18.5 normal = 25.0 alto = 30.0 where \u00e9 especialmente \u00fatil na defini\u00e7\u00e3o de fun\u00e7\u00f5es recursivas, pois permite nomear as invoca\u00e7\u00f5es, como por exemplo na defini\u00e7\u00e3o da fun\u00e7\u00e3o que calcula os termos da sequ\u00eancia de Fibonacci. Sem Where fib 0 = 0 fib 1 = 1 fib n = fib ( n - 1 ) + fib ( n - 2 ) Com Where fib 0 = 0 fib 1 = 1 fib n = prev + prevPrev where prev = fib ( n - 1 ) prevPrev = fib ( n - 2 ) Neste caso pode-se argumentar que n\u00e3o houve ganhos com o mudan\u00e7a, dado que a fun\u00e7\u00e3o \u00e9 muito simples. Em fun\u00e7\u00f5es mais complexas, contudo, os benef\u00edcios em termos de legibilidade aumentam, como na fun\u00e7\u00e3o a seguir. collatz :: Int -> Int -> Int collatz n i | i == 1 = n | even anterior = anterior ` div ` 2 | otherwise = anterior * 3 + 1 where anterior = collatz n ( i - 1 ) converge :: Int -> Int -> Bool converge n passo | termo == 1 = True | otherwise = converge n ( passo + 1 ) where termo = collatz n passo Finalmente, note que where pode ser aninhado, isto \u00e9, defini\u00e7\u00f5es locais podem tamb\u00e9m ter suas pr\u00f3prias defini\u00e7\u00f5es locais. let ... in let ... in oferece uma outra alternativa em Haskell para fazer defini\u00e7\u00f5es locais. Neste caso, defini\u00e7\u00f5es que se seguem ao let s\u00e3o vis\u00edveis na express\u00e3o definida no in . fib 0 = 0 fib 1 = 1 fib n = let prev = fib ( n - 1 ) prevPrev = fib ( n - 2 ) in prev + prevPrev areaCilindro r a = let areaLateral = 2 * pi * r * a areaTopo = pi * r ^ 2 in areaLateral + 2 * areaTopo Nestes exemplos, parece que where e let in s\u00e3o apenas sintaxes diferentes para o mesmo fim, criar defini\u00e7\u00f5es locais, mas h\u00e1 algumas diferen\u00e7as fundamentais. Primeiro, enquanto o as defini\u00e7\u00f5es feitas no where s\u00e3o amarradas ao contexto da fun\u00e7\u00e3o em que est\u00e3o colocadas, podendo ser vistas em quaisquer outras partes da fun\u00e7\u00e3o, por exemplo nas guardas do c\u00e1lculo do imc , as defini\u00e7\u00f5es feitas no let s\u00e3o muito mais localizadas, v\u00e1lidas apenas dentro do in correspondente. Segundo, let ... in s\u00e3o express\u00f5es e podem aparecer em qualquer lugar onde uma express\u00e3o \u00e9 esperada. Por exemplo, eles podem ser usados para definir constantes ou fun\u00e7\u00f5es literalmente no meio de uma express\u00e3o maior. > 2 * ( let um = 1 in um + 2 ) + 3 9 > let quadrado x = x * x in quadrado 3 9 Em alguns contextos em que o escopo \u00e9 muito claro, podemos omitir o in da defini\u00e7\u00e3o. No GHCi, por exemplo, se o fizermos ent\u00e3o a defini\u00e7\u00e3o feita ser\u00e1 v\u00e1lida por toda a execu\u00e7\u00e3o do REPL, ou at\u00e9 que seja sobrescrita. > let quadrado x = x * x in quadrado 3 9 > quadrado 3 < interactive >: 25 : 1 : error : Variable not in scope : quadrado :: t0 -> t > let quadrado x = x * x > quadrado 3 9","title":"Defini\u00e7\u00f5es Locais"},{"location":"functions/where_let_in/#definicao-local-de-funcoes","text":"Frequentemente em nossas fun\u00e7\u00f5es precisamos usar mais de uma vez um valor calculado. Na fun\u00e7\u00e3o a seguir, por exemplo, que indica o n\u00edvel do \u00edndice de massa corporal, o c\u00e1lculo do \u00edndice p / a ^ 2 \u00e9 feito em tr\u00eas locais diferentes. imc p a | p / a ^ 2 <= 18.5 = \"Baixo\" | p / a ^ 2 <= 25.0 = \"Normal\" | p / a ^ 2 <= 30.0 = \"Alto\" Uma alternativa que tornaria o c\u00f3digo mais manuten\u00edvel seria especificar o c\u00e1lculo em uma fun\u00e7\u00e3o auxiliar, como no seguinte c\u00f3digo. aux p a = p / a ^ 2 imc p a | aux p a <= 18.5 = \"Baixo\" | aux p a <= 25.0 = \"Normal\" | aux p a <= 30.0 = \"Alto\" Entretanto, a aux \u00e9 vis\u00edvel para todas as outras fun\u00e7\u00f5es especificadas no mesmo arquivo, mesmo que n\u00e3o tenham nenhum interesse na mesma. Al\u00e9m disso, se outras fun\u00e7\u00f5es auxiliares forem necess\u00e1rias, ter\u00e3o cada uma que usar um nome \u00fanico. Para estes casos, Haskell nos permite fazer defini\u00e7\u00f5es \"locais\" das fun\u00e7\u00f5es auxiliares, isto \u00e9, que ser\u00e3o vis\u00edveis apenas dentro do escopo da fun\u00e7\u00e3o em que s\u00e3o definidas. Isso pode ser feito usando-se where e let in .","title":"Defini\u00e7\u00e3o Local de Fun\u00e7\u00f5es"},{"location":"functions2/pattern_matching/","text":"Casamento de Padr\u00f5es Mencionamos anteriormente que quando especificamos a lista de par\u00e2metros formais que uma fun\u00e7\u00e3o recebe, estamos dizendo ao compilador que os par\u00e2metros passados na invoca\u00e7\u00e3o da fun\u00e7\u00e3o devem ser associados aos par\u00e2metros formais. Em Haskell, este processo acontece por meio de um casamento de padr\u00f5es . Tipos de Padr\u00e3o O casamento de padr\u00f5es \u00e9 o processo pelo qual os valores em uma express\u00e3o s\u00e3o decompostos e associados aos elementos de um padr\u00e3o . Em outras palavras, dada uma express\u00e3o e um padr\u00e3o, \u00e9 feita uma tentativa de decomposi\u00e7\u00e3o da express\u00e3o de acordo com o especificado pelo padr\u00e3o. Se a decomposi\u00e7\u00e3o \u00e9 bem sucedida, isto \u00e9, se a express\u00e3o e o padr\u00e3o tem exatamente o mesmo tipo e se constantes especificadas no padr\u00e3o tem o mesmo valor na mesma posi\u00e7\u00e3o da express\u00e3o, ent\u00e3o o casamento \u00e9 bem sucedido ; caso contr\u00e1rio, o casamento fracassa . \u00c9 mais f\u00e1cil entender a descri\u00e7\u00e3o de casamento de padr\u00f5es acima usando exemplos. Para isso, vamos dividir os padr\u00f5es em alguns tipos e analisar exemplos de cada um destes tipos. Constante Considere a seguinte tabela, com suas colunas padr\u00e3o , cujas entradas s\u00e3o constantes , valor , cujas cujas entradas queremos tentar casar com o padr\u00e3o, e resultado , que informa o resultado do casamento. Padr\u00e3o Valor Resultado 10 10 Sucesso 10 20 Fracasso 10 'C' Erro True False Fracasso False False Sucesso Para cada linha, imagine uma fun\u00e7\u00e3o definida como a seguir, mas onde o s\u00edmbolo \u2588 \u00e9 substitu\u00eddo pelo padr\u00e3o minhaFun\u00e7\u00e3o \u2588 = \"Sucesso!\" e que voc\u00ea esteja invocando a fun\u00e7\u00e3o no ghci assim como a seguir, mas onde o s\u00edmbolo \u2593 \u00e9 substitu\u00eddo pelo valor. > minhaFun\u00e7\u00e3o \u2593 Por exemplo, para a primeira linha, a fun\u00e7\u00e3o fica assim minhaFun\u00e7\u00e3o 10 = \"Sucesso!\" e a invoca\u00e7\u00e3o fica assim. > minhaFun\u00e7\u00e3o 10 Quando a invoca\u00e7\u00e3o \u00e9 feita, o ghci pega o valor passado, 10, e tenta cas\u00e1-lo com o padr\u00e3o especificado na defini\u00e7\u00e3o de minhaFun\u00e7\u00e3o, 10. Neste caso, h\u00e1 um casamento entre o valor e o padr\u00e3o. * Main > minhaFuncao 10 \"Deu certo\" J\u00e1 para a segunda linha, n\u00e3o h\u00e1 um casamento, pois o valor 10 n\u00e3o pode ser decomposto como a constante 20, e o ghci reclama com um erro que n\u00e3o vem ao caso agora. * Main > minhaFuncao 20 \"*** Exception: scratch.hs:87:1-28: Non-exhaustive patterns in function minhaFuncao Vari\u00e1vel Se em vez de constantes a coluna padr\u00e3o tivesse como elementos uma vari\u00e1vel, ent\u00e3o o casamento sempre seria bem sucedido. Neste caso, a coluna associa\u00e7\u00f5es 1 mostra quais os valores associados \u00e0 cada vari\u00e1vel do padr\u00e3o. Padr\u00e3o Valor Resultado Associa\u00e7\u00e3o x 10 Sucesso x = 10 x 20 Sucesso x = 20 x 'C' Sucesso x = 'C' x False Sucesso x = False x (1,2,3) Sucesso x = (1,2,3) Curinga Como j\u00e1 mencionado antes, _ na defini\u00e7\u00e3o de uma fun\u00e7\u00e3o funciona como uma vari\u00e1vel, mas cujo valor \u00e9 descartado, isto \u00e9, n\u00e3o \u00e9 associado a uma vari\u00e1vel. Isto \u00e9 na verdade um casamento em que o padr\u00e3o \u00e9 um curinga , que \u00e9 sempre bem sucedido mas que n\u00e3o gera uma associa\u00e7\u00e3o. Padr\u00e3o Valor Resultado _ 10 Sucesso _ 20 Sucesso _ 'C' Sucesso _ False Sucesso _ (1,2,3) Sucesso Tupla Como demonstrado no exemplo da fun\u00e7\u00e3o soma2v , tuplas podem ser usados como padr\u00e3o, permitindo decompor uma tupla usada como valor. O casamento de tuplas no valor e no padr\u00e3o pode levar aos seguintes resultados, observando que o casamento de padr\u00f5es \u00e9 aplicado recursivamente em cada elemento da tupla. Sucesso se a tupla padr\u00e3o tiver a mesma aridade que a tupla valores e cada elemento da tupla padr\u00e3o casa com o elemento correspondente da tupla valor. Fracasso se a tupla padr\u00e3o tiver a mesma aridade que a tupla valore e algum elemento da tupla padr\u00e3o n\u00e3o casa com o elemento correspondente da tupla valor. Resulta em um erro de tipo se a tupla de padr\u00f5es n\u00e3o tiver a mesma aridade que a tupla de valores ou algum elemento da tupla de padr\u00f5es resultar um erro de tipo no casamento com o elemento correspondente da tupla de valores. Padr\u00e3o Valor Resultado Associa\u00e7\u00e3o (x,y) (1,2) Sucesso x = 1 e y = 2 (1,y) (1,2) Sucesso y = 2 (1,y) (2,2) Fracasso (_,y) (1,2) Sucesso y = 2 (_,y) (10,2) Sucesso y = 2 ('X',y) ('X',2) Sucesso y = 2 (x,y) (1,(2,3)) Sucesso x = 1; y = (2,3) (_, (_,y)) (1,(2,3)) Sucesso y = 3 (x,y) (1,(2,3),3) Erro de tipo (1,y) ('x',(2,3)) Erro de tipo x (1,2) Sucesso x = (1,2) (x,y) 1 Erro de tipo Listas Por completude, precisamos mencionar que o casamento funciona tamb\u00e9m para listas, mas deixaremos para mais tarde esta discuss\u00e3o, quando nos focarmos em listas. Mais de um padr\u00e3o Nos exemplos vistos nas tabelas, temos sempre um valor e um padr\u00e3o, mas fun\u00e7\u00f5es podem ter diversos par\u00e2metros. Neste caso, o casamento de padr\u00f5es acontece para cada um dos par\u00e2metros passados na invoca\u00e7\u00e3o da fun\u00e7\u00e3o, da esquerda para a direita. Por exemplo, considerando a seguinte defini\u00e7\u00e3o minhaFun\u00e7\u00e3o'' ( a , b ) (( c , d ), _ , f ) g = a + b + c + d + f + fst g + snd g invoca\u00e7\u00e3o * Main > minhaFun\u00e7\u00e3o'' ( 1 , 2 ) (( 3 , 4 ), 5 , 6 ) ( 7 , 8 ) 31 Isto \u00e9, temos as seguintes associa\u00e7\u00f5es a = 1, b = 2, c = 3, d = 4, f = 6, g = (7,8) . Defini\u00e7\u00e3o de Fun\u00e7\u00f5es Al\u00e9m de decompor os par\u00e2metros passados para um fun\u00e7\u00e3o e como mencionado anteriormente , casamento de padr\u00f5es pode ser usado na defini\u00e7\u00e3o de fun\u00e7\u00f5es para simplificar testes via if-then-else e guardas nos par\u00e2metros da fun\u00e7\u00e3o. Neste caso, a fun\u00e7\u00e3o \u00e9 definida como uma sequ\u00eancia de equa\u00e7\u00f5es em que s\u00e3o feitas tentativas sucessivas de casamento de padr\u00f5es, na ordem das defini\u00e7\u00f5es. O resultado da invoca\u00e7\u00e3o da fun\u00e7\u00e3o \u00e9 dado pela primeira equa\u00e7\u00e3o em que houver um casamento bem sucedido e todas as guardas forem satisfeitas. Se ao final n\u00e3o houver casamento ou se as guardas n\u00e3o forem satisfeitas, ocorre um erro de execu\u00e7\u00e3o . O exemplo seguinte mostra o uso de padr\u00f5es curinga, constantes e vari\u00e1veis, combinados com guardas e, um caso especial, gerando um erro. Voc\u00ea consegue determinar o que a fun\u00e7\u00e3o faz? pr\u00f3ximos3 :: Int -> Char -> ( Int , Int , Int ) pr\u00f3ximos3 0 _ = ( - 1 , 0 , 1 ) pr\u00f3ximos3 n 'd' | n > 0 = ( n - 1 , n - 2 , n - 3 ) | n < 0 = ( n + 1 , n + 2 , n + 3 ) pr\u00f3ximos3 n 'a' | n < 0 = ( n - 1 , n - 2 , n - 3 ) | n > 0 = ( n + 1 , n + 2 , n + 3 ) pr\u00f3ximos3 _ _ = error \"Use d ou a\" Vejamos outros exemplos, do m\u00f3dulo prelude do Haskell. Primeiro, a fun\u00e7\u00e3o not , que nega o valor passado. not :: Bool -> Bool not True = False not False = True Vejamos agora diferentes defini\u00e7\u00f5es do operador && . Observe que como o operador \u00e9 infixo, a defini\u00e7\u00e3o das equa\u00e7\u00f5es segue esta nota\u00e7\u00e3o, mesmo que a defini\u00e7\u00e3o do prot\u00f3tipo n\u00e3o siga. A primeira defini\u00e7\u00e3o usa somente constantes como padr\u00e3o. Esta defini\u00e7\u00e3o est\u00e1 correta, mas \u00e9 mais complexa do que o necess\u00e1rio, j\u00e1 que somente a primeira equa\u00e7\u00e3o resulta em True . ( && ) Bool -> Bool -> Bool True && True = True True && False = False False && True = False False && False = False Uma vers\u00e3o simplificada pelo uso de padr\u00f5es curinga, seria a seguinte. Observe como ela \u00e9 mais leg\u00edvel. ( && ) Bool -> Bool -> Bool True && True = True _ && _ = False Finalmente, uma terceira vers\u00e3o que usa um padr\u00e3o vari\u00e1vel e um curinga tamb\u00e9m poderia ser usada. ( && ) Bool -> Bool -> Bool True && b = b False && _ = False Como exemplo do casamento em padr\u00f5es em tuplas, relembre as defini\u00e7\u00f5es de fst e snd . fst ( x , _ ) = x snd ( _ , y ) = y Exerc\u00edcio Seguindo os moldes da defini\u00e7\u00e3o do operador && , defina o operador l\u00f3gico ou || de tr\u00eas formas diferentes. Seguindo os moldes da defini\u00e7\u00e3o do operador && , defina o operador l\u00f3gico ou || de tr\u00eas formas diferentes. Defina 3 fun\u00e7\u00f5es, usando if - then - else , guardas e casamento de padr\u00f5es, que calculem os n\u00fameros da s\u00e9rie de Fibonacci, a saber Fib(1) = 1 Fib(2) = 1 Fib(n) = Fib(n-1) + Fib(n-2) Resolu\u00e7\u00e3o ```hs Surprise! ``` case - of Esta estrutura se assemelha ao switch de linguagens como C e Java, e tem a seguinte sintaxe, onde os padr\u00f5es devem estar perfeitamente alinhados. case expression of pattern -> result pattern -> result pattern -> result Por exemplo, vamos definir uma fun\u00e7\u00e3o que retorne o nome do m\u00eas, dado o seu n\u00famero. Seria poss\u00edvel escreve esta fun\u00e7\u00e3o com if aninhados, assim. nome_mes m = if m == 1 then \"JAN\" else if m == 2 then \"FEB\" else if m == 3 then \"MAR\" ... else if m == 11 then \"NOV\" else \"DEZ\" Usando guardas, ficaria assim: nome_mes m | m == 1 = \"JAN\" | m == 2 = \"FEB\" | m == 3 = \"MAR\" ... | m == 11 = \"NOV\" | otherwise \"DEZ\" Usando case - of , a nomeMes m = case m of 1 -> \"JAN\" m of 2 -> \"FEB\" m of 3 -> \"MAR\" ... m of 11 -> \"NOV\" m of 12 -> \"DEZ\" \u00c9 importante notar que \u00e9 poss\u00edvel aninhar case-of . A fun\u00e7\u00e3o pr\u00f3ximos3 poderia ser reescrita assim. Observe o alinhamento dentro do segundo case. pr\u00f3ximos3''' :: Int -> Char -> ( Int , Int , Int ) pr\u00f3ximos3''' n dir = case n of 0 -> ( - 1 , 0 , 1 ) _ -> case dir of 'd' -> if n > 0 then ( n - 1 , n - 2 , n - 3 ) else ( n + 1 , n + 2 , n + 3 ) 'a' -> if n < 0 then ( n - 1 , n - 2 , n - 3 ) else ( n + 1 , n + 2 , n + 3 ) _ -> error \"Use d ou a\" Listas Toda lista \u00e9 ou uma lista vazia ou ou um elemento cabe\u00e7a seguido por uma lista cauda. Assim, se cobrir estes dois casos em uma defini\u00e7\u00e3o por casamento de padr\u00f5es, ter\u00e1 coberto \"todos\" os casos! Mas como? Vejamos um exemplo. oQueH\u00e1NaCabe\u00e7a :: ( Show a ) => [ a ] -> String oQueH\u00e1NaCabe\u00e7a [] = \"Nada\" oQueH\u00e1NaCabe\u00e7a ( x : xs ) = \"H\u00e1 \" ++ x Linha 1: n\u00e3o se preocupe esta linha; ela apenas implica que a lista deve ser de valores convert\u00edveis a String Linha 2: esta linha usa um padr\u00e3o constante para testar se a lista \u00e9 vazia, isto \u00e9, [] e, neste caso, retornar a string \"Nada\" como resultado. Linha 3: este \u00e9 o caso mais interessante, pois usa um padr\u00e3o que define uma lista em que x \u00e9 a cabe\u00e7a, concatenada por : a uma cauda xs , e retorna \"H\u00e1 \" seguido do valor casado com x . Observe que foram usados par\u00eanteses na linha 3 para especificar o padr\u00e3o, e n\u00e3o apenas x : xs como seria de se esperar. A verdade \u00e9 que o padr\u00e3o \u00e9 x : xs e os par\u00eantesis s\u00e3o usados apenas para impedir que Haskell primeiro avalie oQueH\u00e1NaCabe\u00e7a x antes de avaliar o operador : e o seu segundo operando. Esta \u00e9 uma das idiossincrasias de Haskell com a qual voc\u00ea simplesmente ter\u00e1 que aprender a conviver para dividir listas entre cabe\u00e7a e cauda em um casamento de padr\u00f5es. Embora estes dois padr\u00f5es, isto \u00e9, lista vazia e cabe\u00e7a seguida de cauda, cubram todas as possibilidades de listas, n\u00e3o quer dizer que n\u00e3o haja melhores op\u00e7\u00f5es, dependendo do que precise extrair da lista. Por exemplo, na pr\u00f3xima fun\u00e7\u00e3o h\u00e1 4 casos de casamento de padr\u00f5es distintos: oQueH\u00e1NaLista :: ( Show a ) => [ a ] -> String oQueH\u00e1NaLista [] = \"Nada\" oQueH\u00e1NaLista [ x ] = \"S\u00f3 \" ++ ( show x ) oQueH\u00e1NaLista [ x1 , x2 ] = \"H\u00e1 \" ++ ( show x1 ) ++ \" e \" ++ ( show x2 ) oQueH\u00e1NaLista ( x : xs ) = \"H\u00e1 \" ++ ( show x ) ++ \" e mais um monte de coisas\" Linha 2: lista vazia; Linha 3: lista com exatamente um elemento, casado com x . Linha 4: lista com exatamente 2 elementos, casados com x1 e x2 . Linha 5: lista com mais de 2 elementos, em que a cabe\u00e7a \u00e9 casada com x e a cauda com xs . Outra forma de obter exatamente o mesmo resultado, usando mais o operador cons , seria a seguinte. oQueH\u00e1NaLista :: ( Show a ) => [ a ] -> String oQueH\u00e1NaLista [] = \"Nada\" oQueH\u00e1NaLista ( x :[] ) = \"S\u00f3 \" ++ ( show x ) oQueH\u00e1NaLista ( x1 : x2 :[] ) = \"H\u00e1 \" ++ ( show x1 ) ++ \" e \" ++ ( show x2 ) oQueH\u00e1NaLista ( x : xs ) = \"H\u00e1 \" ++ ( show x ) ++ \" e mais um monte de coisas\" Dado que strings s\u00e3o apenas listas de Char, estas tamb\u00e9m podem ser decompostas por casamentos de padr\u00f5es. resumo :: String -> String resumo [] -> \"Nada\" resumo [ _ ] -> \"Um\" resumo [ _ , _ ] -> \"Dois\" resumo _ -> \"Muitos\" Assim como listas podem ter elementos mais complexos que tipos primitivos, por exemplo tuplas e listas, tamb\u00e9m os casamentos de padr\u00f5es aplicados a estas listas ser\u00e3o mais complexos. Por exemplo, considere uma lista de tr\u00eas ou mais String, isto \u00e9, uma lista de lista de Char; \u00e9 poss\u00edvel, por exemplo, selecionar a primeira letra de cada uma das tr\u00eas primeiras strings com a seguinte fun\u00e7\u00e3o. iniciais :: [ String ] -> [ Char ] iniciais [] = [] iniciais [( x : _ )] = [ x ] iniciais [( x : _ ),( y : _ )] = [ x , y ] iniciais (( x : _ ) : ( y : _ ) : ( z : _ ) : _ ) = [ x , y , z ] Recurs\u00e3o A recurs\u00e3o \u00e9 essencial no processamento de listas e, de fato, muitas das fun\u00e7\u00f5es listadas na se\u00e7\u00e3o anterior podem e s\u00e3o definidas recursivamente, como a fun\u00e7\u00e3o maximum : \\(maximum~[1,2,3] = max~1 \\left( maximum~[2,3] = max~2 \\left( maximum~[3] = 3 \\right) \\right)\\) Vejamos algumas defini\u00e7\u00f5es. 2 maximum maximum' [] = error \"lista vazia\" maximum' [ h ] = h maximum' ( h : t ) = max h ( maximum' t ) length length' :: [ a ] -> Int length' [] = 0 length' ( x : xs ) = 1 + length' xs last last' :: [ a ] -> a last' [] = error \"List is empty\" last' [ x ] = x last' ( _ : xs ) = last' xs reverse reverse' :: [ a ] -> [ a ] reverse' [] = [] reverse' ( x : xs ) = reverse' xs ++ [ x ] replicate replicate' 0 e = [] replicate' x e = e : replicate' ( x - 1 ) e zip zip' [] _ = [] zip' _ [] = [] zip' ( x : xs ) ( y : ys ) = ( x , y ) : zip' xs ys elem elem' _ [] = False elem' e ( x : xs ) = e == x || elem' e xs ++ maisMais :: [ a ] -> [ a ] -> [ a ] maisMais [] [] = [] maisMais [] y = y maisMais ( x : xs ) y = x : maisMais xs y Exerc\u00edcio Defina a fun\u00e7\u00e3o take Defina a fun\u00e7\u00e3o drop Defina a fun\u00e7\u00e3o uni\u00e3o que recebe duas listas sem repeti\u00e7\u00f5es retorna a concatena\u00e7\u00e3o das listas, sem repeti\u00e7\u00f5es, usando recursividade. Defina a fun\u00e7\u00e3o uni\u00e3o que recebe duas listas sem repeti\u00e7\u00f5es retorna a concatena\u00e7\u00e3o das listas, sem repeti\u00e7\u00f5es, usando compreens\u00e3o de listas. Ordena\u00e7\u00e3o Selection-sort ( https://www.youtube.com/embed/Ns4TPTC8whw ) Defina uma fun\u00e7\u00e3o fr que receba um inteiro i e uma lista de inteiros l e retorne a lista l sem a primeira ocorr\u00eancia de i em l . Defina uma fun\u00e7\u00e3o fm que receba uma lista de inteiros l e retorne o menor inteiro da lista. Defina uma fun\u00e7\u00e3o fs que receba uma lista de inteiros l , escolha o menor inteiro m de l e retorne m concatenado a cabe\u00e7a da lista gerada por fs (fr m l) Merge-Sort ( https://www.youtube.com/embed/XaqR3G_NVoo ) Defina uma fun\u00e7\u00e3o fd que receba uma lista e retorne suas duas metades em uma dupla: metade [ 1 .. 11 ] = ([ 1 , 2 , 3 , 4 , 5 ],[ 6 , 7 , 8 , 9 , 10 , 11 ]) Defina uma fun\u00e7\u00e3o fu que receba duas listas ordenadas e retorne uma lista ordenada com a uni\u00e3o das listas uni\u00e3o [ 1 , 3 , 5 , 7 ] [ 2 , 4 , 6 , 7 ] = [ 1 , 2 , 3 , 5 , 6 , 7 , 7 ] Defina uma fun\u00e7\u00e3o fm que receba uma lista, divida-a na metade usando fd , aplique fm recursivamente em cada metade, e calcule a uni\u00e3o das listas resultantes usando fu . Quick-sort Defina uma fun\u00e7\u00e3o fp que receba uma lista l de inteiros e retorne retorne uma tripla (p,m1,m2) em que p \u00e9 o primeiro elemento da lista l m1 \u00e9 a lista dos elementos em l menores ou iguais a p , exclusive m2 \u00e9 a lista dos elementos em l maiores que p Defina uma fun\u00e7\u00e3o fq que recebe uma lista l , calcule (p,m1,m2) = fp l e retorne fq m1 concatenado a p concatenado a fq m2 . O termo em ingl\u00eas \u00e9 bind . \u21a9 Todas as fun\u00e7\u00f5es definidas a seguir tem nome terminado em ``` para evitar colis\u00e3o com as fun\u00e7\u00f5es padr\u00e3o. \u21a9","title":"Padr\u00f5es"},{"location":"functions2/pattern_matching/#casamento-de-padroes","text":"Mencionamos anteriormente que quando especificamos a lista de par\u00e2metros formais que uma fun\u00e7\u00e3o recebe, estamos dizendo ao compilador que os par\u00e2metros passados na invoca\u00e7\u00e3o da fun\u00e7\u00e3o devem ser associados aos par\u00e2metros formais. Em Haskell, este processo acontece por meio de um casamento de padr\u00f5es .","title":"Casamento de Padr\u00f5es"},{"location":"functions2/pattern_matching/#tipos-de-padrao","text":"O casamento de padr\u00f5es \u00e9 o processo pelo qual os valores em uma express\u00e3o s\u00e3o decompostos e associados aos elementos de um padr\u00e3o . Em outras palavras, dada uma express\u00e3o e um padr\u00e3o, \u00e9 feita uma tentativa de decomposi\u00e7\u00e3o da express\u00e3o de acordo com o especificado pelo padr\u00e3o. Se a decomposi\u00e7\u00e3o \u00e9 bem sucedida, isto \u00e9, se a express\u00e3o e o padr\u00e3o tem exatamente o mesmo tipo e se constantes especificadas no padr\u00e3o tem o mesmo valor na mesma posi\u00e7\u00e3o da express\u00e3o, ent\u00e3o o casamento \u00e9 bem sucedido ; caso contr\u00e1rio, o casamento fracassa . \u00c9 mais f\u00e1cil entender a descri\u00e7\u00e3o de casamento de padr\u00f5es acima usando exemplos. Para isso, vamos dividir os padr\u00f5es em alguns tipos e analisar exemplos de cada um destes tipos.","title":"Tipos de Padr\u00e3o"},{"location":"functions2/pattern_matching/#definicao-de-funcoes","text":"Al\u00e9m de decompor os par\u00e2metros passados para um fun\u00e7\u00e3o e como mencionado anteriormente , casamento de padr\u00f5es pode ser usado na defini\u00e7\u00e3o de fun\u00e7\u00f5es para simplificar testes via if-then-else e guardas nos par\u00e2metros da fun\u00e7\u00e3o. Neste caso, a fun\u00e7\u00e3o \u00e9 definida como uma sequ\u00eancia de equa\u00e7\u00f5es em que s\u00e3o feitas tentativas sucessivas de casamento de padr\u00f5es, na ordem das defini\u00e7\u00f5es. O resultado da invoca\u00e7\u00e3o da fun\u00e7\u00e3o \u00e9 dado pela primeira equa\u00e7\u00e3o em que houver um casamento bem sucedido e todas as guardas forem satisfeitas. Se ao final n\u00e3o houver casamento ou se as guardas n\u00e3o forem satisfeitas, ocorre um erro de execu\u00e7\u00e3o . O exemplo seguinte mostra o uso de padr\u00f5es curinga, constantes e vari\u00e1veis, combinados com guardas e, um caso especial, gerando um erro. Voc\u00ea consegue determinar o que a fun\u00e7\u00e3o faz? pr\u00f3ximos3 :: Int -> Char -> ( Int , Int , Int ) pr\u00f3ximos3 0 _ = ( - 1 , 0 , 1 ) pr\u00f3ximos3 n 'd' | n > 0 = ( n - 1 , n - 2 , n - 3 ) | n < 0 = ( n + 1 , n + 2 , n + 3 ) pr\u00f3ximos3 n 'a' | n < 0 = ( n - 1 , n - 2 , n - 3 ) | n > 0 = ( n + 1 , n + 2 , n + 3 ) pr\u00f3ximos3 _ _ = error \"Use d ou a\" Vejamos outros exemplos, do m\u00f3dulo prelude do Haskell. Primeiro, a fun\u00e7\u00e3o not , que nega o valor passado. not :: Bool -> Bool not True = False not False = True Vejamos agora diferentes defini\u00e7\u00f5es do operador && . Observe que como o operador \u00e9 infixo, a defini\u00e7\u00e3o das equa\u00e7\u00f5es segue esta nota\u00e7\u00e3o, mesmo que a defini\u00e7\u00e3o do prot\u00f3tipo n\u00e3o siga. A primeira defini\u00e7\u00e3o usa somente constantes como padr\u00e3o. Esta defini\u00e7\u00e3o est\u00e1 correta, mas \u00e9 mais complexa do que o necess\u00e1rio, j\u00e1 que somente a primeira equa\u00e7\u00e3o resulta em True . ( && ) Bool -> Bool -> Bool True && True = True True && False = False False && True = False False && False = False Uma vers\u00e3o simplificada pelo uso de padr\u00f5es curinga, seria a seguinte. Observe como ela \u00e9 mais leg\u00edvel. ( && ) Bool -> Bool -> Bool True && True = True _ && _ = False Finalmente, uma terceira vers\u00e3o que usa um padr\u00e3o vari\u00e1vel e um curinga tamb\u00e9m poderia ser usada. ( && ) Bool -> Bool -> Bool True && b = b False && _ = False Como exemplo do casamento em padr\u00f5es em tuplas, relembre as defini\u00e7\u00f5es de fst e snd . fst ( x , _ ) = x snd ( _ , y ) = y Exerc\u00edcio Seguindo os moldes da defini\u00e7\u00e3o do operador && , defina o operador l\u00f3gico ou || de tr\u00eas formas diferentes. Seguindo os moldes da defini\u00e7\u00e3o do operador && , defina o operador l\u00f3gico ou || de tr\u00eas formas diferentes. Defina 3 fun\u00e7\u00f5es, usando if - then - else , guardas e casamento de padr\u00f5es, que calculem os n\u00fameros da s\u00e9rie de Fibonacci, a saber Fib(1) = 1 Fib(2) = 1 Fib(n) = Fib(n-1) + Fib(n-2) Resolu\u00e7\u00e3o ```hs Surprise! ```","title":"Defini\u00e7\u00e3o de Fun\u00e7\u00f5es"},{"location":"functions2/pattern_matching/#listas","text":"Toda lista \u00e9 ou uma lista vazia ou ou um elemento cabe\u00e7a seguido por uma lista cauda. Assim, se cobrir estes dois casos em uma defini\u00e7\u00e3o por casamento de padr\u00f5es, ter\u00e1 coberto \"todos\" os casos! Mas como? Vejamos um exemplo. oQueH\u00e1NaCabe\u00e7a :: ( Show a ) => [ a ] -> String oQueH\u00e1NaCabe\u00e7a [] = \"Nada\" oQueH\u00e1NaCabe\u00e7a ( x : xs ) = \"H\u00e1 \" ++ x Linha 1: n\u00e3o se preocupe esta linha; ela apenas implica que a lista deve ser de valores convert\u00edveis a String Linha 2: esta linha usa um padr\u00e3o constante para testar se a lista \u00e9 vazia, isto \u00e9, [] e, neste caso, retornar a string \"Nada\" como resultado. Linha 3: este \u00e9 o caso mais interessante, pois usa um padr\u00e3o que define uma lista em que x \u00e9 a cabe\u00e7a, concatenada por : a uma cauda xs , e retorna \"H\u00e1 \" seguido do valor casado com x . Observe que foram usados par\u00eanteses na linha 3 para especificar o padr\u00e3o, e n\u00e3o apenas x : xs como seria de se esperar. A verdade \u00e9 que o padr\u00e3o \u00e9 x : xs e os par\u00eantesis s\u00e3o usados apenas para impedir que Haskell primeiro avalie oQueH\u00e1NaCabe\u00e7a x antes de avaliar o operador : e o seu segundo operando. Esta \u00e9 uma das idiossincrasias de Haskell com a qual voc\u00ea simplesmente ter\u00e1 que aprender a conviver para dividir listas entre cabe\u00e7a e cauda em um casamento de padr\u00f5es. Embora estes dois padr\u00f5es, isto \u00e9, lista vazia e cabe\u00e7a seguida de cauda, cubram todas as possibilidades de listas, n\u00e3o quer dizer que n\u00e3o haja melhores op\u00e7\u00f5es, dependendo do que precise extrair da lista. Por exemplo, na pr\u00f3xima fun\u00e7\u00e3o h\u00e1 4 casos de casamento de padr\u00f5es distintos: oQueH\u00e1NaLista :: ( Show a ) => [ a ] -> String oQueH\u00e1NaLista [] = \"Nada\" oQueH\u00e1NaLista [ x ] = \"S\u00f3 \" ++ ( show x ) oQueH\u00e1NaLista [ x1 , x2 ] = \"H\u00e1 \" ++ ( show x1 ) ++ \" e \" ++ ( show x2 ) oQueH\u00e1NaLista ( x : xs ) = \"H\u00e1 \" ++ ( show x ) ++ \" e mais um monte de coisas\" Linha 2: lista vazia; Linha 3: lista com exatamente um elemento, casado com x . Linha 4: lista com exatamente 2 elementos, casados com x1 e x2 . Linha 5: lista com mais de 2 elementos, em que a cabe\u00e7a \u00e9 casada com x e a cauda com xs . Outra forma de obter exatamente o mesmo resultado, usando mais o operador cons , seria a seguinte. oQueH\u00e1NaLista :: ( Show a ) => [ a ] -> String oQueH\u00e1NaLista [] = \"Nada\" oQueH\u00e1NaLista ( x :[] ) = \"S\u00f3 \" ++ ( show x ) oQueH\u00e1NaLista ( x1 : x2 :[] ) = \"H\u00e1 \" ++ ( show x1 ) ++ \" e \" ++ ( show x2 ) oQueH\u00e1NaLista ( x : xs ) = \"H\u00e1 \" ++ ( show x ) ++ \" e mais um monte de coisas\" Dado que strings s\u00e3o apenas listas de Char, estas tamb\u00e9m podem ser decompostas por casamentos de padr\u00f5es. resumo :: String -> String resumo [] -> \"Nada\" resumo [ _ ] -> \"Um\" resumo [ _ , _ ] -> \"Dois\" resumo _ -> \"Muitos\" Assim como listas podem ter elementos mais complexos que tipos primitivos, por exemplo tuplas e listas, tamb\u00e9m os casamentos de padr\u00f5es aplicados a estas listas ser\u00e3o mais complexos. Por exemplo, considere uma lista de tr\u00eas ou mais String, isto \u00e9, uma lista de lista de Char; \u00e9 poss\u00edvel, por exemplo, selecionar a primeira letra de cada uma das tr\u00eas primeiras strings com a seguinte fun\u00e7\u00e3o. iniciais :: [ String ] -> [ Char ] iniciais [] = [] iniciais [( x : _ )] = [ x ] iniciais [( x : _ ),( y : _ )] = [ x , y ] iniciais (( x : _ ) : ( y : _ ) : ( z : _ ) : _ ) = [ x , y , z ]","title":"Listas"},{"location":"functions2/pattern_matching/#recursao","text":"A recurs\u00e3o \u00e9 essencial no processamento de listas e, de fato, muitas das fun\u00e7\u00f5es listadas na se\u00e7\u00e3o anterior podem e s\u00e3o definidas recursivamente, como a fun\u00e7\u00e3o maximum : \\(maximum~[1,2,3] = max~1 \\left( maximum~[2,3] = max~2 \\left( maximum~[3] = 3 \\right) \\right)\\) Vejamos algumas defini\u00e7\u00f5es. 2 maximum maximum' [] = error \"lista vazia\" maximum' [ h ] = h maximum' ( h : t ) = max h ( maximum' t ) length length' :: [ a ] -> Int length' [] = 0 length' ( x : xs ) = 1 + length' xs last last' :: [ a ] -> a last' [] = error \"List is empty\" last' [ x ] = x last' ( _ : xs ) = last' xs reverse reverse' :: [ a ] -> [ a ] reverse' [] = [] reverse' ( x : xs ) = reverse' xs ++ [ x ] replicate replicate' 0 e = [] replicate' x e = e : replicate' ( x - 1 ) e zip zip' [] _ = [] zip' _ [] = [] zip' ( x : xs ) ( y : ys ) = ( x , y ) : zip' xs ys elem elem' _ [] = False elem' e ( x : xs ) = e == x || elem' e xs ++ maisMais :: [ a ] -> [ a ] -> [ a ] maisMais [] [] = [] maisMais [] y = y maisMais ( x : xs ) y = x : maisMais xs y Exerc\u00edcio Defina a fun\u00e7\u00e3o take Defina a fun\u00e7\u00e3o drop Defina a fun\u00e7\u00e3o uni\u00e3o que recebe duas listas sem repeti\u00e7\u00f5es retorna a concatena\u00e7\u00e3o das listas, sem repeti\u00e7\u00f5es, usando recursividade. Defina a fun\u00e7\u00e3o uni\u00e3o que recebe duas listas sem repeti\u00e7\u00f5es retorna a concatena\u00e7\u00e3o das listas, sem repeti\u00e7\u00f5es, usando compreens\u00e3o de listas. Ordena\u00e7\u00e3o Selection-sort ( https://www.youtube.com/embed/Ns4TPTC8whw ) Defina uma fun\u00e7\u00e3o fr que receba um inteiro i e uma lista de inteiros l e retorne a lista l sem a primeira ocorr\u00eancia de i em l . Defina uma fun\u00e7\u00e3o fm que receba uma lista de inteiros l e retorne o menor inteiro da lista. Defina uma fun\u00e7\u00e3o fs que receba uma lista de inteiros l , escolha o menor inteiro m de l e retorne m concatenado a cabe\u00e7a da lista gerada por fs (fr m l) Merge-Sort ( https://www.youtube.com/embed/XaqR3G_NVoo ) Defina uma fun\u00e7\u00e3o fd que receba uma lista e retorne suas duas metades em uma dupla: metade [ 1 .. 11 ] = ([ 1 , 2 , 3 , 4 , 5 ],[ 6 , 7 , 8 , 9 , 10 , 11 ]) Defina uma fun\u00e7\u00e3o fu que receba duas listas ordenadas e retorne uma lista ordenada com a uni\u00e3o das listas uni\u00e3o [ 1 , 3 , 5 , 7 ] [ 2 , 4 , 6 , 7 ] = [ 1 , 2 , 3 , 5 , 6 , 7 , 7 ] Defina uma fun\u00e7\u00e3o fm que receba uma lista, divida-a na metade usando fd , aplique fm recursivamente em cada metade, e calcule a uni\u00e3o das listas resultantes usando fu . Quick-sort Defina uma fun\u00e7\u00e3o fp que receba uma lista l de inteiros e retorne retorne uma tripla (p,m1,m2) em que p \u00e9 o primeiro elemento da lista l m1 \u00e9 a lista dos elementos em l menores ou iguais a p , exclusive m2 \u00e9 a lista dos elementos em l maiores que p Defina uma fun\u00e7\u00e3o fq que recebe uma lista l , calcule (p,m1,m2) = fp l e retorne fq m1 concatenado a p concatenado a fq m2 . O termo em ingl\u00eas \u00e9 bind . \u21a9 Todas as fun\u00e7\u00f5es definidas a seguir tem nome terminado em ``` para evitar colis\u00e3o com as fun\u00e7\u00f5es padr\u00e3o. \u21a9","title":"Recurs\u00e3o"},{"location":"functions2/recursion/","text":"Recursividade Uma fun\u00e7\u00e3o \u00e9 dita recursiva quando ela \u00e9 definida em termos de si mesma . Estas fun\u00e7\u00f5es s\u00e3o muito importantes tanto na matem\u00e1tica, onde s\u00e3o tamb\u00e9m conhecidas como recorr\u00eancias . Por exemplo, vejamos como \u00e9 definido um exemplo recorrentes de fun\u00e7\u00e3o na computa\u00e7\u00e3o ( pun intended ) de forma recursiva, o c\u00e1lculo do fatorial de um n\u00famero. Considere a seguinte defini\u00e7\u00e3o. \\[ n! = \\begin{cases} 1 & \\text{se } n = 0\\\\ n * (n-1)! & \\text{se } n > 0 \\end{cases} \\] Por esta defini\u00e7\u00e3o, podemos calcular o fatorial de 4, por exemplo, assim. \\[ \\begin{align} 4! &= 4 * (4-1)! \\\\ &= 4 * (3 * (3-1)!) \\\\ &= 4 * (3 * (2 * (2-1)!)) \\\\ &= 4 * (3 * (2 * (1 * (1-1)!))) \\\\ &= 4 * (3 * (2 * (1 * 0!))) \\\\ &= 4 * (3 * (2 * (1 * 1))) \\\\ &= 4 * (3 * (2 * 1)) \\\\ &= 4 * (3 * 2) \\\\ &= 4 * 6 \\\\ &= 24 \\end{align} \\] Na computa\u00e7\u00e3o, as fun\u00e7\u00f5es recursivas s\u00e3o importantes por serem uma estrat\u00e9gia de resolu\u00e7\u00e3o de problemas , pois possibilitam resolver problemas pouco a pouco, e especialmente importantes na programa\u00e7\u00e3o funcional, onde servem de alternativa \u00e0s instru\u00e7\u00f5es de itera\u00e7\u00e3o como for (;;) e while () , comuns nas linguagens imperativas. Em Haskell N\u00e3o h\u00e1 nada de especial em termos de sintaxe na declara\u00e7\u00e3o de fun\u00e7\u00f5es recursivas. O c\u00e1lculo do fatorial pode ser traduzido quase que diretamente para Haskell usando guardas. fatorialGuardas n | n == 0 = 1 | otherwise = n * fatorialGuardas ( n - 1 ) Observe que a defini\u00e7\u00e3o \u00e9 iniciada tratando o caso em que 0 \u00e9 passado como par\u00e2metro; este \u00e9 o que chamamos de caso base , que serve para limitar a recurs\u00e3o e impedir que execute para sempre. J\u00e1 o que torna a fun\u00e7\u00e3o recursiva acontece na \u00faltima linha: a invoca\u00e7\u00e3o da pr\u00f3pria fun\u00e7\u00e3o. Como esta invoca\u00e7\u00e3o ser\u00e1 feita para o valor passado como par\u00e2metro menos 1, temos a garantia de que, para qualquer n\u00famero positivo passado como par\u00e2metro, em algum momento haver\u00e1 uma invoca\u00e7\u00e3o da fun\u00e7\u00e3o com o par\u00e2metro igual a 0 , que ser\u00e1 respondida pelo caso base. \u00c9 importante ficar claro que para cada invoca\u00e7\u00e3o da fun\u00e7\u00e3o, \\(n\\) assume um valor diferente, o que pode fazer parecer que o valor de \\(n\\) est\u00e1 mudando, mas isso n\u00e3o poderia estar mais longe da verdade! Cada \\(n\\) s\u00f3 existe no escopo de uma invoca\u00e7\u00e3o da fun\u00e7\u00e3o. Pictograficamente, \\(n\\) s\u00f3 \u00e9 vis\u00edvel dentro da \"caixinha\" onde foi associada a um valor. Outra forma absolutamente equivalente de definir a fun\u00e7\u00e3o \u00e9 usando casamento de padr\u00f5es, como a seguir. fatorialPM 0 = 1 fatorialPM n = n * fatorialPM ( n - 1 ) Considerando as duas defini\u00e7\u00f5es da fun\u00e7\u00e3o, considere o que acontece se as mesmas forem invocadas com um n\u00famero negativo como par\u00e2metro. O que acontece? A recurs\u00e3o simplesmente \"nunca\" termina, continuando com \\(n\\) indo para o - infinito. Acontece que n\u00e3o \u00e9 definido o fatorial de n\u00fameros negativos e, por isso, precisamos que um erro seja lan\u00e7ado quando uma tentativa de invoca\u00e7\u00e3o deste tipo ocorrer. H\u00e1 diferentes formas de se lan\u00e7ar um erro, sendo a primeira simplesmente limitar os valores v\u00e1lidos para os par\u00e2metros. fatorialGuardas n | n == 0 = 1 | n > 0 = n * fatorialGuardas ( n - 1 ) A outra alternativa \u00e9 explicitamente causar um erro. fatorialGuardas' n | n == 0 = 1 | n > 0 = n * fatorialGuardas' ( n - 1 ) | otherwise = error \"N\u00e3o se pode calcular o fatorial de n\u00fameros negativos\" fatorialGuardas'' n | n == 0 = 1 | otherwise = if n > 0 then n * fatorialGuardas'' ( n - 1 ) else error \"N\u00e3o se pode calcular o fatorial de n\u00fameros negativos\" Fun\u00e7\u00f5es Recursivas Caso base - Limita recurs\u00e3o. Caso geral - Faz chamada recursiva para problema \" menor \" Note que em ambas as formas, temos algumas defini\u00e7\u00f5es simples, os casos base , que n\u00e3o fazem recurs\u00e3o, e os casos recursivos , envolvem recurs\u00e3o. Este padr\u00e3o se repetir\u00e1 praticamente sempre nas defini\u00e7\u00f5es recursivas, o que n\u00e3o quer dizer que a defini\u00e7\u00e3o ser\u00e1 \u00f3bvia. M\u00e1ximo Divisor Comum O m\u00e1ximo divisor comum de dois n\u00fameros \u00e9, bem, o maior dentre os divisores comuns. Por exemplo, considere os n\u00fameros 18 e 12: j\u00e1 que o 18 tem como divisores {18, 9, 6, 3, 2, 1} e o 12 tem {12, 6, 4, 3, 2, 1}, o maior dentre os divisores comuns \u00e9 6, isto \u00e9, o mdc(18,12) = 6. Logo, se quisermos implementar uma fun\u00e7\u00e3o que calcule o mdc, podemos come\u00e7ar por encontrar o conjunto de divisores, usando uma recurs\u00e3o, e ent\u00e3o iterar pelos conjuntos para identificar o maior comum, com outra recurs\u00e3o. Enquanto esta abordagem \u00e9 um bom exerc\u00edcio de manipula\u00e7\u00e3o de listas, se o objetivo \u00e9 calcular o mdc de forma recursiva, h\u00e1 uma abordagem melhor, conhecida como o algoritmo de Euclides . De forma direta, este algoritmo pode ser expresso como a seguinte fun\u00e7\u00e3o recursiva, onde \\(a >= b\\) \\[ mdc(a,b) = \\begin{cases} a & \\text{se } b = 0\\\\ \\text{mdc}(b, a \\text{ mod } b) & \\text{caso contr\u00e1rio } \\end{cases} \\] Em Haskell, a defini\u00e7\u00e3o fica assim. mdc :: Integer -> Integer -> Integer mdc a b | b == 0 = a | otherwise = mdc b ( a ` mod ` b ) Fibonacci Considere a fun\u00e7\u00e3o que retorna um termo da sequ\u00eancia de Fibonacci, em que os dois primeiros termos s\u00e3o 1 e todos os outros termos s\u00e3o iguais \u00e0 soma dos dois termos anteriores. \\[ F(n) = \\begin{cases} 1 & \\text{se } n = 1\\\\ 1 & \\text{se } n = 2\\\\ F(n-1) + F(n - 2) & \\text{se } n > 2 \\end{cases} \\] A mesma tradu\u00e7\u00e3o direta da defini\u00e7\u00e3o matem\u00e1tica para Haskell tamb\u00e9m pode ser feita aqui, sendo a \u00fanica diferen\u00e7a o fato de que duas invoca\u00e7\u00f5es recursivas s\u00e3o feitas a cada passo. H\u00e1, contudo, diversas possibilidades de tradu\u00e7\u00e3o. fibIf n = if n == 1 then 1 else if n == 2 then 1 else fibIf ( n - 1 ) + fibIf ( n - 2 ) fibGuard n | n == 1 = 1 | n == 2 = 1 | otherwise = fibGuard ( n - 1 ) + fibGuard ( n - 2 ) fibPattern 1 = 1 fibPattern 2 = 1 fibPattern n = fibPattern ( n - 1 ) + fibPattern ( n - 2 ) fibCase x = case x of 1 -> 0 2 -> 1 n -> fibCase ( n - 1 ) + fibCase ( n - 2 ) Conjectura de Collatz Considere a seguinte fun\u00e7\u00e3o para construir uma sequ\u00eancia de n\u00fameros usando \\(n\\) como base. \\[ F_n(i) = \\begin{cases} n & \\text{se } i = 1\\\\ F_n(i-1)/2 & \\text{se } F_n(i-1) \\text{ \u00e9 par}\\\\ F_n(i-1)* 3 + 1 & \\text{se } F_n(i-1) \\text{ \u00e9 \u00edmpar} \\end{cases} \\] Exerc\u00edcio Defina a fun\u00e7\u00e3o acima em Haskell. Segundo a conjectura de Collatz , para qualquer valor de \\(n\\) , em algum momento a sequ\u00eancia converge para o valor 1 e a partir da\u00ed repete infinitamente os termos 4, 2, 1. Por exemplo, para \\(n=7\\) , a sequ\u00eancia \u00e9 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1; para \\(n=12\\) , 12, 6, 3, 10, 5, 16, 8, 4, 2, 1; para \\(n=19\\) , 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1; e, para \\(n=27\\) , 27, 82, 41, 124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1 Esta \u00e9 uma conjectura pois n\u00e3o se sabe se a sequ\u00eancia realmente converge para 1 dado qualquer \\(n\\) . O que voc\u00ea acha de testar alguns valores para tentar identificar h\u00e1 ou n\u00e3o uma converg\u00eancia? Em C, poder\u00edamos fazer o seguinte: int collatz ( int n , int i ){ if ( i == 1 ) return n ; else { int f_n_i_menos_1 = collatz ( n , i -1 ); if ( f_n_i_menos_1 % 2 == 0 ) return f_n_i_menos_1 / 2 ; else f_n_i_menos_1 * 3 + 1 ; } bool converge ( int n ) { bool convergiu = false ; for ( int i = 0 ; ! convergiu ; i ++ ) convergiu = collatz ( n , i ) == 1 ; return convergiu ; } Por mais ineficiente que seja, este c\u00f3digo em C funciona e pode servir de base para uma vers\u00e3o em Haskell, mas como escrever a itera\u00e7\u00e3o? Como dito anteriormente, a itera\u00e7\u00e3o pode ser feita por meio de outra recurs\u00e3o! collatz :: Int -> Int -> Int collatz n i | i == 1 = n | even ( collatz n ( i - 1 )) = collatz n ( i - 1 ) ` div ` 2 | otherwise = collatz n ( i - 1 ) * 3 + 1 converge :: Int -> Bool converge n = convergeInterna n 1 convergeInterna :: Int -> Int -> Bool convergeInterna n passo | collatz n passo == 1 = True | otherwise = convergeInterna n ( passo + 1 ) Vejamos alguns exemplos. * Main > collatz 7 13 16 * Main > collatz 7 17 1 * Main > converge 7 True * Main > converge 12 True * Main > convergeInterna 7 15 True * Main > convergeInterna 7 1 True Tente executar a fun\u00e7\u00e3o para o n\u00famero 27, cuja sequ\u00eancia calculada acima tem 111 passos. Quando seu computador come\u00e7ar a se desesperar ou voc\u00ea cansar de esperar, aperte Ctrl + C . Mas por qu\u00ea esta fun\u00e7\u00e3o t\u00e3o simples ficou t\u00e3o pesada? Por qu\u00ea para calcular se a sequ\u00eancia converge, primeiro a fun\u00e7\u00e3o testou o primeiro termo, 27, e viu que n\u00e3o era igual 1; calculou ent\u00e3o o segundo termo, para isto calculando o primeiro termo novamente, e testando se igual a 1; calculou ent\u00e3o o terceiro termo, para isso calculando o segundo termo, para isso calculando o primeiro, e assim por diante. Al\u00e9m disso, no c\u00e1lculo de cada termo, h\u00e1 um teste para ver se o termo anterior \u00e9 \u00edmpar ou par, o que por si s\u00f3 calcula o termo anterior. Mais tarde veremos como tornar esta fun\u00e7\u00e3o muito mais eficiente, como na vers\u00e3o em C, em que o termo anterior s\u00f3 \u00e9 calculado uma vez, mas por enquanto pensemos em como podemos limitar o n\u00famero de passos nesta itera\u00e7\u00e3o. Exerc\u00edcio Modifique a defini\u00e7\u00e3o da fun\u00e7\u00e3o converge para impedir que execute ad eternum . Dica Use um contador para limitar o n\u00famero de recurs\u00f5es e, no caso do limite ser alcan\u00e7ado, emita um erro. Resolu\u00e7\u00e3o Use um contador para limitar o n\u00famero de recurs\u00f5es e, no caso do limite ser alcan\u00e7ado, emita um erro. collatz :: Int -> Int -> Int collatz n i | i == 1 = n | even ( collatz n ( i - 1 )) = collatz n ( i - 1 ) ` div ` 2 | otherwise = collatz n ( i - 1 ) * 3 + 1 converge :: Int -> Int -> Int -> Bool converge n passo limite | limite == 0 = error \"N\u00e3o alcan\u00e7ou uma resposta\" | collatz n passo == 1 = True | otherwise = converge n ( passo + 1 ) ( limite - 1 ) Binomial H\u00e1 v\u00e1rias maneiras de se calcular o n\u00famero de combina\u00e7\u00f5es que se pode obter com \\(k\\) elementos de um conjunto de \\(n\\) elementos. Uma destas formas \u00e9 via a seguinte recorr\u00eancia. \\[ \\binom{n}{k} = \\begin{cases} \\text{indefinido} & \\text{se} k > n\\\\ 1 & \\text{se } k = 0\\\\ 1 & \\text{se } k = n\\\\ \\binom{n-1}{k} + \\binom{n-1}{k-1} & \\text{caso contr\u00e1rio } \\end{cases} \\] Binomial Implemente uma fun\u00e7\u00e3o recursiva que calcule \\(\\binom{n}{k}\\) Resolu\u00e7\u00e3o A ser implementado Recurs\u00e3o e Listas Fun\u00e7\u00f5es recursivas s\u00e3o particularmente importantes na manipula\u00e7\u00e3o listas, como veremos adiante. Recurs\u00e3o de Cauda A recurs\u00e3o de cauda \u00e9 uma t\u00e9cnica important\u00edssima para melhorar o desempenho de fun\u00e7\u00f5es recursivas ao economizar os recursos do sistema, e ao permitir as recurs\u00f5es possam at\u00e9 ser infinitas, como em la\u00e7os infinitos usados em jogos, por exemplo. Esta t\u00e9cnica ser\u00e1 explorada no futuro, uma vez que j\u00e1 estejam confort\u00e1veis com recurs\u00f5es n\u00e3o otimizadas.","title":"Recurs\u00e3o"},{"location":"functions2/recursion/#recursividade","text":"Uma fun\u00e7\u00e3o \u00e9 dita recursiva quando ela \u00e9 definida em termos de si mesma . Estas fun\u00e7\u00f5es s\u00e3o muito importantes tanto na matem\u00e1tica, onde s\u00e3o tamb\u00e9m conhecidas como recorr\u00eancias . Por exemplo, vejamos como \u00e9 definido um exemplo recorrentes de fun\u00e7\u00e3o na computa\u00e7\u00e3o ( pun intended ) de forma recursiva, o c\u00e1lculo do fatorial de um n\u00famero. Considere a seguinte defini\u00e7\u00e3o. \\[ n! = \\begin{cases} 1 & \\text{se } n = 0\\\\ n * (n-1)! & \\text{se } n > 0 \\end{cases} \\] Por esta defini\u00e7\u00e3o, podemos calcular o fatorial de 4, por exemplo, assim. \\[ \\begin{align} 4! &= 4 * (4-1)! \\\\ &= 4 * (3 * (3-1)!) \\\\ &= 4 * (3 * (2 * (2-1)!)) \\\\ &= 4 * (3 * (2 * (1 * (1-1)!))) \\\\ &= 4 * (3 * (2 * (1 * 0!))) \\\\ &= 4 * (3 * (2 * (1 * 1))) \\\\ &= 4 * (3 * (2 * 1)) \\\\ &= 4 * (3 * 2) \\\\ &= 4 * 6 \\\\ &= 24 \\end{align} \\] Na computa\u00e7\u00e3o, as fun\u00e7\u00f5es recursivas s\u00e3o importantes por serem uma estrat\u00e9gia de resolu\u00e7\u00e3o de problemas , pois possibilitam resolver problemas pouco a pouco, e especialmente importantes na programa\u00e7\u00e3o funcional, onde servem de alternativa \u00e0s instru\u00e7\u00f5es de itera\u00e7\u00e3o como for (;;) e while () , comuns nas linguagens imperativas.","title":"Recursividade"},{"location":"functions2/recursion/#em-haskell","text":"N\u00e3o h\u00e1 nada de especial em termos de sintaxe na declara\u00e7\u00e3o de fun\u00e7\u00f5es recursivas. O c\u00e1lculo do fatorial pode ser traduzido quase que diretamente para Haskell usando guardas. fatorialGuardas n | n == 0 = 1 | otherwise = n * fatorialGuardas ( n - 1 ) Observe que a defini\u00e7\u00e3o \u00e9 iniciada tratando o caso em que 0 \u00e9 passado como par\u00e2metro; este \u00e9 o que chamamos de caso base , que serve para limitar a recurs\u00e3o e impedir que execute para sempre. J\u00e1 o que torna a fun\u00e7\u00e3o recursiva acontece na \u00faltima linha: a invoca\u00e7\u00e3o da pr\u00f3pria fun\u00e7\u00e3o. Como esta invoca\u00e7\u00e3o ser\u00e1 feita para o valor passado como par\u00e2metro menos 1, temos a garantia de que, para qualquer n\u00famero positivo passado como par\u00e2metro, em algum momento haver\u00e1 uma invoca\u00e7\u00e3o da fun\u00e7\u00e3o com o par\u00e2metro igual a 0 , que ser\u00e1 respondida pelo caso base. \u00c9 importante ficar claro que para cada invoca\u00e7\u00e3o da fun\u00e7\u00e3o, \\(n\\) assume um valor diferente, o que pode fazer parecer que o valor de \\(n\\) est\u00e1 mudando, mas isso n\u00e3o poderia estar mais longe da verdade! Cada \\(n\\) s\u00f3 existe no escopo de uma invoca\u00e7\u00e3o da fun\u00e7\u00e3o. Pictograficamente, \\(n\\) s\u00f3 \u00e9 vis\u00edvel dentro da \"caixinha\" onde foi associada a um valor. Outra forma absolutamente equivalente de definir a fun\u00e7\u00e3o \u00e9 usando casamento de padr\u00f5es, como a seguir. fatorialPM 0 = 1 fatorialPM n = n * fatorialPM ( n - 1 ) Considerando as duas defini\u00e7\u00f5es da fun\u00e7\u00e3o, considere o que acontece se as mesmas forem invocadas com um n\u00famero negativo como par\u00e2metro. O que acontece? A recurs\u00e3o simplesmente \"nunca\" termina, continuando com \\(n\\) indo para o - infinito. Acontece que n\u00e3o \u00e9 definido o fatorial de n\u00fameros negativos e, por isso, precisamos que um erro seja lan\u00e7ado quando uma tentativa de invoca\u00e7\u00e3o deste tipo ocorrer. H\u00e1 diferentes formas de se lan\u00e7ar um erro, sendo a primeira simplesmente limitar os valores v\u00e1lidos para os par\u00e2metros. fatorialGuardas n | n == 0 = 1 | n > 0 = n * fatorialGuardas ( n - 1 ) A outra alternativa \u00e9 explicitamente causar um erro. fatorialGuardas' n | n == 0 = 1 | n > 0 = n * fatorialGuardas' ( n - 1 ) | otherwise = error \"N\u00e3o se pode calcular o fatorial de n\u00fameros negativos\" fatorialGuardas'' n | n == 0 = 1 | otherwise = if n > 0 then n * fatorialGuardas'' ( n - 1 ) else error \"N\u00e3o se pode calcular o fatorial de n\u00fameros negativos\" Fun\u00e7\u00f5es Recursivas Caso base - Limita recurs\u00e3o. Caso geral - Faz chamada recursiva para problema \" menor \" Note que em ambas as formas, temos algumas defini\u00e7\u00f5es simples, os casos base , que n\u00e3o fazem recurs\u00e3o, e os casos recursivos , envolvem recurs\u00e3o. Este padr\u00e3o se repetir\u00e1 praticamente sempre nas defini\u00e7\u00f5es recursivas, o que n\u00e3o quer dizer que a defini\u00e7\u00e3o ser\u00e1 \u00f3bvia.","title":"Em Haskell"},{"location":"functions2/recursion/#recursao-e-listas","text":"Fun\u00e7\u00f5es recursivas s\u00e3o particularmente importantes na manipula\u00e7\u00e3o listas, como veremos adiante.","title":"Recurs\u00e3o e Listas"},{"location":"functions2/recursion/#recursao-de-cauda","text":"A recurs\u00e3o de cauda \u00e9 uma t\u00e9cnica important\u00edssima para melhorar o desempenho de fun\u00e7\u00f5es recursivas ao economizar os recursos do sistema, e ao permitir as recurs\u00f5es possam at\u00e9 ser infinitas, como em la\u00e7os infinitos usados em jogos, por exemplo. Esta t\u00e9cnica ser\u00e1 explorada no futuro, uma vez que j\u00e1 estejam confort\u00e1veis com recurs\u00f5es n\u00e3o otimizadas.","title":"Recurs\u00e3o de Cauda"},{"location":"functions3/highorder/","text":"Fun\u00e7\u00f5es de ordem superior Quando estudamos linguagens de programa\u00e7\u00e3o, \u00e9 comum denominar como cidad\u00e3os de primeira classe (do ingl\u00eas, first class citizens ) as entidades que podem ser atribu\u00eddas a vari\u00e1veis, passadas como par\u00e2metro, retornadas como resultado ou operadas de forma geral. Em Haskell, fun\u00e7\u00f5es s\u00e3o cidad\u00e3s de primeira classe! Vejamos um exemplo em que uma fun\u00e7\u00e3o \u00e9 associada a uma vari\u00e1vel, o que efetivamente torna esta vari\u00e1vel uma fun\u00e7\u00e3o! Prelude > f x y = x + y Prelude > g = f Prelude > g 1 2 3 Outro conceito relacionado \u00e9 o das fun\u00e7\u00f5es de ordem superior , aquelas fun\u00e7\u00f5es que ou recebem como par\u00e2metro ou retornam como resultado outras fun\u00e7\u00f5es, e que s\u00f3 podem existir em linguagens em que fun\u00e7\u00f5es s\u00e3o cidad\u00e3s de primeira classe. Vejamos um exemplo de uma fun\u00e7\u00e3o de ordem superior que aplica uma outra fun\u00e7\u00e3o, recebida como par\u00e2metro, aos seus outros par\u00e2metros. somar :: Int -> Int -> Int somar x y = x + y multiplicar :: Int -> Int -> Int multiplicar x y = x * y dividir :: Int -> Int -> Int dividir x y = x ` div ` y operar :: ( Int -> Int -> Int ) -> Int -> Int -> Int operar f x y = f x y -- >>> operar somar 3 4 -- 7 -- >>> operar multiplicar 3 4 -- 12 -- >>> operar dividir 3 4 -- 0 Observe que a fun\u00e7\u00e3o operar tem como primeiro par\u00e2metro formal #!f , que \u00e9 do tipo ( Int -> Int -> Int ) , isto \u00e9, uma fun\u00e7\u00e3o que recebe dois inteiros e retorna um inteiro. Esta fun\u00e7\u00e3o f \u00e9 aplicada aos demais par\u00e2metros de de operar para calcular o resultado. Fun\u00e7\u00f5es de alta ordem s\u00e3o \u00fateis em diversas situa\u00e7\u00f5es, por exemplo, como forma de criar um comportamento configur\u00e1vel no seu c\u00f3digo, e s\u00e3o frequentes na biblioteca da linguagem Haskell, dentre as quais destacamos map , filter , e diversos tipos de fold . map Seja uma lista de inteiros sobre a qual voc\u00ea queira executar diversas transforma\u00e7\u00f5es, por exemplo, multiplicar todos os valores por 10, somar 3, testar se par ou achar o m\u00f3dulo por 3. Voc\u00ea pode come\u00e7ar definindo fun\u00e7\u00f5es que fazem transforma\u00e7\u00f5es em um \u00fanico elemento e, para cada uma, uma fun\u00e7\u00e3o correspondente para listas. multiplicarPor10 :: Int -> Int multiplicarPor10 x = x * 10 multiplicarPor10Lista :: [ Int ] -> [ Int ] multiplicarPor10Lista l = [ multiplicarPor10 e | e <- l ] -- >>>multiplicarPor10Lista [2..5] -- [20,30,40,50] somar3 :: Int -> Int somar3 x = x + 3 somar3Lista :: [ Int ] -> [ Int ] somar3Lista l = [ somar3 e | e <- l ] -- >>>somar3Lista [2..5] -- [5,6,7,8] \u00e9Par :: Int -> Bool \u00e9Par x = even x \u00e9ParLista :: [ Int ] -> [ Bool ] \u00e9ParLista l = [ \u00e9Par e | e <- l ] -- >>>\u00e9ParLista [2..5] -- [True,False,True,False] mod3 :: Int -> Int mod3 x = x ` mod ` 3 mod3Lista :: [ Int ] -> [ Int ] mod3Lista l = [ mod3 e | e <- l ] -- >>>mod3Lista [2..5] -- [2,0,1,2] Se voc\u00ea observar as fun\u00e7\u00f5es para as listas perceber\u00e1 que todas tem uma mesma estrutura. Gra\u00e7as \u00e0s fun\u00e7\u00f5es de ordem superior, voc\u00ea pode aproveitar este fato e criar uma fun\u00e7\u00e3o, gen\u00e9rica, que sirva para aplicar qualquer das transforma\u00e7\u00f5es desejadas. Como as fun\u00e7\u00f5es acima, nossa fun\u00e7\u00e3o gen\u00e9rica recebe uma lista de um tipo a e resultar\u00e1 em uma lista de um tipo b . Por iso, chamemos nossa fun\u00e7\u00e3o de mapeie , pois com ela mapearemos cada valor da lista de entrada para a lista de resultado. Al\u00e9m da lista de entrada, mapeie mas tamb\u00e9m receber\u00e1 uma fun\u00e7\u00e3o com tipo a -> b , a ser aplicada nas transforma\u00e7\u00f5es. mapeie :: ( a -> b ) -> [ a ] -> [ b ] mapeie f xs = [ f x | x <- xs ] Uma vez definida a fun\u00e7\u00e3o, sua invoca\u00e7\u00e3o \u00e9 trivial. > mapeie multiplicarPor10 [ 1 .. 10 ] [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 ] > mapeie somar3 [ 1 .. 10 ] [ 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] > mapeie \u00e9Par [ 1 .. 10 ] [ False , True , False , True , False , True , False , True , False , True ] > mapeie mod3 [ 1 .. 10 ] [ 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 ] A fun\u00e7\u00e3o mapeie , na verdade, serve para aplicar qualquer fun\u00e7\u00e3o que transforme a para b em uma lista de elementos do tipo a , resultando em uma lista de elementos do tipo b . Esta fun\u00e7\u00e3o \u00e9 t\u00e3o \u00fatil, que j\u00e1 existe na biblioteca do Haskell e de qualquer linguagem de programa\u00e7\u00e3o funcional (e mesmo outras, como Python e Java). > : i map map :: ( a -> b ) -> [ a ] -> [ b ] -- Defined in \u2018GHC.Base\u2019 fold (redu\u00e7\u00e3o) Um outro procedimento recorrente sobre dados \u00e9 a redu\u00e7\u00e3o ou sumariza\u00e7\u00e3o de um conjunto para um \u00fanico valor, como \u00e9 feito pelas fun\u00e7\u00f5es product e sum nos seguintes exemplos. > sum [ 1 .. 10 ] 55 > product [ 1 .. 3 ] 6 Vamos tentar generalizar estas duas fun\u00e7\u00f5es usando uma fun\u00e7\u00e3o de ordem superior. Isto \u00e9, definimos uma fun\u00e7\u00e3o de ordem superior que receba um operador, como ( + ) e ( * ) , e aplique a uma lista de inteiros calculando resumo dos elementos da lista, como o somat\u00f3rio ou o produt\u00f3rio no caso dos operadores ( + ) e ( * ) . Comecemos por redefinir sum e product para entender melhor suas estruturas. sum' :: [ Int ] -> Int sum' [] = 0 sum' ( n : ns ) = n + sum' ns Podemos pensar na fun\u00e7\u00e3o sum' como gerando uma express\u00e3o formada pelos elementos da lista mais o valor 0, separados pelo operador + , por exemplo, sum' [ 1 , 2 , 3 ] = 1 + 2 + 3 + 0 e sum' [ 7 , 9 , 14 ] = 7 + 9 + 14 + 0 . Observe que o valor 0 \u00e9 escolhido como resultado do caso base, 0, pois ele n\u00e3o afeta o somat\u00f3rio, isto \u00e9, 0 \u00e9 o elemento neutro (ou identidade) da adi\u00e7\u00e3o. product' :: [ Int ] -> Int product' [] = 1 product' ( n : ns ) = n * product' ns No caso de product , embora a estrutura seja a mesma, alteramos o caso base para 1, o elemento neutro da multiplica\u00e7\u00e3o. Assim, por mais estranho que possa parecer, o produt\u00f3rio de uma lista vazia \u00e9 definido como 1. 1 A express\u00e3o gerada pela fun\u00e7\u00e3o \u00e9 semelhante, isto \u00e9, product' [ 1 , 2 , 3 ] = 1 * 2 * 3 * 1 e product' [ 7 , 9 , 14 ] = 7 * 9 * 14 * 1 . Podemos ent\u00e3o generalizar a fun\u00e7\u00e3o como uma recurs\u00e3o em que o caso gen\u00e9rico \u00e9 a do operador especificado e o caso base retorna o elemento neutro da opera\u00e7\u00e3o. O tipo da fun\u00e7\u00e3o \u00e9 claro; ela deve receber um operar, que \u00e9 uma fun\u00e7\u00e3o que recebe dois inteiros e retorna um inteiro, a lista de inteiros para aplicar o operador, e retornar um resultado tamb\u00e9m inteiro. A recurs\u00e3o consistir\u00e1 em um caso gen\u00e9rico, que aplica o operador \u00e0 cabe\u00e7a da lista e ao resultado da invoca\u00e7\u00e3o recursivo na cauda, e de um caso base que retorne o elemento neutro da opera\u00e7\u00e3o. Mas como saber qual \u00e9 o elemento neutro? resumir :: ( Int -> Int -> Int ) -> [ Int ] -> Int resumir f [] = ?? resumir f ( n : ns ) = n ` f ` ( resumir f ns ) N\u00e3o nos resta alternativa sen\u00e3o passar o pr\u00f3prio elemento neutro na invoca\u00e7\u00e3o da fun\u00e7\u00e3o, resultando na seguinte defini\u00e7\u00e3o. resumir :: ( Int -> Int -> Int ) -> Int -> [ Int ] -> Int resumir f i [] = i resumir f i ( n : ns ) = n ` f ` ( resumir f i ns ) -- >>> resumir somar 0 [1..5] -- 15 -- >>> resumir multiplicar 1 [1..5] -- 120 Uma varia\u00e7\u00e3o ligeiramente diferente, alterando a chamada recursiva, gera os mesmos resultados. resumir' :: ( Int -> Int -> Int ) -> Int -> [ Int ] -> Int resumir' f i [] = i resumir' f i ( n : ns ) = resumir' f ( i ` f ` n ) ns -- >>> resumir somar 0 [1..5] -- 15 -- >>> resumir' multiplicar 1 [1..5] -- 120 A diferen\u00e7a aqui \u00e9 que em vez da recurs\u00e3o passar o elemento neutro adiante para ser usado no caso base, intocado, o elemento neutro \u00e9 usado de cara e operado com a cabe\u00e7a da lista; o resultado desta opera\u00e7\u00e3o \u00e9 que \u00e9 ent\u00e3o passado para a chamada recursiva at\u00e9 que, no caso base, seja retornado como o resultado da fun\u00e7\u00e3o. Uma outra forma de ver isso \u00e9 comparando as express\u00f5es geradas pelas duas declara\u00e7\u00f5es. Neste caso, consideraremos operador o e um elemento neutro i , mas, desta vez, observemos tamb\u00e9m a ordem em que as opera\u00e7\u00f5es ser\u00e3o efetivamente executadas, denotando a ordem por meio de par\u00eanteses. Fun\u00e7\u00e3o resumir o i [ 1 , 2 , 3 ] resumir' o i [ 1 , 2 , 3 ] Express\u00e3o 1 ` o ` ( 2 ` o ` ( 3 ` o ` i )) (( i ` o ` 1 ) ` o ` 2 ) ` o ` 3 \u00c1rvore `o` / \\ 1 `o` / \\ 2 `o` / \\ 3 i `o` / \\ `o` 3 / \\ `o` 2 / \\ i 1 Pelas express\u00f5es vemos que os operadores s\u00e3o tratados como associativo \u00e0 direita, no caso de resumir , e \u00e0 direita, no caso de resumir' , e a associatividade tem implica\u00e7\u00f5es profundas no c\u00e1lculo de uma express\u00e3o. Considere a opera\u00e7\u00e3o de multiplica\u00e7\u00e3o; por ser associativa, isto \u00e9, associativa \u00e0 direita e \u00e0 esquerda, \\(1*2*3*4 = ((1*2)*3)*4 = 1*(2*(3*4)) = 24\\) . Agora considere a divis\u00e3o; por ser associativa \u00e0 esquerda \\(1/2/3/4 = ((1/2)/3)/4 = (0,5/3)/4 = 0,167/4 = 0.0146 \\neq 1/(2/(3/4)) = 1/(2/0,75) = 1/2,67 = 0,375\\) Esta diferen\u00e7a precisa ficar bem clara, pois estas duas fun\u00e7\u00f5es s\u00e3o usadas muito frequentemente em Haskell, sendo definidas (de forma mais geral) na biblioteca como foldX . foldl e foldr Fold \u00e9 o termo usado para descrever a opera\u00e7\u00e3o de dobrar a lista sobre si mesma, combinando os elementos at\u00e9 que s\u00f3 sobre um valor. Outro nome usado frequentemente \u00e9 reduce , que inclusive nomeia fun\u00e7\u00f5es semelhantes em outras linguagens. Haskell tem v\u00e1rias vers\u00f5es de fold , mas as duas mais b\u00e1sicas s\u00e3o foldl e foldr , sendo que diferen\u00e7a no nome vem do fato das fun\u00e7\u00f5es assumirem que a fun\u00e7\u00e3o passada como par\u00e2metro \u00e9 associativa a direita (como +, *) ou a esquerda (como +, *, /, -). > foldr ( + ) 0 [ 1 , 3 , 5 ] 9 > foldl ( + ) 0 [ 1 , 3 , 5 ] 9 > foldr div 1 [ 100 , 10 , 2 ] 20 > foldl div 1 [ 100 , 10 , 2 ] 0 Assim, os exemplos acima podem ser vistos como se segue, evidenciando por qu\u00ea o resultado da divis\u00e3o inteira \u00e9 diferente nas duas chamadas. foldr ( + ) 0 [ 1 , 3 , 5 ] = 1 + ( 3 + ( 5 + ( 0 ))) = 1 + ( 3 + ( 5 )) = 1 + ( 8 ) = 9 foldl ( + ) 0 [ 1 , 3 , 5 ] = (( 0 + 1 ) + 3 ) + 5 = (( 1 ) + 3 ) + 5 = ( 4 ) + 5 = 9 foldr div 1 [ 100 , 10 , 2 ] = 100 ` div ` ( 10 ` div ` ( 2 ` div ` ( 1 ))) = 100 ` div ` ( 10 ` div ` ( 2 )) = 100 ` div ` ( 5 ) = 20 foldl div 1 [ 100 , 10 , 2 ] = (( 1 ` div ` 100 ) ` div ` 10 ) ` div ` 2 = (( 0 ) ` div ` 10 ) ` div ` 2 = ( 0 ) ` div ` 2 = 0 Outra distin\u00e7\u00e3o a ser feita entre as duas fun\u00e7\u00f5es \u00e9 o fato de uma usar muito mais recursos que a outra durante a computa\u00e7\u00e3o, mas voltaremos a discutir isso quando falarmos sobre recurs\u00e3o de cauda. foldl1 e foldr1 Para invocar as fun\u00e7\u00f5es foldl e foldr \u00e9 necess\u00e1rio especificar o valor a ser usado \"na ponta\" do c\u00e1lculo, isto \u00e9, como primeiro elemento no caso de foldl e como \u00faltimo elemento no caso de foldr . Se n\u00e3o houver um valor que naturalmente se encaixe, sempre pode-se usar ou o primeiro ou o \u00faltimo elemento da pr\u00f3pria lista, desde que esta n\u00e3o seja vazia. \u00c9 exatamente isso que as fun\u00e7\u00f5es foldl1 e foldr1 fazem. Se usadas nas mesmas listas dos exemplos anteriores, temos os seguintes resultados. foldr1 ( + ) [ 1 , 3 , 5 ] = 1 + ( 3 + ( 5 )) = 1 + ( 8 ) = 9 foldl1 ( + ) [ 1 , 3 , 5 ] = (( 1 ) + 3 ) + 5 = ( 4 ) + 5 = 9 foldr1 div [ 100 , 10 , 2 ] = 100 ` div ` ( 10 ` div ` ( 2 )) = 100 ` div ` ( 5 ) = 20 foldl1 div [ 100 , 10 , 2 ] = ( 100 ` div ` 10 ) ` div ` 2 = ( 10 ) ` div ` 2 = 5 Foldable Todos os exemplos usados at\u00e9 agora foram sobre listas de n\u00fameros, mas a especifica\u00e7\u00e3o das fun\u00e7\u00f5es de redu\u00e7\u00e3o n\u00e3o faz esta exig\u00eancia. Destrinchemos o exemplo de foldr . > : t foldr foldr :: Foldable t => ( a -> b -> b ) -> b -> t a -> b De forma geral, a defini\u00e7\u00e3o diz que a fun\u00e7\u00e3o passada como primeiro par\u00e2metro deve receber um par\u00e2metro do tipo vari\u00e1vel a e outro b e que o resultado deve ser do tipo b . Na pr\u00e1tica, esta defini\u00e7\u00e3o permite que usemos fun\u00e7\u00f5es assim\u00e9tricas como par\u00e2metro, isto \u00e9, que tenha par\u00e2metros de tipos distintos. Assimetria Na execu\u00e7\u00e3o seguinte a fun\u00e7\u00e3o foi definida para testar se o n\u00famero passado como par\u00e2metro \u00e9 maior que 5 e combinar a resposta com outras anteriores, na forma de um booleano. > maiorque5 i b = b && ( i > 5 ) > foldr maiorque5 True [ 1 , 2 , 3 , 4 ] False > foldr maiorque5 True [ 1 , 2 , 3 , 4 , 6 ] False > foldr maiorque5 True [ 6 .. 10 ] True A defini\u00e7\u00e3o de foldr tamb\u00e9m diz que o valor inicial da fun\u00e7\u00e3o deve ser do tipo b , mas que a lista de valores deve encapsular um valor do tipo a ; o encapsulamento \u00e9 feito por elementos da classe Foldable . Listas s\u00e3o Foldable (como um : i [] pode rapidamente demonstrar), mas n\u00e3o s\u00e3o as \u00fanicas estruturas deste tipo. At\u00e9 mesmo tipos alg\u00e9bricos recursivos, dependendo de suas defini\u00e7\u00f5es, podem satisfazer este crit\u00e9rio. Por exemplo, podemos definir uma \u00e1rvore que se \"dobra\" em uma travessia por em ordem dos seus elementos e usar o folds para encontrar o maior valor da lista, como no exemplo a seguir. import Data.Foldable as F data \u00c1rvore a = Nada | N\u00f3 a ( \u00c1rvore a ) ( \u00c1rvore a ) deriving ( Show , Eq , Read ) instance F . Foldable \u00c1rvore where foldMap f Nada = mempty foldMap f ( N\u00f3 a ae ad ) = F . foldMap f ae ` mappend ` f a ` mappend ` F . foldMap f ad foldr f acc Nada = acc foldr f acc ( N\u00f3 a ae ad ) = foldr f ( f a ( foldr f acc ad )) ae {- >>>arv = N\u00f3 1 (N\u00f3 2 (N\u00f3 4 Nada Nada) Nada) (N\u00f3 3 Nada Nada) >>> foldr (+) 0 arv 10 >>>arv2 = N\u00f3 \"a\" (N\u00f3 \"b\" (N\u00f3 \"c\" Nada Nada) Nada) (N\u00f3 \"d\" Nada Nada) >>> foldr (++) \"\" arv2 \"cbad\" -} Considere a seguinte \u00e1rvore: N\u00f3 1 / \\ N\u00f3 2 N\u00f3 3 / \\ / \\ N\u00f3 4 Nada Nada Nada / \\ Nada Nada Ou, Haskell, arv = N\u00f3 1 ( N\u00f3 2 ( N\u00f3 4 Nada Nada ) Nada ) ( N\u00f3 3 Nada Nada ) . Fold tem o seguinte efeito. > foldr ( + ) 0 arv 10 O poder desta abordagem est\u00e1 na genericidade na cria\u00e7\u00e3o da \u00e1rvore, que tamb\u00e9m pode armazenar outros dados e ser dobrada termos de outra opera\u00e7\u00e3o, por exemplo String e ++ : > arv2 = N\u00f3 \"a\" ( N\u00f3 \"b\" ( N\u00f3 \"c\" Nada Nada ) Nada ) ( N\u00f3 \"d\" Nada Nada ) > foldr ( ++ ) \"\" arv2 \"cbad\" Para mais detalhes, visite http://learnyouahaskell.com/functors-applicative-functors-and-monoids#monoids TODO Expandir sobre foldable e traversable. filter e all A fun\u00e7\u00e3o filter recebe como par\u00e2metros um predicado e uma lista e retorna como resultado um lista com todos os elementos da lista original que satisfazem ao predicado. J\u00e1 fun\u00e7\u00e3o all retorna a lista dos elementos que satisfazem ao predicado. Estas fun\u00e7\u00f5es podem ser definidas e usadas como a seguir. filter :: ( a -> Bool ) -> [ a ] -> [ a ] filter p xs = [ x | x <- xs , p x ] all :: ( a -> Bool ) -> [ a ] -> Bool all p [] = True all p ( x : xs ) = p x && all p xs > f x = x > 10 > filter f [ 1 .. 15 ] [ 11 , 12 , 13 , 14 , 15 ] > all f [ 1 .. 15 ] False > all f [ 11 .. 15 ] True Enquanto n\u00e3o impressionantes, estas fun\u00e7\u00f5es podem ser usadas para demonstrar uma outra funcionalidade de Haskell. Observe as seguintes invoca\u00e7\u00f5es. > filter ( > 10 ) [ 1 .. 15 ] [ 11 , 12 , 13 , 14 , 15 ] > filter ( 10 > ) [ 1 .. 15 ] [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] > all ( > 10 ) [ 1 .. 15 ] False > all ( > 10 ) [ 11 .. 15 ] False Os predicados definidos como ( > 10 ) e ( 10 > ) s\u00e3o exemplos de Currying . Currying (aplica\u00e7\u00e3o parcial) Em outras linguagens, fun\u00e7\u00f5es s\u00e3o normalmente definidas com sintaxe semelhante \u00e0 f :: ( a , b ) -> c , isto \u00e9, o nome da fun\u00e7\u00e3o, seguido de um tupla de tipos de par\u00e2metros, e de um tipo de resultado. Isso \u00e9 verdade para C, Java, Pascal, etc. Currying \u00e9 o processo pelo qual uma fun\u00e7\u00e3o deste tipo \u00e9 transformada em uma fun\u00e7\u00e3o do tipo f :: a -> (( b ) -> c ) , ou seja, uma fun\u00e7\u00e3o que recebe somente um par\u00e2metro e retorna uma outra fun\u00e7\u00e3o que recebe os demais par\u00e2metros e retorna, ao o mesmo tipo que a primeira fun\u00e7\u00e3o. O processo pode ser feito para fun\u00e7\u00f5es mais complexas, exatamente da mesma forma, por exemplo transformando f :: ( a , b , c ) -> d em f :: a -> (( b , c ) -> d ) , e tamb\u00e9m aplicado recursivamente levando, levando a fun\u00e7\u00e3o f :: a -> ( b -> ( c -> d )) , que pode ser simplificado de forma n\u00e3o amb\u00edgua para f :: a -> b -> c -> d , que \u00e9 forma usada pelo Haskell. Isso quer dizer que quando voc\u00ea define uma fun\u00e7\u00e3o em Haskell, voce especifica o tipo usando a forma Curryed , mesmo que defina a fun\u00e7\u00e3o da forma tradicional. Acontece que o pr\u00f3prio Haskell, por baixo dos panos, transforma a sua fun\u00e7\u00e3o no correspondente ao tipo, o que permite que voc\u00ea fa\u00e7a coisas muito legais, como no exemplo a seguir. > 1 + 2 3 > ( 1 + ) 2 3 Esta t\u00e9cnica \u00e9 conhecida como aplica\u00e7\u00e3o parcial, e serve para derivar fun\u00e7\u00f5es mais especializadas. > f = ( 1 + ) > f 2 3 Estas fun\u00e7\u00f5es derivadas s\u00e3o como quaisquer outras fun\u00e7\u00f5es, e podem ser usadas por exemplo em maps e filters. > f = ( 1 + ) > map f [ 1 , 2 , 3 ] [ 2 , 3 , 4 ] > f = ( == 10 ) > map f [ 1 , 10 , 2 , 10 , 3 , 10 ] [ False , True , False , True , False , True ] > filter f [ 1 , 10 , 2 , 10 , 3 , 10 ] [ 10 , 10 , 10 ] Lambda (\u03bb) Uma fun\u00e7\u00e3o an\u00f4nima \u00e9 uma fun\u00e7\u00e3o, pasmem, sem um nome, definida, por exemplo, no ato da invoca\u00e7\u00e3o de uma fun\u00e7\u00e3o de ordem superior, e tamb\u00e9m conhecidas como abstra\u00e7\u00e3o \\(\\lambda\\) , um termo advindo do c\u00e1lculo \\(\\lambda\\) . Um lambda \u00e9 definido em Haskell com a seguinte sintaxe: \\ v1 v2 ... vn -> exp , onde o \\ \u00e9 uma alus\u00e3o ao s\u00edmbolo \\(\\lambda\\) , v1 v2 ... vn s\u00e3o os par\u00e2metros formais da fun\u00e7\u00e3o, e exp \u00e9 uma express\u00e3o sobre as vari\u00e1veis. Por exemplo, \\ x -> x + 1 e \\ x y -> x * y s\u00e3o as fun\u00e7\u00f5es que somam 1 ao par\u00e2metro e multiplicam os par\u00e2metros, respectivamente; observe seus usos no exemplo a seguir. > ( \\ x -> x + 1 ) 5 6 > ( \\ x y -> x * y ) 4 5 20 Como qualquer outra fun\u00e7\u00e3o, lambdas podem ser associadas a vari\u00e1veis e sofrerem aplica\u00e7\u00e3o parcial, embora usos como os do exemplo seguinte n\u00e3o pare\u00e7am muito \u00fateis. > mult = ( \\ x y -> x * y ) > mult4 = mult 4 > mult 4 5 20 > mult4 5 20 A verdadeira utilidade das lambdas \u00e9 no invoca\u00e7\u00e3o de fun\u00e7\u00f5es como map e filter , como a seguir. > filter ( \\ x -> x > 10 ) [ 1 .. 20 ] [ 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 ] > map ( \\ x -> x * 2 ) [ 1 .. 10 ] [ 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 18 , 20 ] H\u00e1 muito mais que pode ser dito sobre abstra\u00e7\u00f5es lambda, por exemplo sobre como f x = 2 * x \u00e9 na verdade apenas a\u00e7\u00facar sint\u00e1tico para f = \\ x -> 2 * x e f x y = x * y \u00e9 na verdade f = \\ x -> \\ y -> x * y , mas isso est\u00e1 fora do escopo deste curso. Operador $ (aplica\u00e7\u00e3o) O operador $ tem uma defini\u00e7\u00e3o muito simples, dizendo apenas que ao receber uma fun\u00e7\u00e3o e um outro argumento, aplica a fun\u00e7\u00e3o ao par\u00e2metro. ( $ ) :: ( a -> b ) -> a -> b f $ x = f x Mas se tudo o que ele faz \u00e9 aplicar uma fun\u00e7\u00e3o a um par\u00e2metro, por que \u00e9 que se voc\u00ea olhar qualquer exemplo de c\u00f3digo Haskell com mais do que algumas linhas de c\u00f3digo, voc\u00ea encontrar\u00e1 o operador $ em uso? A resposta est\u00e1 na preced\u00eancia e na associatividade de operador; compare-as com as de outros operadores. > : i ( $ ) ( $ ) :: ( a -> b ) -> a -> b infixr 0 $ > : i ( + ) ... infixl 6 + > : i ( * ) ... infixl 7 * > : i ( ^ ) ... infixr 8 ^ Por ter preced\u00eancia t\u00e3o baixa, o operador ser\u00e1 o \u00faltimo a ser executado, e por ser associativo \u00e0 direita, toda a express\u00e3o \u00e0 direita do operador ser\u00e1 resolvida antes que ele seja executado, mesmo outras inst\u00e2ncias de $ . Vejamos um exemplo de como isso pode ser \u00fatil; considere a express\u00e3o a seguir. Para for\u00e7ar sua avalia\u00e7\u00e3o da direita para a esquerda, foi necess\u00e1rio o uso de diversos par\u00eanteses. filter even ( map floor ( map sqrt ( filter ( > 100 ) ( map ( 2 ^ ) [ 1 .. 10 ])))) TODO Imagem mostrando a resolu\u00e7\u00e3o e evidenciando a preced\u00eancia imposta pelos par\u00eanteses. Esta mesma express\u00e3o pode ser reescrita trocando-se os par\u00eanteses por > filter even $ map floor $ map sqrt $ filter ( > 100 ) $ map ( 2 ^ ) [ 1 .. 10 ] Outro uso interessante est\u00e1 na \"invers\u00e3o\" da fun\u00e7\u00e3o map . Esta fun\u00e7\u00e3o aplica uma outra fun\u00e7\u00e3o, como nos exemplos acima, a todos os elementos de uma lista. Mas como o $ , \u00e9 poss\u00edvel aplicar um argumento a uma lista de fun\u00e7\u00f5es! map f [ 1 , 2 , 3 , 4 ] ==> [ f 1 , f 2 , f 3 , f 4 ] map ( $ x ) [ f1 , f2 , f3 , f4 ] = [ f1 $ x , f2 $ x , f3 $ x , f4 $ x ] Por exemplo: > map ( $ 10 ) [ sqrt , ( + 4 ), ( 20 - ), ( ^ 2 )] [ 3.1622776601683795 , 14.0 , 10.0 , 100.0 ] Operador . (composi\u00e7\u00e3o) Na matem\u00e1tica \u00e9 comum falarmos em composi\u00e7\u00e3o de fun\u00e7\u00f5es, isto, \u00e9 na aplica\u00e7\u00e3o de uma fun\u00e7\u00e3o ao resultado da aplica\u00e7\u00e3o de outra fun\u00e7\u00e3o, isto \u00e9, dadas duas fun\u00e7\u00f5es \\(f\\) e \\(g\\) , \\((fog)(x) = f(g(x))\\) . Por exemplo, sejam \\(f(x) = x*x\\) e \\(g(x) = x+10\\) , \\(fog(3) = (3+10)*(3+10) = 13*13 = 169\\) . Em Haskell, a composi\u00e7\u00e3o de duas fun\u00e7\u00f5es \u00e9 feita pelo operador . , por exemplo: > f x = x * x > g x = x + 10 > fog = f . g > fog 3 169 Defini\u00e7\u00e3o A defini\u00e7\u00e3o deste operador \u00e9 interessante, pois este operador \u00e9 uma fun\u00e7\u00e3o de ordem superior que recebe duas fun\u00e7\u00f5es como par\u00e2metro e retorna uma fun\u00e7\u00e3o como resultado, constru\u00edda como uma abstra\u00e7\u00e3o lambda. ( . ) :: ( b -> c ) -> ( a -> b ) -> a -> c f . g = \\ x -> f ( g x ) Uma defini\u00e7\u00e3o alternativa seria a seguinte, onde o tipo do resultado fica mais expl\u00edcito e em vez da fun\u00e7\u00e3o lambda, usamos uma nota\u00e7\u00e3o simplificada para gerar a fun\u00e7\u00e3o resposta. o :: ( b -> c ) -> ( a -> b ) -> ( a -> c ) o f g x = f ( g x ) -- >>>f x = x*x -- >>>g x = x+10 -- >>>fog = f `o` g -- >>> fog 3 169 Simplifica\u00e7\u00e3o Sobre os usos deste operador, veja o exemplo seguinte, onde v\u00e1rias transforma\u00e7\u00f5es devem ser feitas sobre a mesma lista de valores. > map negate ( map sum ( map tail [[ 1 .. 5 ],[ 3 .. 6 ],[ 1 .. 7 ]])) [ - 14 , - 15 , - 27 ] Uma primeira observa\u00e7\u00e3o importante sobre este c\u00f3digo \u00e9 que a lista \u00e9 percorrida 3 vezes, o que certamente ter\u00e1 um impacto em termos de desempenho. Este problema pode ser resolvido passando-se uma \u00fanica fun\u00e7\u00e3o para o map que fa\u00e7a todas as transforma\u00e7\u00f5es. 2 > map ( \\ xs -> negate ( sum ( tail xs ))) [[ 1 .. 5 ],[ 3 .. 6 ],[ 1 .. 7 ]] [ - 14 , - 15 , - 27 ] Embora o uso da fun\u00e7\u00e3o lambda tenha melhorado o desempenho, uma composi\u00e7\u00e3o das diversas fun\u00e7\u00f5es tem o mesmo efeito, e um c\u00f3digo mais leg\u00edvel. map ( negate . sum . tail ) [[ 1 .. 5 ],[ 3 .. 6 ],[ 1 .. 7 ]] [ - 14 , - 15 , - 27 ] Why is an empty sum 0 and an empty product 1? \u21a9 Learn you a Haskell: Function composition \u21a9","title":"Ordem superior"},{"location":"functions3/highorder/#funcoes-de-ordem-superior","text":"Quando estudamos linguagens de programa\u00e7\u00e3o, \u00e9 comum denominar como cidad\u00e3os de primeira classe (do ingl\u00eas, first class citizens ) as entidades que podem ser atribu\u00eddas a vari\u00e1veis, passadas como par\u00e2metro, retornadas como resultado ou operadas de forma geral. Em Haskell, fun\u00e7\u00f5es s\u00e3o cidad\u00e3s de primeira classe! Vejamos um exemplo em que uma fun\u00e7\u00e3o \u00e9 associada a uma vari\u00e1vel, o que efetivamente torna esta vari\u00e1vel uma fun\u00e7\u00e3o! Prelude > f x y = x + y Prelude > g = f Prelude > g 1 2 3 Outro conceito relacionado \u00e9 o das fun\u00e7\u00f5es de ordem superior , aquelas fun\u00e7\u00f5es que ou recebem como par\u00e2metro ou retornam como resultado outras fun\u00e7\u00f5es, e que s\u00f3 podem existir em linguagens em que fun\u00e7\u00f5es s\u00e3o cidad\u00e3s de primeira classe. Vejamos um exemplo de uma fun\u00e7\u00e3o de ordem superior que aplica uma outra fun\u00e7\u00e3o, recebida como par\u00e2metro, aos seus outros par\u00e2metros. somar :: Int -> Int -> Int somar x y = x + y multiplicar :: Int -> Int -> Int multiplicar x y = x * y dividir :: Int -> Int -> Int dividir x y = x ` div ` y operar :: ( Int -> Int -> Int ) -> Int -> Int -> Int operar f x y = f x y -- >>> operar somar 3 4 -- 7 -- >>> operar multiplicar 3 4 -- 12 -- >>> operar dividir 3 4 -- 0 Observe que a fun\u00e7\u00e3o operar tem como primeiro par\u00e2metro formal #!f , que \u00e9 do tipo ( Int -> Int -> Int ) , isto \u00e9, uma fun\u00e7\u00e3o que recebe dois inteiros e retorna um inteiro. Esta fun\u00e7\u00e3o f \u00e9 aplicada aos demais par\u00e2metros de de operar para calcular o resultado. Fun\u00e7\u00f5es de alta ordem s\u00e3o \u00fateis em diversas situa\u00e7\u00f5es, por exemplo, como forma de criar um comportamento configur\u00e1vel no seu c\u00f3digo, e s\u00e3o frequentes na biblioteca da linguagem Haskell, dentre as quais destacamos map , filter , e diversos tipos de fold .","title":"Fun\u00e7\u00f5es de ordem superior"},{"location":"functions3/highorder/#map","text":"Seja uma lista de inteiros sobre a qual voc\u00ea queira executar diversas transforma\u00e7\u00f5es, por exemplo, multiplicar todos os valores por 10, somar 3, testar se par ou achar o m\u00f3dulo por 3. Voc\u00ea pode come\u00e7ar definindo fun\u00e7\u00f5es que fazem transforma\u00e7\u00f5es em um \u00fanico elemento e, para cada uma, uma fun\u00e7\u00e3o correspondente para listas. multiplicarPor10 :: Int -> Int multiplicarPor10 x = x * 10 multiplicarPor10Lista :: [ Int ] -> [ Int ] multiplicarPor10Lista l = [ multiplicarPor10 e | e <- l ] -- >>>multiplicarPor10Lista [2..5] -- [20,30,40,50] somar3 :: Int -> Int somar3 x = x + 3 somar3Lista :: [ Int ] -> [ Int ] somar3Lista l = [ somar3 e | e <- l ] -- >>>somar3Lista [2..5] -- [5,6,7,8] \u00e9Par :: Int -> Bool \u00e9Par x = even x \u00e9ParLista :: [ Int ] -> [ Bool ] \u00e9ParLista l = [ \u00e9Par e | e <- l ] -- >>>\u00e9ParLista [2..5] -- [True,False,True,False] mod3 :: Int -> Int mod3 x = x ` mod ` 3 mod3Lista :: [ Int ] -> [ Int ] mod3Lista l = [ mod3 e | e <- l ] -- >>>mod3Lista [2..5] -- [2,0,1,2] Se voc\u00ea observar as fun\u00e7\u00f5es para as listas perceber\u00e1 que todas tem uma mesma estrutura. Gra\u00e7as \u00e0s fun\u00e7\u00f5es de ordem superior, voc\u00ea pode aproveitar este fato e criar uma fun\u00e7\u00e3o, gen\u00e9rica, que sirva para aplicar qualquer das transforma\u00e7\u00f5es desejadas. Como as fun\u00e7\u00f5es acima, nossa fun\u00e7\u00e3o gen\u00e9rica recebe uma lista de um tipo a e resultar\u00e1 em uma lista de um tipo b . Por iso, chamemos nossa fun\u00e7\u00e3o de mapeie , pois com ela mapearemos cada valor da lista de entrada para a lista de resultado. Al\u00e9m da lista de entrada, mapeie mas tamb\u00e9m receber\u00e1 uma fun\u00e7\u00e3o com tipo a -> b , a ser aplicada nas transforma\u00e7\u00f5es. mapeie :: ( a -> b ) -> [ a ] -> [ b ] mapeie f xs = [ f x | x <- xs ] Uma vez definida a fun\u00e7\u00e3o, sua invoca\u00e7\u00e3o \u00e9 trivial. > mapeie multiplicarPor10 [ 1 .. 10 ] [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 ] > mapeie somar3 [ 1 .. 10 ] [ 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] > mapeie \u00e9Par [ 1 .. 10 ] [ False , True , False , True , False , True , False , True , False , True ] > mapeie mod3 [ 1 .. 10 ] [ 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 ] A fun\u00e7\u00e3o mapeie , na verdade, serve para aplicar qualquer fun\u00e7\u00e3o que transforme a para b em uma lista de elementos do tipo a , resultando em uma lista de elementos do tipo b . Esta fun\u00e7\u00e3o \u00e9 t\u00e3o \u00fatil, que j\u00e1 existe na biblioteca do Haskell e de qualquer linguagem de programa\u00e7\u00e3o funcional (e mesmo outras, como Python e Java). > : i map map :: ( a -> b ) -> [ a ] -> [ b ] -- Defined in \u2018GHC.Base\u2019","title":"map"},{"location":"functions3/highorder/#fold-reducao","text":"Um outro procedimento recorrente sobre dados \u00e9 a redu\u00e7\u00e3o ou sumariza\u00e7\u00e3o de um conjunto para um \u00fanico valor, como \u00e9 feito pelas fun\u00e7\u00f5es product e sum nos seguintes exemplos. > sum [ 1 .. 10 ] 55 > product [ 1 .. 3 ] 6 Vamos tentar generalizar estas duas fun\u00e7\u00f5es usando uma fun\u00e7\u00e3o de ordem superior. Isto \u00e9, definimos uma fun\u00e7\u00e3o de ordem superior que receba um operador, como ( + ) e ( * ) , e aplique a uma lista de inteiros calculando resumo dos elementos da lista, como o somat\u00f3rio ou o produt\u00f3rio no caso dos operadores ( + ) e ( * ) . Comecemos por redefinir sum e product para entender melhor suas estruturas. sum' :: [ Int ] -> Int sum' [] = 0 sum' ( n : ns ) = n + sum' ns Podemos pensar na fun\u00e7\u00e3o sum' como gerando uma express\u00e3o formada pelos elementos da lista mais o valor 0, separados pelo operador + , por exemplo, sum' [ 1 , 2 , 3 ] = 1 + 2 + 3 + 0 e sum' [ 7 , 9 , 14 ] = 7 + 9 + 14 + 0 . Observe que o valor 0 \u00e9 escolhido como resultado do caso base, 0, pois ele n\u00e3o afeta o somat\u00f3rio, isto \u00e9, 0 \u00e9 o elemento neutro (ou identidade) da adi\u00e7\u00e3o. product' :: [ Int ] -> Int product' [] = 1 product' ( n : ns ) = n * product' ns No caso de product , embora a estrutura seja a mesma, alteramos o caso base para 1, o elemento neutro da multiplica\u00e7\u00e3o. Assim, por mais estranho que possa parecer, o produt\u00f3rio de uma lista vazia \u00e9 definido como 1. 1 A express\u00e3o gerada pela fun\u00e7\u00e3o \u00e9 semelhante, isto \u00e9, product' [ 1 , 2 , 3 ] = 1 * 2 * 3 * 1 e product' [ 7 , 9 , 14 ] = 7 * 9 * 14 * 1 . Podemos ent\u00e3o generalizar a fun\u00e7\u00e3o como uma recurs\u00e3o em que o caso gen\u00e9rico \u00e9 a do operador especificado e o caso base retorna o elemento neutro da opera\u00e7\u00e3o. O tipo da fun\u00e7\u00e3o \u00e9 claro; ela deve receber um operar, que \u00e9 uma fun\u00e7\u00e3o que recebe dois inteiros e retorna um inteiro, a lista de inteiros para aplicar o operador, e retornar um resultado tamb\u00e9m inteiro. A recurs\u00e3o consistir\u00e1 em um caso gen\u00e9rico, que aplica o operador \u00e0 cabe\u00e7a da lista e ao resultado da invoca\u00e7\u00e3o recursivo na cauda, e de um caso base que retorne o elemento neutro da opera\u00e7\u00e3o. Mas como saber qual \u00e9 o elemento neutro? resumir :: ( Int -> Int -> Int ) -> [ Int ] -> Int resumir f [] = ?? resumir f ( n : ns ) = n ` f ` ( resumir f ns ) N\u00e3o nos resta alternativa sen\u00e3o passar o pr\u00f3prio elemento neutro na invoca\u00e7\u00e3o da fun\u00e7\u00e3o, resultando na seguinte defini\u00e7\u00e3o. resumir :: ( Int -> Int -> Int ) -> Int -> [ Int ] -> Int resumir f i [] = i resumir f i ( n : ns ) = n ` f ` ( resumir f i ns ) -- >>> resumir somar 0 [1..5] -- 15 -- >>> resumir multiplicar 1 [1..5] -- 120 Uma varia\u00e7\u00e3o ligeiramente diferente, alterando a chamada recursiva, gera os mesmos resultados. resumir' :: ( Int -> Int -> Int ) -> Int -> [ Int ] -> Int resumir' f i [] = i resumir' f i ( n : ns ) = resumir' f ( i ` f ` n ) ns -- >>> resumir somar 0 [1..5] -- 15 -- >>> resumir' multiplicar 1 [1..5] -- 120 A diferen\u00e7a aqui \u00e9 que em vez da recurs\u00e3o passar o elemento neutro adiante para ser usado no caso base, intocado, o elemento neutro \u00e9 usado de cara e operado com a cabe\u00e7a da lista; o resultado desta opera\u00e7\u00e3o \u00e9 que \u00e9 ent\u00e3o passado para a chamada recursiva at\u00e9 que, no caso base, seja retornado como o resultado da fun\u00e7\u00e3o. Uma outra forma de ver isso \u00e9 comparando as express\u00f5es geradas pelas duas declara\u00e7\u00f5es. Neste caso, consideraremos operador o e um elemento neutro i , mas, desta vez, observemos tamb\u00e9m a ordem em que as opera\u00e7\u00f5es ser\u00e3o efetivamente executadas, denotando a ordem por meio de par\u00eanteses. Fun\u00e7\u00e3o resumir o i [ 1 , 2 , 3 ] resumir' o i [ 1 , 2 , 3 ] Express\u00e3o 1 ` o ` ( 2 ` o ` ( 3 ` o ` i )) (( i ` o ` 1 ) ` o ` 2 ) ` o ` 3 \u00c1rvore `o` / \\ 1 `o` / \\ 2 `o` / \\ 3 i `o` / \\ `o` 3 / \\ `o` 2 / \\ i 1 Pelas express\u00f5es vemos que os operadores s\u00e3o tratados como associativo \u00e0 direita, no caso de resumir , e \u00e0 direita, no caso de resumir' , e a associatividade tem implica\u00e7\u00f5es profundas no c\u00e1lculo de uma express\u00e3o. Considere a opera\u00e7\u00e3o de multiplica\u00e7\u00e3o; por ser associativa, isto \u00e9, associativa \u00e0 direita e \u00e0 esquerda, \\(1*2*3*4 = ((1*2)*3)*4 = 1*(2*(3*4)) = 24\\) . Agora considere a divis\u00e3o; por ser associativa \u00e0 esquerda \\(1/2/3/4 = ((1/2)/3)/4 = (0,5/3)/4 = 0,167/4 = 0.0146 \\neq 1/(2/(3/4)) = 1/(2/0,75) = 1/2,67 = 0,375\\) Esta diferen\u00e7a precisa ficar bem clara, pois estas duas fun\u00e7\u00f5es s\u00e3o usadas muito frequentemente em Haskell, sendo definidas (de forma mais geral) na biblioteca como foldX .","title":"fold (redu\u00e7\u00e3o)"},{"location":"functions3/highorder/#filter-e-all","text":"A fun\u00e7\u00e3o filter recebe como par\u00e2metros um predicado e uma lista e retorna como resultado um lista com todos os elementos da lista original que satisfazem ao predicado. J\u00e1 fun\u00e7\u00e3o all retorna a lista dos elementos que satisfazem ao predicado. Estas fun\u00e7\u00f5es podem ser definidas e usadas como a seguir. filter :: ( a -> Bool ) -> [ a ] -> [ a ] filter p xs = [ x | x <- xs , p x ] all :: ( a -> Bool ) -> [ a ] -> Bool all p [] = True all p ( x : xs ) = p x && all p xs > f x = x > 10 > filter f [ 1 .. 15 ] [ 11 , 12 , 13 , 14 , 15 ] > all f [ 1 .. 15 ] False > all f [ 11 .. 15 ] True Enquanto n\u00e3o impressionantes, estas fun\u00e7\u00f5es podem ser usadas para demonstrar uma outra funcionalidade de Haskell. Observe as seguintes invoca\u00e7\u00f5es. > filter ( > 10 ) [ 1 .. 15 ] [ 11 , 12 , 13 , 14 , 15 ] > filter ( 10 > ) [ 1 .. 15 ] [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] > all ( > 10 ) [ 1 .. 15 ] False > all ( > 10 ) [ 11 .. 15 ] False Os predicados definidos como ( > 10 ) e ( 10 > ) s\u00e3o exemplos de Currying .","title":"filter e all"},{"location":"functions3/highorder/#currying-aplicacao-parcial","text":"Em outras linguagens, fun\u00e7\u00f5es s\u00e3o normalmente definidas com sintaxe semelhante \u00e0 f :: ( a , b ) -> c , isto \u00e9, o nome da fun\u00e7\u00e3o, seguido de um tupla de tipos de par\u00e2metros, e de um tipo de resultado. Isso \u00e9 verdade para C, Java, Pascal, etc. Currying \u00e9 o processo pelo qual uma fun\u00e7\u00e3o deste tipo \u00e9 transformada em uma fun\u00e7\u00e3o do tipo f :: a -> (( b ) -> c ) , ou seja, uma fun\u00e7\u00e3o que recebe somente um par\u00e2metro e retorna uma outra fun\u00e7\u00e3o que recebe os demais par\u00e2metros e retorna, ao o mesmo tipo que a primeira fun\u00e7\u00e3o. O processo pode ser feito para fun\u00e7\u00f5es mais complexas, exatamente da mesma forma, por exemplo transformando f :: ( a , b , c ) -> d em f :: a -> (( b , c ) -> d ) , e tamb\u00e9m aplicado recursivamente levando, levando a fun\u00e7\u00e3o f :: a -> ( b -> ( c -> d )) , que pode ser simplificado de forma n\u00e3o amb\u00edgua para f :: a -> b -> c -> d , que \u00e9 forma usada pelo Haskell. Isso quer dizer que quando voc\u00ea define uma fun\u00e7\u00e3o em Haskell, voce especifica o tipo usando a forma Curryed , mesmo que defina a fun\u00e7\u00e3o da forma tradicional. Acontece que o pr\u00f3prio Haskell, por baixo dos panos, transforma a sua fun\u00e7\u00e3o no correspondente ao tipo, o que permite que voc\u00ea fa\u00e7a coisas muito legais, como no exemplo a seguir. > 1 + 2 3 > ( 1 + ) 2 3 Esta t\u00e9cnica \u00e9 conhecida como aplica\u00e7\u00e3o parcial, e serve para derivar fun\u00e7\u00f5es mais especializadas. > f = ( 1 + ) > f 2 3 Estas fun\u00e7\u00f5es derivadas s\u00e3o como quaisquer outras fun\u00e7\u00f5es, e podem ser usadas por exemplo em maps e filters. > f = ( 1 + ) > map f [ 1 , 2 , 3 ] [ 2 , 3 , 4 ] > f = ( == 10 ) > map f [ 1 , 10 , 2 , 10 , 3 , 10 ] [ False , True , False , True , False , True ] > filter f [ 1 , 10 , 2 , 10 , 3 , 10 ] [ 10 , 10 , 10 ]","title":"Currying (aplica\u00e7\u00e3o parcial)"},{"location":"functions3/highorder/#lambda","text":"Uma fun\u00e7\u00e3o an\u00f4nima \u00e9 uma fun\u00e7\u00e3o, pasmem, sem um nome, definida, por exemplo, no ato da invoca\u00e7\u00e3o de uma fun\u00e7\u00e3o de ordem superior, e tamb\u00e9m conhecidas como abstra\u00e7\u00e3o \\(\\lambda\\) , um termo advindo do c\u00e1lculo \\(\\lambda\\) . Um lambda \u00e9 definido em Haskell com a seguinte sintaxe: \\ v1 v2 ... vn -> exp , onde o \\ \u00e9 uma alus\u00e3o ao s\u00edmbolo \\(\\lambda\\) , v1 v2 ... vn s\u00e3o os par\u00e2metros formais da fun\u00e7\u00e3o, e exp \u00e9 uma express\u00e3o sobre as vari\u00e1veis. Por exemplo, \\ x -> x + 1 e \\ x y -> x * y s\u00e3o as fun\u00e7\u00f5es que somam 1 ao par\u00e2metro e multiplicam os par\u00e2metros, respectivamente; observe seus usos no exemplo a seguir. > ( \\ x -> x + 1 ) 5 6 > ( \\ x y -> x * y ) 4 5 20 Como qualquer outra fun\u00e7\u00e3o, lambdas podem ser associadas a vari\u00e1veis e sofrerem aplica\u00e7\u00e3o parcial, embora usos como os do exemplo seguinte n\u00e3o pare\u00e7am muito \u00fateis. > mult = ( \\ x y -> x * y ) > mult4 = mult 4 > mult 4 5 20 > mult4 5 20 A verdadeira utilidade das lambdas \u00e9 no invoca\u00e7\u00e3o de fun\u00e7\u00f5es como map e filter , como a seguir. > filter ( \\ x -> x > 10 ) [ 1 .. 20 ] [ 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 ] > map ( \\ x -> x * 2 ) [ 1 .. 10 ] [ 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 18 , 20 ] H\u00e1 muito mais que pode ser dito sobre abstra\u00e7\u00f5es lambda, por exemplo sobre como f x = 2 * x \u00e9 na verdade apenas a\u00e7\u00facar sint\u00e1tico para f = \\ x -> 2 * x e f x y = x * y \u00e9 na verdade f = \\ x -> \\ y -> x * y , mas isso est\u00e1 fora do escopo deste curso.","title":"Lambda (\u03bb)"},{"location":"functions3/highorder/#operador-aplicacao","text":"O operador $ tem uma defini\u00e7\u00e3o muito simples, dizendo apenas que ao receber uma fun\u00e7\u00e3o e um outro argumento, aplica a fun\u00e7\u00e3o ao par\u00e2metro. ( $ ) :: ( a -> b ) -> a -> b f $ x = f x Mas se tudo o que ele faz \u00e9 aplicar uma fun\u00e7\u00e3o a um par\u00e2metro, por que \u00e9 que se voc\u00ea olhar qualquer exemplo de c\u00f3digo Haskell com mais do que algumas linhas de c\u00f3digo, voc\u00ea encontrar\u00e1 o operador $ em uso? A resposta est\u00e1 na preced\u00eancia e na associatividade de operador; compare-as com as de outros operadores. > : i ( $ ) ( $ ) :: ( a -> b ) -> a -> b infixr 0 $ > : i ( + ) ... infixl 6 + > : i ( * ) ... infixl 7 * > : i ( ^ ) ... infixr 8 ^ Por ter preced\u00eancia t\u00e3o baixa, o operador ser\u00e1 o \u00faltimo a ser executado, e por ser associativo \u00e0 direita, toda a express\u00e3o \u00e0 direita do operador ser\u00e1 resolvida antes que ele seja executado, mesmo outras inst\u00e2ncias de $ . Vejamos um exemplo de como isso pode ser \u00fatil; considere a express\u00e3o a seguir. Para for\u00e7ar sua avalia\u00e7\u00e3o da direita para a esquerda, foi necess\u00e1rio o uso de diversos par\u00eanteses. filter even ( map floor ( map sqrt ( filter ( > 100 ) ( map ( 2 ^ ) [ 1 .. 10 ])))) TODO Imagem mostrando a resolu\u00e7\u00e3o e evidenciando a preced\u00eancia imposta pelos par\u00eanteses. Esta mesma express\u00e3o pode ser reescrita trocando-se os par\u00eanteses por > filter even $ map floor $ map sqrt $ filter ( > 100 ) $ map ( 2 ^ ) [ 1 .. 10 ] Outro uso interessante est\u00e1 na \"invers\u00e3o\" da fun\u00e7\u00e3o map . Esta fun\u00e7\u00e3o aplica uma outra fun\u00e7\u00e3o, como nos exemplos acima, a todos os elementos de uma lista. Mas como o $ , \u00e9 poss\u00edvel aplicar um argumento a uma lista de fun\u00e7\u00f5es! map f [ 1 , 2 , 3 , 4 ] ==> [ f 1 , f 2 , f 3 , f 4 ] map ( $ x ) [ f1 , f2 , f3 , f4 ] = [ f1 $ x , f2 $ x , f3 $ x , f4 $ x ] Por exemplo: > map ( $ 10 ) [ sqrt , ( + 4 ), ( 20 - ), ( ^ 2 )] [ 3.1622776601683795 , 14.0 , 10.0 , 100.0 ]","title":"Operador $ (aplica\u00e7\u00e3o)"},{"location":"functions3/highorder/#operador-composicao","text":"Na matem\u00e1tica \u00e9 comum falarmos em composi\u00e7\u00e3o de fun\u00e7\u00f5es, isto, \u00e9 na aplica\u00e7\u00e3o de uma fun\u00e7\u00e3o ao resultado da aplica\u00e7\u00e3o de outra fun\u00e7\u00e3o, isto \u00e9, dadas duas fun\u00e7\u00f5es \\(f\\) e \\(g\\) , \\((fog)(x) = f(g(x))\\) . Por exemplo, sejam \\(f(x) = x*x\\) e \\(g(x) = x+10\\) , \\(fog(3) = (3+10)*(3+10) = 13*13 = 169\\) . Em Haskell, a composi\u00e7\u00e3o de duas fun\u00e7\u00f5es \u00e9 feita pelo operador . , por exemplo: > f x = x * x > g x = x + 10 > fog = f . g > fog 3 169","title":"Operador . (composi\u00e7\u00e3o)"},{"location":"functions3/lazy/","text":"Avalia\u00e7\u00e3o Pregui\u00e7osa Considere o seguinte c\u00f3digo novamente. imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" where imc' = p / a ^ 2 O uso de where na defini\u00e7\u00e3o, al\u00e9m de melhorar a legibilidade do c\u00f3digo, d\u00e1 ao compilador Haskell a oportunidade de usar uma de suas mais importantes funcionalidades, a avalia\u00e7\u00e3o pregui\u00e7osa . Quando a fun\u00e7\u00e3o imc \u00e9 invocada, imc' n\u00e3o \u00e9 calculada at\u00e9 que a primeira guarda seja testada. Isso acontece porqu\u00ea pela avalia\u00e7\u00e3o pregui\u00e7osa do Haskell, a avalia\u00e7\u00e3o acontece apenas quando necess\u00e1ria . Para demonstrar esta funcionalidade, vamos usar a fun\u00e7\u00e3o trace , que imprime uma mensagem na tela a cada computa\u00e7\u00e3o de imc' import Debug.Trace ( trace ) imc :: Double -> Double -> String imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" | otherwise = \"Muito, muito alto\" where imc' = trace \"hmmm... \" ( p / a ^ 2 ) Agora atribu\u00edmos uma invoca\u00e7\u00e3o da fun\u00e7\u00e3o a y e verificamos que somente quando tentamos ver o valor de de y \u00e9 que o c\u00e1lculo \u00e9 realmente feito. * Main > y = imc 90 1.8 * Main > y \"hmmm... Alto\" Al\u00e9m disso, a avalia\u00e7\u00e3o acontece no m\u00e1ximo uma vez , o que quer dizer que se a primeira guarda falha e a segunda deve ser testada, imc' n\u00e3o \u00e9 recomputada, pois o Haskell se lembra do valor j\u00e1 calculado para os mesmos par\u00e2metros. import Debug.Trace ( trace ) imc :: Double -> Double -> String imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" | otherwise = \"Muito, muito alto\" where imc' = trace \"hmmm... \" ( p / a ^ 2 ) Na pr\u00f3xima execu\u00e7\u00e3o, mesmo o resultado tendo sido gerado pela terceira guarda, veja que imc' s\u00f3 foi executado uma vez. * Main > imc 90 1.8 \"hmmm... Alto\" Outro princ\u00edpio da avalia\u00e7\u00e3o pregui\u00e7osa \u00e9 que se deve avaliar somente o necess\u00e1rio . Observe a pr\u00f3xima defini\u00e7\u00e3o, onde m\u00faltiplos where s\u00e3o usados (onde todas as defini\u00e7\u00f5es est\u00e3o perfeitamente indentadas.) imc p a | imc' <= baixo = \"Baixo\" | imc' <= normal = \"Normal\" | imc' <= alto = \"Alto\" where imc' = trace \"hmmm... \" ( p / a ^ 2 ) baixo = trace \"b\" ( 18.5 ) normal = trace \"n\" ( 25.0 ) alto = trace \"a\" ( 30.0 ) Dependendo da chamada, os valores de normal e alto nunca ser\u00e3o avaliados. * Main > imc 90 1.8 \"hmmm... b n a Alto\" * Main > imc 70 1.8 \"hmmm... b n Normal\" Pr\u00f3s A avalia\u00e7\u00e3o pregui\u00e7osa \u00e9 imprescind\u00edvel para algumas funcionalidades do Haskell, como a capacidade de expressar uma lista infinita no pr\u00f3ximo trecho de c\u00f3digo. Se a lista tivesse que ser constru\u00edda antes de se poder acessar seu in\u00edcio, as chamadas nunca terminariam. * Main > x = [ 1 , 3 .. ] * Main > take 2 x [ 1 , 3 ] * Main > take 4 x [ 1 , 3 , 5 , 7 ] * Main > take 20 x [ 1 , 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 , 19 , 21 , 23 , 25 , 27 , 29 , 31 , 33 , 35 , 37 , 39 ] Mesmo quando as chamadas terminal, pode ser que o tempo de execu\u00e7\u00e3o seja alto demais. Por exemplo, considere a lista dos elementos da s\u00e9rie de Fibonacci geradas por uma defini\u00e7\u00e3o recursiva. fibWhere 0 = 0 fibWhere 1 = 1 fibWhere n = prev + prevPrev where prev = fibWhere ( n - 1 ) prevPrev = fibWhere ( n - 2 ) Se voc\u00ea invocar esta fun\u00e7\u00e3o para calcular fib 5 , ter\u00e1 uma resposta rapidamente. Se tentar com 20 ou 30, ter\u00e1 que esperar um pouco. Mas se tentar com fib 300 , ter\u00e1 que esperar por muito tempo at\u00e9 que veja algum progresso. Ainda assim, a seguinte chamada termina quase que imediatamente! * Main > length [ fib n | n <- [ 1 .. 300 ]] 300 * Main > x = [ fib n | n <- [ 1 .. 300 ]] * Main > take 1 x [ 1 ] * Main > take 3 x [ 1 , 1 , 2 ] Isso acontece pois para se saber o comprimento da lista n\u00e3o \u00e9 necess\u00e1rio conhecer o valor dos elementos, apenas como s\u00e3o definidos. O Haskell ent\u00e3o gera uma lista de \"invoca\u00e7\u00f5es\" da fun\u00e7\u00e3o fib , mas n\u00e3o chega a executar as invoca\u00e7\u00f5es enquanto precisar. Contras Como uma moeda sempre tem duas faces, vejamos o lado ruim da avalia\u00e7\u00e3o pregui\u00e7osa. Em vez de uma fun\u00e7\u00e3o custosa como a Fibonacci recursiva, se construirmos uma lista de somat\u00f3rios de \\(2i + 2*+1, 0\\leq 1 \\leq 100\\) , ou seja, 0+1, 2+3, 4+5,... * Main > x = [ 2 * i + 2 * i + 1 | i <- [ 0 .. 100 ]] * Main > take 3 x [ 1 , 5 , 9 ] * Main > take 5 x [ 1 , 5 , 9 , 13 , 17 ] * Main > last x 401 * Main > length x 101 Sem a avalia\u00e7\u00e3o pregui\u00e7osa, ter\u00edamos uma lista de 100 inteiros, sendo o maior 401, que cabe facilmente em um array de bytes. Contudo, com a avalia\u00e7\u00e3o pregui\u00e7osa, temos uma lista de express\u00f5es que indicam duas multiplica\u00e7\u00f5es e duas somas, certamente mais espa\u00e7osas que a alternativa anterior. A principal consequ\u00eancia disto \u00e9 que, embora leve \u00e0 economia de computa\u00e7\u00e3o, \u00e0s vezes a avalia\u00e7\u00e3o pregui\u00e7osa leva ao uso exagerado de espa\u00e7o. Al\u00e9m disso, computa\u00e7\u00f5es pesadas invocadas em um per\u00edodo de pouca atividade no sistema podem ser executadas mais tarde, quando o sistema est\u00e1 sobrecarregado, aumentando a variabilidade do tempo de execu\u00e7\u00e3o e dificultando a previs\u00e3o de t\u00e9rmino da computa\u00e7\u00e3o. Como funciona A computa\u00e7\u00e3o de uma fun\u00e7\u00e3o em Haskell pode ser entendida em termos da reescrita de express\u00f5es, da ordem de reescrita e do compartilhamento de resultados pr\u00e9vios. \u00c9 tamb\u00e9m baseado nestes mecanismos que a avalia\u00e7\u00e3o pregui\u00e7osa se torna poss\u00edvel. Reescrita H\u00e1 diferentes tipos de reescrita em Haskell. O tipo mais simples \u00e9 a redu\u00e7\u00e3o em que uma express\u00e3o \u00e9 substitu\u00edda por outra, equivalente, mas mais simples. Por exemplo, a express\u00e3o 2 + 2 pode ser reescrita como #hs 4 . Outra forma de reescrita \u00e9 o desdobramento ( unfolding ), em que o lado esquerdo de uma equa\u00e7\u00e3o \u00e9 substitu\u00eddo pelo lado direito. Por exemplo, quando invocamos 1 + head [ 1 , 2 , 3 ] , Haskell tenta achar uma defini\u00e7\u00e3o da fun\u00e7\u00e3o head que case com a invoca\u00e7\u00e3o. Suponha que exista uma defini\u00e7\u00e3o head ( x : _ ) = x ; neste caso, head ( x : _ ) = x \u00e9 reescrito como 1 e head [ 1 , 2 , 3 ] \u00e9 reescrito como 1, levando a express\u00e3o inicial a ser reduzida a 1 + 1 , onde uma redu\u00e7\u00e3o \u00e9 aplicada, levando a 2 . Ordem de reescrita Uma vez entendido que express\u00f5es podem ser reescritas, surge a d\u00favida do que substituir primeiro, quando houver m\u00faltiplas op\u00e7\u00f5es. Por exemplo, se temos a seguinte invoca\u00e7\u00e3o head (( 1 + 1 ) : ( 2 + 2 ) :[] ) ent\u00e3o podemos reduzir 1 + 1 para 1, ou 2 + 2 para 4, ou head (( 1 + 1 ) : ( 2 + 2 ) :[] ) para ( 1 + 1 ) . Haskell escolhe sempre a redu\u00e7\u00e3o mais \"externa\" ( outermost reduction ou avalia\u00e7\u00e3o call-by-name ), no caso, a terceira op\u00e7\u00e3o acima. Isso faz com que 2 + 2 nunca seja reduzido, economizando recursos. Esta abordagem n\u00e3o \u00e9 muito comum, nem mesmo entre outras linguagens funcionais, que usam uma avalia\u00e7\u00e3o gulosa ( call-by-value ou eager ). Compartilhamento Outro aspecto importante no processo de redu\u00e7\u00e3o \u00e9 o fato de que Haskell identifica express\u00f5es repetidas e compartilha o resultado da avalia\u00e7\u00e3o de uma inst\u00e2ncia com as outras. Por exemplo, a seguinte express\u00e3o aparece no seu c\u00f3digo, ( head x ) : ( head y ) : ( head x ) : [] , ent\u00e3o Haskell sabe que as duas apari\u00e7\u00f5es de head x levar\u00e3o ao mesmo valor, gra\u00e7as \u00e0 aus\u00eancia de efeitos colaterais. As express\u00f5es s\u00e3o substitu\u00eddas por uma refer\u00eancia para a express\u00e3o, que uma vez resolvida, \u00e9 substitu\u00edda na express\u00e3o original. A avalia\u00e7\u00e3o pregui\u00e7osa pode ser entendida como a combina\u00e7\u00e3o da reescrita do tipo call-by-name com o compartilhamento, sendo tamb\u00e9m conhecida como call-by-need .","title":"Que pregui\u00e7a"},{"location":"functions3/lazy/#avaliacao-preguicosa","text":"Considere o seguinte c\u00f3digo novamente. imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" where imc' = p / a ^ 2 O uso de where na defini\u00e7\u00e3o, al\u00e9m de melhorar a legibilidade do c\u00f3digo, d\u00e1 ao compilador Haskell a oportunidade de usar uma de suas mais importantes funcionalidades, a avalia\u00e7\u00e3o pregui\u00e7osa . Quando a fun\u00e7\u00e3o imc \u00e9 invocada, imc' n\u00e3o \u00e9 calculada at\u00e9 que a primeira guarda seja testada. Isso acontece porqu\u00ea pela avalia\u00e7\u00e3o pregui\u00e7osa do Haskell, a avalia\u00e7\u00e3o acontece apenas quando necess\u00e1ria . Para demonstrar esta funcionalidade, vamos usar a fun\u00e7\u00e3o trace , que imprime uma mensagem na tela a cada computa\u00e7\u00e3o de imc' import Debug.Trace ( trace ) imc :: Double -> Double -> String imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" | otherwise = \"Muito, muito alto\" where imc' = trace \"hmmm... \" ( p / a ^ 2 ) Agora atribu\u00edmos uma invoca\u00e7\u00e3o da fun\u00e7\u00e3o a y e verificamos que somente quando tentamos ver o valor de de y \u00e9 que o c\u00e1lculo \u00e9 realmente feito. * Main > y = imc 90 1.8 * Main > y \"hmmm... Alto\" Al\u00e9m disso, a avalia\u00e7\u00e3o acontece no m\u00e1ximo uma vez , o que quer dizer que se a primeira guarda falha e a segunda deve ser testada, imc' n\u00e3o \u00e9 recomputada, pois o Haskell se lembra do valor j\u00e1 calculado para os mesmos par\u00e2metros. import Debug.Trace ( trace ) imc :: Double -> Double -> String imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" | otherwise = \"Muito, muito alto\" where imc' = trace \"hmmm... \" ( p / a ^ 2 ) Na pr\u00f3xima execu\u00e7\u00e3o, mesmo o resultado tendo sido gerado pela terceira guarda, veja que imc' s\u00f3 foi executado uma vez. * Main > imc 90 1.8 \"hmmm... Alto\" Outro princ\u00edpio da avalia\u00e7\u00e3o pregui\u00e7osa \u00e9 que se deve avaliar somente o necess\u00e1rio . Observe a pr\u00f3xima defini\u00e7\u00e3o, onde m\u00faltiplos where s\u00e3o usados (onde todas as defini\u00e7\u00f5es est\u00e3o perfeitamente indentadas.) imc p a | imc' <= baixo = \"Baixo\" | imc' <= normal = \"Normal\" | imc' <= alto = \"Alto\" where imc' = trace \"hmmm... \" ( p / a ^ 2 ) baixo = trace \"b\" ( 18.5 ) normal = trace \"n\" ( 25.0 ) alto = trace \"a\" ( 30.0 ) Dependendo da chamada, os valores de normal e alto nunca ser\u00e3o avaliados. * Main > imc 90 1.8 \"hmmm... b n a Alto\" * Main > imc 70 1.8 \"hmmm... b n Normal\"","title":"Avalia\u00e7\u00e3o Pregui\u00e7osa"},{"location":"functions3/lazy/#como-funciona","text":"A computa\u00e7\u00e3o de uma fun\u00e7\u00e3o em Haskell pode ser entendida em termos da reescrita de express\u00f5es, da ordem de reescrita e do compartilhamento de resultados pr\u00e9vios. \u00c9 tamb\u00e9m baseado nestes mecanismos que a avalia\u00e7\u00e3o pregui\u00e7osa se torna poss\u00edvel.","title":"Como funciona"},{"location":"functions3/lazy/#reescrita","text":"H\u00e1 diferentes tipos de reescrita em Haskell. O tipo mais simples \u00e9 a redu\u00e7\u00e3o em que uma express\u00e3o \u00e9 substitu\u00edda por outra, equivalente, mas mais simples. Por exemplo, a express\u00e3o 2 + 2 pode ser reescrita como #hs 4 . Outra forma de reescrita \u00e9 o desdobramento ( unfolding ), em que o lado esquerdo de uma equa\u00e7\u00e3o \u00e9 substitu\u00eddo pelo lado direito. Por exemplo, quando invocamos 1 + head [ 1 , 2 , 3 ] , Haskell tenta achar uma defini\u00e7\u00e3o da fun\u00e7\u00e3o head que case com a invoca\u00e7\u00e3o. Suponha que exista uma defini\u00e7\u00e3o head ( x : _ ) = x ; neste caso, head ( x : _ ) = x \u00e9 reescrito como 1 e head [ 1 , 2 , 3 ] \u00e9 reescrito como 1, levando a express\u00e3o inicial a ser reduzida a 1 + 1 , onde uma redu\u00e7\u00e3o \u00e9 aplicada, levando a 2 .","title":"Reescrita"},{"location":"functions3/lazy/#ordem-de-reescrita","text":"Uma vez entendido que express\u00f5es podem ser reescritas, surge a d\u00favida do que substituir primeiro, quando houver m\u00faltiplas op\u00e7\u00f5es. Por exemplo, se temos a seguinte invoca\u00e7\u00e3o head (( 1 + 1 ) : ( 2 + 2 ) :[] ) ent\u00e3o podemos reduzir 1 + 1 para 1, ou 2 + 2 para 4, ou head (( 1 + 1 ) : ( 2 + 2 ) :[] ) para ( 1 + 1 ) . Haskell escolhe sempre a redu\u00e7\u00e3o mais \"externa\" ( outermost reduction ou avalia\u00e7\u00e3o call-by-name ), no caso, a terceira op\u00e7\u00e3o acima. Isso faz com que 2 + 2 nunca seja reduzido, economizando recursos. Esta abordagem n\u00e3o \u00e9 muito comum, nem mesmo entre outras linguagens funcionais, que usam uma avalia\u00e7\u00e3o gulosa ( call-by-value ou eager ).","title":"Ordem de reescrita"},{"location":"functions3/lazy/#compartilhamento","text":"Outro aspecto importante no processo de redu\u00e7\u00e3o \u00e9 o fato de que Haskell identifica express\u00f5es repetidas e compartilha o resultado da avalia\u00e7\u00e3o de uma inst\u00e2ncia com as outras. Por exemplo, a seguinte express\u00e3o aparece no seu c\u00f3digo, ( head x ) : ( head y ) : ( head x ) : [] , ent\u00e3o Haskell sabe que as duas apari\u00e7\u00f5es de head x levar\u00e3o ao mesmo valor, gra\u00e7as \u00e0 aus\u00eancia de efeitos colaterais. As express\u00f5es s\u00e3o substitu\u00eddas por uma refer\u00eancia para a express\u00e3o, que uma vez resolvida, \u00e9 substitu\u00edda na express\u00e3o original. A avalia\u00e7\u00e3o pregui\u00e7osa pode ser entendida como a combina\u00e7\u00e3o da reescrita do tipo call-by-name com o compartilhamento, sendo tamb\u00e9m conhecida como call-by-need .","title":"Compartilhamento"},{"location":"functions3/tail_recursion/","text":"Recurs\u00e3o de cauda Considere a seguinte fun\u00e7\u00e3o, que calcula o somat\u00f3rio dos elementos em uma lista. soma [] = 0 soma ( x : xs ) = x + soma xs N\u00e3o h\u00e1 nada de errado com esta defini\u00e7\u00e3o, n\u00e3o \u00e9 mesmo? Veja como funciona perfeitamente. > soma [ 1 .. 10 ] 55 > soma [ 1 .. 10000 ] 50005000 > Mas testemos com uma lista \"um pouco\" maior e teremos uma desagrad\u00e1vel surpresa. > soma [ 1 .. 100000000 ] *** Exception: stack overflow Para entender o que aconteceu aqui, precisamos entender como a invoca\u00e7\u00e3o \u00e9 tratada pelo computador. Por exemplo, no caso para resolver soma [ 1 , 2 , 3 , 4 , 5 ] , o seguinte acontece: para calcular soma [ 1 , 2 , 3 , 4 , 5 ] , primeiro \u00e9 necess\u00e1rio calcular soma [ 2 , 3 , 4 , 5 ] , ent\u00e3o a invoca\u00e7\u00e3o recursiva \u00e9 feita e somente ap\u00f3s levar a uma resposta, a pergunta original \u00e9 respondida; mas, para calcular soma [ 2 , 3 , 4 , 5 ] primeiro \u00e9 necess\u00e1rio calcular soma [ 3 , 4 , 5 ] , e a invoca\u00e7\u00e3o recursiva \u00e9 feita, e assim por diante; as informa\u00e7\u00f5es que permitem ao programa continuar a execu\u00e7\u00e3o de uma invoca\u00e7\u00e3o depois da chamada recursiva retornar, isto \u00e9, o valor da cabe\u00e7a da lista na invoca\u00e7\u00e3o atual, s\u00e3o \"empilhadas\" na mem\u00f3ria; Acontece que se a pilha ( stack ) cresce muito, como \u00e9 o caso quando fazemos uma invoca\u00e7\u00e3o soma [ 100000000 ] , ela extrapola a capacidade do processo de crescer a pilha e \"transborda\" ( overflow ) o espa\u00e7o reservado para a pilha, que \u00e9 o erro visto no exemplo anterior. Acontece que Haskell \u00e9 inteligente o suficiente para perceber se a fun\u00e7\u00e3o n\u00e3o tiver pend\u00eancias e, neste caso, n\u00e3o colocar na pilha. Para n\u00e3o deixar pend\u00eancias, a chamada recursiva deve receber toda a informa\u00e7\u00e3o que seja necess\u00e1ria para o c\u00e1lculo do resultado final da fun\u00e7\u00e3o. Esta t\u00e9cnica \u00e9 conhecida como recurs\u00e3o de cauda , pois a chamada recursiva \u00e9 a \u00faltima coisa feita na fun\u00e7\u00e3o e, por isso, n\u00e3o deixa pend\u00eancias. Em outras palavra o resultado da chamada recursiva \u00e9 o resultado da chamada . No exemplo da soma, podemos reescrever a fun\u00e7\u00e3o assim: soma acc [] = acc soma acc ( x : xs ) = soma ( acc + x ) xs Como n\u00e3o h\u00e1 pilha, \u00e9 poss\u00edvel calcular somat\u00f3rios bem maiores, pois nada fica para tr\u00e1s, correto? A verdade \u00e9 que o Haskell \u00e9 muito pregui\u00e7oso, e n\u00e3o avalia o + enquanto n\u00e3o for necess\u00e1rio, ent\u00e3o a computa\u00e7\u00e3o fica na verdade assim. Haskell nos d\u00e1, contudo, a op\u00e7\u00e3o de for\u00e7ar o c\u00e1lculo do acumulador antes de pass\u00e1-lo como par\u00e2metro para a chamada recursiva usando a fun\u00e7\u00e3o seq . soma acc [] = acc soma acc ( x : xs ) = seq acc soma ( acc + x ) xs O que a segunda linha do c\u00f3digo faz \u00e9 dizer ao Haskell que \"primeiro avalie acc e na sequ\u00eancia avalie soma ( acc + x ) xs . Outra forma, mais idiom\u00e1tica de escrever o mesmo c\u00f3digo \u00e9 usando seq de forma infixa. soma acc [] = acc soma acc ( x : xs ) = acc ` seq ` soma ( acc + x ) xs Felizmente voc\u00ea quase nunca precisar\u00e1 usar seq manualmente quando estiver escrevendo c\u00f3digo que v\u00e1 entrar em produ\u00e7\u00e3o, isto \u00e9, que ser\u00e1 compilado, pois poder\u00e1 usar a flag -O para dizer ao compilador que tente encontrar onde o uso de seq seria apropriado, e o compilador faz um excelente trabalho neste sentido. A t\u00e9cnica de passar um acumulador ou acumuladores na invoca\u00e7\u00e3o recursiva \u00e9 muito comum e deve estar sempre em sua mente. E se voc\u00ea n\u00e3o quiser \"poluir\" a API com um par\u00e2metro que s\u00f3 faz sentido por causa da recurs\u00e3o, voc\u00ea pode usar fun\u00e7\u00f5es auxiliares, como a seguir. soma l = soma' 0 l where soma' acc [] = acc soma' acc ( x : xs ) = soma' ( acc + x ) xs Vejamos um outro exemplo do uso de recurs\u00e3o de cauda, desta vez para calcular os n\u00fameros da sequ\u00eancia de Fibonacci \"de baixo para cima\". fibUp :: Integer -> Integer fibUp 0 = 0 fibUp 1 = 1 fibUp n = fibUpTo 0 1 1 n where fibUpTo prevPrev prev prevCount limit = if prevCount == limit then prev + prevPrev else fibUpTo prev ( prev + prevPrev ) ( prevCount + 1 ) limit","title":"Recurs\u00e3o de cauda"},{"location":"functions3/tail_recursion/#recursao-de-cauda","text":"Considere a seguinte fun\u00e7\u00e3o, que calcula o somat\u00f3rio dos elementos em uma lista. soma [] = 0 soma ( x : xs ) = x + soma xs N\u00e3o h\u00e1 nada de errado com esta defini\u00e7\u00e3o, n\u00e3o \u00e9 mesmo? Veja como funciona perfeitamente. > soma [ 1 .. 10 ] 55 > soma [ 1 .. 10000 ] 50005000 > Mas testemos com uma lista \"um pouco\" maior e teremos uma desagrad\u00e1vel surpresa. > soma [ 1 .. 100000000 ] *** Exception: stack overflow Para entender o que aconteceu aqui, precisamos entender como a invoca\u00e7\u00e3o \u00e9 tratada pelo computador. Por exemplo, no caso para resolver soma [ 1 , 2 , 3 , 4 , 5 ] , o seguinte acontece: para calcular soma [ 1 , 2 , 3 , 4 , 5 ] , primeiro \u00e9 necess\u00e1rio calcular soma [ 2 , 3 , 4 , 5 ] , ent\u00e3o a invoca\u00e7\u00e3o recursiva \u00e9 feita e somente ap\u00f3s levar a uma resposta, a pergunta original \u00e9 respondida; mas, para calcular soma [ 2 , 3 , 4 , 5 ] primeiro \u00e9 necess\u00e1rio calcular soma [ 3 , 4 , 5 ] , e a invoca\u00e7\u00e3o recursiva \u00e9 feita, e assim por diante; as informa\u00e7\u00f5es que permitem ao programa continuar a execu\u00e7\u00e3o de uma invoca\u00e7\u00e3o depois da chamada recursiva retornar, isto \u00e9, o valor da cabe\u00e7a da lista na invoca\u00e7\u00e3o atual, s\u00e3o \"empilhadas\" na mem\u00f3ria; Acontece que se a pilha ( stack ) cresce muito, como \u00e9 o caso quando fazemos uma invoca\u00e7\u00e3o soma [ 100000000 ] , ela extrapola a capacidade do processo de crescer a pilha e \"transborda\" ( overflow ) o espa\u00e7o reservado para a pilha, que \u00e9 o erro visto no exemplo anterior. Acontece que Haskell \u00e9 inteligente o suficiente para perceber se a fun\u00e7\u00e3o n\u00e3o tiver pend\u00eancias e, neste caso, n\u00e3o colocar na pilha. Para n\u00e3o deixar pend\u00eancias, a chamada recursiva deve receber toda a informa\u00e7\u00e3o que seja necess\u00e1ria para o c\u00e1lculo do resultado final da fun\u00e7\u00e3o. Esta t\u00e9cnica \u00e9 conhecida como recurs\u00e3o de cauda , pois a chamada recursiva \u00e9 a \u00faltima coisa feita na fun\u00e7\u00e3o e, por isso, n\u00e3o deixa pend\u00eancias. Em outras palavra o resultado da chamada recursiva \u00e9 o resultado da chamada . No exemplo da soma, podemos reescrever a fun\u00e7\u00e3o assim: soma acc [] = acc soma acc ( x : xs ) = soma ( acc + x ) xs Como n\u00e3o h\u00e1 pilha, \u00e9 poss\u00edvel calcular somat\u00f3rios bem maiores, pois nada fica para tr\u00e1s, correto? A verdade \u00e9 que o Haskell \u00e9 muito pregui\u00e7oso, e n\u00e3o avalia o + enquanto n\u00e3o for necess\u00e1rio, ent\u00e3o a computa\u00e7\u00e3o fica na verdade assim. Haskell nos d\u00e1, contudo, a op\u00e7\u00e3o de for\u00e7ar o c\u00e1lculo do acumulador antes de pass\u00e1-lo como par\u00e2metro para a chamada recursiva usando a fun\u00e7\u00e3o seq . soma acc [] = acc soma acc ( x : xs ) = seq acc soma ( acc + x ) xs O que a segunda linha do c\u00f3digo faz \u00e9 dizer ao Haskell que \"primeiro avalie acc e na sequ\u00eancia avalie soma ( acc + x ) xs . Outra forma, mais idiom\u00e1tica de escrever o mesmo c\u00f3digo \u00e9 usando seq de forma infixa. soma acc [] = acc soma acc ( x : xs ) = acc ` seq ` soma ( acc + x ) xs Felizmente voc\u00ea quase nunca precisar\u00e1 usar seq manualmente quando estiver escrevendo c\u00f3digo que v\u00e1 entrar em produ\u00e7\u00e3o, isto \u00e9, que ser\u00e1 compilado, pois poder\u00e1 usar a flag -O para dizer ao compilador que tente encontrar onde o uso de seq seria apropriado, e o compilador faz um excelente trabalho neste sentido. A t\u00e9cnica de passar um acumulador ou acumuladores na invoca\u00e7\u00e3o recursiva \u00e9 muito comum e deve estar sempre em sua mente. E se voc\u00ea n\u00e3o quiser \"poluir\" a API com um par\u00e2metro que s\u00f3 faz sentido por causa da recurs\u00e3o, voc\u00ea pode usar fun\u00e7\u00f5es auxiliares, como a seguir. soma l = soma' 0 l where soma' acc [] = acc soma' acc ( x : xs ) = soma' ( acc + x ) xs Vejamos um outro exemplo do uso de recurs\u00e3o de cauda, desta vez para calcular os n\u00fameros da sequ\u00eancia de Fibonacci \"de baixo para cima\". fibUp :: Integer -> Integer fibUp 0 = 0 fibUp 1 = 1 fibUp n = fibUpTo 0 1 1 n where fibUpTo prevPrev prev prevCount limit = if prevCount == limit then prev + prevPrev else fibUpTo prev ( prev + prevPrev ) ( prevCount + 1 ) limit","title":"Recurs\u00e3o de cauda"},{"location":"intro/","text":"Introdu\u00e7\u00e3o Programar um computador consiste em comunicar ao computador instru\u00e7\u00f5es para que ele resolva problemas, e a comunica\u00e7\u00e3o entre duas entidades s\u00f3 \u00e9 poss\u00edvel se usarem uma linguagem em comum, isto \u00e9, dominada por ambas as partes. Comunica\u00e7\u00e3o 1 A\u00e7\u00e3o ou efeito de comunicar, de transmitir ou de receber ideias, conhecimento, mensagens etc., buscando compartilhar informa\u00e7\u00f5es. Embora este curso assuma que voc\u00ea j\u00e1 saiba programar em alguma linguagem, ou exatamente por isso, \u00e9 importante que fa\u00e7amos uma revis\u00e3o de algumas ideias b\u00e1sicas de programa\u00e7\u00e3o antes de mergulharmos no paradigma funcional, para que possamos melhor posicionar este paradigma com em rela\u00e7\u00e3o aos demais. Linguagens Quando humanos se comunicam, usam linguagens naturais , como o portugu\u00eas, libras, ou canton\u00eas. Linguagens naturais s\u00e3o cheias de nuances e depend\u00eancias do contexto, o que lhes confere grande poder de express\u00e3o mas tamb\u00e9m leva a possibilidade de ambiguidade. Por isso, linguagens naturais n\u00e3o s\u00e3o boas para a comunica\u00e7\u00e3o entre computadores ou computadores e humanos , pois esta deve ser precisa. Isto ocorre a despeito do grande esfor\u00e7o dispendido e na evolu\u00e7\u00e3o do processamento de linguagens naturais, como as \"alexas\" e \"siris\" do mundo podem provar. A comunica\u00e7\u00e3o entre computadores \u00e9 feita por um protocolo de comunica\u00e7\u00e3o, assunto para outro curso. J\u00e1 a comunica\u00e7\u00e3o entre humanos e computadores, na programa\u00e7\u00e3o do computador, \u00e9 feita por meio de linguagens de programa\u00e7\u00e3o , que s\u00e3o muito mais restritas que as linguagens naturais e, por isso, n\u00e3o amb\u00edguas. Linguagem de Programa\u00e7\u00e3o 2 A linguagem de programa\u00e7\u00e3o \u00e9 um m\u00e9todo padronizado, formado por um conjunto de regras sint\u00e1ticas e sem\u00e2nticas, de implementa\u00e7\u00e3o de um c\u00f3digo fonte - que pode ser compilado e transformado em um programa de computador, ou usado como script interpretado - que informar\u00e1 instru\u00e7\u00f5es de processamento ao computador. A n\u00e3o ambiguidade das linguagens de programa\u00e7\u00e3o vem do fato de terem sintaxe e sem\u00e2ntica precisas, descritas por uma gram\u00e1tica tamb\u00e9m precisa. Sintaxe A sintaxe de uma linguagem descreve o que constitui um programa estruturalmente correto e \u00e9 definida por uma gram\u00e1tica. Sem\u00e2ntica O significado de um programa \u00e9 definido por sua sem\u00e2ntica, ou seja, por regras que definem como as instru\u00e7\u00f5es especificado devem ser interpretadas. Serem precisas n\u00e3o quer dizer que as linguagens sejam simples, como demonstra claramente a seguinte imagem, um programa \"hello world\" na linguagem Piet . Tamb\u00e9m n\u00e3o quer dizer que sejam limitadas. De fato, h\u00e1 milhares de linguagens de programa\u00e7\u00e3o por a\u00ed, e contando, com diferentes caracter\u00edsticas que as tornam mais ou menos apropriadas para resolver diferentes problemas. Dado o grande n\u00famero de linguagens, nada melhor que classific\u00e1-las em grandes fam\u00edlias ou paradigmas de programa\u00e7\u00e3o baseado em suas caracter\u00edsticas mais relevantes. Imperativo x Descritivo Os primeiros \"computadores\" eram m\u00e1quinas que computavam mecanicamente seus resultados. Os computadores de segunda gera\u00e7\u00e3o, da qual destacamos o ENIAC (circa 1955), n\u00e3o tinham partes mec\u00e2nicas, sendo programados por conex\u00f5es el\u00e9tricas de seus diversos componentes. A gera\u00e7\u00e3o seguinte tinha computadores que interpretavam c\u00f3digo escrito em uma linguagem de programa\u00e7\u00e3o. Imperativo x Descritivo Imperativo: como Descritivo: o qu\u00ea Estas primeiras linguagens eram todas imperativas , no sentido de que ditavam ao computador uma sequ\u00eancia de a\u00e7\u00f5es a serem executadas para se chegar a um resultado. Isto \u00e9, estas linguagens permitiam ao programador dizer como realizar uma computa\u00e7\u00e3o. Imperativo leia a linha 1 do arquivo separe a linha por espa\u00e7os pegue a segunda parte da linha converta a parte para n\u00famero se o n\u00famero for maior que 15, escreva na tela leia a pr\u00f3xima linha do arquivo volte para o passo 2 Este paradigma tem suas ra\u00edzes no modelo computacional cl\u00e1ssico de von Neumann e na m\u00e1quina de Turing. Em contrapartida a este modelo, surgiram mais tarde linguagens declarativas , em que o programador diz o qu\u00ea deve ser computado e o computador se encarrega de achar um \"como\" adequado. Descritivo selecione todas as linhas do arquivo, em que a segunda parte da linha, interpretada como um n\u00famero, \u00e9 maior que 15, e imprima-os na tela. Com uma an\u00e1lise r\u00e1pida das linguagens mais conhecidas, voc\u00ea deve reconhecer a maior parte como imperativas, por exemplo, C, Java, e Python. J\u00e1 dentre as linguagens declarativas, se destacam SQL, LINQ, e Prolog. Ortogonalmente ao foco no \"como X o qu\u00ea\", podemos nos focar em como as instru\u00e7\u00f5es s\u00e3o organizadas mais em um n\u00edvel mais alto, de onde se destacam quatro paradigmas principais: procedimental , orientado a objetos , l\u00f3gico e funcional . 3 Procedimental Linguagens que usam o paradigma procedimental organizam instru\u00e7\u00f5es em blocos, denominados procedimentos, de onde vem o nome, ou fun\u00e7\u00f5es. A ideia \u00e9 que o c\u00f3digo seja modularizado para separar funcionalidades e torn\u00e1-lo mais compreens\u00edvel e manuten\u00edvel. Cada fun\u00e7\u00e3o deve executar uma opera\u00e7\u00e3o bem espec\u00edfica; fun\u00e7\u00f5es associadas s\u00e3o colocadas em um mesmo arquivo; e arquivos associados s\u00e3o colocados em um mesmo namespace . O c\u00f3digo seguinte, em C, mostra a fun\u00e7\u00e3o main , ponto de entrada do programa e de onde a fun\u00e7\u00e3o printf , importada de stdio . h , \u00e9 invocada. #include <stdio.h> int main () { printf ( \"Hello, World!\" ); return 0 ; } Al\u00e9m da linguagem C, outros exemplos \u00f3bvios deste paradigma s\u00e3o as linguagens Pascal, Fortran e Python. Contudo, mesmo linguagens como Java e C++ podem ser consideradas procedurais, uma vez que organizam a computa\u00e7\u00e3o em m\u00e9todos, que s\u00e3o nada mais que fun\u00e7\u00f5es. Mas como m\u00e9todos est\u00e3o fortemente associados a classes e suas inst\u00e2ncias, os objetos, estas linguagens s\u00e3o melhor classificadas como orientadas a objetos. Orientado a Objetos Na orienta\u00e7\u00e3o a objetos, o foco est\u00e1 n\u00e3o na execu\u00e7\u00e3o passo a passo de fun\u00e7\u00f5es, mas na organiza\u00e7\u00e3o de dados e fun\u00e7\u00f5es associadas em objetos. Embora esta organiza\u00e7\u00e3o possa ser feita em qualquer linguagem estruturada, a sintaxe das linguagens orientadas a objeto facilita e torna mais natural este trabalho. Dois conceitos b\u00e1sicos na orienta\u00e7\u00e3o a objetos s\u00e3o as classes e os objetos . Classes s\u00e3o abstra\u00e7\u00f5es de tipos de coisas encontrados no mundo real, ou seja, receitas de estruturas de dados que definem quais informa\u00e7\u00f5es devem ser considerados em conjunto para representar um objeto e quais as a\u00e7\u00f5es associadas a este objeto. Por exemplo, se no mundo real cachorros tem uma data de nascimento e um nome, e s\u00e3o capazes de latir, uma classe que represente cachorros pode ser definida assim em Java. class Cachorro { int diaNascimento ; int mesNascimento ; int anoNascimento ; String nome ; void latir ( int quantidade ) { for ( int i = 0 ; i < quantidade ; i ++ ) System . out . println ( nome + \": Au!\" ); } } J\u00e1 um objeto \u00e9 uma inst\u00e2ncia de uma classe, uma representa\u00e7\u00e3o n\u00e3o de um tipo mas de uma coisa em si. Um c\u00e3o qualquer poderia ser representado assim Cachorro cachorro1 = new Cachorro ( 25 , 12 , 2020 , \"Napole\u00e3o\" ); cachorro1 . latir ( 3 ); e a execu\u00e7\u00e3o deste c\u00f3digo resultaria em Napole\u00e3o: Au! Napole\u00e3o: Au! Napole\u00e3o: Au! Observe que o \".\" em cachorro1 . latir ( 3 ) quer dizer \"executar a fun\u00e7\u00e3o latir no objeto cachorro1 \", o que leva a string Napole\u00e3o a aparecer antes de cada latido. Duas coisas podem ser ditas sobre este \".\". Primeiro, que ele n\u00e3o \u00e9 necess\u00e1rio: o objeto em si poderia ser passado como par\u00e2metro para uma fun\u00e7\u00e3o latir que recebesse o objeto al\u00e9m da quantidade de latidos; de fato, em Python, a classe seria definida como a seguir, o que implica que o \".\" \u00e9 s\u00f3 \"a\u00e7\u00facar sint\u00e1tico\" para a execu\u00e7\u00e3o de uma fun\u00e7\u00e3o. class Cachorro : diaNascimento mesNascimento anoNascimento nome def latir ( self , quantidade ): for i in range ( 0 , quantidade ): print ( self . nome + \": Au!\" ) Segundo, na orienta\u00e7\u00e3o a objetos conceitual, n\u00e3o se fala em invoca\u00e7\u00e3o de fun\u00e7\u00f5es mas de sinais sendo transmitidos entre objetos: envie mensagem para o 2 \"somar-se com 3\", ao que o objeto 2 responderia com uma mensagem \"refer\u00eancia ao objeto 5\". Em Smalltalk, esta intera\u00e7\u00e3o seria escrita assim: x := 2 + 3 . Grande parte do poder da orienta\u00e7\u00e3o objetos est\u00e1 no encapsulamento do como opera\u00e7\u00f5es s\u00e3o executadas, nos m\u00e9todos. Uma outra ordem de encapsulamento, de outro tipo, \u00e9 encontrada no paradigma l\u00f3gico. L\u00f3gico No paradigma l\u00f3gico, declaram-se fatos b\u00e1sicos e regras sobre como os fatos se relacionam e pergunta-se ao programa se certos fatos s\u00e3o ou n\u00e3o s\u00e3o verdade, ou quais fatos s\u00e3o verdades. Por exemplo, como fatos, podemos declarar eh_maior_que ( gato , rato ). eh_maior_que ( le\u00e3o , gato ). eh_maior_que ( elefante , le\u00e3o ). eh_maior_que ( elefante , moto ). eh_maior_que ( le\u00e3o , cachorro ). e como regras podemos declarar que vale a transitividade eh_maior_que ( A , B ) :- eh_maior_que ( A , C ), eh_maior_que ( C , B ). e, finalmente, perguntar se elefante \u00e9 maior que rato eh_maior_que ( elefante , rato ). ao que seremos respondidos com um \"sim\". Voc\u00ea consegue imaginar quantas linhas de c\u00f3digo voc\u00ea precisaria para expressar a mesma l\u00f3gica acima em uma linguagem como C ou Java? Apesar do claro poder deste paradigma, o mesmo tem poucos representantes, como Prolog e Mercury, e mesmo que exista v\u00e1rios compiladores do primeiro, o uso comercial do paradigma \u00e9 bem limitado. Funcional A programa\u00e7\u00e3o funcional, como indicado pelo nome, \u00e9 focada na organiza\u00e7\u00e3o do processamento em termos de fun\u00e7\u00f5es, mas de uma forma diferente da programa\u00e7\u00e3o procedimental. De forma geral, fun\u00e7\u00f5es s\u00e3o blocos de c\u00f3digo criadas essencialmente para se obter reusabilidade : uma vez definidas, as fun\u00e7\u00f5es podem ser invocadas repetidas vezes para executar a mesma tarefa sobre diferentes par\u00e2metros , sempre retornando um resultado. 4 Um programa funcional consiste basicamente justaposi\u00e7\u00e3o de fun\u00e7\u00f5es, ligando os sa\u00eddas de fun\u00e7\u00f5es \u00e0s entradas de outras fun\u00e7\u00f5es, at\u00e9 que um resultado final seja produzido. Neste sentido, podemos dividir as fun\u00e7\u00f5es em puras e com efeitos colaterais . Efeito colateral Dizemos que uma fun\u00e7\u00e3o \u00e9 pura quando ela depende somente dos par\u00e2metros passados para calcular o seu resultado, ou seja, fun\u00e7\u00f5es puras s\u00e3o como na matem\u00e1tica, mapeiam uma mesma entrada em exatamente uma mesma sa\u00edda. Por exemplo, as seguintes fun\u00e7\u00f5es, definidas em Erlang, calculam A + B , A * C e ( A + B ) * ( A + B ) e, independentemente de quantas vezes voc\u00ea o fizer, add ( 2 , 3 ) sempre retornar\u00e1 5 . add ( A , B ) -> A + B . mult ( A , B ) -> A * B . mult_add ( A , B ) -> mult ( add ( A , B ), add ( A , B )). J\u00e1 fun\u00e7\u00f5es que dependem de outras informa\u00e7\u00f5es para calcular o seu resultado, como o conte\u00fado de um arquivo no disco, uma mensagem recebida na interface de rede ou algo digitado pelo usu\u00e1rio, s\u00e3o chamadas de fun\u00e7\u00f5es impuras ou com efeitos colaterais . Agora observe a fun\u00e7\u00e3o seguinte, escrita em Python; a cada invoca\u00e7\u00e3o, a vari\u00e1vel acc tem seu valor alterado e, mesmo que invocada com a mesma entrada, o resultado da fun\u00e7\u00e3o \u00e9 sempre diferente. def soma ( x ): global acc acc = acc + x return acc Por um lado, efeitos colaterais s\u00e3o essencias para se desempenhar algumas opera\u00e7\u00f5es, como Entrada/Sa\u00edda. Por exemplo, ao invocar print no Python, o terminal tem seu estado alterado, e cada nova invoca\u00e7\u00e3o altera mais o estado. Da mesma forma, ao se invocar scanf em um c\u00f3digo C, a fun\u00e7\u00e3o acessa o estado do teclado, que dependendo do que o usu\u00e1rio digitou. Por outro lado, se uma fun\u00e7\u00e3o n\u00e3o tem efeitos colaterais ela pode ser muito mais facilmente testada e at\u00e9 mesmo provada correta, sendo almejadas como blocos de constru\u00e7\u00e3o. Assim, ao mesmo tempo em que precisamos executar opera\u00e7\u00f5es que causam efeitos colaterais, queremos minimiz\u00e1-los pois s\u00e3o fontes de indeterminismo e bugs no c\u00f3digo. Linguagens diferentes tomam rumos diferentes com respeito a efeitos colaterais. Enquanto s\u00e3o lugar comum na programa\u00e7\u00e3o procedimental, ficando totalmente sob responsabilidade do desenvolvedor evitar que causem problemas, na programa\u00e7\u00e3o funcional s\u00e3o evitados ao tratar vari\u00e1veis n\u00e3o como \u00e1reas de mem\u00f3ria alter\u00e1veis, mas como inc\u00f3gnitas, como na matem\u00e1tica, evitando que estado seja \"acumulado\" fora dos par\u00e2metros formais da fun\u00e7\u00e3o. Nas linguagens deste paradigma, ou exce\u00e7\u00f5es s\u00e3o feitas para opera\u00e7\u00f5es que demandam efeitos colaterais, dando origem \u00e0s linguagens funcionais n\u00e3o puras , ou os efeitos colaterais s\u00e3o completamente abolidos, mesmo que \u00e0s custas de \"artif\u00edcios\", 5 como em Haskell. Al\u00e9m das linguagens funcionais puras e n\u00e3o puras, h\u00e1 as linguagens n\u00e3o funcionais e, dentro destas, aquelas com elementos de programa\u00e7\u00e3o funcional. \"Funcionalidades\" Muitas linguagens modernas, como Python e JavaScript, embora n\u00e3o estritamente funcionais, tem diversos elementos de programa\u00e7\u00e3o funcional, ou diretamente na linguagem ou via frameworks . Python, por exemplo, tem v\u00e1rias funcionalidades caracter\u00edsticas do paradigma funcional, embora seja poss\u00edvel ignor\u00e1-las por completo. Por exemplo, imagine que voc\u00ea queira criar uma lista com o quadrado de todos os n\u00fameros de 1 a x . Voc\u00ea pode optar por um for cl\u00e1ssico def quads ( x ): lista = [] for i in range ( 1 , x ): lista . append ( i * i ) return lista ou por uma compreens\u00e3o de listas , caracter\u00edsticas da programa\u00e7\u00e3o funcional. def quads2 ( x ): return [ e ** 2 for e in range ( 1 , x )] Al\u00e9m disso, h\u00e1 linguagens funcionais que tamb\u00e9m se enquadram em outros paradigmas e que podem ser consideradas h\u00edbridas, ou multi-paradigma. Multi-paradigma Muitas linguagens modernas podem ser classificadas ao mesmo tempo em muitos paradigmas, por exemplo, a linguagem Scala \u00e9 ao mesmo tempo funcional e orientada a objetos, sendo muito dif\u00edcil us\u00e1-la sem fazer uso extensivo de ambos aspectos. object HelloWorld { def main ( args : Array [ String ]) : Unit = { println ( \"Hello, world!\" ) } } Para cada servi\u00e7o, uma ferramenta! Encontramos vantagens e desvantagens em cada paradigma. Como desenvolvedores de tecnologia, nada mais justo que voc\u00eas conhe\u00e7am todos os paradigmas e que possam, assim, escolher aquele paradigma e, dentro dele, aquela linguagem que permite resolver o seu problema da forma mais eficiente, isto \u00e9, rapidamente, com menor custo e com melhor qualidade. Mas quanto ao paradigma funcional, em especial, \u00e9 importante compreend\u00ea-lo pois muitas de suas funcionalidades tem sido incorporadas a outras linguagens, como compreens\u00e3o de listas em Python, fun\u00e7\u00f5es lambda em Java e C++, e processamento ass\u00edncrono, que pode ser visto como uma forma de avalia\u00e7\u00e3o pregui\u00e7osa, em diversas linguagens. Algumas caracter\u00edsticas importantes do paradigma: Sem efeitos colaterais: executando um programa, de repente voc\u00ea percebe que uma certa vari\u00e1vel tem um valor estranho e fica se perguntando quem foi que atribuiu tal valor; efeitos colaterais s\u00e3o a origem de boa parte dos bugs e elimin\u00e1-los, ou ao menos reduz\u00ed-los, permite que voc\u00ea identifique rapidamente onde altera\u00e7\u00f5es poderiam ter acontecido. Camadas de abstra\u00e7\u00e3o: fun\u00e7\u00f5es podem ser compostas levando a programas verdadeiramente complexos, permitindo que abstra\u00e7\u00f5es sejam definidas em diversas camadas. Al\u00e9m disso, \u00e9 poss\u00edvel, em teoria, ser provar a corretude de fun\u00e7\u00f5es e, mesmo que na pr\u00e1tica isso n\u00e3o se realize, h\u00e1 ferramentas que conseguem usar esta ideia para lhe ajudar a encontrar bugs. Processamento paralelo eficiente: a aus\u00eancia de efeitos colaterais tamb\u00e9m implica que fun\u00e7\u00f5es sem depend\u00eancias podem ser executadas em paralelo, sem se preocupar com qualquer sincroniza\u00e7\u00e3o, isto \u00e9, sem mutexes e vari\u00e1veis de condi\u00e7\u00e3o, etc. Avalia\u00e7\u00e3o pregui\u00e7osa: fun\u00e7\u00f5es s\u00f3 precisam realmente ser executadas se seus resultados s\u00e3o necess\u00e1rios e o compilador consegue atrasar a execu\u00e7\u00e3o de fun\u00e7\u00f5es enquanto poss\u00edvel. Recurs\u00e3o de calda: alguns problemas podem ser descritos muito facilmente como uma recurs\u00e3o que com uma itera\u00e7\u00e3o, mas linguagens tradicionais tem um limite no tamanho das pilhas de fun\u00e7\u00e3o; linguagens funcionais conseguem, em certas condi\u00e7\u00f5es, usar recurs\u00e3o infinita, contornando esta limita\u00e7\u00e3o. Fun\u00e7\u00f5es de ordem superior: fun\u00e7\u00f5es podem receber outras fun\u00e7\u00f5es como par\u00e2metro e com isso podemos compor fun\u00e7\u00f5es, por exemplo para implementar orienta\u00e7\u00e3o a objetos. Como j\u00e1 ficou \u00f3bvio, h\u00e1 muitas, muitas linguagens de programa\u00e7\u00e3o por a\u00ed e \u00e9 poss\u00edvel escrever c\u00f3digo bom em cada um delas, assim como \u00e9 poss\u00edvel escrever c\u00f3digo ruim em cada uma delas. Tamb\u00e9m \u00e9 poss\u00edvel escrever usando orienta\u00e7\u00e3o a objetos ou funcionalmente em cada uma delas, mas embora seja poss\u00edvel , h\u00e1 aquelas linguagens que suportam melhor cada um dos paradigmas. Dentre estas, h\u00e1 diversas op\u00e7\u00f5es de linguagens que podemos usar para estudar o paradigma funcional, por exemplo: Scheme Lisp ML F# Erlang Elixir Haskell Clojure Neste curso, veremos princ\u00edpios gerais e que, em teoria, poderiam ser aplicados em quaisquer destas linguagens. Contudo, como a sintaxe pode variar muito de uma linguagem para outra, precisaremos nos focar em uma \u00fanica. Assim, nosso foco aqui ser\u00e1 em Haskell, uma linguagem funcional madura e est\u00e1vel. Comunica\u00e7\u00e3o \u21a9 Linguagem de Programa\u00e7\u00e3o \u21a9 Programming Language Families \u21a9 void \u00e9 simplesmente um resultado que diz que o resultado n\u00e3o importa. \u21a9 What is a Monad? \u21a9","title":"Introdu\u00e7\u00e3o"},{"location":"intro/#introducao","text":"Programar um computador consiste em comunicar ao computador instru\u00e7\u00f5es para que ele resolva problemas, e a comunica\u00e7\u00e3o entre duas entidades s\u00f3 \u00e9 poss\u00edvel se usarem uma linguagem em comum, isto \u00e9, dominada por ambas as partes. Comunica\u00e7\u00e3o 1 A\u00e7\u00e3o ou efeito de comunicar, de transmitir ou de receber ideias, conhecimento, mensagens etc., buscando compartilhar informa\u00e7\u00f5es. Embora este curso assuma que voc\u00ea j\u00e1 saiba programar em alguma linguagem, ou exatamente por isso, \u00e9 importante que fa\u00e7amos uma revis\u00e3o de algumas ideias b\u00e1sicas de programa\u00e7\u00e3o antes de mergulharmos no paradigma funcional, para que possamos melhor posicionar este paradigma com em rela\u00e7\u00e3o aos demais.","title":"Introdu\u00e7\u00e3o"},{"location":"intro/#linguagens","text":"Quando humanos se comunicam, usam linguagens naturais , como o portugu\u00eas, libras, ou canton\u00eas. Linguagens naturais s\u00e3o cheias de nuances e depend\u00eancias do contexto, o que lhes confere grande poder de express\u00e3o mas tamb\u00e9m leva a possibilidade de ambiguidade. Por isso, linguagens naturais n\u00e3o s\u00e3o boas para a comunica\u00e7\u00e3o entre computadores ou computadores e humanos , pois esta deve ser precisa. Isto ocorre a despeito do grande esfor\u00e7o dispendido e na evolu\u00e7\u00e3o do processamento de linguagens naturais, como as \"alexas\" e \"siris\" do mundo podem provar. A comunica\u00e7\u00e3o entre computadores \u00e9 feita por um protocolo de comunica\u00e7\u00e3o, assunto para outro curso. J\u00e1 a comunica\u00e7\u00e3o entre humanos e computadores, na programa\u00e7\u00e3o do computador, \u00e9 feita por meio de linguagens de programa\u00e7\u00e3o , que s\u00e3o muito mais restritas que as linguagens naturais e, por isso, n\u00e3o amb\u00edguas. Linguagem de Programa\u00e7\u00e3o 2 A linguagem de programa\u00e7\u00e3o \u00e9 um m\u00e9todo padronizado, formado por um conjunto de regras sint\u00e1ticas e sem\u00e2nticas, de implementa\u00e7\u00e3o de um c\u00f3digo fonte - que pode ser compilado e transformado em um programa de computador, ou usado como script interpretado - que informar\u00e1 instru\u00e7\u00f5es de processamento ao computador. A n\u00e3o ambiguidade das linguagens de programa\u00e7\u00e3o vem do fato de terem sintaxe e sem\u00e2ntica precisas, descritas por uma gram\u00e1tica tamb\u00e9m precisa. Sintaxe A sintaxe de uma linguagem descreve o que constitui um programa estruturalmente correto e \u00e9 definida por uma gram\u00e1tica. Sem\u00e2ntica O significado de um programa \u00e9 definido por sua sem\u00e2ntica, ou seja, por regras que definem como as instru\u00e7\u00f5es especificado devem ser interpretadas. Serem precisas n\u00e3o quer dizer que as linguagens sejam simples, como demonstra claramente a seguinte imagem, um programa \"hello world\" na linguagem Piet . Tamb\u00e9m n\u00e3o quer dizer que sejam limitadas. De fato, h\u00e1 milhares de linguagens de programa\u00e7\u00e3o por a\u00ed, e contando, com diferentes caracter\u00edsticas que as tornam mais ou menos apropriadas para resolver diferentes problemas. Dado o grande n\u00famero de linguagens, nada melhor que classific\u00e1-las em grandes fam\u00edlias ou paradigmas de programa\u00e7\u00e3o baseado em suas caracter\u00edsticas mais relevantes.","title":"Linguagens"},{"location":"intro/#imperativo-x-descritivo","text":"Os primeiros \"computadores\" eram m\u00e1quinas que computavam mecanicamente seus resultados. Os computadores de segunda gera\u00e7\u00e3o, da qual destacamos o ENIAC (circa 1955), n\u00e3o tinham partes mec\u00e2nicas, sendo programados por conex\u00f5es el\u00e9tricas de seus diversos componentes. A gera\u00e7\u00e3o seguinte tinha computadores que interpretavam c\u00f3digo escrito em uma linguagem de programa\u00e7\u00e3o. Imperativo x Descritivo Imperativo: como Descritivo: o qu\u00ea Estas primeiras linguagens eram todas imperativas , no sentido de que ditavam ao computador uma sequ\u00eancia de a\u00e7\u00f5es a serem executadas para se chegar a um resultado. Isto \u00e9, estas linguagens permitiam ao programador dizer como realizar uma computa\u00e7\u00e3o. Imperativo leia a linha 1 do arquivo separe a linha por espa\u00e7os pegue a segunda parte da linha converta a parte para n\u00famero se o n\u00famero for maior que 15, escreva na tela leia a pr\u00f3xima linha do arquivo volte para o passo 2 Este paradigma tem suas ra\u00edzes no modelo computacional cl\u00e1ssico de von Neumann e na m\u00e1quina de Turing. Em contrapartida a este modelo, surgiram mais tarde linguagens declarativas , em que o programador diz o qu\u00ea deve ser computado e o computador se encarrega de achar um \"como\" adequado. Descritivo selecione todas as linhas do arquivo, em que a segunda parte da linha, interpretada como um n\u00famero, \u00e9 maior que 15, e imprima-os na tela. Com uma an\u00e1lise r\u00e1pida das linguagens mais conhecidas, voc\u00ea deve reconhecer a maior parte como imperativas, por exemplo, C, Java, e Python. J\u00e1 dentre as linguagens declarativas, se destacam SQL, LINQ, e Prolog. Ortogonalmente ao foco no \"como X o qu\u00ea\", podemos nos focar em como as instru\u00e7\u00f5es s\u00e3o organizadas mais em um n\u00edvel mais alto, de onde se destacam quatro paradigmas principais: procedimental , orientado a objetos , l\u00f3gico e funcional . 3","title":"Imperativo x Descritivo"},{"location":"intro/#procedimental","text":"Linguagens que usam o paradigma procedimental organizam instru\u00e7\u00f5es em blocos, denominados procedimentos, de onde vem o nome, ou fun\u00e7\u00f5es. A ideia \u00e9 que o c\u00f3digo seja modularizado para separar funcionalidades e torn\u00e1-lo mais compreens\u00edvel e manuten\u00edvel. Cada fun\u00e7\u00e3o deve executar uma opera\u00e7\u00e3o bem espec\u00edfica; fun\u00e7\u00f5es associadas s\u00e3o colocadas em um mesmo arquivo; e arquivos associados s\u00e3o colocados em um mesmo namespace . O c\u00f3digo seguinte, em C, mostra a fun\u00e7\u00e3o main , ponto de entrada do programa e de onde a fun\u00e7\u00e3o printf , importada de stdio . h , \u00e9 invocada. #include <stdio.h> int main () { printf ( \"Hello, World!\" ); return 0 ; } Al\u00e9m da linguagem C, outros exemplos \u00f3bvios deste paradigma s\u00e3o as linguagens Pascal, Fortran e Python. Contudo, mesmo linguagens como Java e C++ podem ser consideradas procedurais, uma vez que organizam a computa\u00e7\u00e3o em m\u00e9todos, que s\u00e3o nada mais que fun\u00e7\u00f5es. Mas como m\u00e9todos est\u00e3o fortemente associados a classes e suas inst\u00e2ncias, os objetos, estas linguagens s\u00e3o melhor classificadas como orientadas a objetos.","title":"Procedimental"},{"location":"intro/#orientado-a-objetos","text":"Na orienta\u00e7\u00e3o a objetos, o foco est\u00e1 n\u00e3o na execu\u00e7\u00e3o passo a passo de fun\u00e7\u00f5es, mas na organiza\u00e7\u00e3o de dados e fun\u00e7\u00f5es associadas em objetos. Embora esta organiza\u00e7\u00e3o possa ser feita em qualquer linguagem estruturada, a sintaxe das linguagens orientadas a objeto facilita e torna mais natural este trabalho. Dois conceitos b\u00e1sicos na orienta\u00e7\u00e3o a objetos s\u00e3o as classes e os objetos . Classes s\u00e3o abstra\u00e7\u00f5es de tipos de coisas encontrados no mundo real, ou seja, receitas de estruturas de dados que definem quais informa\u00e7\u00f5es devem ser considerados em conjunto para representar um objeto e quais as a\u00e7\u00f5es associadas a este objeto. Por exemplo, se no mundo real cachorros tem uma data de nascimento e um nome, e s\u00e3o capazes de latir, uma classe que represente cachorros pode ser definida assim em Java. class Cachorro { int diaNascimento ; int mesNascimento ; int anoNascimento ; String nome ; void latir ( int quantidade ) { for ( int i = 0 ; i < quantidade ; i ++ ) System . out . println ( nome + \": Au!\" ); } } J\u00e1 um objeto \u00e9 uma inst\u00e2ncia de uma classe, uma representa\u00e7\u00e3o n\u00e3o de um tipo mas de uma coisa em si. Um c\u00e3o qualquer poderia ser representado assim Cachorro cachorro1 = new Cachorro ( 25 , 12 , 2020 , \"Napole\u00e3o\" ); cachorro1 . latir ( 3 ); e a execu\u00e7\u00e3o deste c\u00f3digo resultaria em Napole\u00e3o: Au! Napole\u00e3o: Au! Napole\u00e3o: Au! Observe que o \".\" em cachorro1 . latir ( 3 ) quer dizer \"executar a fun\u00e7\u00e3o latir no objeto cachorro1 \", o que leva a string Napole\u00e3o a aparecer antes de cada latido. Duas coisas podem ser ditas sobre este \".\". Primeiro, que ele n\u00e3o \u00e9 necess\u00e1rio: o objeto em si poderia ser passado como par\u00e2metro para uma fun\u00e7\u00e3o latir que recebesse o objeto al\u00e9m da quantidade de latidos; de fato, em Python, a classe seria definida como a seguir, o que implica que o \".\" \u00e9 s\u00f3 \"a\u00e7\u00facar sint\u00e1tico\" para a execu\u00e7\u00e3o de uma fun\u00e7\u00e3o. class Cachorro : diaNascimento mesNascimento anoNascimento nome def latir ( self , quantidade ): for i in range ( 0 , quantidade ): print ( self . nome + \": Au!\" ) Segundo, na orienta\u00e7\u00e3o a objetos conceitual, n\u00e3o se fala em invoca\u00e7\u00e3o de fun\u00e7\u00f5es mas de sinais sendo transmitidos entre objetos: envie mensagem para o 2 \"somar-se com 3\", ao que o objeto 2 responderia com uma mensagem \"refer\u00eancia ao objeto 5\". Em Smalltalk, esta intera\u00e7\u00e3o seria escrita assim: x := 2 + 3 . Grande parte do poder da orienta\u00e7\u00e3o objetos est\u00e1 no encapsulamento do como opera\u00e7\u00f5es s\u00e3o executadas, nos m\u00e9todos. Uma outra ordem de encapsulamento, de outro tipo, \u00e9 encontrada no paradigma l\u00f3gico.","title":"Orientado a Objetos"},{"location":"intro/#logico","text":"No paradigma l\u00f3gico, declaram-se fatos b\u00e1sicos e regras sobre como os fatos se relacionam e pergunta-se ao programa se certos fatos s\u00e3o ou n\u00e3o s\u00e3o verdade, ou quais fatos s\u00e3o verdades. Por exemplo, como fatos, podemos declarar eh_maior_que ( gato , rato ). eh_maior_que ( le\u00e3o , gato ). eh_maior_que ( elefante , le\u00e3o ). eh_maior_que ( elefante , moto ). eh_maior_que ( le\u00e3o , cachorro ). e como regras podemos declarar que vale a transitividade eh_maior_que ( A , B ) :- eh_maior_que ( A , C ), eh_maior_que ( C , B ). e, finalmente, perguntar se elefante \u00e9 maior que rato eh_maior_que ( elefante , rato ). ao que seremos respondidos com um \"sim\". Voc\u00ea consegue imaginar quantas linhas de c\u00f3digo voc\u00ea precisaria para expressar a mesma l\u00f3gica acima em uma linguagem como C ou Java? Apesar do claro poder deste paradigma, o mesmo tem poucos representantes, como Prolog e Mercury, e mesmo que exista v\u00e1rios compiladores do primeiro, o uso comercial do paradigma \u00e9 bem limitado.","title":"L\u00f3gico"},{"location":"intro/#funcional","text":"A programa\u00e7\u00e3o funcional, como indicado pelo nome, \u00e9 focada na organiza\u00e7\u00e3o do processamento em termos de fun\u00e7\u00f5es, mas de uma forma diferente da programa\u00e7\u00e3o procedimental. De forma geral, fun\u00e7\u00f5es s\u00e3o blocos de c\u00f3digo criadas essencialmente para se obter reusabilidade : uma vez definidas, as fun\u00e7\u00f5es podem ser invocadas repetidas vezes para executar a mesma tarefa sobre diferentes par\u00e2metros , sempre retornando um resultado. 4 Um programa funcional consiste basicamente justaposi\u00e7\u00e3o de fun\u00e7\u00f5es, ligando os sa\u00eddas de fun\u00e7\u00f5es \u00e0s entradas de outras fun\u00e7\u00f5es, at\u00e9 que um resultado final seja produzido. Neste sentido, podemos dividir as fun\u00e7\u00f5es em puras e com efeitos colaterais .","title":"Funcional"},{"location":"intro/#multi-paradigma","text":"Muitas linguagens modernas podem ser classificadas ao mesmo tempo em muitos paradigmas, por exemplo, a linguagem Scala \u00e9 ao mesmo tempo funcional e orientada a objetos, sendo muito dif\u00edcil us\u00e1-la sem fazer uso extensivo de ambos aspectos. object HelloWorld { def main ( args : Array [ String ]) : Unit = { println ( \"Hello, world!\" ) } }","title":"Multi-paradigma"},{"location":"intro/#para-cada-servico-uma-ferramenta","text":"Encontramos vantagens e desvantagens em cada paradigma. Como desenvolvedores de tecnologia, nada mais justo que voc\u00eas conhe\u00e7am todos os paradigmas e que possam, assim, escolher aquele paradigma e, dentro dele, aquela linguagem que permite resolver o seu problema da forma mais eficiente, isto \u00e9, rapidamente, com menor custo e com melhor qualidade. Mas quanto ao paradigma funcional, em especial, \u00e9 importante compreend\u00ea-lo pois muitas de suas funcionalidades tem sido incorporadas a outras linguagens, como compreens\u00e3o de listas em Python, fun\u00e7\u00f5es lambda em Java e C++, e processamento ass\u00edncrono, que pode ser visto como uma forma de avalia\u00e7\u00e3o pregui\u00e7osa, em diversas linguagens. Algumas caracter\u00edsticas importantes do paradigma: Sem efeitos colaterais: executando um programa, de repente voc\u00ea percebe que uma certa vari\u00e1vel tem um valor estranho e fica se perguntando quem foi que atribuiu tal valor; efeitos colaterais s\u00e3o a origem de boa parte dos bugs e elimin\u00e1-los, ou ao menos reduz\u00ed-los, permite que voc\u00ea identifique rapidamente onde altera\u00e7\u00f5es poderiam ter acontecido. Camadas de abstra\u00e7\u00e3o: fun\u00e7\u00f5es podem ser compostas levando a programas verdadeiramente complexos, permitindo que abstra\u00e7\u00f5es sejam definidas em diversas camadas. Al\u00e9m disso, \u00e9 poss\u00edvel, em teoria, ser provar a corretude de fun\u00e7\u00f5es e, mesmo que na pr\u00e1tica isso n\u00e3o se realize, h\u00e1 ferramentas que conseguem usar esta ideia para lhe ajudar a encontrar bugs. Processamento paralelo eficiente: a aus\u00eancia de efeitos colaterais tamb\u00e9m implica que fun\u00e7\u00f5es sem depend\u00eancias podem ser executadas em paralelo, sem se preocupar com qualquer sincroniza\u00e7\u00e3o, isto \u00e9, sem mutexes e vari\u00e1veis de condi\u00e7\u00e3o, etc. Avalia\u00e7\u00e3o pregui\u00e7osa: fun\u00e7\u00f5es s\u00f3 precisam realmente ser executadas se seus resultados s\u00e3o necess\u00e1rios e o compilador consegue atrasar a execu\u00e7\u00e3o de fun\u00e7\u00f5es enquanto poss\u00edvel. Recurs\u00e3o de calda: alguns problemas podem ser descritos muito facilmente como uma recurs\u00e3o que com uma itera\u00e7\u00e3o, mas linguagens tradicionais tem um limite no tamanho das pilhas de fun\u00e7\u00e3o; linguagens funcionais conseguem, em certas condi\u00e7\u00f5es, usar recurs\u00e3o infinita, contornando esta limita\u00e7\u00e3o. Fun\u00e7\u00f5es de ordem superior: fun\u00e7\u00f5es podem receber outras fun\u00e7\u00f5es como par\u00e2metro e com isso podemos compor fun\u00e7\u00f5es, por exemplo para implementar orienta\u00e7\u00e3o a objetos. Como j\u00e1 ficou \u00f3bvio, h\u00e1 muitas, muitas linguagens de programa\u00e7\u00e3o por a\u00ed e \u00e9 poss\u00edvel escrever c\u00f3digo bom em cada um delas, assim como \u00e9 poss\u00edvel escrever c\u00f3digo ruim em cada uma delas. Tamb\u00e9m \u00e9 poss\u00edvel escrever usando orienta\u00e7\u00e3o a objetos ou funcionalmente em cada uma delas, mas embora seja poss\u00edvel , h\u00e1 aquelas linguagens que suportam melhor cada um dos paradigmas. Dentre estas, h\u00e1 diversas op\u00e7\u00f5es de linguagens que podemos usar para estudar o paradigma funcional, por exemplo: Scheme Lisp ML F# Erlang Elixir Haskell Clojure Neste curso, veremos princ\u00edpios gerais e que, em teoria, poderiam ser aplicados em quaisquer destas linguagens. Contudo, como a sintaxe pode variar muito de uma linguagem para outra, precisaremos nos focar em uma \u00fanica. Assim, nosso foco aqui ser\u00e1 em Haskell, uma linguagem funcional madura e est\u00e1vel. Comunica\u00e7\u00e3o \u21a9 Linguagem de Programa\u00e7\u00e3o \u21a9 Programming Language Families \u21a9 void \u00e9 simplesmente um resultado que diz que o resultado n\u00e3o importa. \u21a9 What is a Monad? \u21a9","title":"Para cada servi\u00e7o, uma ferramenta!"},{"location":"intro/haskell/","text":"Haskell A primeira vers\u00e3o da linguagem Haskell, cujo nome \u00e9 uma homenagem ao matem\u00e1tico e l\u00f3gico Haskell B. Curry , apareceu em 1987 do esfor\u00e7o para se consolidar v\u00e1rios avan\u00e7os propostos no paradigma funcional. A linguagem ficou famosa pura , de prop\u00f3sito geral e por ter caracter\u00edsticas marcantes como avalia\u00e7\u00e3o pregui\u00e7osa , e tipagem est\u00e1tica , forte e por infer\u00eancia , como discutiremos mais adiante. Mais do que uma linguagem, Haskell era uma especifica\u00e7\u00e3o, ou s\u00e9rie de especifica\u00e7\u00f5es, tendo tido v\u00e1rias implementa\u00e7\u00f5es distintas. A vers\u00e3o de 98 foi um marco da linguagem, sendo uma vers\u00e3o considerada est\u00e1vel. Nesta \u00e9poca surgiu o Glasgow Haskell Compiler (GHC), que se tornou o compilador Haskell \"padr\u00e3o\". A vers\u00e3o seguinte da linguagem come\u00e7ou a ser especificada em 2006 e anunciada em 2009, a Haskell 2010. Dentre os principais avan\u00e7os desta vers\u00e3o est\u00e1 a possibilidade de interagir com c\u00f3digo escrito em outras linguagens, via a foreign function interface (FFI). Mas chega de hist\u00f3ria e vamos colocar a m\u00e3o na massa vendo alguns exemplos linguagem. Exemplos simples Para pequenos experimentos e exerc\u00edcios, podemos usar o Repl.It 1 para ter acesso a um interpretador Haskell sem a necessidade de instala\u00e7\u00e3o. Do lado direito do s\u00edtio, na \u00e1rea marcada em vermelho, digite ghci seguido de Enter . Agora digite as express\u00f5es a seguir. 1 + 1 True && True 100 / 10 ( 10 + 4 ) * 50 3 * ( - 2 ) 2 * - 1 Estas express\u00f5es fazem uso de operadores comuns e se comportam exatamente como voc\u00ea esperaria, depois de ter aprendido a programar em qualquer linguagem, em qualquer paradigma. Operadores s\u00e3o a\u00e7\u00facar sint\u00e1tico para fun\u00e7\u00f5es, a alma da programa\u00e7\u00e3o funcional. Exemplos um pouco menos complexos Para exemplos um pouco mais interessantes, usamos o lado esquerdo do s\u00edtio. Voc\u00ea pode come\u00e7ar substituindo a linha que aparece por padr\u00e3o por soma2n a b = a + b (em vermelho ). Do lado direito ent\u00e3o digite o comando : load main (ou simplesmente : l main ) (em verde ), que ir\u00e1 carregar o arquivo sendo editado \u00e0 esquerda, main.hs. Uma vez carregado o arquivo, voc\u00ea pode usar suas novas fun\u00e7\u00f5es (em amarelo ). Exemplos menos simples ainda Para desenvolver e usar c\u00f3digo um pouco mais complexo, voc\u00ea dever\u00e1 instalar o compilador Haskell na sua m\u00e1quina, seguindo as instru\u00e7\u00f5es espec\u00edficas. 2 Neste caso, tamb\u00e9m recomendo o uso de uma IDE. REPL \u00e9 o acr\u00f4nimo para Read, Evaluate, Print, Loop. \u21a9 Instru\u00e7\u00f5es de como instalar o GHC s\u00e3o espec\u00edficas para cada sistema operacional. Por isso, consulte o s\u00edtio https://www.haskell.org/platform/ para instalar o Haskell na sua m\u00e1quina. Frequentemente a solu\u00e7\u00e3o \u00e9 usar o ghcup . \u21a9","title":"Haskell"},{"location":"intro/haskell/#haskell","text":"A primeira vers\u00e3o da linguagem Haskell, cujo nome \u00e9 uma homenagem ao matem\u00e1tico e l\u00f3gico Haskell B. Curry , apareceu em 1987 do esfor\u00e7o para se consolidar v\u00e1rios avan\u00e7os propostos no paradigma funcional. A linguagem ficou famosa pura , de prop\u00f3sito geral e por ter caracter\u00edsticas marcantes como avalia\u00e7\u00e3o pregui\u00e7osa , e tipagem est\u00e1tica , forte e por infer\u00eancia , como discutiremos mais adiante. Mais do que uma linguagem, Haskell era uma especifica\u00e7\u00e3o, ou s\u00e9rie de especifica\u00e7\u00f5es, tendo tido v\u00e1rias implementa\u00e7\u00f5es distintas. A vers\u00e3o de 98 foi um marco da linguagem, sendo uma vers\u00e3o considerada est\u00e1vel. Nesta \u00e9poca surgiu o Glasgow Haskell Compiler (GHC), que se tornou o compilador Haskell \"padr\u00e3o\". A vers\u00e3o seguinte da linguagem come\u00e7ou a ser especificada em 2006 e anunciada em 2009, a Haskell 2010. Dentre os principais avan\u00e7os desta vers\u00e3o est\u00e1 a possibilidade de interagir com c\u00f3digo escrito em outras linguagens, via a foreign function interface (FFI). Mas chega de hist\u00f3ria e vamos colocar a m\u00e3o na massa vendo alguns exemplos linguagem.","title":"Haskell"},{"location":"intro/more/","text":"Para saber mais Para saber um pouco mais da hist\u00f3ria do paradigma funcional, os seguintes v\u00eddeos s\u00e3o muito \u00fateis. Sobre a hist\u00f3ria das linguagens de programa\u00e7\u00e3o Sobre porqu\u00ea PF n\u00e3o \u00e9 mais comum","title":"Mais Haskell"},{"location":"intro/more/#para-saber-mais","text":"Para saber um pouco mais da hist\u00f3ria do paradigma funcional, os seguintes v\u00eddeos s\u00e3o muito \u00fateis. Sobre a hist\u00f3ria das linguagens de programa\u00e7\u00e3o Sobre porqu\u00ea PF n\u00e3o \u00e9 mais comum","title":"Para saber mais"},{"location":"io/io/","text":"Entrada e Sa\u00edda Em programa\u00e7\u00e3o dizemos que uma fun\u00e7\u00e3o tem efeitos colaterais quando l\u00ea ou modifica qualquer estado al\u00e9m do que lhe foi passado como par\u00e2metro e suas vari\u00e1veis locais. Linguagens de funcionais puras n\u00e3o tem efeitos colaterais e \u00e9 por isso que toda vez que uma fun\u00e7\u00e3o \u00e9 invocada com os mesmos par\u00e2metros, ela retorna o mesmo resultado, assim como 2+2 = 4, sempre. O problema de ser uma linguagem funcional pura est\u00e1 em realizar Entrada e Sa\u00edda (E/S, I/O), ou seja, interagir com o mundo exterior ao programa em execu\u00e7\u00e3o, por exemplo lendo do teclado, manipulando arquivos, ou mesmo modificando o estado da mem\u00f3ria de v\u00eddeo para desenhar ou escrever algo na tela, pois isso \u00e9 um efeito colateral. Como E/S \u00e9 uma realidade dos programas de computador, as linguagens funcionais devem ou abdicar de sua pureza ou usar de artimanhas para realiz\u00e1-las. No caso de Haskell, E/S \u00e9 encapsulada em M\u00f4nadas, um conceito no qual n\u00e3o nos aprofundaremos neste curso. A\u00e7\u00f5es de E/S E/S \u00e9 executada por meio de uma a\u00e7\u00e3o E/S , uma fun\u00e7\u00e3o especial que se comunica com o mundo \"exterior\". As seguintes fun\u00e7\u00f5es s\u00e3o exemplos de a\u00e7\u00f5es que se comunicam com teclado e monitor. A\u00e7\u00e3o Descri\u00e7\u00e3o getChar L\u00ea um caractere do teclado. putChar Escreve um caractere na tela. getLine L\u00ea uma linha do teclado. putStr Escreve uma string na tela. putStrLn Escreve uma string na tela e quebra a linha. binding Uma vez que tenha visto estas fun\u00e7\u00f5es, \u00e9 natural que queira escrever algo como nome = getLine , mas isso n\u00e3o ter\u00e1 o efeito que voc\u00ea espera. Prelude > nome = getLine Prelude > nome lalala \"lalala\" Prelude > putStr nome < interactive >: 11 : 8 : error : \u2022 Couldn't match type \u2018 IO String \u2019 with \u2018 [ Char ] \u2019 Expected type : String Actual type : IO String \u2022 In the first argument of \u2018 putStr \u2019 , namely \u2018 nome \u2019 In the expression : putStr nome In an equation for \u2018 it \u2019 : it = putStr nome O que aconteceu no exemplo acima foi que a a\u00e7\u00e3o getLine foi atribu\u00edda a nome , n\u00e3o uma string. Para fazer o que voc\u00ea quer, isto \u00e9, executar uma a\u00e7\u00e3o e atribuir o seu resultado a uma vari\u00e1vel, precisamos usar o operador <- . Prelude > nome <- getLine lala Prelude > print nome \"lala\" Dizemos que o operador <- faz o binding (atrelamento) do valor \u00e0 vari\u00e1vel. IO Se explorarmos o tipo das a\u00e7\u00f5es veremos que elas n\u00e3o tem retorno como esperar\u00edamos, por exemplo, getLine tem tipo getLine :: IO String . O IO no tipo do resultado \u00e9 um tipo alg\u00e9brico que encapsula o resultado da a\u00e7\u00e3o, mas diferenciar a a\u00e7\u00e3o de outras fun\u00e7\u00f5es que resultem em String . Todas as a\u00e7\u00f5es retornam um IO a , onde a \u00e9 uma vari\u00e1vel de tipo, mesmo aquelas que n\u00e3o retornam nada de \u00fatil, como a a\u00e7\u00e3o putChar , que resulta em putChar :: Char -> IO () , isto \u00e9, o encapsulamento da tupla vazia (tamb\u00e9m conhecida como Unit ). Mas por qu\u00ea esta diferencia\u00e7\u00e3o? Para marcar fun\u00e7\u00f5es impuras e separ\u00e1-las das fun\u00e7\u00f5es puras . Este estigma de uma fun\u00e7\u00e3o impura serve para que o compilador Haskell determine quando a a\u00e7\u00e3o pode executar e quando n\u00e3o pode, sendo que uma fun\u00e7\u00e3o impura s\u00f3 pode executar dentro de outra fun\u00e7\u00e3o impura. Isso quer dizer que eu n\u00e3o consigo fazer uma a\u00e7\u00e3o de E/S e retornar somente o resultado desta a\u00e7\u00e3o, como em l\u00eaNomePura :: String l\u00eaNomePura = x <- getLine Na verdade, este c\u00f3digo nem compila, pois o que \u00e9 o resultado da express\u00e3o \u00e0 direita na equa\u00e7\u00e3o? Na verdade, ela nem \u00e9 uma express\u00e3o. > : t x <- getLine < no location info >: error : not an expression : \u2018 x <- getLine \u2019 Uma outra tentativa seria a seguinte. Mas como vimos, este c\u00f3digo n\u00e3o executa a a\u00e7\u00e3o, apenas d\u00e1 outro nome para a\u00e7\u00e3o getLine . l\u00eaNomeImpura :: IO String l\u00eaNomeImpura = getLine do O problema aqui \u00e9 que voc\u00ea n\u00e3o est\u00e1 descrevendo como um c\u00e1lculo acontece, mas dizendo ao processo que execute a\u00e7\u00f5es. Isso est\u00e1 muito mais para o paradigma imperativo que para o funcional. E de fato, para executar a\u00e7\u00f5es, voc\u00ea precisara usar o modo imperativo do Haskell, usando do . l\u00eaNomeImpura' :: IO String l\u00eaNomeImpura' = do putStr \"Digite o seu nome\" getLine O modo imperativo essencialmente diz que as a\u00e7\u00f5es devem ser executadas na ordem em que foram definidas e que o resultado do bloco \u00e9 o resultado da \u00faltima a\u00e7\u00e3o do bloco, neste exemplo, getLine . return Nem sempre o resultado ser\u00e1 gerado pela \u00faltima a\u00e7\u00e3o, e neste caso voc\u00ea ter\u00e1 que construir o resultado manualmente, como no c\u00f3digo a seguir, usando um return no final. l\u00eaNomeImpura' :: IO String l\u00eaNomeImpura' = do putStr \"Digite o seu nome\" x <- getLine putStr \"Obrigado\" return ( \"O nome \u00e9 : \" ++ x ) O return pode causar confus\u00e3o, pois ele n\u00e3o faz o que voc\u00ea imagina. O que ele faz \u00e9 construir um valor do tipo IO com o valor passado, e que pode ser usado como resposta para o bloco. > x = return 3 > x 3 > : t x x :: ( Monad m , Num a ) => m a let in Frequentemente voc\u00ea precisar\u00e1 intercalar c\u00f3digo puro com c\u00f3digo n\u00e3o puro, como no exemplo incorreto a seguir. import Data.Char main = do putStrLn \"Digite seu nome: \" nome <- getLine nomeMai\u00fasculo = map toUpper nome nomeMin\u00fasculo = map toLower nome putStrLn $ \"Ol\u00e1. Seu nome em letras mai\u00fasculas \u00e9 \" ++ nomeMai\u00fasculo ++ \" e em letras min\u00fasculas \u00e9 \" ++ nomeMin\u00fasculo Este exemplo, embora se assemelhe ao que outras linguagens fazem, n\u00e3o \u00e9 correto em Haskell pois o c\u00f3digo puro n\u00e3o pode ser invocado de forma imperativa, pois c\u00f3digos puros s\u00e3o defini\u00e7\u00f5es de equa\u00e7\u00f5es, n\u00e3o instru\u00e7\u00f5es de execu\u00e7\u00e3o. A forma apropriada para fazer as defini\u00e7\u00f5es de nomeMai\u00fasculo e nomeMin\u00fasculo de forma que sejam us\u00e1veis na invoca\u00e7\u00e3o de putStrLn \u00e9 via let e in ; bom, neste caso, como o contexto do let \u00e9 bem claro, o in \u00e9 omitido. import Data.Char main = do putStrLn \"Digite seu nome: \" nome <- getLine let nomeMai\u00fasculo = map toUpper nome nomeMin\u00fasculo = map toLower nome putStrLn $ \"Ol\u00e1. Seu nome em letras mai\u00fasculas \u00e9 \" ++ nomeMai\u00fasculo ++ \" e em letras min\u00fasculas \u00e9 \" ++ nomeMin\u00fasculo main At\u00e9 agora temos usado as fun\u00e7\u00f5es que escrevemos apenas dentro do GHCi, de modo interpretado, o que demanda uma instala\u00e7\u00e3o do interpretador. Quando escrevemos um programa para ser executado em outras m\u00e1quinas, normalmente queremos que ele seja um execut\u00e1vel auto-contido, isto \u00e9, que execute independentemente de haver ou n\u00e3o um interpretador Haskell em tais m\u00e1quinas. Para isso, devemos compilar o programa e gerar um arquivo execut\u00e1vel. Quando compilamos um programa Haskell, este deve ter uma fun\u00e7\u00e3o main (em um m\u00f3dulo que dever explicitamente denominado Main , caso tenha mais de um m\u00f3dulo), e que ser\u00e1 sempre a fun\u00e7\u00e3o invocada quando o execut\u00e1vel for invocado. Como a\u00e7\u00f5es de E/S s\u00f3 podem ser executadas dentro de outras a\u00e7\u00f5es de E/S, a fun\u00e7\u00e3o main deve ser uma a\u00e7\u00e3o E/S tamb\u00e9m. main :: IO () main = do putStrLn \"Digite seu nome: \" nome <- getLine putStrLn $ \"Ol\u00e1, \" ++ nome >> ghc --make main.hs [1 of 1] Compiling Main ( main.hs, main.o ) Linking main ... >> ./main Digite seu nome: Asdrubalino Ol\u00e1, Asdrubalino do \u00e9 a\u00e7\u00facar sint\u00e1tico TODO main = do print \"lala\" print \"lele\" print \"lili\" main = print \"lala\" >> print \"lele\" >> print \"lili\" Fun\u00e7\u00f5es \u00fateis sequence_ :: [ IO a ] -> IO () sequence :: [ IO a ] -> IO [ a ]","title":"IO"},{"location":"io/io/#entrada-e-saida","text":"Em programa\u00e7\u00e3o dizemos que uma fun\u00e7\u00e3o tem efeitos colaterais quando l\u00ea ou modifica qualquer estado al\u00e9m do que lhe foi passado como par\u00e2metro e suas vari\u00e1veis locais. Linguagens de funcionais puras n\u00e3o tem efeitos colaterais e \u00e9 por isso que toda vez que uma fun\u00e7\u00e3o \u00e9 invocada com os mesmos par\u00e2metros, ela retorna o mesmo resultado, assim como 2+2 = 4, sempre. O problema de ser uma linguagem funcional pura est\u00e1 em realizar Entrada e Sa\u00edda (E/S, I/O), ou seja, interagir com o mundo exterior ao programa em execu\u00e7\u00e3o, por exemplo lendo do teclado, manipulando arquivos, ou mesmo modificando o estado da mem\u00f3ria de v\u00eddeo para desenhar ou escrever algo na tela, pois isso \u00e9 um efeito colateral. Como E/S \u00e9 uma realidade dos programas de computador, as linguagens funcionais devem ou abdicar de sua pureza ou usar de artimanhas para realiz\u00e1-las. No caso de Haskell, E/S \u00e9 encapsulada em M\u00f4nadas, um conceito no qual n\u00e3o nos aprofundaremos neste curso.","title":"Entrada e Sa\u00edda"},{"location":"io/io/#acoes-de-es","text":"E/S \u00e9 executada por meio de uma a\u00e7\u00e3o E/S , uma fun\u00e7\u00e3o especial que se comunica com o mundo \"exterior\". As seguintes fun\u00e7\u00f5es s\u00e3o exemplos de a\u00e7\u00f5es que se comunicam com teclado e monitor. A\u00e7\u00e3o Descri\u00e7\u00e3o getChar L\u00ea um caractere do teclado. putChar Escreve um caractere na tela. getLine L\u00ea uma linha do teclado. putStr Escreve uma string na tela. putStrLn Escreve uma string na tela e quebra a linha.","title":"A\u00e7\u00f5es de E/S"},{"location":"io/io/#binding","text":"Uma vez que tenha visto estas fun\u00e7\u00f5es, \u00e9 natural que queira escrever algo como nome = getLine , mas isso n\u00e3o ter\u00e1 o efeito que voc\u00ea espera. Prelude > nome = getLine Prelude > nome lalala \"lalala\" Prelude > putStr nome < interactive >: 11 : 8 : error : \u2022 Couldn't match type \u2018 IO String \u2019 with \u2018 [ Char ] \u2019 Expected type : String Actual type : IO String \u2022 In the first argument of \u2018 putStr \u2019 , namely \u2018 nome \u2019 In the expression : putStr nome In an equation for \u2018 it \u2019 : it = putStr nome O que aconteceu no exemplo acima foi que a a\u00e7\u00e3o getLine foi atribu\u00edda a nome , n\u00e3o uma string. Para fazer o que voc\u00ea quer, isto \u00e9, executar uma a\u00e7\u00e3o e atribuir o seu resultado a uma vari\u00e1vel, precisamos usar o operador <- . Prelude > nome <- getLine lala Prelude > print nome \"lala\" Dizemos que o operador <- faz o binding (atrelamento) do valor \u00e0 vari\u00e1vel.","title":"binding"},{"location":"io/io/#io","text":"Se explorarmos o tipo das a\u00e7\u00f5es veremos que elas n\u00e3o tem retorno como esperar\u00edamos, por exemplo, getLine tem tipo getLine :: IO String . O IO no tipo do resultado \u00e9 um tipo alg\u00e9brico que encapsula o resultado da a\u00e7\u00e3o, mas diferenciar a a\u00e7\u00e3o de outras fun\u00e7\u00f5es que resultem em String . Todas as a\u00e7\u00f5es retornam um IO a , onde a \u00e9 uma vari\u00e1vel de tipo, mesmo aquelas que n\u00e3o retornam nada de \u00fatil, como a a\u00e7\u00e3o putChar , que resulta em putChar :: Char -> IO () , isto \u00e9, o encapsulamento da tupla vazia (tamb\u00e9m conhecida como Unit ). Mas por qu\u00ea esta diferencia\u00e7\u00e3o? Para marcar fun\u00e7\u00f5es impuras e separ\u00e1-las das fun\u00e7\u00f5es puras . Este estigma de uma fun\u00e7\u00e3o impura serve para que o compilador Haskell determine quando a a\u00e7\u00e3o pode executar e quando n\u00e3o pode, sendo que uma fun\u00e7\u00e3o impura s\u00f3 pode executar dentro de outra fun\u00e7\u00e3o impura. Isso quer dizer que eu n\u00e3o consigo fazer uma a\u00e7\u00e3o de E/S e retornar somente o resultado desta a\u00e7\u00e3o, como em l\u00eaNomePura :: String l\u00eaNomePura = x <- getLine Na verdade, este c\u00f3digo nem compila, pois o que \u00e9 o resultado da express\u00e3o \u00e0 direita na equa\u00e7\u00e3o? Na verdade, ela nem \u00e9 uma express\u00e3o. > : t x <- getLine < no location info >: error : not an expression : \u2018 x <- getLine \u2019 Uma outra tentativa seria a seguinte. Mas como vimos, este c\u00f3digo n\u00e3o executa a a\u00e7\u00e3o, apenas d\u00e1 outro nome para a\u00e7\u00e3o getLine . l\u00eaNomeImpura :: IO String l\u00eaNomeImpura = getLine","title":"IO"},{"location":"io/io/#do","text":"O problema aqui \u00e9 que voc\u00ea n\u00e3o est\u00e1 descrevendo como um c\u00e1lculo acontece, mas dizendo ao processo que execute a\u00e7\u00f5es. Isso est\u00e1 muito mais para o paradigma imperativo que para o funcional. E de fato, para executar a\u00e7\u00f5es, voc\u00ea precisara usar o modo imperativo do Haskell, usando do . l\u00eaNomeImpura' :: IO String l\u00eaNomeImpura' = do putStr \"Digite o seu nome\" getLine O modo imperativo essencialmente diz que as a\u00e7\u00f5es devem ser executadas na ordem em que foram definidas e que o resultado do bloco \u00e9 o resultado da \u00faltima a\u00e7\u00e3o do bloco, neste exemplo, getLine .","title":"do"},{"location":"io/io/#return","text":"Nem sempre o resultado ser\u00e1 gerado pela \u00faltima a\u00e7\u00e3o, e neste caso voc\u00ea ter\u00e1 que construir o resultado manualmente, como no c\u00f3digo a seguir, usando um return no final. l\u00eaNomeImpura' :: IO String l\u00eaNomeImpura' = do putStr \"Digite o seu nome\" x <- getLine putStr \"Obrigado\" return ( \"O nome \u00e9 : \" ++ x ) O return pode causar confus\u00e3o, pois ele n\u00e3o faz o que voc\u00ea imagina. O que ele faz \u00e9 construir um valor do tipo IO com o valor passado, e que pode ser usado como resposta para o bloco. > x = return 3 > x 3 > : t x x :: ( Monad m , Num a ) => m a","title":"return"},{"location":"io/io/#let-in","text":"Frequentemente voc\u00ea precisar\u00e1 intercalar c\u00f3digo puro com c\u00f3digo n\u00e3o puro, como no exemplo incorreto a seguir. import Data.Char main = do putStrLn \"Digite seu nome: \" nome <- getLine nomeMai\u00fasculo = map toUpper nome nomeMin\u00fasculo = map toLower nome putStrLn $ \"Ol\u00e1. Seu nome em letras mai\u00fasculas \u00e9 \" ++ nomeMai\u00fasculo ++ \" e em letras min\u00fasculas \u00e9 \" ++ nomeMin\u00fasculo Este exemplo, embora se assemelhe ao que outras linguagens fazem, n\u00e3o \u00e9 correto em Haskell pois o c\u00f3digo puro n\u00e3o pode ser invocado de forma imperativa, pois c\u00f3digos puros s\u00e3o defini\u00e7\u00f5es de equa\u00e7\u00f5es, n\u00e3o instru\u00e7\u00f5es de execu\u00e7\u00e3o. A forma apropriada para fazer as defini\u00e7\u00f5es de nomeMai\u00fasculo e nomeMin\u00fasculo de forma que sejam us\u00e1veis na invoca\u00e7\u00e3o de putStrLn \u00e9 via let e in ; bom, neste caso, como o contexto do let \u00e9 bem claro, o in \u00e9 omitido. import Data.Char main = do putStrLn \"Digite seu nome: \" nome <- getLine let nomeMai\u00fasculo = map toUpper nome nomeMin\u00fasculo = map toLower nome putStrLn $ \"Ol\u00e1. Seu nome em letras mai\u00fasculas \u00e9 \" ++ nomeMai\u00fasculo ++ \" e em letras min\u00fasculas \u00e9 \" ++ nomeMin\u00fasculo","title":"let in"},{"location":"io/io/#main","text":"At\u00e9 agora temos usado as fun\u00e7\u00f5es que escrevemos apenas dentro do GHCi, de modo interpretado, o que demanda uma instala\u00e7\u00e3o do interpretador. Quando escrevemos um programa para ser executado em outras m\u00e1quinas, normalmente queremos que ele seja um execut\u00e1vel auto-contido, isto \u00e9, que execute independentemente de haver ou n\u00e3o um interpretador Haskell em tais m\u00e1quinas. Para isso, devemos compilar o programa e gerar um arquivo execut\u00e1vel. Quando compilamos um programa Haskell, este deve ter uma fun\u00e7\u00e3o main (em um m\u00f3dulo que dever explicitamente denominado Main , caso tenha mais de um m\u00f3dulo), e que ser\u00e1 sempre a fun\u00e7\u00e3o invocada quando o execut\u00e1vel for invocado. Como a\u00e7\u00f5es de E/S s\u00f3 podem ser executadas dentro de outras a\u00e7\u00f5es de E/S, a fun\u00e7\u00e3o main deve ser uma a\u00e7\u00e3o E/S tamb\u00e9m. main :: IO () main = do putStrLn \"Digite seu nome: \" nome <- getLine putStrLn $ \"Ol\u00e1, \" ++ nome >> ghc --make main.hs [1 of 1] Compiling Main ( main.hs, main.o ) Linking main ... >> ./main Digite seu nome: Asdrubalino Ol\u00e1, Asdrubalino","title":"main"},{"location":"io/io/#do-e-acucar-sintatico","text":"TODO main = do print \"lala\" print \"lele\" print \"lili\" main = print \"lala\" >> print \"lele\" >> print \"lili\"","title":"do \u00e9 a\u00e7\u00facar sint\u00e1tico"},{"location":"io/io/#funcoes-uteis","text":"sequence_ :: [ IO a ] -> IO () sequence :: [ IO a ] -> IO [ a ]","title":"Fun\u00e7\u00f5es \u00fateis"},{"location":"io/iotest/","text":"","title":"Iotest"},{"location":"lambda/lambda/","text":"C\u00e1lculo \\(\\lambda\\) O c\u00e1lculo \\(\\lambda\\) ( \\(\\lambda\\) -calculus) \u00e9 um sistema formal para express\u00e3o de computa\u00e7\u00e3o desenvolvido pelo matem\u00e1tico Alonzo Church em 1930 e que serve de base para o paradigma de programa\u00e7\u00e3o funcional. O formalismo em si \u00e9 muito simples e consiste na descri\u00e7\u00e3o da computa\u00e7\u00e3o executada na forma de termos lambda, que podem dos seguintes tipos: constante: por exemplo, 4; 1 vari\u00e1vel: por exemplo, \\(x\\) ; abstra\u00e7\u00e3o: se \\(t\\) \u00e9 um termo lambda e \\(x\\) \u00e9 uma vari\u00e1vel, ent\u00e3o \\((\\lambda x.t)\\) \u00e9 uma abstra\u00e7\u00e3o, que define uma fun\u00e7\u00e3o onde \\(x\\) \u00e9 um par\u00e2metro a ser aplicado em \\(t\\) , por exemplo, a abstra\u00e7\u00e3o \\(\\lambda x.x*x\\) \u00e9 fun\u00e7\u00e3o \\(f(x) = x^2\\) ; aplica\u00e7\u00e3o: se \\(t\\) e \\(s\\) s\u00e3o termos, ent\u00e3o \\((ts)\\) \u00e9 uma aplica\u00e7\u00e3o, que representa a invoca\u00e7\u00e3o da fun\u00e7\u00e3o \\(t\\) com par\u00e2metro \\(s\\) , por exemplo, \\(((\\lambda x.x*x)3)\\) corresponde a invoca\u00e7\u00e3o de \\(f(3)\\) , onde \\(f(x) = x^2\\) . O c\u00e1lculo da computa\u00e7\u00e3o acontece pela aplica\u00e7\u00e3o sucessiva de certas regras de transforma\u00e7\u00e3o que reduzem (\"simplificam\") os termos at\u00e9 que um resultado seja obtido. As redu\u00e7\u00f5es \\(\\beta\\) s\u00e3o as mais importantes no contexto do nosso estudo, pois elas reduzem uma aplica\u00e7\u00f5es. Por exemplo, seja o termo lambda \\((\\lambda x.2 \\times x)5\\) ; a redu\u00e7\u00e3o \\(\\beta\\) reduz o termo pela substitui\u00e7\u00e3o de todas as ocorr\u00eancias de \\(x\\) por 5, que pode ser novamente substitu\u00eddo pela aplica\u00e7\u00e3o do operador \\(\\times\\) , isto \u00e9 \\[ \\begin{eqnarray} (\\lambda x.2 \\times x)5 &\\rightarrow_\\beta& 5 \\times 2 \\\\ &\\rightarrow& 10\\\\ \\end{eqnarray} \\] Algo muito importante na \\(\\beta\\) redu\u00e7\u00e3o \u00e9 que qualquer termo pode ser usado na substitui\u00e7\u00e3o de uma vari\u00e1vel, mesmo um termo que represente outra fun\u00e7\u00e3o, como na redu\u00e7\u00e3o seguinte. \\[ \\begin{eqnarray} (\\lambda f.f~5) (\\lambda x.x + 1) &\\rightarrow_\\beta& (\\lambda x.x + 1)5\\\\ &\\rightarrow_\\beta& 5 + 1\\\\ &\\rightarrow& 6\\\\ \\end{eqnarray} \\] Isso \u00e9 o que se denomina considerar fun\u00e7\u00f5es como cidad\u00e3os de primeira classe (do ingl\u00eas, first class citizens ), algo equivalente a dizer que fun\u00e7\u00f5es tamb\u00e9m tamb\u00e9m s\u00e3o dados. Em termos mais complexos, haver\u00e3o m\u00faltiplas possibilidades de redu\u00e7\u00e3o \\(\\beta\\) , como no exemplo seguinte, onde h\u00e1 duas possibilidades. Fa\u00e7amos primeiro a redu\u00e7\u00e3o da express\u00e3o mais interna. \\[ \\begin{eqnarray} (\\lambda x.\\lambda y.x + ((\\lambda x.x - 3) y)) 5~6 &\\rightarrow_\\beta& (\\lambda x.\\lambda y.x + (y - 3)) 5~6\\\\ &\\rightarrow_\\beta& (\\lambda y.5 + (y - 3)) 6 \\\\ &\\rightarrow_\\beta& 5 + (6 - 3) \\\\ &\\rightarrow& 5 + 3\\\\ &\\rightarrow& 8\\\\ \\end{eqnarray} \\] A outra possibilidade \u00e9 fazer a redu\u00e7\u00e3o primeiro da express\u00e3o mais externa, mas neste caso \u00e9 necess\u00e1rio observar que h\u00e1 dois \\(x\\) distintos no termo, e que somente um ser\u00e1 substitu\u00eddo por 5. \\[ \\begin{eqnarray} (\\lambda x.\\lambda y.x + ((\\lambda x.x - 3) y)) 5~6 &\\rightarrow_\\beta& (\\lambda y.5 + ((\\lambda x.x - 3) y))6 \\\\ &\\rightarrow_\\beta& 5 + ((\\lambda x.x - 3) 6) \\\\ &\\rightarrow_\\beta& 5 + (6 - 3) \\\\ &\\rightarrow& 5 + 3 \\\\ &\\rightarrow& 8 \\end{eqnarray} \\] Apesar da ordem de redu\u00e7\u00e3o diferente, o resultado deve ser obviamente o mesmo. Exerc\u00edcio Reduza o termo lambda \\(((\\lambda x.(\\lambda y. x + y)5) ((\\lambda y.y-3)7))\\) Resolu\u00e7\u00e3o 9 Rela\u00e7\u00e3o com Haskell \"Mas por qu\u00ea complicar tanto?\", voc\u00ea me pergunta; \"Haskell n\u00e3o \u00e9 complicado o suficiente para voc\u00ea?\" O objetivo n\u00e3o \u00e9 complicar, mas mostrar como o c\u00e1lculo \\(\\lambda\\) \u00e9 poderoso para representar computa\u00e7\u00f5es e, por conseguinte, como o Haskell tamb\u00e9m \u00e9. De fato, os conceitos discutidos at\u00e9 agora s\u00e3o a base das seguintes funcionalidades do Haskell. Fun\u00e7\u00f5es de alta ordem Fun\u00e7\u00f5es lambda (fun\u00e7\u00f5es an\u00f4nimas) Currying Avalia\u00e7\u00e3o pregui\u00e7osa Colocando de outra forma, Haskell \u00e9 apenas uma implementa\u00e7\u00e3o, com sintaxe mais amig\u00e1vel, do C\u00e1lculo \\(\\lambda\\) . Na verdade este n\u00e3o \u00e9 um termo lambda, mas uma simplifica\u00e7\u00e3o de como um termo lambda poderia ser usado para representar uma constante, n\u00e3o somente num\u00e9rica mas tamb\u00e9m, por exemplo, booleanos. A forma purista do c\u00e1lculo \\(\\lambda\\) seria muito complicada para este curso. \u21a9","title":"C\u00e1lculo \u03bb"},{"location":"lambda/lambda/#calculo-lambda","text":"O c\u00e1lculo \\(\\lambda\\) ( \\(\\lambda\\) -calculus) \u00e9 um sistema formal para express\u00e3o de computa\u00e7\u00e3o desenvolvido pelo matem\u00e1tico Alonzo Church em 1930 e que serve de base para o paradigma de programa\u00e7\u00e3o funcional. O formalismo em si \u00e9 muito simples e consiste na descri\u00e7\u00e3o da computa\u00e7\u00e3o executada na forma de termos lambda, que podem dos seguintes tipos: constante: por exemplo, 4; 1 vari\u00e1vel: por exemplo, \\(x\\) ; abstra\u00e7\u00e3o: se \\(t\\) \u00e9 um termo lambda e \\(x\\) \u00e9 uma vari\u00e1vel, ent\u00e3o \\((\\lambda x.t)\\) \u00e9 uma abstra\u00e7\u00e3o, que define uma fun\u00e7\u00e3o onde \\(x\\) \u00e9 um par\u00e2metro a ser aplicado em \\(t\\) , por exemplo, a abstra\u00e7\u00e3o \\(\\lambda x.x*x\\) \u00e9 fun\u00e7\u00e3o \\(f(x) = x^2\\) ; aplica\u00e7\u00e3o: se \\(t\\) e \\(s\\) s\u00e3o termos, ent\u00e3o \\((ts)\\) \u00e9 uma aplica\u00e7\u00e3o, que representa a invoca\u00e7\u00e3o da fun\u00e7\u00e3o \\(t\\) com par\u00e2metro \\(s\\) , por exemplo, \\(((\\lambda x.x*x)3)\\) corresponde a invoca\u00e7\u00e3o de \\(f(3)\\) , onde \\(f(x) = x^2\\) . O c\u00e1lculo da computa\u00e7\u00e3o acontece pela aplica\u00e7\u00e3o sucessiva de certas regras de transforma\u00e7\u00e3o que reduzem (\"simplificam\") os termos at\u00e9 que um resultado seja obtido. As redu\u00e7\u00f5es \\(\\beta\\) s\u00e3o as mais importantes no contexto do nosso estudo, pois elas reduzem uma aplica\u00e7\u00f5es. Por exemplo, seja o termo lambda \\((\\lambda x.2 \\times x)5\\) ; a redu\u00e7\u00e3o \\(\\beta\\) reduz o termo pela substitui\u00e7\u00e3o de todas as ocorr\u00eancias de \\(x\\) por 5, que pode ser novamente substitu\u00eddo pela aplica\u00e7\u00e3o do operador \\(\\times\\) , isto \u00e9 \\[ \\begin{eqnarray} (\\lambda x.2 \\times x)5 &\\rightarrow_\\beta& 5 \\times 2 \\\\ &\\rightarrow& 10\\\\ \\end{eqnarray} \\] Algo muito importante na \\(\\beta\\) redu\u00e7\u00e3o \u00e9 que qualquer termo pode ser usado na substitui\u00e7\u00e3o de uma vari\u00e1vel, mesmo um termo que represente outra fun\u00e7\u00e3o, como na redu\u00e7\u00e3o seguinte. \\[ \\begin{eqnarray} (\\lambda f.f~5) (\\lambda x.x + 1) &\\rightarrow_\\beta& (\\lambda x.x + 1)5\\\\ &\\rightarrow_\\beta& 5 + 1\\\\ &\\rightarrow& 6\\\\ \\end{eqnarray} \\] Isso \u00e9 o que se denomina considerar fun\u00e7\u00f5es como cidad\u00e3os de primeira classe (do ingl\u00eas, first class citizens ), algo equivalente a dizer que fun\u00e7\u00f5es tamb\u00e9m tamb\u00e9m s\u00e3o dados. Em termos mais complexos, haver\u00e3o m\u00faltiplas possibilidades de redu\u00e7\u00e3o \\(\\beta\\) , como no exemplo seguinte, onde h\u00e1 duas possibilidades. Fa\u00e7amos primeiro a redu\u00e7\u00e3o da express\u00e3o mais interna. \\[ \\begin{eqnarray} (\\lambda x.\\lambda y.x + ((\\lambda x.x - 3) y)) 5~6 &\\rightarrow_\\beta& (\\lambda x.\\lambda y.x + (y - 3)) 5~6\\\\ &\\rightarrow_\\beta& (\\lambda y.5 + (y - 3)) 6 \\\\ &\\rightarrow_\\beta& 5 + (6 - 3) \\\\ &\\rightarrow& 5 + 3\\\\ &\\rightarrow& 8\\\\ \\end{eqnarray} \\] A outra possibilidade \u00e9 fazer a redu\u00e7\u00e3o primeiro da express\u00e3o mais externa, mas neste caso \u00e9 necess\u00e1rio observar que h\u00e1 dois \\(x\\) distintos no termo, e que somente um ser\u00e1 substitu\u00eddo por 5. \\[ \\begin{eqnarray} (\\lambda x.\\lambda y.x + ((\\lambda x.x - 3) y)) 5~6 &\\rightarrow_\\beta& (\\lambda y.5 + ((\\lambda x.x - 3) y))6 \\\\ &\\rightarrow_\\beta& 5 + ((\\lambda x.x - 3) 6) \\\\ &\\rightarrow_\\beta& 5 + (6 - 3) \\\\ &\\rightarrow& 5 + 3 \\\\ &\\rightarrow& 8 \\end{eqnarray} \\] Apesar da ordem de redu\u00e7\u00e3o diferente, o resultado deve ser obviamente o mesmo. Exerc\u00edcio Reduza o termo lambda \\(((\\lambda x.(\\lambda y. x + y)5) ((\\lambda y.y-3)7))\\) Resolu\u00e7\u00e3o 9","title":"C\u00e1lculo  \\(\\lambda\\)"},{"location":"lambda/lambda/#relacao-com-haskell","text":"\"Mas por qu\u00ea complicar tanto?\", voc\u00ea me pergunta; \"Haskell n\u00e3o \u00e9 complicado o suficiente para voc\u00ea?\" O objetivo n\u00e3o \u00e9 complicar, mas mostrar como o c\u00e1lculo \\(\\lambda\\) \u00e9 poderoso para representar computa\u00e7\u00f5es e, por conseguinte, como o Haskell tamb\u00e9m \u00e9. De fato, os conceitos discutidos at\u00e9 agora s\u00e3o a base das seguintes funcionalidades do Haskell. Fun\u00e7\u00f5es de alta ordem Fun\u00e7\u00f5es lambda (fun\u00e7\u00f5es an\u00f4nimas) Currying Avalia\u00e7\u00e3o pregui\u00e7osa Colocando de outra forma, Haskell \u00e9 apenas uma implementa\u00e7\u00e3o, com sintaxe mais amig\u00e1vel, do C\u00e1lculo \\(\\lambda\\) . Na verdade este n\u00e3o \u00e9 um termo lambda, mas uma simplifica\u00e7\u00e3o de como um termo lambda poderia ser usado para representar uma constante, n\u00e3o somente num\u00e9rica mas tamb\u00e9m, por exemplo, booleanos. A forma purista do c\u00e1lculo \\(\\lambda\\) seria muito complicada para este curso. \u21a9","title":"Rela\u00e7\u00e3o com Haskell"},{"location":"types/","text":"Tipos Seja diasMes a fun\u00e7\u00e3o que calcula a quantidade de dias em um m\u00eas, dado o n\u00famero do m\u00eas, definida assim: diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 O que acontece se voc\u00ea passar 7.2 como argumento para a fun\u00e7\u00e3o? O resultado est\u00e1 correto? Isso nos leva a perguntar como definir que uma fun\u00e7\u00e3o s\u00f3 \u00e9 aplic\u00e1vel a n\u00fameros inteiros, do tipo inteiro. Em linguagens de programa\u00e7\u00e3o, um tipo \u00e9 um nome dado a uma cole\u00e7\u00e3o de valores que tem um mesmo comportamento na linguagem. Em C, por exemplo, temos os tipos int e short , ambos associados a valores inteiros mas com n\u00famero de bits diferentes usados para represent\u00e1-los. Algumas linguagens s\u00e3o denominadas fracamente tipadas , o que quer dizer que o uso de tipos \u00e9 relaxado e pode at\u00e9 ser alterado em tempo de execu\u00e7\u00e3o. Por exemplo, no seguinte c\u00f3digo em Python a vari\u00e1vel x assume tr\u00eas tipos diferentes, em momentos diferentes. x = \"lala\" print ( type ( x )) x = 10 print ( type ( x )) x = 10.0 print ( type ( x )) <class 'str' > <class 'int' > <class 'float' > J\u00e1 a linguagem Haskell \u00e9 o que chamamos de fortemente tipada , o que quer dizer que toda vari\u00e1vel, constante, e fun\u00e7\u00e3o tem apenas um tipo e este sempre pode ser determinado. Al\u00e9m disso, Haskell \u00e9 estaticamente tipada , ou seja, os tipos s\u00e3o determinados em tempo de compila\u00e7\u00e3o, em oposi\u00e7\u00e3o \u00e0s linguagens dinamicamente tipadas, que determinam o tipo durante a execu\u00e7\u00e3o do programa. Para definir o tipo de uma express\u00e3o, usa-se ap\u00f3s :: < Tipo > ap\u00f3s a mesma, como nos seguintes exemplos. > x = 1 :: Int > y = 1 :: Integer > z = 1 :: Double Assim como type em Python, o GHCi tem o comando : type (ou simplesmente : t ) que permite verificar o tipo de uma express\u00e3o. Por exemplo: > : type x x :: Int > : t y y :: Integer > : t z z :: Double Acontece que se se olharmos novamente para os exemplos de c\u00f3digo em Haskell vistos no cap\u00edtulo anterior, veremos que em lugar algum foram definidos tipos; isto \u00e9 poss\u00edvel porqu\u00ea Haskell consegue inferir os tipos dos dados de forma muito acurada, olhando para as fun\u00e7\u00f5es que manipulam os dados. Por exemplo, na pela defini\u00e7\u00e3o da fun\u00e7\u00e3o quad x = x * x , Haskell sabe que x precisa ser oper\u00e1vel com * , logo, precisa ser um n\u00famero. Apesar da capacidade de infer\u00eancia do Haskell, frequentemente especificamos tipos, principalmente para fun\u00e7\u00f5es, mais como uma forma de facilitar a leitura e manuten\u00e7\u00e3o do c\u00f3digo e para indicar sua inten\u00e7\u00e3o ao compilador, que ir\u00e1 testar se os tipos indicados podem ser satisfeitos pelo c\u00f3digo e lhe informar caso contr\u00e1rio.","title":"Tipos"},{"location":"types/#tipos","text":"Seja diasMes a fun\u00e7\u00e3o que calcula a quantidade de dias em um m\u00eas, dado o n\u00famero do m\u00eas, definida assim: diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 O que acontece se voc\u00ea passar 7.2 como argumento para a fun\u00e7\u00e3o? O resultado est\u00e1 correto? Isso nos leva a perguntar como definir que uma fun\u00e7\u00e3o s\u00f3 \u00e9 aplic\u00e1vel a n\u00fameros inteiros, do tipo inteiro. Em linguagens de programa\u00e7\u00e3o, um tipo \u00e9 um nome dado a uma cole\u00e7\u00e3o de valores que tem um mesmo comportamento na linguagem. Em C, por exemplo, temos os tipos int e short , ambos associados a valores inteiros mas com n\u00famero de bits diferentes usados para represent\u00e1-los. Algumas linguagens s\u00e3o denominadas fracamente tipadas , o que quer dizer que o uso de tipos \u00e9 relaxado e pode at\u00e9 ser alterado em tempo de execu\u00e7\u00e3o. Por exemplo, no seguinte c\u00f3digo em Python a vari\u00e1vel x assume tr\u00eas tipos diferentes, em momentos diferentes. x = \"lala\" print ( type ( x )) x = 10 print ( type ( x )) x = 10.0 print ( type ( x )) <class 'str' > <class 'int' > <class 'float' > J\u00e1 a linguagem Haskell \u00e9 o que chamamos de fortemente tipada , o que quer dizer que toda vari\u00e1vel, constante, e fun\u00e7\u00e3o tem apenas um tipo e este sempre pode ser determinado. Al\u00e9m disso, Haskell \u00e9 estaticamente tipada , ou seja, os tipos s\u00e3o determinados em tempo de compila\u00e7\u00e3o, em oposi\u00e7\u00e3o \u00e0s linguagens dinamicamente tipadas, que determinam o tipo durante a execu\u00e7\u00e3o do programa. Para definir o tipo de uma express\u00e3o, usa-se ap\u00f3s :: < Tipo > ap\u00f3s a mesma, como nos seguintes exemplos. > x = 1 :: Int > y = 1 :: Integer > z = 1 :: Double Assim como type em Python, o GHCi tem o comando : type (ou simplesmente : t ) que permite verificar o tipo de uma express\u00e3o. Por exemplo: > : type x x :: Int > : t y y :: Integer > : t z z :: Double Acontece que se se olharmos novamente para os exemplos de c\u00f3digo em Haskell vistos no cap\u00edtulo anterior, veremos que em lugar algum foram definidos tipos; isto \u00e9 poss\u00edvel porqu\u00ea Haskell consegue inferir os tipos dos dados de forma muito acurada, olhando para as fun\u00e7\u00f5es que manipulam os dados. Por exemplo, na pela defini\u00e7\u00e3o da fun\u00e7\u00e3o quad x = x * x , Haskell sabe que x precisa ser oper\u00e1vel com * , logo, precisa ser um n\u00famero. Apesar da capacidade de infer\u00eancia do Haskell, frequentemente especificamos tipos, principalmente para fun\u00e7\u00f5es, mais como uma forma de facilitar a leitura e manuten\u00e7\u00e3o do c\u00f3digo e para indicar sua inten\u00e7\u00e3o ao compilador, que ir\u00e1 testar se os tipos indicados podem ser satisfeitos pelo c\u00f3digo e lhe informar caso contr\u00e1rio.","title":"Tipos"},{"location":"types/basic/","text":"Tipos B\u00e1sicos e seus Operadores Como toda linguagem de programa\u00e7\u00e3o, Haskell tem v\u00e1rios tipos pr\u00e9-definidos para representar n\u00fameros, valores booleanos, e (sequ\u00eancias de) caracteres. Algo a se notar \u00e9 que os nomes dos tipos s\u00e3o iniciados com letras mai\u00fasculas , diferentemente dos nomes de fun\u00e7\u00f5es e vari\u00e1veis. N\u00fameros Os tipos b\u00e1sicos para a representa\u00e7\u00e3o de n\u00fameros em Haskell s\u00e3o apresentados na seguinte tabela. Observe que o tipo Integer ter precis\u00e3o arbitr\u00e1ria, ou seja, pode ser usado para representar n\u00fameros com \"qualquer\" quantidade de d\u00edgitos, diferentemente de Int , que s\u00f3 consegue representar n\u00fameros em uma faixa espec\u00edfica (64 bits). Tipos num\u00e9ricos Tipo Descri\u00e7\u00e3o Valores Int Inteiro de precis\u00e3o finita 4, -14, 2147483647 Integer Inteiro de precis\u00e3o arbitr\u00e1ria 30414093201713378043612608166064768844377641568960512000000000000 Float Ponto flutuante de precis\u00e3o simples 25.132742 Double Ponto flutuante de precis\u00e3o dupla 25.132741228718345 Operadores Diversos operadores s\u00e3o definidos para os tipos num\u00e9ricos b\u00e1sicos, como mostra a tabela a seguir. Operador Opera\u00e7\u00e3o Exemplo + Adi\u00e7\u00e3o 1 + 1 \u2b46 2 - Subtra\u00e7\u00e3o 1 - 1 \u2b46 0 * Multiplica\u00e7\u00e3o 1 * 1 \u2b46 1 / Divis\u00e3o 1 / 1 \u2b46 1 ^ Exponencia\u00e7\u00e3o 2 ^ 4 \u2b46 16 - Invers\u00e3o de sinal 2 - ( - 10 ) \u2b46 10 negate Invers\u00e3o de sinal 2 negate ( - 10 ) \u2b46 10 quot Divis\u00e3o inteira, truncado para o 0, i.e., quot a b \u00e9 igual a \\(\\lfloor\\frac{a}{b}\\rfloor\\) se \\(a>0\\) e \\(\\lceil\\frac{a}{b}\\rceil\\) se \\(a<0\\) quot 8 3 \u2b46 2 e quot ( - 8 ) 3 \u2b46 - 2 rem Resto da divis\u00e3o inteira, tal que ( quot x y ) * y + ( rem x y ) \u2b46 x rem 8 3 \u2b46 2 e rem ( - 8 ) 3 \u2b46 - 2 div Divis\u00e3o inteira, truncado para baixo, i.e., div a b \u00e9 igual a \\(\\lfloor\\frac{a}{b}\\rfloor\\) div 8 3 \u2b46 2 e div ( - 8 ) 3 \u2b46 - 3 mod M\u00f3dulo do inteiro, tal que ( div x y ) * y + ( mod x y ) \u2b46 x mod ( - 8 ) 3 \u2b46 1 e mod ( 8 ) 3 \u2b46 2 Infixo X Prefixo Observe que alguns destes operadores s\u00e3o naturalmente infixos, e.g., + , e outros, prefixos, e.g., rem . 1 Contudo, ambos podem ser usados da outra forma, como mostrado nos seguintes exemplos, em que os operadores infixos s\u00e3o envelopados em por par\u00eanteses e os pr\u00e9-fixos em aspas invertidas simples. 10 + 20 ( + ) 10 20 quot 10 3 10 ` quot ` 3 Tipos para n\u00fameros Caso voc\u00ea queira ou precise, pode especificar um tipo para um n\u00famero, por exemplo, 20 :: Int ou 20 :: Double . Exerc\u00edcios Usar todos os operadores Evidenciar diferen\u00e7as entrem quot/rem e div/mod. Booleanos Para representa\u00e7\u00e3o de valores l\u00f3gicos, Haskell define o tipo Bool . Tipo Descri\u00e7\u00e3o Valores Bool Booleano True ou False Para este tipo, temos os seguintes operadores. Operador Opera\u00e7\u00e3o && E l\u00f3gico || OU l\u00f3gico not Nega\u00e7\u00e3o == Igualdade /= Diferen\u00e7a Caracteres Finalmente, para a representa\u00e7\u00e3o de caracteres individuais, Haskell usa o tipo Char , e para sequ\u00eancias de caracteres, usa o tipo String . Exemplos dos dois tipos s\u00e3o apresentados na tabela a seguir. Tipo Descri\u00e7\u00e3o Valores Char Caractere '1'; 'a'; 'B' String Sequ\u00eancia de caracteres \"Eu\"; \"Hello\"; \"Zabumba\" O tipo String \u00e9, na verdade, apenas um \"apelido\" para o tipo lista de caracteres e, assim sendo, voltaremos a falar de String quando estudarmos listas, mais adiante. Haskell trabalha com caracteres Unicode, que incluem s\u00edmbolos e letras em diferentes l\u00ednguas, n\u00fameros, sinais de pontua\u00e7\u00e3o, separadores e outros caracteres especiais, como emojis e caracteres de controle. A seguir, algumas fun\u00e7\u00f5es de manipula\u00e7\u00e3o de caracteres. 3 Fun\u00e7\u00e3o Descri\u00e7\u00e3o Exemplo isSpace Testa se \u00e9 um espa\u00e7o em branco ' ' ) ou um dos seguintes caractere de controle \\ t , \\ n , \\ r , \\ f ou \\ v isSpace '\\ t' \u2b46 True e isSpace ' ' \u2b46 True isControl Testa se \u00e9 um caracter de controle isControl '\\ t' \u2b46 True isLetter Testa se \u00e9 uma letra isLetter 'A' \u2b46 True e isLetter '\\ t' \u2b46 False isDigit Testa se \u00e9 um d\u00edgito isDigit 'A' \u2b46 False e isDigit '3' \u2b46 True isLower Testa se \u00e9 uma letra min\u00fascula isLower 'a' \u2b46 True e isLower '\\ t' \u2b46 False isUpper Testa se \u00e9 uma letra mai\u00fascula isUpper 'A' \u2b46 True e isUpper '\\ t' \u2b46 False toLower Transforma uma letra em min\u00fascula toLower 'a' \u2b46 'a' e toLower 'A' \u2b46 'a' toUpper Transforma uma letra em mai\u00fascula toUpper 'A' \u2b46 'A' e toUpper 'a' \u2b46 'A' Operadores s\u00e3o fun\u00e7\u00f5es cujos nomes s\u00f3 contem caracteres especiais. Eles s\u00e3o naturalmente infixos. \u21a9 Observe que o o -10 est\u00e1 entre par\u00eanteses n\u00e3o porque o operador demanda, mas para deixar claro que o - faz parte do n\u00famero. \u21a9 \u21a9 Diversas outras fun\u00e7\u00f5es est\u00e3o dispon\u00edveis no pacote Data.Char . \u21a9","title":"B\u00e1sicos"},{"location":"types/basic/#tipos-basicos-e-seus-operadores","text":"Como toda linguagem de programa\u00e7\u00e3o, Haskell tem v\u00e1rios tipos pr\u00e9-definidos para representar n\u00fameros, valores booleanos, e (sequ\u00eancias de) caracteres. Algo a se notar \u00e9 que os nomes dos tipos s\u00e3o iniciados com letras mai\u00fasculas , diferentemente dos nomes de fun\u00e7\u00f5es e vari\u00e1veis.","title":"Tipos B\u00e1sicos e seus Operadores"},{"location":"types/basic/#numeros","text":"Os tipos b\u00e1sicos para a representa\u00e7\u00e3o de n\u00fameros em Haskell s\u00e3o apresentados na seguinte tabela. Observe que o tipo Integer ter precis\u00e3o arbitr\u00e1ria, ou seja, pode ser usado para representar n\u00fameros com \"qualquer\" quantidade de d\u00edgitos, diferentemente de Int , que s\u00f3 consegue representar n\u00fameros em uma faixa espec\u00edfica (64 bits).","title":"N\u00fameros"},{"location":"types/basic/#booleanos","text":"Para representa\u00e7\u00e3o de valores l\u00f3gicos, Haskell define o tipo Bool . Tipo Descri\u00e7\u00e3o Valores Bool Booleano True ou False Para este tipo, temos os seguintes operadores. Operador Opera\u00e7\u00e3o && E l\u00f3gico || OU l\u00f3gico not Nega\u00e7\u00e3o == Igualdade /= Diferen\u00e7a","title":"Booleanos"},{"location":"types/basic/#caracteres","text":"Finalmente, para a representa\u00e7\u00e3o de caracteres individuais, Haskell usa o tipo Char , e para sequ\u00eancias de caracteres, usa o tipo String . Exemplos dos dois tipos s\u00e3o apresentados na tabela a seguir. Tipo Descri\u00e7\u00e3o Valores Char Caractere '1'; 'a'; 'B' String Sequ\u00eancia de caracteres \"Eu\"; \"Hello\"; \"Zabumba\" O tipo String \u00e9, na verdade, apenas um \"apelido\" para o tipo lista de caracteres e, assim sendo, voltaremos a falar de String quando estudarmos listas, mais adiante. Haskell trabalha com caracteres Unicode, que incluem s\u00edmbolos e letras em diferentes l\u00ednguas, n\u00fameros, sinais de pontua\u00e7\u00e3o, separadores e outros caracteres especiais, como emojis e caracteres de controle. A seguir, algumas fun\u00e7\u00f5es de manipula\u00e7\u00e3o de caracteres. 3 Fun\u00e7\u00e3o Descri\u00e7\u00e3o Exemplo isSpace Testa se \u00e9 um espa\u00e7o em branco ' ' ) ou um dos seguintes caractere de controle \\ t , \\ n , \\ r , \\ f ou \\ v isSpace '\\ t' \u2b46 True e isSpace ' ' \u2b46 True isControl Testa se \u00e9 um caracter de controle isControl '\\ t' \u2b46 True isLetter Testa se \u00e9 uma letra isLetter 'A' \u2b46 True e isLetter '\\ t' \u2b46 False isDigit Testa se \u00e9 um d\u00edgito isDigit 'A' \u2b46 False e isDigit '3' \u2b46 True isLower Testa se \u00e9 uma letra min\u00fascula isLower 'a' \u2b46 True e isLower '\\ t' \u2b46 False isUpper Testa se \u00e9 uma letra mai\u00fascula isUpper 'A' \u2b46 True e isUpper '\\ t' \u2b46 False toLower Transforma uma letra em min\u00fascula toLower 'a' \u2b46 'a' e toLower 'A' \u2b46 'a' toUpper Transforma uma letra em mai\u00fascula toUpper 'A' \u2b46 'A' e toUpper 'a' \u2b46 'A' Operadores s\u00e3o fun\u00e7\u00f5es cujos nomes s\u00f3 contem caracteres especiais. Eles s\u00e3o naturalmente infixos. \u21a9 Observe que o o -10 est\u00e1 entre par\u00eanteses n\u00e3o porque o operador demanda, mas para deixar claro que o - faz parte do n\u00famero. \u21a9 \u21a9 Diversas outras fun\u00e7\u00f5es est\u00e3o dispon\u00edveis no pacote Data.Char . \u21a9","title":"Caracteres"},{"location":"types/functions/","text":"Tipos de fun\u00e7\u00f5es Agora que j\u00e1 conhecemos alguns tipos, podemos ver como us\u00e1-los na defini\u00e7\u00e3o de fun\u00e7\u00f5es. Para faz\u00ea-lo, devemos usar a seguinte sintaxe, onde o s\u00edmbolo :: pode ser lido como \u00e9 do tipo e -> como um separador dos tipos de par\u00e2metros formais e do tipo da sa\u00edda. nomeFuncao :: tipo_arg1 -> ... -> tipo_argN -> tipo_saida nomeFuncao arg1 ... argN = < definicao > Por exemplo, o prot\u00f3tipo da fun\u00e7\u00e3o diaMes , isto \u00e9, a defini\u00e7\u00e3o dos tipos de entrada e sa\u00edda da fun\u00e7\u00e3o, fica assim: diasMes :: Int -> Int diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 Esta defini\u00e7\u00e3o pode ent\u00e3o ser lida como \"a fun\u00e7\u00e3o diasMes \u00e9 do tipo que recebe um inteiro como entrada e retorna um inteiro como sa\u00edda. J\u00e1 uma fun\u00e7\u00e3o que calcula a m\u00e9dia de tr\u00eas n\u00fameros reais ter\u00e1 a seguinte defini\u00e7\u00e3o, incluindo o prot\u00f3tipo m3n :: Float -> Float -> Float -> Float m3n a b c = ( a + b + c ) / 2 Exerc\u00edcios Defina o prot\u00f3tipo da fun\u00e7\u00e3o de convers\u00e3o de Fahrenheit para Celsius f2c x = ( x - 32 ) / 1.8 Descubra a quanto 100f corresponde em C\u00e9lsius Resolu\u00e7\u00e3o f2c :: Float -> Float f2c x = ( x - 32 ) / 1.8 Defina o prot\u00f3tipo da soma de dois n\u00fameros inteiros soma2int a b = a + b Aplique a fun\u00e7\u00e3o aos valores 2 e 3. Aplique a fun\u00e7\u00e3o aos valores 2.0 e 3.0. Resolu\u00e7\u00e3o soma2int :: Int -> Int -> Int soma2int a b = a + b Aplique a fun\u00e7\u00e3o aos valores 2.0 e 3.0. Aplique a fun\u00e7\u00e3o aos valores 2 e 3. Defina o prot\u00f3tipo da soma de dois n\u00fameros reais soma2reais a b = a + b Resolu\u00e7\u00e3o soma2reais :: Float -> Float -> Float Explique a diferen\u00e7a de comportamento das duas \u00faltimas invoca\u00e7\u00f5es. Resolu\u00e7\u00e3o As fun\u00e7\u00f5es se comportam diferentemente, sendo que a primeira mostra um erro quando aplicada a dois n\u00fameros reais, porqu\u00ea \\(Z \\subset R\\) mas \\(R \\not\\subset Z\\) .","title":"Fun\u00e7\u00f5es"},{"location":"types/functions/#tipos-de-funcoes","text":"Agora que j\u00e1 conhecemos alguns tipos, podemos ver como us\u00e1-los na defini\u00e7\u00e3o de fun\u00e7\u00f5es. Para faz\u00ea-lo, devemos usar a seguinte sintaxe, onde o s\u00edmbolo :: pode ser lido como \u00e9 do tipo e -> como um separador dos tipos de par\u00e2metros formais e do tipo da sa\u00edda. nomeFuncao :: tipo_arg1 -> ... -> tipo_argN -> tipo_saida nomeFuncao arg1 ... argN = < definicao > Por exemplo, o prot\u00f3tipo da fun\u00e7\u00e3o diaMes , isto \u00e9, a defini\u00e7\u00e3o dos tipos de entrada e sa\u00edda da fun\u00e7\u00e3o, fica assim: diasMes :: Int -> Int diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 Esta defini\u00e7\u00e3o pode ent\u00e3o ser lida como \"a fun\u00e7\u00e3o diasMes \u00e9 do tipo que recebe um inteiro como entrada e retorna um inteiro como sa\u00edda. J\u00e1 uma fun\u00e7\u00e3o que calcula a m\u00e9dia de tr\u00eas n\u00fameros reais ter\u00e1 a seguinte defini\u00e7\u00e3o, incluindo o prot\u00f3tipo m3n :: Float -> Float -> Float -> Float m3n a b c = ( a + b + c ) / 2 Exerc\u00edcios Defina o prot\u00f3tipo da fun\u00e7\u00e3o de convers\u00e3o de Fahrenheit para Celsius f2c x = ( x - 32 ) / 1.8 Descubra a quanto 100f corresponde em C\u00e9lsius Resolu\u00e7\u00e3o f2c :: Float -> Float f2c x = ( x - 32 ) / 1.8 Defina o prot\u00f3tipo da soma de dois n\u00fameros inteiros soma2int a b = a + b Aplique a fun\u00e7\u00e3o aos valores 2 e 3. Aplique a fun\u00e7\u00e3o aos valores 2.0 e 3.0. Resolu\u00e7\u00e3o soma2int :: Int -> Int -> Int soma2int a b = a + b Aplique a fun\u00e7\u00e3o aos valores 2.0 e 3.0. Aplique a fun\u00e7\u00e3o aos valores 2 e 3. Defina o prot\u00f3tipo da soma de dois n\u00fameros reais soma2reais a b = a + b Resolu\u00e7\u00e3o soma2reais :: Float -> Float -> Float Explique a diferen\u00e7a de comportamento das duas \u00faltimas invoca\u00e7\u00f5es. Resolu\u00e7\u00e3o As fun\u00e7\u00f5es se comportam diferentemente, sendo que a primeira mostra um erro quando aplicada a dois n\u00fameros reais, porqu\u00ea \\(Z \\subset R\\) mas \\(R \\not\\subset Z\\) .","title":"Tipos de fun\u00e7\u00f5es"},{"location":"types/lists/","text":"Listas Listas s\u00e3o pe\u00e7as fundamentais no desenvolvimento de programas usando o paradigma funcional, por serem estruturas de dados que permitem agregar v\u00e1rias informa\u00e7\u00f5es na forma de uma cole\u00e7\u00e3o ordenada de elementos. Por exemplo, [ \"Eu\" , \"amo\" , \"programa\u00e7\u00e3o\" , \"funcional\" ] \u00e9 a cole\u00e7\u00e3o de quatro strings em que o primeiro elemento \u00e9 \"Eu\" , o segundo \"amo\" , o terceiro \"programa\u00e7\u00e3o\" e o quarto e \u00faltimo \"funcional\" . J\u00e1 [ 1 :: Int , 2 :: Int , 3 :: Int ] \u00e9 uma lista de 3 elementos do tipo Int , onde o primeiro elemento \u00e9 1, o segundo 2, e o terceiro 3. \"Mas e as tuplas?\", voc\u00ea pergunta, \"N\u00e3o s\u00e3o exatamente isto?\" Listas x Tuplas Listas tem duas particularidades que as diferenciam de tuplas. Primeiro, enquanto as tuplas ( 1 :: Int , 2 :: Int , 3 :: Int ) e ( 1 :: Int , 2 :: Int , 3 :: Int , 4 :: Int ) tem tipos diferentes, isto \u00e9, uma \u00e9 uma tupla de tr\u00eas inteiros e a outra uma tupla de quatro inteiros, as listas [ 1 :: Int , 2 :: Int , 3 :: Int ] e [ 1 :: Int , 2 :: Int , 3 :: Int , 4 :: Int ] tem exatamente o mesmo tipo, lista de inteiros , ou mais especificamente, [ Int ] . Ou seja, as cardinalidades das tuplas fazem parte do seu tipo mas n\u00e3o das listas e portanto listas com cardinalidades diferentes mas com elementos do mesmo tipo, s\u00e3o do mesmo tipo. Segundo, enquanto uma tupla pode ter elementos de tipos diferentes, todos os elementos de uma lista devem ser do mesmo tipo. Ou seja, enquanto \u00e9 poss\u00edvel definir x = ( \"Joao\" , 14 , True ) , n\u00e3o \u00e9 poss\u00edvel definir x = [ \"Joao\" , 14 , True ] . Ali\u00e1s, outra forma de escrever a lista [ 1 :: Int , 2 :: Int , 3 :: Int ] , especificando seu tipo, \u00e9 [ 1 , 2 , 3 ] :: [ Int ] . \u00c9 preciso observar contudo que \u00e9 poss\u00edvel construir uma lista [ 1 , 2 , 3 , 4 , 17 , 4.2 ] , mas isto s\u00f3 \u00e9 poss\u00edvel porqu\u00ea existe um tipo do qual todos os elementos da lista s\u00e3o derivados, no caso, Fractional . De fato, quando definimos este lista, Haskell automaticamente faz o boxing dos cinco primeiros valores para ponto flutuante. > z = [ 1 , 2 , 3 , 4 , 17 , 4.2 ] > z [ 1.0 , 2.0 , 3.0 , 4.0 , 17.0 , 4.2 ] > : t z z :: Fractional a => [ a ] J\u00e1 a tupla ( 1 , 2 , 3 , 4 , 17 , 4.2 ) tem elementos com tipos diferentes. 1 > : t t t :: ( Num , Num , Num , Num , Num , Fractional ) Uma vez diferenciadas das tuplas, estamos livres para explorar outros aspectos das listas, iniciando por como s\u00e3o constru\u00eddas. Estrutura Dado uma lista qualquer, de qualquer tipo, ela pode ser ou vazia ou n\u00e3o vazia, sendo que a lista vazia \u00e9 representada em Haskell por [] . Listas n\u00e3o vazias s\u00e3o representadas como a concatena\u00e7\u00e3o do primeiro elemento da lista com uma lista com os demais elementos, usando o operador de concatena\u00e7\u00e3o : , ou cons . Por exemplo, a lista dos n\u00fameros 1, 2 e 3 nesta ordem \u00e9 constru\u00edda como 1 : 2 : 3 :[] ; observe que como o 3 \u00e9 o \u00faltimo elemento da lista, a lista que vem depois do cons \u00e9 a lista vazia. > x = 1 : 2 : 3 :[] > x [ 1 , 2 , 3 ] Cabe\u00e7a e Cauda Estas partes da lista, isto \u00e9 o primeiro elemento e o restante, s\u00e3o o que chamamos de cabe\u00e7a ( head ) e cauda ( tail ) da lista. No exemplo anterior, 1 : 2 : 3 :[] , 1 \u00e9 a cabe\u00e7a e 2 : 3 :[] a cauda. Haskell inclusive define fun\u00e7\u00f5es para recuperar estas partes de uma lista qualquer. > head x 1 > tail x [ 2 , 3 ] Dado uma lista de elementos de um tipo qualquer, a cabe\u00e7a desta lista \u00e9 um elemento do mesmo tipo e a cauda \u00e9 lista de elementos do tipo. Logo, podemos subdividir a cauda tamb\u00e9m em uma cabe\u00e7a e uma cauda, no exemplo, 2 e 3 :[] . > head ( tail x ) 2 > tail ( tail x ) [ 3 ] Podemos aplicar head e tail mais uma vez na lista, obtendo 3 e [] como resultado. > head ( tail ( tail x )) 3 > tail ( tail ( tail x )) [] Mas e se formos al\u00e9m? Neste caso estar\u00edamos tentando identificar o primeiro elemento da lista, mas sendo a lista vazia, isto n\u00e3o \u00e9 poss\u00edvel. Tampouco podemos extrair a lista ap\u00f3s a cabe\u00e7a. > head [] *** Exception: Prelude . head : empty list > tail [] *** Exception: Prelude . tail : empty list Logo, qualquer itera\u00e7\u00e3o nos elementos de uma lista, geralmente especificada por uma recurs\u00e3o que extrai a cabe\u00e7a da lista a cada passo, precisa tomar cuidado para n\u00e3o tentar extrair a cabe\u00e7a da lista vazia, como veremos na sess\u00e3o sobre recurs\u00e3o aplicada a listas. Um pouco de a\u00e7\u00facar sint\u00e1tico A especifica\u00e7\u00e3o manual de uma lista usando o operador cons n\u00e3o \u00e9 muito utilizada na pr\u00e1tica, sendo a especifica\u00e7\u00e3o usando colchetes e v\u00edrgulas mais comum, como feito nos primeiros exemplos deste cap\u00edtulo, e \u00e9 inclusive como o pr\u00f3prio Haskell exibe as listas. O efeito final \u00e9 o mesmo, ficando para voc\u00ea a decis\u00e3o de qual constru\u00e7\u00e3o usar. 1 :[] \u00e9 igual a [ 1 ] 2 : 1 :[] \u00e9 igual a [ 2 , 1 ] As duas nota\u00e7\u00f5es podem at\u00e9 ser misturadas, como em 1 : 2 : [ 3 , 4 , 5 ] , que \u00e9 equivalente [ 1 , 2 , 3 , 4 , 5 ] . Strings Se o a\u00e7\u00facar sint\u00e1tico dos colchetes n\u00e3o representa economia em termos de digita\u00e7\u00e3o de listas em geral, quando falamos em listas de caracteres a economia \u00e9 clara e o resultado muito mais agrad\u00e1vel. Isto por que para listas de caracteres, como [ 'a' , 'b' , 'c' ] , podemos escrever simplesmente \"abc\" , com exatamente o mesmo efeito, e at\u00e9 misturar com o uso de cons. > \"abc\" \"abc\" > [ 'a' , 'b' , 'c' ] \"abc\" > 'a' : [ 'b' , 'c' ] \"abc\" > 'a' : \"bc\" \"abc\" Listas de caracteres tem este tratamento especial porqu\u00ea correspondem a strings , as quais j\u00e1 estamos acostumados as trabalhar usando aspas duplas. Este tipo \u00e9 t\u00e3o importante que tem um apelido na linguagem, String , e s\u00e3o a forma mais b\u00e1sica de se lidar com texto em Haskell. 2 Exerc\u00edcios Defina fun\u00e7\u00e3o que retorne substring de t elementos come\u00e7ando na posi\u00e7\u00e3o i minhaFuncao \"entrada1\" 2 2 retorna \"tr\" Defina fun\u00e7\u00e3o que retorne substring com os \u00faltimos u elementos minhaFuncao \"entrada1\" 2 retorna \"a1\" Defina fun\u00e7\u00e3o que receba duas strings e retorne a resultado da concatena\u00e7\u00e3o das substrings de t elementos come\u00e7ando na posi\u00e7\u00e3o i minhaFuncao \"entrada1\" \"entrada2\" 2 2 retorna \"trtr\" [qualquer coisa] Uma lista pode conter elementos de qualquer tipo, desde que todos os elementos sejam do mesmo tipo. Logo, uma lista pode conter tipos primitivos, mas tamb\u00e9m tipos complexos, como tuplas e outras listas. Vejamos alguns exemplos: [ 1 , 2 , 3 ] :: [ Int ] - Lista de inteiros. [[ 1 , 2 , 3 ]] :: [[ Int ]] - Lista de listas de inteiros de inteiros. [[ 1 , 2 , 3 ], [] ,[ 3 , 4 , 5 , 6 , 7 , 8 , 9 ]] :: [[ Int ]] - Lista de listas de inteiros de inteiros. [( 1 , 2 , 3 ),( 3 , 4 , 5 )] :: [( Int , Int , Int )] - Lista de triplas de inteiros. ( \"lala\" ,[ 'l' , 'a' ], 'l' : '\u00e3' : 'o' :[] ) - Tripla de listas de Char. [ \"lala\" ,[ 'l' , 'a' ], 'l' : '\u00e3' : 'o' :[] ] - Lista de listas de Char. [ True , False , True ] :: [ Bool ] - Lista de booleanos. [( 4 , Ouro ),( 5 , Paus )] :: [ Carta ] - Lista de cartas. [( 1 , 2 , 3 ),( 3 )] - Um bug. Fun\u00e7\u00f5es \u00fateis A seguir, uma pequena amostra das fun\u00e7\u00f5es dispon\u00edveis na biblioteca padr\u00e3o do Haskell para manipula\u00e7\u00e3o de listas, aplic\u00e1veis dependendo do tipo da lista. Por exemplo, reverse funciona para qualquer tipo de lista, prod apenas para n\u00fameros. Operador Opera\u00e7\u00e3o Exemplo ++ Concatena\u00e7\u00e3o de listas > \"foo\" ++ \"bar\" \"foobar\" !! Elemento no \u00edndice > [ 1 , 2 , 3 , 4 ] !! 2 3 reverse Lista ao contr\u00e1rio > reverse [ 1 , 2 , 3 , 4 ] [4,3,2,1] length Comprimento da string > length \"foo bar\" 7 last \u00daltimo elemento da lista > last \"foo bar\" r concat Retorna a concatena\u00e7\u00e3o das listas dentro de uma lista > concat [[ 1 , 2 , 3 , 4 ],[ 5 , 6 , 7 , 8 ]] [1,2,3,4,5,6,7,8] > concat [[[ 1 , 2 , 3 ]],[[ 4 , 5 , 6 ]]] [[ 1 , 2 , 3 ],[ 4 , 5 , 6 ]] elem Verifica se o par\u00e2metro \u00e9 um elemento da lista > elem 'o' \"foo bar\" True null Verifica se a lista \u00e9 vazia > null \"\" True > null [] True > null [ 1 , 2 ] False replicate Constr\u00f3i uma lista pela replica\u00e7\u00e3o de um elemento > replicate 4 ( 1 , 2 ) [( 1 , 2 ),( 1 , 2 ),( 1 , 2 ),( 1 , 2 )] take Sublista iniciando em 0 > take 3 1 : 2 : 3 : 4 : 5 :[] [ 1 , 2 , 3 ] drop Sublista come\u00e7ando em um \u00edndice > drop 3 [ 'f' , 'o' , 'o' , ' ' , 'b' , 'a' , 'r' ] \" bar\" takeWhile Sublista iniciando em 0 e at\u00e9 o primeiro elemento que n\u00e3o satisfaz ao crit\u00e9rio, exclusive > takeWhile ( < 4 ) [ 1 , 2 , 3 , 4 , 5 , 6 ] [ 1 , 2 , 3 ] dropWhile Sublista come\u00e7ando no primeiro elemento que n\u00e3o satisfaz ao crit\u00e9rio, inclusive > dropWhile ( < 4 ) [ 1 , 2 , 3 , 4 , 5 , 6 ] 4 , 5 , 6 splitAt Dupla das sublistas geradas pela divis\u00e3o no \u00edndice especificado > splitAt 3 [ 1 , 2 , 3 , 4 , 5 , 6 ] ([ 1 , 2 , 3 ],[ 4 , 5 , 6 ]) zip Lista de pares com os elementos das duas listas passadas como par\u00e2metro > zip [ 1 , 2 , 3 ] [ 4 , 5 , 6 ] [( 1 , 4 ),( 2 , 5 ),( 3 , 6 )] sum Somat\u00f3rio dos elementos da lista > sum [ 1 , 2 , 3 , 4 , 5 , 6 ] 16 product Produt\u00f3rio dos elementos da lista > product [ 1 , 2 , 3 , 4 , 5 , 6 ] 720 maximum Maior dos elemento lista > maximum [ 1 , 2 , 3 , 4 , 5 , 6 ] 6 minimum Menor dos elementos da lista > minimum [ 1 , 2 , 3 , 4 , 5 , 6 ] 1 Enumera\u00e7\u00e3o Para facilitar a vida dos desenvolvedores, Haskell permite a constru\u00e7\u00e3o de listas por enumera\u00e7\u00e3o, bastando para isso especificar o primeiro elemento da lista, opcionalmente o segundo, e o \u00faltimo elemento, isto \u00e9 [ < primE > {, segE } ..< ultE > ] . 3 > [ 11 , 13 .. 23 ] [ 11 , 13 , 15 , 17 , 19 , 21 , 23 ] > [ - 15 , - 13 .. 14 ] [ - 15 , - 13 , - 11 , - 9 , - 7 , - 5 , - 3 , - 1 , 1 , 3 , 5 , 7 , 9 , 11 , 13 ] Observe que Haskell determinou um passo de incremento igual a \\(13-11 = 2\\) no primeiro exemplo e \\((-13) - (-15) = 2\\) no segundo exemplo, e usou estes passos para gerar as lista. Tamb\u00e9m \u00e9 poss\u00edvel definir um passo negativo, como no pr\u00f3ximo exemplo. > [ 11 , 9 .. 0 ] [ 11 , 9 , 7 , 5 , 3 , 1 ] Como mencionado, o segundo elemento \u00e9 opcional na enumera\u00e7\u00e3o e caso n\u00e3o especificado, Haskell assume que seja \\(1\\) , como no exemplo a seguir. > [ 11 .. 23 ] [ 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 ] > [ 3.5 .. 10 ] [ 3.5 , 4.5 , 5.5 , 6.5 , 7.5 , 8.5 , 9.5 , 10.5 ] Contudo, n\u00e3o \u00e9 poss\u00edvel omitir o segundo elemento se a inten\u00e7\u00e3o for gerar uma lista com valores decrescentes. > [ 11 .. 0 ] [] A enumera\u00e7\u00e3o pode ser feita para outros tipos que n\u00e3o sejam num\u00e9ricos, bastando que exista uma rela\u00e7\u00e3o de ordem entre os elementos para que Haskell consiga \"incrementar\" a cada passo. Isso existe, por exemplo, entre os caracteres, mas possivelmente para tipos definidos pelo desenvolvedor. 4 Este ponto ser\u00e1 revisto depois que estudarmos tipos alg\u00e9bricos. > [ 'a' .. 'm' ] \"abcdefghijklm\" > data Naipe = Copas | Espada | Ouro | Paus deriving ( Ord , Eq , Enum , Show ) > [ Copas .. Ouro ] [ Copas , Espada , Ouro ] Exerc\u00edcio Defina uma fun\u00e7\u00e3o que dado um n\u00famero inteiro x, gere uma lista de 1 a x e de volta a 1. Resolu\u00e7\u00e3o vaiEVolta n = lista ++ drop 1 ( reverse lista ) where lista = [ 1 .. n ] > vaiEVolta 3 [ 1 , 2 , 3 , 2 , 1 ] Defina uma fun\u00e7\u00e3o que calcule o fatorial e um n\u00famero n, usando product e listas por enumera\u00e7\u00e3o. Resolu\u00e7\u00e3o fatorial n = product [ 1 .. n ] Compreens\u00e3o A compreens\u00e3o de listas \u00e9 uma forma de construir listas pela defini\u00e7\u00e3o de uma regra de constru\u00e7\u00e3o, e \u00e9 muito comum nas linguagens funcionais, incluindo Haskell. Defini\u00e7\u00e3o em fun\u00e7\u00e3o de outra lista Suponha que tenha uma lista de n\u00fameros e que gostaria de gerar uma nova lista em que cada valor da lista original \u00e9 acrescido de 30%. Com compreens\u00e3o de listas isto pode ser feito muito facilmente usando a compreens\u00e3o de listas [ e * 1.3 | e <- lista ] . Esta compreens\u00e3o diz que ser\u00e1 constru\u00edda uma lista cujos elementos ser\u00e3o da forma e * 1.3 , onde e s\u00e3o os elementos da lista original. Veja o exemplo de execu\u00e7\u00e3o. > lista = [ 10 , 20 , 30 , 40 , 100 ] > [ e * 1.3 | e <- lista ] [ 13.0 , 26.0 , 39.0 , 52.0 , 130.0 ] Sintaxe A compreens\u00e3o de listas \u00e9 baseada na compreens\u00e3o de conjuntos, da teoria de conjuntos da matem\u00e1tica. A seguinte compreens\u00e3o de conjuntos pode ser lida como o conjunto \\(A\\) formado pela aplica\u00e7\u00e3o da fun\u00e7\u00e3o \\(f\\) a todos os valores \\(x\\) tal que \\(x\\) pertence ao conjunto \\(C\\) e para os quais valem os predicados \\(P_i, 1\\leq i \\leq n\\) . \\(A = \\{ f(x) | x \\in C \\land P_1(x) \\land \\ldots \\land P_n(x)\\}\\) A compreens\u00e3o de listas \u00e9 similar a = [ f x | x <- c , p1 x , ... , pn x ] Uma diferen\u00e7a importante \u00e9 que enquanto n\u00e3o h\u00e1 ordem nos conjuntos, h\u00e1 ordem nas listas e a constru\u00e7\u00e3o \u00e9 feita na ordem da lista original. Listas infinitas Assim como \u00e9 poss\u00edvel expressar um conjunto infinito usando compreens\u00e3o de conjuntos, por exemplo o conjunto dos quadrados de todos os n\u00fameros naturais \\(S = \\{e^2 | e \\in \\mathcal{N} \\}\\) , podemos expressar listas infinitas usando enumera\u00e7\u00e3o e compreens\u00e3o de listas como lq = [ e ** 2 | e <- [ 1 .. ]] . \"Mas como \u00e9 poss\u00edvel?\", voc\u00ea me pergunta, afinal, a mem\u00f3ria do computador \u00e9 finita e portanto n\u00e3o poderia armazenar uma lista infinita. Esta \u00e9 uma das m\u00e1gicas de Haskell, conhecida como avalia\u00e7\u00e3o pregui\u00e7osa, e ser\u00e1 discutida mais adiante. Por enquanto, basta acreditar que, desde que voc\u00ea n\u00e3o tente enumerar todos os elementos, uma lista infinita pode se representada em Haskell. Podemos, inclusive, consultar alguns elementos da lista infinita constru\u00edda acima para, por exemplo, verificar se um certo n\u00famero \u00e9 um quadrado perfeito! > lq = [ e ** 2 | e <- [ 1 .. ]] > elem 4 lq True > elem 16 lq True Observe, contudo, que se um elemento n\u00e3o estiver na lista, a fun\u00e7\u00e3o nunca retornar\u00e1! > elem 3 lq ^ CInterrupted . Exerc\u00edcio Modifique o exemplo acima para limitar a quantidade de elementos que ser\u00e3o buscados na lista de quadrados. Resolu\u00e7\u00e3o > elem 16 ( take 100 lq ) True > elem 20 ( take 100 lq ) False > elem 64 ( take 5 lq ) False Compreens\u00e3o como uma itera\u00e7\u00e3o Sabendo que a fun\u00e7\u00e3o ord do m\u00f3dulo Data . Char converte um caractere para seu valor na tabela ASCII, imagine que voc\u00ea queira converter uma String para uma lista dos valores ASCII correspondentes. Isso pode ser feito trivialmente com compreens\u00e3o de listas. > import Data.Char ( ord ) Data . Char > [ ord e | e <- \"abcd,'dasdfa;lkqwoiur\" ] [ 97 , 98 , 99 , 100 , 44 , 39 , 100 , 97 , 115 , 100 , 102 , 97 , 59 , 108 , 107 , 113 , 119 , 111 , 105 , 117 , 114 ] Isto demonstra que a constru\u00e7\u00e3o da lista pode ser usada aplicar uma fun\u00e7\u00e3o a todos os elementos de um \"conjunto\". No pr\u00f3ximo exemplo, usamos esta habilidade para capitalizar de uma String. Data . Char > import Data.Char ( toUpper ) Data . Char > [ toUpper e | e <- \"abcd,'dasdfa;lkqwoiur\" ] \"ABCD,'DASDFA;LKQWOIUR\" A lista resultante pode tem tipos complexos como elementos, como no exemplo seguinte, em que compreens\u00e3o gera uma com tuplas com as vers\u00f5es min\u00fascula e em mai\u00fascula de cada letra encontrada na entrada. Data . Char > [ ( toUpper e , toLower e ) | e <- \"abCD\" ] [( 'A' , 'a' ),( 'B' , 'b' ),( 'C' , 'c' ),( 'D' , 'd' )] Exerc\u00edcio Explique [ ( e , chr (( ord e - ord 'a' + 10 ) mod 26 + (ord 'a'))) | e <- ['a'..'z']] Resolu\u00e7\u00e3o Retorna uma lista de tuplas em que os primeiros elementos s\u00e3o letras e seus pares s\u00e3o letras 10 posi\u00e7\u00f5es adiante no alfabeto, m\u00f3dulo 26. Predicados Imagine agora que voc\u00ea queira construir uma lista com os quadrados dos n\u00fameros naturais m\u00faltiplos de 3 e menores que 100. Neste caso, podemos adicionar um teste aos elementos sendo aplicados na constru\u00e7\u00e3o da lista > [ e ^ 2 | e <- [ 1 .. 100 ], e ` mod ` 3 == 0 ] [ 9 , 36 , 81 , 144 , 225 , 324 , 441 , 576 , 729 , 900 , 1089 , 1296 , 1521 , 1764 , 2025 , 2304 , 2601 , 2916 , 3249 , 3600 , 3969 , 4356 , 4761 , 5184 , 5625 , 6084 , 6561 , 7056 , 7569 , 8100 , 8649 , 9216 , 9801 ] Observe que os predicados em si podem ser t\u00e3o complexos quanto se queira. Data . Char > [ e ^ 2 | e <- [ 1 .. 100 ], e ` mod ` 3 == 0 , e ^ 2 ` mod ` 4 == 0 ] [ 36 , 144 , 324 , 576 , 900 , 1296 , 1764 , 2304 , 2916 , 3600 , 4356 , 5184 , 6084 , 7056 , 8100 , 9216 ] Exerc\u00edcio Usando compreens\u00e3o de listas, defina uma fun\u00e7\u00e3o que gera a lista dos divisores de um n\u00famero. Resolu\u00e7\u00e3o > divisores x = [ e | e <- [ 1 .. x ], x ` mod ` e == 0 ] > divisores 10 [ 1 , 2 , 5 , 10 ] Usando a fun\u00e7\u00e3o definida acima, defina uma fun\u00e7\u00e3o que teste se um n\u00famero \u00e9 primo. Resolu\u00e7\u00e3o > divisores x = [ e | e <- [ 1 .. x ], x ` mod ` e == 0 ] > primo x = divisores x == [ 1 , x ] > primo 7 True > primo 45 False M\u00faltiplos geradores Uma compreens\u00e3o de listas pode ter mais de um gerador ( <- ), o que faz com que todas as combina\u00e7\u00f5es dos elementos gerados sejam aplicadas \u00e0 fun\u00e7\u00e3o. Por exemplo, a seguinte compreens\u00e3o combina todos os n\u00fameros de 1 a 4 com todos os n\u00fameros de 1 a 4 na constru\u00e7\u00e3o de uma tupla de dois inteiros. > [( x , y ) | x <- [ 1 .. 4 ], y <- [ 1 .. 4 ]] [( 1 , 1 ),( 1 , 2 ),( 1 , 3 ),( 1 , 4 ),( 2 , 1 ),( 2 , 2 ),( 2 , 3 ),( 2 , 4 ),( 3 , 1 ),( 3 , 2 ),( 3 , 3 ),( 3 , 4 ),( 4 , 1 ),( 4 , 2 ),( 4 , 3 ),( 4 , 4 )] Veja que predicados podem ser normalmente aplicados a m\u00faltiplos geradores, como no seguinte exemplo, em que somente as combina\u00e7\u00f5es onde \\(x,y\\) s\u00e3o usadas. > [( x , y ) | x <- [ 1 .. 4 ], y <- [ 1 .. 4 ], x < y ] [( 1 , 2 ),( 1 , 3 ),( 1 , 4 ),( 2 , 3 ),( 2 , 4 ),( 3 , 4 )] \u00c9 importante observar que a ordem dos geradores altera a ordem dos elementos da lista gerada, pois para cada elemento gerado pelo primeiro gerador, ser\u00e1 combinado a cada elemento gerado pelo segundo. > [ ( x , y ) | x <- [ 1 .. 4 ], y <- [ 'a' .. 'd' ]] [( 1 , 'a' ),( 1 , 'b' ),( 1 , 'c' ),( 1 , 'd' ),( 2 , 'a' ),( 2 , 'b' ),( 2 , 'c' ),( 2 , 'd' ),( 3 , 'a' ),( 3 , 'b' ),( 3 , 'c' ),( 3 , 'd' ),( 4 , 'a' ),( 4 , 'b' ),( 4 , 'c' ),( 4 , 'd' )] > [ ( x , y ) | y <- [ 'a' .. 'd' ], x <- [ 1 .. 4 ]] [( 1 , 'a' ),( 2 , 'a' ),( 3 , 'a' ),( 4 , 'a' ),( 1 , 'b' ),( 2 , 'b' ),( 3 , 'b' ),( 4 , 'b' ),( 1 , 'c' ),( 2 , 'c' ),( 3 , 'c' ),( 4 , 'c' ),( 1 , 'd' ),( 2 , 'd' ),( 3 , 'd' ),( 4 , 'd' )] Al\u00e9m disso, \u00e9 poss\u00edvel definir um gerador em termos dos geradores anteriores. Por exemplo > [ ( x , y ) | x <- [ 1 .. 4 ], y <- [ 1 .. x ]] [( 1 , 1 ),( 2 , 1 ),( 2 , 2 ),( 3 , 1 ),( 3 , 2 ),( 3 , 3 ),( 4 , 1 ),( 4 , 2 ),( 4 , 3 ),( 4 , 4 )] Este construto \u00e9 deveras poderoso, pois geradores podem ser aplicados eles pr\u00f3prios a compreens\u00e3o de listas. Outra possibilidade \u00e9 a aplica\u00e7\u00e3o recursiva, como no seguinte c\u00f3digo. partitions [] = [ [] ] partitions ( x : xs ) = [ x : e | e <- partitions xs ] ++ partitions xs Exerc\u00edcio Explique o que a fun\u00e7\u00e3o acima faz, com um exemplo. Dado uma lista l , calcule todas as permuta\u00e7\u00f5es de seus elementos. Resolu\u00e7\u00e3o permuta\u00e7\u00f5es :: [ a ] -> [[ a ]] permuta\u00e7\u00f5es [] -> [ [] ] permuta\u00e7\u00f5es ( h : t ) = [ take n permCauda ++ [ h ] ++ drop n permCauda | n <- [ 0 .. length t ], permCauda <- permuta\u00e7\u00f5es t ] Foi feita uma pequena edi\u00e7\u00e3o na sa\u00edda do comando : t para claridade, pois o resultado real envolvia supertipos, a serem vistos mais adiante. \u21a9 Haskell define tamb\u00e9m o tipo Text , uma forma mais moderna e eficiente de se manipular texto, mas n\u00e3o discutiremos Text aqui. \u21a9 Par\u00e2metros especificados entre <> s\u00e3o obrigat\u00f3rios e entre {} s\u00e3o opcionais. \u21a9 No exemplo, observe o espa\u00e7o entre Copas e .. . \u21a9","title":"Listas"},{"location":"types/lists/#listas","text":"Listas s\u00e3o pe\u00e7as fundamentais no desenvolvimento de programas usando o paradigma funcional, por serem estruturas de dados que permitem agregar v\u00e1rias informa\u00e7\u00f5es na forma de uma cole\u00e7\u00e3o ordenada de elementos. Por exemplo, [ \"Eu\" , \"amo\" , \"programa\u00e7\u00e3o\" , \"funcional\" ] \u00e9 a cole\u00e7\u00e3o de quatro strings em que o primeiro elemento \u00e9 \"Eu\" , o segundo \"amo\" , o terceiro \"programa\u00e7\u00e3o\" e o quarto e \u00faltimo \"funcional\" . J\u00e1 [ 1 :: Int , 2 :: Int , 3 :: Int ] \u00e9 uma lista de 3 elementos do tipo Int , onde o primeiro elemento \u00e9 1, o segundo 2, e o terceiro 3. \"Mas e as tuplas?\", voc\u00ea pergunta, \"N\u00e3o s\u00e3o exatamente isto?\"","title":"Listas"},{"location":"types/lists/#listas-x-tuplas","text":"Listas tem duas particularidades que as diferenciam de tuplas. Primeiro, enquanto as tuplas ( 1 :: Int , 2 :: Int , 3 :: Int ) e ( 1 :: Int , 2 :: Int , 3 :: Int , 4 :: Int ) tem tipos diferentes, isto \u00e9, uma \u00e9 uma tupla de tr\u00eas inteiros e a outra uma tupla de quatro inteiros, as listas [ 1 :: Int , 2 :: Int , 3 :: Int ] e [ 1 :: Int , 2 :: Int , 3 :: Int , 4 :: Int ] tem exatamente o mesmo tipo, lista de inteiros , ou mais especificamente, [ Int ] . Ou seja, as cardinalidades das tuplas fazem parte do seu tipo mas n\u00e3o das listas e portanto listas com cardinalidades diferentes mas com elementos do mesmo tipo, s\u00e3o do mesmo tipo. Segundo, enquanto uma tupla pode ter elementos de tipos diferentes, todos os elementos de uma lista devem ser do mesmo tipo. Ou seja, enquanto \u00e9 poss\u00edvel definir x = ( \"Joao\" , 14 , True ) , n\u00e3o \u00e9 poss\u00edvel definir x = [ \"Joao\" , 14 , True ] . Ali\u00e1s, outra forma de escrever a lista [ 1 :: Int , 2 :: Int , 3 :: Int ] , especificando seu tipo, \u00e9 [ 1 , 2 , 3 ] :: [ Int ] . \u00c9 preciso observar contudo que \u00e9 poss\u00edvel construir uma lista [ 1 , 2 , 3 , 4 , 17 , 4.2 ] , mas isto s\u00f3 \u00e9 poss\u00edvel porqu\u00ea existe um tipo do qual todos os elementos da lista s\u00e3o derivados, no caso, Fractional . De fato, quando definimos este lista, Haskell automaticamente faz o boxing dos cinco primeiros valores para ponto flutuante. > z = [ 1 , 2 , 3 , 4 , 17 , 4.2 ] > z [ 1.0 , 2.0 , 3.0 , 4.0 , 17.0 , 4.2 ] > : t z z :: Fractional a => [ a ] J\u00e1 a tupla ( 1 , 2 , 3 , 4 , 17 , 4.2 ) tem elementos com tipos diferentes. 1 > : t t t :: ( Num , Num , Num , Num , Num , Fractional ) Uma vez diferenciadas das tuplas, estamos livres para explorar outros aspectos das listas, iniciando por como s\u00e3o constru\u00eddas.","title":"Listas x Tuplas"},{"location":"types/lists/#estrutura","text":"Dado uma lista qualquer, de qualquer tipo, ela pode ser ou vazia ou n\u00e3o vazia, sendo que a lista vazia \u00e9 representada em Haskell por [] . Listas n\u00e3o vazias s\u00e3o representadas como a concatena\u00e7\u00e3o do primeiro elemento da lista com uma lista com os demais elementos, usando o operador de concatena\u00e7\u00e3o : , ou cons . Por exemplo, a lista dos n\u00fameros 1, 2 e 3 nesta ordem \u00e9 constru\u00edda como 1 : 2 : 3 :[] ; observe que como o 3 \u00e9 o \u00faltimo elemento da lista, a lista que vem depois do cons \u00e9 a lista vazia. > x = 1 : 2 : 3 :[] > x [ 1 , 2 , 3 ]","title":"Estrutura"},{"location":"types/lists/#funcoes-uteis","text":"A seguir, uma pequena amostra das fun\u00e7\u00f5es dispon\u00edveis na biblioteca padr\u00e3o do Haskell para manipula\u00e7\u00e3o de listas, aplic\u00e1veis dependendo do tipo da lista. Por exemplo, reverse funciona para qualquer tipo de lista, prod apenas para n\u00fameros. Operador Opera\u00e7\u00e3o Exemplo ++ Concatena\u00e7\u00e3o de listas > \"foo\" ++ \"bar\" \"foobar\" !! Elemento no \u00edndice > [ 1 , 2 , 3 , 4 ] !! 2 3 reverse Lista ao contr\u00e1rio > reverse [ 1 , 2 , 3 , 4 ] [4,3,2,1] length Comprimento da string > length \"foo bar\" 7 last \u00daltimo elemento da lista > last \"foo bar\" r concat Retorna a concatena\u00e7\u00e3o das listas dentro de uma lista > concat [[ 1 , 2 , 3 , 4 ],[ 5 , 6 , 7 , 8 ]] [1,2,3,4,5,6,7,8] > concat [[[ 1 , 2 , 3 ]],[[ 4 , 5 , 6 ]]] [[ 1 , 2 , 3 ],[ 4 , 5 , 6 ]] elem Verifica se o par\u00e2metro \u00e9 um elemento da lista > elem 'o' \"foo bar\" True null Verifica se a lista \u00e9 vazia > null \"\" True > null [] True > null [ 1 , 2 ] False replicate Constr\u00f3i uma lista pela replica\u00e7\u00e3o de um elemento > replicate 4 ( 1 , 2 ) [( 1 , 2 ),( 1 , 2 ),( 1 , 2 ),( 1 , 2 )] take Sublista iniciando em 0 > take 3 1 : 2 : 3 : 4 : 5 :[] [ 1 , 2 , 3 ] drop Sublista come\u00e7ando em um \u00edndice > drop 3 [ 'f' , 'o' , 'o' , ' ' , 'b' , 'a' , 'r' ] \" bar\" takeWhile Sublista iniciando em 0 e at\u00e9 o primeiro elemento que n\u00e3o satisfaz ao crit\u00e9rio, exclusive > takeWhile ( < 4 ) [ 1 , 2 , 3 , 4 , 5 , 6 ] [ 1 , 2 , 3 ] dropWhile Sublista come\u00e7ando no primeiro elemento que n\u00e3o satisfaz ao crit\u00e9rio, inclusive > dropWhile ( < 4 ) [ 1 , 2 , 3 , 4 , 5 , 6 ] 4 , 5 , 6 splitAt Dupla das sublistas geradas pela divis\u00e3o no \u00edndice especificado > splitAt 3 [ 1 , 2 , 3 , 4 , 5 , 6 ] ([ 1 , 2 , 3 ],[ 4 , 5 , 6 ]) zip Lista de pares com os elementos das duas listas passadas como par\u00e2metro > zip [ 1 , 2 , 3 ] [ 4 , 5 , 6 ] [( 1 , 4 ),( 2 , 5 ),( 3 , 6 )] sum Somat\u00f3rio dos elementos da lista > sum [ 1 , 2 , 3 , 4 , 5 , 6 ] 16 product Produt\u00f3rio dos elementos da lista > product [ 1 , 2 , 3 , 4 , 5 , 6 ] 720 maximum Maior dos elemento lista > maximum [ 1 , 2 , 3 , 4 , 5 , 6 ] 6 minimum Menor dos elementos da lista > minimum [ 1 , 2 , 3 , 4 , 5 , 6 ] 1","title":"Fun\u00e7\u00f5es \u00fateis"},{"location":"types/lists/#enumeracao","text":"Para facilitar a vida dos desenvolvedores, Haskell permite a constru\u00e7\u00e3o de listas por enumera\u00e7\u00e3o, bastando para isso especificar o primeiro elemento da lista, opcionalmente o segundo, e o \u00faltimo elemento, isto \u00e9 [ < primE > {, segE } ..< ultE > ] . 3 > [ 11 , 13 .. 23 ] [ 11 , 13 , 15 , 17 , 19 , 21 , 23 ] > [ - 15 , - 13 .. 14 ] [ - 15 , - 13 , - 11 , - 9 , - 7 , - 5 , - 3 , - 1 , 1 , 3 , 5 , 7 , 9 , 11 , 13 ] Observe que Haskell determinou um passo de incremento igual a \\(13-11 = 2\\) no primeiro exemplo e \\((-13) - (-15) = 2\\) no segundo exemplo, e usou estes passos para gerar as lista. Tamb\u00e9m \u00e9 poss\u00edvel definir um passo negativo, como no pr\u00f3ximo exemplo. > [ 11 , 9 .. 0 ] [ 11 , 9 , 7 , 5 , 3 , 1 ] Como mencionado, o segundo elemento \u00e9 opcional na enumera\u00e7\u00e3o e caso n\u00e3o especificado, Haskell assume que seja \\(1\\) , como no exemplo a seguir. > [ 11 .. 23 ] [ 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 ] > [ 3.5 .. 10 ] [ 3.5 , 4.5 , 5.5 , 6.5 , 7.5 , 8.5 , 9.5 , 10.5 ] Contudo, n\u00e3o \u00e9 poss\u00edvel omitir o segundo elemento se a inten\u00e7\u00e3o for gerar uma lista com valores decrescentes. > [ 11 .. 0 ] [] A enumera\u00e7\u00e3o pode ser feita para outros tipos que n\u00e3o sejam num\u00e9ricos, bastando que exista uma rela\u00e7\u00e3o de ordem entre os elementos para que Haskell consiga \"incrementar\" a cada passo. Isso existe, por exemplo, entre os caracteres, mas possivelmente para tipos definidos pelo desenvolvedor. 4 Este ponto ser\u00e1 revisto depois que estudarmos tipos alg\u00e9bricos. > [ 'a' .. 'm' ] \"abcdefghijklm\" > data Naipe = Copas | Espada | Ouro | Paus deriving ( Ord , Eq , Enum , Show ) > [ Copas .. Ouro ] [ Copas , Espada , Ouro ] Exerc\u00edcio Defina uma fun\u00e7\u00e3o que dado um n\u00famero inteiro x, gere uma lista de 1 a x e de volta a 1. Resolu\u00e7\u00e3o vaiEVolta n = lista ++ drop 1 ( reverse lista ) where lista = [ 1 .. n ] > vaiEVolta 3 [ 1 , 2 , 3 , 2 , 1 ] Defina uma fun\u00e7\u00e3o que calcule o fatorial e um n\u00famero n, usando product e listas por enumera\u00e7\u00e3o. Resolu\u00e7\u00e3o fatorial n = product [ 1 .. n ]","title":"Enumera\u00e7\u00e3o"},{"location":"types/lists/#compreensao","text":"A compreens\u00e3o de listas \u00e9 uma forma de construir listas pela defini\u00e7\u00e3o de uma regra de constru\u00e7\u00e3o, e \u00e9 muito comum nas linguagens funcionais, incluindo Haskell.","title":"Compreens\u00e3o"},{"location":"types/operators/","text":"Operadores Operadores s\u00e3o apenas fun\u00e7\u00f5es, mas fun\u00e7\u00f5es com algumas particularidades. Em primeiro lugar, operadores s\u00e3o fun\u00e7\u00f5es bin\u00e1rias, isto \u00e9, que recebem exatamente dois par\u00e2metros. Em segundo lugar, o nome do operador \u00e9 escrito apenas com s\u00edmbolos (sem letras e n\u00fameros). Em terceiro, operadores s\u00e3o naturalmente infixos, isto \u00e9, s\u00e3o colocados entre os dois operandos em sua invoca\u00e7\u00e3o. Veja o seguinte exemplo, em que se declara o operador ****** que \u00e9 essencialmente igual ao operador + . Observe que o prot\u00f3tipo \u00e9 especificado com o operador entre par\u00eanteses, mas o a defini\u00e7\u00e3o da equa\u00e7\u00e3o \u00e9 feita usando a nota\u00e7\u00e3o infixa. ( ****** ) :: Int -> Int -> Int x ****** y = x + y A invoca\u00e7\u00e3o do operador \u00e9 feita normalmente. > 1 ****** 3 4 > ( ****** ) 1 3 4 Prioridades Quando uma express\u00e3o tem v\u00e1rios operadores e fun\u00e7\u00f5es, estas s\u00e3o executadas na ordem e suas prioridades, a n\u00e3o ser que par\u00eanteses sejam usados para for\u00e7ar uma ordem de avalia\u00e7\u00e3o. > 1 + 2 * 3 7 > ( 1 + 2 ) * 3 9 As ordens de prioridade s\u00e3o dadas pela defini\u00e7\u00e3o dos operadores e podem ser verificadas usando o comando : i do GHCi. No resultado da execu\u00e7\u00e3o trecho adiante, abreviado, identificamos que os operadores de adi\u00e7\u00e3o, multiplica\u00e7\u00e3o e exponencia\u00e7\u00e3o tem, respectivamente, prioridades 6, 7 e 8. ghci > : i ( + ) ... infixl 6 + ghci > : i ( * ) ... infixl 7 * ghci > : i ( ^ ) ... infixr 8 ^ Observe que fun\u00e7\u00f5es normais tem prioridade maior que a dos operadores, independente de como s\u00e3o definidas. No exemplo a seguir, a fun\u00e7\u00e3o double nada mais \u00e9 que uma soma, mas ainda assim \u00e9 avaliada primeiro na quando imersa em uma express\u00e3o contendo operadores. > double x = x + x > 3 * double 2 + 1 13","title":"Operadores"},{"location":"types/operators/#operadores","text":"Operadores s\u00e3o apenas fun\u00e7\u00f5es, mas fun\u00e7\u00f5es com algumas particularidades. Em primeiro lugar, operadores s\u00e3o fun\u00e7\u00f5es bin\u00e1rias, isto \u00e9, que recebem exatamente dois par\u00e2metros. Em segundo lugar, o nome do operador \u00e9 escrito apenas com s\u00edmbolos (sem letras e n\u00fameros). Em terceiro, operadores s\u00e3o naturalmente infixos, isto \u00e9, s\u00e3o colocados entre os dois operandos em sua invoca\u00e7\u00e3o. Veja o seguinte exemplo, em que se declara o operador ****** que \u00e9 essencialmente igual ao operador + . Observe que o prot\u00f3tipo \u00e9 especificado com o operador entre par\u00eanteses, mas o a defini\u00e7\u00e3o da equa\u00e7\u00e3o \u00e9 feita usando a nota\u00e7\u00e3o infixa. ( ****** ) :: Int -> Int -> Int x ****** y = x + y A invoca\u00e7\u00e3o do operador \u00e9 feita normalmente. > 1 ****** 3 4 > ( ****** ) 1 3 4","title":"Operadores"},{"location":"types/tuples/","text":"Tuplas Nas fun\u00e7\u00f5es vistas at\u00e9 agora, todos os par\u00e2metros eram de algum tipo simples. Por exemplo, vejamos a fun\u00e7\u00e3o soma2n que soma 2 n\u00fameros: soma2n :: Int -> Int -> Int soma2n a b = a + b Muitas vezes estes tipos simples precisam ser associados para significar algo de mais alto n\u00edvel. Por exemplo, seja a fun\u00e7\u00e3o soma2v que soma as coordenadas x e y de 2 pontos representando dois vetores. Como poder\u00edamos definir tal fun\u00e7\u00e3o, j\u00e1 que o resultado deve ter informa\u00e7\u00e3o tanto sobre a coordenada x quanto y do resultado? soma2v :: Int -> Int -> Int -> Int -> \u2588\u2588\u2588\u2588\u2588\u2588 soma2v x1 y1 x2 y2 = \u2588\u2588\u2588\u2588\u2588 A resposta est\u00e1 no uso de tipos estruturados, que agregam outros tipos. No caso, a solu\u00e7\u00e3o ideal para o par ordenado est\u00e1 na forma de uma tupla de dois elementos. Tuplas s\u00e3o geralmente representadas usando a sintaxe ( Elem1 , Elem2 , ... , ElemN ) , tanto em Haskell como em diversas outras linguagens. Assim, a fun\u00e7\u00e3o soma2v pode ser redefinida como a seguir. Observe que a fun\u00e7\u00e3o define claramente que as tuplas ter\u00e3o 2 elementos e qual a vari\u00e1vel associada a cada um dos pontos. soma2v :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) soma2v p1 p2 = \u2588\u2588\u2588\u2588\u2588 Para acessar as diferentes coordenadas dentro das tuplas podemos usar as fun\u00e7\u00f5es fst e snd , 1 abrevia\u00e7\u00f5es para first e second e que retornam o primeiro e o segundo elemento de uma tupla de dois elementos, um par, respectivamente. Isto \u00e9, > snd ( 1 , 2 ) 2 > fst ( 3 , 4 ) 3 > fst ( snd (( 1 , 2 , 3 ),( 4 , 5 ))) 4 > fst ( 1 , 2 , 3 ) <== Erro ! Assim, usando fst e snd , a defini\u00e7\u00e3o da soma dos vetores fica como se segue: soma2v :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) soma2v p1 p2 = (( fst p1 ) + ( fst p2 ), ( snd p1 ) + ( snd p2 )) De forma simplificada, fst e snd poderiam ser definidos com a seguir. Observe que ambas as fun\u00e7\u00f5es esperam por uma dupla de valores e que uma vari\u00e1vel \u00e9 provida para cada elemento da dupla. Assim, como quando usamos vari\u00e1veis simples, os argumentos passados para a fun\u00e7\u00e3o s\u00e3o casados com as vari\u00e1veis e podem ser usados do lado direito da equa\u00e7\u00e3o. fst ( x , y ) = x snd ( x , y ) = y Sabendo que \u00e9 poss\u00edvel \"desmembrar\" a tupla em suas componentes, podemos redefinir a fun\u00e7\u00e3o soma2v como se segue, muito mais intuitiva. soma2v :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) soma2v ( x1 , y1 ) ( x2 , y2 ) = ( x1 + x2 , y1 + y2 ) Para usar a fun\u00e7\u00e3o, podemos invoc\u00e1-la de duas formas, usando a nota\u00e7\u00e3o prefixa ou infixa, com o mesmo resultado. > soma2v ( 3 , 4 ) ( 5 , 4 ) ( 8 , 8 ) > ( 3 , 4 ) ` soma2v ` ( 5 , 4 ) ( 8 , 8 ) Ignorando vari\u00e1veis Na pr\u00e1tica, mas ainda de forma simplificada, as fun\u00e7\u00f5es fst e snd s\u00e3o definidos assim. fst ( x , _ ) = x snd ( _ , y ) = y Observe que o _ \u00e9 usado em substitui\u00e7\u00e3o a um nome para vari\u00e1veis com as quais n\u00e3o nos importamos , isto \u00e9, que n\u00e3o ser\u00e3o usadas no dado escopo. A primeira vista isso poderia parecer uma forma de permitir ao compilador Haskell que otimizasse o uso de recursos, mas a verdade \u00e9 que o compilador consegue muito bem identificar quais vari\u00e1veis ser\u00e3o ou n\u00e3o ser\u00e3o usadas do lado direito da equa\u00e7\u00e3o. O uso de _ \u00e9 na verdade para permitir que o desenvolvedor demonstre que est\u00e1 ciente de que a vari\u00e1vel n\u00e3o foi usada. Exerc\u00edcio Considerando uma tupla de 4 elementos, defina 4 fun\u00e7\u00f5es que, aos moldes de fst e snd , extraiam cada um dos 4 elementos da tupla. N\u00e3o defina um prot\u00f3tipo. Resolu\u00e7\u00e3o prim ( x , _ , _ , _ ) = x segu ( _ , y , _ , _ ) = y terc ( _ , _ , z , _ ) = z quar ( _ , _ , _ , w ) = w Exerc\u00edcio Escreva uma fun\u00e7\u00e3o que receba um inteiro como par\u00e2metro e retorne uma tupla como resultado onde o primeiro elemento \u00e9 um booleano que indica se o n\u00famero \u00e9 negativo, e o segundo elemento \u00e9 o valor absoluto do n\u00famero. Resolu\u00e7\u00e3o \u00e9Neg x = if x < 0 then ( True , abs x ) else ( False , abs x ) \u00e9Neg' x = ( x < 0 , abs x ) Tuplas s\u00e3o como Structs Tuplas est\u00e3o para Haskell assim como estruturas est\u00e3o para outras linguagens. Por exemplo, imagine que se queira armazenar os dados nome, telefone, CPF e endere\u00e7o de uma pessoa. Poder\u00edamos convencionar que seria usado uma tupla em que cada posi\u00e7\u00e3o corresponderia a um dos dados. Neste caso, alguns exemplos de fun\u00e7\u00f5es \u00fateis s\u00e3o mostrados a seguir. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) Uma observa\u00e7\u00e3o a ser feita \u00e9 que, na \u00faltima fun\u00e7\u00e3o, nomear a vari\u00e1vel como _t tem o mesmo efeito que simplesmente _ para o compilador, mas deixa o c\u00f3digo mais leg\u00edvel. Outra observa\u00e7\u00e3o \u00e9 que mesmo com o uso _t , o c\u00f3digo fica rapidamente dif\u00edcil de se ler, pois o desenvolvedor deve manter em mente qual posi\u00e7\u00e3o corresponde a qual dado de uma pessoa. Veja o exemplo de uso das fun\u00e7\u00f5es. > x = fazPessoa \"jose da silva\" \"12345\" \"0003003093\" \"Av das Couves, 14\" > x => ( \"jose da silva\" , \"12345\" , \"0003003093\" , \"Av das Couves, 14\" ) > pegaNome x => \"jose da silva\" > pegaTelefone x => \"12345\" > y = trocaTelefone x \"54321\" > y => ( \"jose da silva\" , \"54321\" , \"0003003093\" , \"Av das Couves, 14\" ) Imagine estruturas mais complexas, contendo outros dados de cada pessoa, e v\u00e1rias outras estruturas semelhantes, como ordens de servi\u00e7o, descri\u00e7\u00e3o de invent\u00e1rios, cadastro de vendedores, etc. Veremos adiante como definir novos tipos de dados pode facilitar o desenvolvimento e n\u00e3o ter que ficar se lembrando das posi\u00e7\u00f5es dos valores dentro das tuplas. O tipo de um tupla Ao definirmos a fun\u00e7\u00e3o soma2v , definimos que o primeiro par\u00e2metro \u00e9 uma tupla com duas componentes do tipo Int , ou seja, ( Int , Int ) ; este \u00e9 o tipo do par\u00e2metro. Podemos confirmar esta informa\u00e7\u00e3o usando : t . > : t soma2v soma2v :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) Para outro exemplo, considere o tipo do resultado da fun\u00e7\u00e3o fazPessoa , uma tupla com quatro String . > x = fazPessoa \"jose da silva\" \"12345\" \"0003003093\" \"Av das Couves, 14\" > : t x x :: ( String , String , String , String ) Observe que tuplas podem ter componentes de tipos diferentes. Por exemplo, podemos ter uma tupla ( \"XMan: Primeira Turma\" , 2000 :: Int , 7.5 :: Float ) , cujo tipo \u00e9 ( String , Int , Float ) . > : t ( \"XMan: Primeira Turma\" , 2000 :: Int , 7.5 :: Float ) ( \"XMan: Primeira Turma\" , 2000 :: Int , 7.5 :: Float ) :: ( String , Int , Float ) Os tipos das componentes de uma tupla podem ter qualquer tipo v\u00e1lido, inclusive outra tupla, como em ( \"XMan: Primeira Turma\" , ( 3 :: Int , 4 :: Int , 2000 :: Int ), 7.5 :: Float ) , cujo tipo \u00e9 ( String , ( Int , Int , Int ), Float ) . > : t ( \"XMan: Primeira Turma\" , ( 3 :: Int , 4 :: Int , 2000 :: Int ), 7.5 :: Float ) ( \"XMan: Primeira Turma\" , ( 3 :: Int , 4 :: Int , 2000 :: Int ), 7.5 :: Float ) :: ( String , ( Int , Int , Int ), Float ) Ordem entre tuplas Dado duas tuplas com mesmo tipo (mesmo tamanho e tipo de suas componentes), podemos compar\u00e1-las lexicograficamente. Isto quer dizer que uma tupla \\(t_1\\) \u00e9 menor que uma tupla \\(t_2\\) se, considerando posi\u00e7\u00f5es da esquerda para a direita. Isto \u00e9, dado tupla \\(t^1\\) e uma tupla \\(t^2\\) , se o primeiro elemento da tupla \\(t^1\\) \u00e9 menor que o primeiro elemento da tupla \\(t^2\\) , ent\u00e3o \\(t^1 < t^2\\) . Caso o primeiro elemento de \\(t^2\\) seja menor, ent\u00e3o \\(t^2 < t^1\\) . E caso os primeiros elementos sejam iguais, a avalia\u00e7\u00e3o \u00e9 repetida para os segundos elementos e assim sucessivamente. > ( 1 , 2 ) < ( 1 , 3 ) True > ( 'a' , 2 ) < ( 'b' , 3 ) True > ( 'a' , 2 ) == ( 'b' , 3 ) False > ( 'a' , 2 ) > ( 'b' , 3 ) False > ( 1 , 2 ) < ( 1 , 3 , 4 ) <== Erro ! > ( 1 , 1 , 1 ) < ( 1 , 1 , 1 ) False > ( 1 , 1 , 1 ) < ( 1 , 1 , 2 ) True > ( 1 , 1 , 1 ) < ( 1 , 2 , 1 ) True > ( 1 , 1 , 1 ) < ( 2 , 1 , 1 ) True > ( 1 , 1 , 1 ) < ( 0 , 2 , 2 ) False Um exemplo do uso desta funcionalidade \u00e9 na compara\u00e7\u00e3o de datas, se as representarmos como tuplas com ano, m\u00eas e dia, nesta ordem . Neste caso, duas datas podem ser comparadas diretamente como compara\u00e7\u00e3o de tuplas. > ( 2000 , 01 , 01 ) < ( 1999 , 12 , 12 ) False > ( 2000 , 01 , 01 ) < ( 2001 , 12 , 12 ) True > ( 2000 , 01 , 01 ) < ( 2000 , 01 , 2 ) True A tupla vazia Por completude, \u00e9 preciso mencionar que tuplas podem ter qualquer aridade, inclusive zero. Isto \u00e9, () \u00e9 uma tupla v\u00e1lida e a \u00fanica inst\u00e2ncia de tuplas de aridade zero. A utilidade desta tupla, denominada Unit , ficar\u00e1 clara mais adiante, quando falarmos sobre entrada e sa\u00edda. Os operadores (, ... ,) Haskell tem v\u00e1rias inst\u00e2ncias de a\u00e7\u00facar sint\u00e1tico. Relativo a tuplas, Haskell prov\u00ea uma fun\u00e7\u00e3o para a constru\u00e7\u00e3o das mesmas, como alternativa \u00e0 sintaxe usada at\u00e9 agora. Por exemplo, para construir a tupla ( 1 , 2 ) , pode se usar (,) 1 2 , e #\u02dchs (,,,,) em vez de ( 1 , 2 , 3 , 4 , 5 ) . Esta possibilidade se estende pelo padr\u00e3o Haskell2010 at\u00e9 a constru\u00e7\u00e3o de tuplas com 15 elementos, mas o GHC vai at\u00e9 tuplas com cerca de 50 elementos. Fun\u00e7\u00f5es definidas no pacote Prelude . \u21a9","title":"Tuplas"},{"location":"types/tuples/#tuplas","text":"Nas fun\u00e7\u00f5es vistas at\u00e9 agora, todos os par\u00e2metros eram de algum tipo simples. Por exemplo, vejamos a fun\u00e7\u00e3o soma2n que soma 2 n\u00fameros: soma2n :: Int -> Int -> Int soma2n a b = a + b Muitas vezes estes tipos simples precisam ser associados para significar algo de mais alto n\u00edvel. Por exemplo, seja a fun\u00e7\u00e3o soma2v que soma as coordenadas x e y de 2 pontos representando dois vetores. Como poder\u00edamos definir tal fun\u00e7\u00e3o, j\u00e1 que o resultado deve ter informa\u00e7\u00e3o tanto sobre a coordenada x quanto y do resultado? soma2v :: Int -> Int -> Int -> Int -> \u2588\u2588\u2588\u2588\u2588\u2588 soma2v x1 y1 x2 y2 = \u2588\u2588\u2588\u2588\u2588 A resposta est\u00e1 no uso de tipos estruturados, que agregam outros tipos. No caso, a solu\u00e7\u00e3o ideal para o par ordenado est\u00e1 na forma de uma tupla de dois elementos. Tuplas s\u00e3o geralmente representadas usando a sintaxe ( Elem1 , Elem2 , ... , ElemN ) , tanto em Haskell como em diversas outras linguagens. Assim, a fun\u00e7\u00e3o soma2v pode ser redefinida como a seguir. Observe que a fun\u00e7\u00e3o define claramente que as tuplas ter\u00e3o 2 elementos e qual a vari\u00e1vel associada a cada um dos pontos. soma2v :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) soma2v p1 p2 = \u2588\u2588\u2588\u2588\u2588 Para acessar as diferentes coordenadas dentro das tuplas podemos usar as fun\u00e7\u00f5es fst e snd , 1 abrevia\u00e7\u00f5es para first e second e que retornam o primeiro e o segundo elemento de uma tupla de dois elementos, um par, respectivamente. Isto \u00e9, > snd ( 1 , 2 ) 2 > fst ( 3 , 4 ) 3 > fst ( snd (( 1 , 2 , 3 ),( 4 , 5 ))) 4 > fst ( 1 , 2 , 3 ) <== Erro ! Assim, usando fst e snd , a defini\u00e7\u00e3o da soma dos vetores fica como se segue: soma2v :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) soma2v p1 p2 = (( fst p1 ) + ( fst p2 ), ( snd p1 ) + ( snd p2 )) De forma simplificada, fst e snd poderiam ser definidos com a seguir. Observe que ambas as fun\u00e7\u00f5es esperam por uma dupla de valores e que uma vari\u00e1vel \u00e9 provida para cada elemento da dupla. Assim, como quando usamos vari\u00e1veis simples, os argumentos passados para a fun\u00e7\u00e3o s\u00e3o casados com as vari\u00e1veis e podem ser usados do lado direito da equa\u00e7\u00e3o. fst ( x , y ) = x snd ( x , y ) = y Sabendo que \u00e9 poss\u00edvel \"desmembrar\" a tupla em suas componentes, podemos redefinir a fun\u00e7\u00e3o soma2v como se segue, muito mais intuitiva. soma2v :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) soma2v ( x1 , y1 ) ( x2 , y2 ) = ( x1 + x2 , y1 + y2 ) Para usar a fun\u00e7\u00e3o, podemos invoc\u00e1-la de duas formas, usando a nota\u00e7\u00e3o prefixa ou infixa, com o mesmo resultado. > soma2v ( 3 , 4 ) ( 5 , 4 ) ( 8 , 8 ) > ( 3 , 4 ) ` soma2v ` ( 5 , 4 ) ( 8 , 8 )","title":"Tuplas"},{"location":"types/tuples/#o-tipo-de-um-tupla","text":"Ao definirmos a fun\u00e7\u00e3o soma2v , definimos que o primeiro par\u00e2metro \u00e9 uma tupla com duas componentes do tipo Int , ou seja, ( Int , Int ) ; este \u00e9 o tipo do par\u00e2metro. Podemos confirmar esta informa\u00e7\u00e3o usando : t . > : t soma2v soma2v :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) Para outro exemplo, considere o tipo do resultado da fun\u00e7\u00e3o fazPessoa , uma tupla com quatro String . > x = fazPessoa \"jose da silva\" \"12345\" \"0003003093\" \"Av das Couves, 14\" > : t x x :: ( String , String , String , String ) Observe que tuplas podem ter componentes de tipos diferentes. Por exemplo, podemos ter uma tupla ( \"XMan: Primeira Turma\" , 2000 :: Int , 7.5 :: Float ) , cujo tipo \u00e9 ( String , Int , Float ) . > : t ( \"XMan: Primeira Turma\" , 2000 :: Int , 7.5 :: Float ) ( \"XMan: Primeira Turma\" , 2000 :: Int , 7.5 :: Float ) :: ( String , Int , Float ) Os tipos das componentes de uma tupla podem ter qualquer tipo v\u00e1lido, inclusive outra tupla, como em ( \"XMan: Primeira Turma\" , ( 3 :: Int , 4 :: Int , 2000 :: Int ), 7.5 :: Float ) , cujo tipo \u00e9 ( String , ( Int , Int , Int ), Float ) . > : t ( \"XMan: Primeira Turma\" , ( 3 :: Int , 4 :: Int , 2000 :: Int ), 7.5 :: Float ) ( \"XMan: Primeira Turma\" , ( 3 :: Int , 4 :: Int , 2000 :: Int ), 7.5 :: Float ) :: ( String , ( Int , Int , Int ), Float )","title":"O tipo de um tupla"},{"location":"types/tuples/#ordem-entre-tuplas","text":"Dado duas tuplas com mesmo tipo (mesmo tamanho e tipo de suas componentes), podemos compar\u00e1-las lexicograficamente. Isto quer dizer que uma tupla \\(t_1\\) \u00e9 menor que uma tupla \\(t_2\\) se, considerando posi\u00e7\u00f5es da esquerda para a direita. Isto \u00e9, dado tupla \\(t^1\\) e uma tupla \\(t^2\\) , se o primeiro elemento da tupla \\(t^1\\) \u00e9 menor que o primeiro elemento da tupla \\(t^2\\) , ent\u00e3o \\(t^1 < t^2\\) . Caso o primeiro elemento de \\(t^2\\) seja menor, ent\u00e3o \\(t^2 < t^1\\) . E caso os primeiros elementos sejam iguais, a avalia\u00e7\u00e3o \u00e9 repetida para os segundos elementos e assim sucessivamente. > ( 1 , 2 ) < ( 1 , 3 ) True > ( 'a' , 2 ) < ( 'b' , 3 ) True > ( 'a' , 2 ) == ( 'b' , 3 ) False > ( 'a' , 2 ) > ( 'b' , 3 ) False > ( 1 , 2 ) < ( 1 , 3 , 4 ) <== Erro ! > ( 1 , 1 , 1 ) < ( 1 , 1 , 1 ) False > ( 1 , 1 , 1 ) < ( 1 , 1 , 2 ) True > ( 1 , 1 , 1 ) < ( 1 , 2 , 1 ) True > ( 1 , 1 , 1 ) < ( 2 , 1 , 1 ) True > ( 1 , 1 , 1 ) < ( 0 , 2 , 2 ) False Um exemplo do uso desta funcionalidade \u00e9 na compara\u00e7\u00e3o de datas, se as representarmos como tuplas com ano, m\u00eas e dia, nesta ordem . Neste caso, duas datas podem ser comparadas diretamente como compara\u00e7\u00e3o de tuplas. > ( 2000 , 01 , 01 ) < ( 1999 , 12 , 12 ) False > ( 2000 , 01 , 01 ) < ( 2001 , 12 , 12 ) True > ( 2000 , 01 , 01 ) < ( 2000 , 01 , 2 ) True","title":"Ordem entre tuplas"},{"location":"types/tuples/#a-tupla-vazia","text":"Por completude, \u00e9 preciso mencionar que tuplas podem ter qualquer aridade, inclusive zero. Isto \u00e9, () \u00e9 uma tupla v\u00e1lida e a \u00fanica inst\u00e2ncia de tuplas de aridade zero. A utilidade desta tupla, denominada Unit , ficar\u00e1 clara mais adiante, quando falarmos sobre entrada e sa\u00edda.","title":"A tupla vazia"},{"location":"types/tuples/#os-operadores","text":"Haskell tem v\u00e1rias inst\u00e2ncias de a\u00e7\u00facar sint\u00e1tico. Relativo a tuplas, Haskell prov\u00ea uma fun\u00e7\u00e3o para a constru\u00e7\u00e3o das mesmas, como alternativa \u00e0 sintaxe usada at\u00e9 agora. Por exemplo, para construir a tupla ( 1 , 2 ) , pode se usar (,) 1 2 , e #\u02dchs (,,,,) em vez de ( 1 , 2 , 3 , 4 , 5 ) . Esta possibilidade se estende pelo padr\u00e3o Haskell2010 at\u00e9 a constru\u00e7\u00e3o de tuplas com 15 elementos, mas o GHC vai at\u00e9 tuplas com cerca de 50 elementos. Fun\u00e7\u00f5es definidas no pacote Prelude . \u21a9","title":"Os operadores (,...,)"},{"location":"types2/algebraic/","text":"Tipos de dados alg\u00e9bricos Em se\u00e7\u00f5es anteriores, vimos que Haskell define diversos tipos de dados, como inteiros, booleanos e strings. Embora possamos usar os tipos b\u00e1sicos para resolver problemas, pode ser mais f\u00e1cil usar um vocabul\u00e1rio espec\u00edfico do problema, por exemplo data, nome, dire\u00e7\u00e3o, etc. Neste caso, podemos criar \"apelidos\" para tipos b\u00e1sicos, usando type . Mas Haskell \u00e9 mais poderoso que isso e permite que defina tipos novos a partir do zero. 1 Por exemplo, lembre-se do problemas discutidos que lidavam com cartas de baralho e como usamos uma dupla de String e Int para representar seus naipes e valores. Com data \u00e9 poss\u00edvel fazer algo melhor. data Com a palavra reservada data \u00e9 poss\u00edvel definir um novo tipo de dados (em ingl\u00eas, data ). O seguinte uso define um tipo para os naipes das cartas de um baralho. data Naipe = Copas | Espadas | Ouro | Paus Pela equa\u00e7\u00e3o seguinte, definimos o tipo de dados Naipe (lado esquerdo) como sendo igual a um dos valores do lado direito, dado que o lado direito \u00e9 uma disjun\u00e7\u00e3o. \u00c9 comum dizer que Naipe \u00e9 uma enumera\u00e7\u00e3o dos valores \u00e0 direita da equa\u00e7\u00e3o. Uma vez definido o tipo, podemos perguntar ao Haskell como ele \u00e9 interpretado. > data Naipe = Copas | Espadas | Ouro | Paus > : i Naipe type Naipe :: * data Naipe = Copas | Espadas | Ouro | Paus -- Defined at <interactive>:1:1 > : i Copas type Naipe :: * data Naipe = Copas | ... -- Defined at <interactive>:1:14 > : t Copas Copas :: Naipe Voc\u00ea tamb\u00e9m j\u00e1 pode usar o tipo em sua defini\u00e7\u00f5es, por exemplo: corDoNaipe :: Naipe -> String corDoNaipe Copas = \"Vermelho\" corDoNaipe Ouro = \"Vermelho\" corDoNaipe Paus = \"Preto\" corDoNaipe Espada = \"Preto\" Ou, equivalentemente, no seguinte exemplo. corDoNaipe :: Naipe -> String corDoNaipe n = case n of Copas -> \"Vermelho\" Ouro -> \"Vermelho\" Paus -> \"Preto\" Espada -> \"Preto\" Mas e o seguinte c\u00f3digo? corDoNaipe'' :: Naipe -> String corDoNaipe'' n | n == Copas = \"Vermelho\" | n == Ouro = \"Vermelho\" | n == Paus = \"Preto\" | n == Espada = \"Preto\" Se test\u00e1-lo, ver\u00e1 que n\u00e3o funciona. Um efeito semelhante \u00e9 observado quando fazemos algo mais simples ainda. Prelude > data Naipe = Copas | Espada | Ouro | Paus Prelude > Copas == Copas < interactive >: 2 : 1 : error : \u2022 No instance for ( Eq Naipe ) arising from a use of \u2018 == \u2019 \u2022 In the expression : Copas == Copas In an equation for \u2018 it \u2019 : it = Copas == Copas O problema aqui \u00e9 que Haskell n\u00e3o sabe como testar se dois naipes s\u00e3o iguais! Agora teste o seguinte. Prelude > True == True True Qual a diferen\u00e7a? Classes de tipos Observe que o tipo Bool foi definido da mesma forma, exceto por algumas informa\u00e7\u00f5es extra que aparecem quando o tipo \u00e9 descrito. Prelude > : i Bool type Bool :: * data Bool = False | True -- Defined in \u2018GHC.Types\u2019 instance Eq Bool -- Defined in \u2018GHC.Classes\u2019 instance Ord Bool -- Defined in \u2018GHC.Classes\u2019 instance Enum Bool -- Defined in \u2018GHC.Enum\u2019 instance Show Bool -- Defined in \u2018GHC.Show\u2019 instance Read Bool -- Defined in \u2018GHC.Read\u2019 instance Bounded Bool -- Defined in \u2018GHC.Enum\u2019 Mas o que s\u00e3o estas informa\u00e7\u00f5es extra? Fa\u00e7amos um teste, simplesmente avaliando um dos valores de Bool e de Naipe . > True True > Copas < interactive >: 9 : 1 : error : \u2022 No instance for ( Show Naipe ) arising from a use of \u2018 print \u2019 \u2022 In a stmt of an interactive GHCi command : print it O erro aparece porqu\u00ea quando a avalia\u00e7\u00e3o \u00e9 feita, o GHCi tenta imprimir o resultado na tela, e para imprimir o resultado ele tenta obter sua representa\u00e7\u00e3o como String usando a fun\u00e7\u00e3o show . > show True \"True\" > show Copas < interactive >: 11 : 1 : error : \u2022 No instance for ( Show Naipe ) arising from a use of \u2018 show \u2019 \u2022 In the expression : show Copas In an equation for \u2018 it \u2019 : it = show Copas No caso do valor booleano, a fun\u00e7\u00e3o funciona, mas no caso do naipe n\u00e3o! Volte no trecho acima onde descrevemos o valor verdadeiro. Uma das diferen\u00e7as para o naipe era a presen\u00e7a da linha instance Show Bool -- Defined in \u2018GHC.Show\u2019 que basicamente dizia que Bool faz parte da classe de tipos Show , a classe dos tipos que podem ser passados como par\u00e2metro para fun\u00e7\u00e3o show . H\u00e1 v\u00e1rias classes de tipo em Haskell, e voc\u00ea ainda pode criar as suas pr\u00f3prias. Show No caso do exemplo anterior, \u00e9 poss\u00edvel incluir o tipo naipe na classe em quest\u00e3o de uma forma manual definindo uma s\u00e9rie de fun\u00e7\u00f5es necess\u00e1rias ao Show ( : i Show ). Mas h\u00e1 um atalho que diz que todas as fun\u00e7\u00f5es necess\u00e1rias devem ser constru\u00eddas segundo um padr\u00e3o, que neste caso basicamente quer dizer que o valor em String \u00e9 simplesmente o texto usado na declara\u00e7\u00e3o. Para fazer isso, basta modificar a defini\u00e7\u00e3o da seguinte forma. data Naipe = Copas | Espadas | Ouro | Paus deriving ( Show ) Assim, podemos refazer as consultas e testes feitas anteriormente. Prelude > data Naipe = Copas | Espadas | Ouro | Paus deriving ( Show ) Prelude > : i Naipe type Naipe :: * data Naipe = Copas | Espadas | Ouro | Paus -- Defined at <interactive>:12:1 instance [ safe ] Show Naipe -- Defined at <interactive>:12:54 Prelude > show Copas \"Copas\" Prelude > Copas Copas Eq Assim como Show , Eq \u00e9 uma classe de tipo que define que todos os membros da class devem ter definidas algumas opera\u00e7\u00f5es, em espec\u00edfico, os operadores ( == ) e ( /= ) , como : i Eq mostra: > : i Eq type Eq :: * -> Constraint class Eq a where ( == ) :: a -> a -> Bool ( /= ) :: a -> a -> Bool {-# MINIMAL (==) | (/=) #-} ... Ord Por sua vez, Ord \u00e9 uma classe de tipo que define capacidades de compara\u00e7\u00e3o entre elementos de um tipo, como : i Ord mostra: > : i Ord type Ord :: * -> Constraint class Eq a => Ord a where compare :: a -> a -> Ordering ( < ) :: a -> a -> Bool ( <= ) :: a -> a -> Bool ( > ) :: a -> a -> Bool ( >= ) :: a -> a -> Bool max :: a -> a -> a min :: a -> a -> a {-# MINIMAL compare | (<=) #-} ... Observe que para que um tipo pertencer a Ord ele tamb\u00e9m deve pertencer a Eq . Enum Finalmente, Enum define a capacidade de, dado um valor de um certo tipo, determinar antecessores e sucessores, bem como construir listas por enumera\u00e7\u00e3o. > : i Enum type Enum :: * -> Constraint class Enum a where succ :: a -> a pred :: a -> a toEnum :: Int -> a fromEnum :: a -> Int enumFrom :: a -> [ a ] enumFromThen :: a -> a -> [ a ] enumFromTo :: a -> a -> [ a ] enumFromThenTo :: a -> a -> a -> [ a ] {-# MINIMAL toEnum, fromEnum #-} ... Read TODO read \"100\" :: Int Defini\u00e7\u00e3o completa Definindo o tipo para o naipe com todas estas classes de tipo, teremos um tipo bem interessante, que pode ser impresso na tela, comparado e usado para gerar listas por enumera\u00e7\u00e3o. > data Naipe = Copas | Espadas | Ouro | Paus deriving ( Show , Eq , Enum , Ord ) > [ Copas .. Paus ] [ Copas , Espadas , Ouro , Paus ] > pred Ouro Espadas Contudo, h\u00e1 limita\u00e7\u00f5es para o que se pode fazer com esta defini\u00e7\u00e3o, como demonstrado pelo pr\u00f3ximo exemplo. > pred Copas *** Exception: pred { Naipe } : tried to take ` pred' of first tag in enumeration CallStack ( from HasCallStack ) : error , called at < interactive >: 9 : 62 in interactive :Ghci1 Tipos mais complexos Mas e se quisermos definir um tipo para representar o valor de uma carta? data Valor = \u00c1s | N\u00famero1 | N\u00famero2 | N\u00famero3 | N\u00famero4 | N\u00famero5 | N\u00famero6 | N\u00famero7 | N\u00famero8 | N\u00famero9 | N\u00famero10 | Valete | Dama | Rei deriving ( Eq , Show , Ord , Enum ) Com esta defini\u00e7\u00e3o \u00e9 poss\u00edvel, por exemplo, comparar os valores das cartas. Mas, convenhamos, \u00e9 uma defini\u00e7\u00e3o horr\u00edvel. Haskell to the rescue! \u00c9 poss\u00edvel definir um valor que seja baseado em outro tipo, como no seguinte exemplo. data Valor = \u00c1s | N\u00famero Int | Valete | Dama | Rei N\u00famero Int define que qualquer combina\u00e7\u00e3o de N\u00famero , denominado o construtor , combinado com um valor do tipo #hs Int , \u00e9 um valor do tipo Valor . > data Valor = \u00c1s | N\u00famero Int | Valete | Dama | Rei deriving ( Eq , Show , Ord ) > as = \u00c1s > valete = Valete > nove = N\u00famero 9 > as \u00c1s > valete Valete > nove N\u00famero 9 Assim como Naipe pode ser usado em um casamento de padr\u00f5es, tamb\u00e9m a defini\u00e7\u00e3o de Valor pode, como no seguinte exemplo. \u00e9Figura :: Valor -> Bool \u00e9Figura ( N\u00famero _ ) -> False \u00e9Figura \u00c1s -> True -- Esta defini\u00e7\u00e3o \u00e9 desnecess\u00e1ria e usada s\u00f3 pra demonstra\u00e7\u00e3o. \u00e9Figura _ -> True Ord e Eq Como na defini\u00e7\u00e3o de Valor tanto Ord e Eq foram usados, Haskell deve ser capaz de comparar todas as possibilidades de valores. Assim, por exemplo, \u00c1s \u00e9 menor que qualquer n\u00famero, que \u00e9 menor que qualquer outra figura. Tamb\u00e9m quaisquer dois n\u00fameros podem ser comparados, sendo resultado determinado pela compara\u00e7\u00e3o dos respectivos inteiros. > data Valor = \u00c1s | N\u00famero Int | Valete | Dama | Rei deriving ( Eq , Show , Ord ) > N\u00famero 3 < N\u00famero 4 True > N\u00famero 3 == N\u00famero 4 False > \u00c1s < N\u00famero 10 True > \u00c1s < Rei True Observe que a defini\u00e7\u00e3o n\u00e3o inclui Enum , para entender porqu\u00ea, tente determinar qual seria o sucessor de \u00c1s e o antecessor de Valete . Como n\u00e3o \u00e9 poss\u00edvel determinar estes valores, o compilador nem permite que Enum seja usado. > data Valor = \u00c1s | N\u00famero Int | Valete | Dama | Rei deriving ( Eq , Show , Ord , Enum ) < interactive >: 21 : 79 : error : \u2022 Can't make a derived instance of \u2018 Enum Valor \u2019 : \u2018 Valor \u2019 must be an enumeration type ( an enumeration consists of one or more nullary , non - GADT constructors ) \u2022 In the data declaration for \u2018 Valor \u2019 Tipos mais complexos ainda Combinemos agora os tipos Naipe e Valor em um \u00fanico tipo que representa uma carta de baralho. A instancia\u00e7\u00e3o \u00e9 feita usando-se o construtor. > data Valor = \u00c1s | N\u00famero Int | Valete | Dama | Rei deriving ( Eq , Show , Ord ) > data Naipe = Copas | Espadas | Ouro | Paus deriving ( Show , Eq , Enum , Ord ) > data CartaT = Carta Naipe Valor deriving ( Eq , Show , Ord ) > Carta Paus Rei Carta Paus Rei > Carta Paus ( N\u00famero 3 ) Carta Paus ( N\u00famero 3 ) > Carta Paus ( N\u00famero 3 ) < Carta Paus Rei True > Carta Paus ( N\u00famero 3 ) < Carta Ouro Rei False > k = Carta Paus Rei > k Carta Paus Rei > : t k k :: CartaT > : i k k :: CartaT -- Defined at <interactive>:28:1 Veja que do lado esquerdo da equa\u00e7\u00e3o temos a defini\u00e7\u00e3o de um tipo CartaT e do lado direito temos a defini\u00e7\u00e3o de um construtor Carta para o tipo CartaT . \u00c9 poss\u00edvel solicitar mais informa\u00e7\u00f5es do Haskell tanto sobre o construtor quanto o tipo, mas nem todas as solicita\u00e7\u00f5es fazem sentido. Quanto ao tipo, CartaT , \u00e9 poss\u00edvel pedir informa\u00e7\u00f5es sobre a defini\u00e7\u00e3o, mas n\u00e3o o tipo da defini\u00e7\u00e3o. > : i CartaT type CartaT :: * data CartaT = Carta Naipe Valor -- Defined at <interactive>:26:1 instance [ safe ] Ord CartaT -- Defined at <interactive>:26:75 instance [ safe ] Show CartaT -- Defined at <interactive>:26:70 instance [ safe ] Eq CartaT -- Defined at <interactive>:26:67 > : t CartaT < interactive >: 1 : 1 : error : \u2022 Data constructor not in scope : CartaT \u2022 Perhaps you meant \u2018 Carta \u2019 ( line 26 ) Quanto ao construtor, Carta , \u00e9 poss\u00edvel perguntar as duas coisas. > : i Carta type CartaT :: * data CartaT = Carta Naipe Valor -- Defined at <interactive>:26:15 > : t Carta Carta :: Naipe -> Valor -> CartaT Veja que quanto perguntamos o tipo do construtor, a resposta \u00e9 que \u00e9 uma fun\u00e7\u00e3o que recebe Naipe e Valor e que retorna uma inst\u00e2ncia do tipo CartaT . Punning Uma vez que esteja claro que tipo e construtores s\u00e3o coisas diferentes, \u00e9 preciso dizer que seus contextos geralmente s\u00e3o diferentes e que, por isso, \u00e9 poss\u00edvel que ambos tenham o mesmo nome. De fato, esta \u00e9 uma abordagem comum na defini\u00e7\u00e3o de tipos alg\u00e9bricos em Haskell, denominada punning . > data Carta = Carta Naipe Valor deriving ( Eq , Show , Ord ) Prelude > a = Carta Copas \u00c1s Prelude > : i a a :: Carta -- Defined at <interactive>:39:1 Prelude > : t a a :: Carta Prelude > : i Carta type Carta :: * data Carta = Carta Naipe Valor -- Defined at <interactive>:38:1 instance [ safe ] Ord Carta -- Defined at <interactive>:38:74 instance [ safe ] Show Carta -- Defined at <interactive>:38:69 instance [ safe ] Eq Carta -- Defined at <interactive>:38:66 Prelude > : t Carta Carta :: Naipe -> Valor -> Carta Casamento de Padr\u00f5es Para que estes tipos sejam \u00fateis, precisamos us\u00e1-los em fun\u00e7\u00f5es, que \u00e9 direto e \u00f3bvio para os tipos mais simples, como visto anteriormente. corDoNaipe :: Naipe -> String corDoNaipe Copas = \"Vermelho\" corDoNaipe Ouro = \"Vermelho\" corDoNaipe Paus = \"Preto\" corDoNaipe Espada = \"Preto\" J\u00e1 para tipos que usam construtores, os padr\u00f5es devem incluir o construtor, como mostram as fun\u00e7\u00f5es a seguir. naipe :: CartaT -> Naipe naipe ( Carta n _ ) = n valor :: CartaT -> Valor valor ( Carta _ v ) = v valorNum\u00e9rico :: Valor -> Int valorNum\u00e9rico \u00c1s = 1 valorNum\u00e9rico ( N\u00famero i ) = i valorNum\u00e9rico Valete = 11 valorNum\u00e9rico Dama = 12 valorNum\u00e9rico Rei = 13 > valorNum\u00e9rico ( N\u00famero 4 ) 4 > valorNum\u00e9rico Rei 13 Exerc\u00edcios Usando tipos alg\u00e9bricos, defina os seguintes tipos e fun\u00e7\u00f5es relacionados a jogos de cartas Naipe Valor Carta Jogo - lista de cartas (apelido, n\u00e3o tipo alg\u00e9brico) \u00e9Canastra l - fun\u00e7\u00e3o que True se l \u00e9 uma sequ\u00eancia (possivelmente desordenada) de 7 cartas. temCanastra l - fun\u00e7\u00e3o que True se l contem uma sub-lista que \u00e9Canastra Usando tipos alg\u00e9bricos, defina as seguintes fun\u00e7\u00f5es e tipos Temperatura - tipo que pode conter um Tipo (Celsius, Kelvin, Farenheit) e um valor real. tempInCelsius - fun\u00e7\u00e3o que recebe uma temperatura qualquer e retorna uma Temperatura em Celsius. Item para outras temperaturas. Compreens\u00e3o de listas Imagine queira selecionar todas as cartas num\u00e9ricas de uma lista l de Carta. Usando compreens\u00e3o de listas, voce pode filtrar estes elementos simplesmente como [ e | N\u00famero e <- l ] . Isto \u00e9, o pr\u00f3prio gerador entende que somente tipos que casem com o construtor N\u00famero dever\u00e3o ser considerados. Nota\u00e7\u00e3o tipo \"record\" TODO Records Maybe Read \u00e9 uma classe de tipo \u00fatil por permitir que strings sejam usadas lidas e interpretadas como o tipo. O tipo Int e outros n\u00fameros, por exemplo, pertencem a esta classe, o que nos diz que podemos fazer o seguinte: > x = read \"100\" :: Int > x 100 > x = read \"100\" :: Float > x 100.0 Acontece que nem sempre a fun\u00e7\u00e3o ser\u00e1 bem sucedida em interpretar a string, por exemplo: > x = read \"Bolhufas\" :: Int > x *** Exception: Prelude . read : no parse Esta \u00e9 apenas uma de muitas situa\u00e7\u00f5es em que uma exce\u00e7\u00e3o pode ser causada por uma falha na execu\u00e7\u00e3o de alguma fun\u00e7\u00e3o. Outros exemplos s\u00e3o falhas de aloca\u00e7\u00e3o de mem\u00f3ria, de abertura de um arquivo no disco, de comunica\u00e7\u00e3o com outro processo via uma rede de computadores, etc. Nestas situa\u00e7\u00f5es, \u00e9 comum o uso do tipo Maybe a definido como se segue: > import Text.Read > : i Maybe data Maybe a = Nothing | Just a ... Este tipo permite que a fun\u00e7\u00e3o indique um erro ao retornar Nothing ou que um valor x foi recuperado da string usando ao retornar Just x . > x = readMaybe \"Bolhufas\" :: Maybe Int > x Nothing > x = readMaybe \"100\" :: Maybe Int > x Just 100 Tipos recursivos Como pode ver at\u00e9 agora, tipos alg\u00e9bricos tem muitos usos, a agora veremos um dos mais interessantes, na defini\u00e7\u00e3o de tipos recursivos. Considere uma lista, como definida pelo operador cons, : : uma lista \u00e9 a concatena\u00e7\u00e3o de um elemento, a cabe\u00e7a da lista, com uma outra lista, a cauda. Usando tipos alg\u00e9bricos, conseguimos representar listas da seguinte forma: data Lista a = Vazio | Elemento a ( Lista a ) deriving ( Show ) busca :: a -> Lista a -> Bool busca _ Vazio = False busca e ( Elemento x xs ) | e == x = True | busca e xs busca' :: a -> Lista a -> Bool busca' _ Vazio = False busca' e ( Elemento x xs ) = e == x || busca e xs > lV = Vazio > l1 = Elemento 1 ( Vazio ) > l2 = Elemento 2 ( Elemento 1 Vazio ) > lV Vazio > l1 Elemento 1 Vazio > l2 Elemento 2 ( Elemento 1 Vazio ) > busca' 1 lV False > busca' 1 l1 True > busca' 1 l2 True > busca' 2 l1 False Para outro exemplo, considere uma \u00e1rvore bin\u00e1ria, uma estrutura de dados formada por n\u00f3s que armazenam algum dado e apontam para outros dois n\u00f3s, denominados filhos \u00e0 esquerda e \u00e0 direita. data \u00c1rvore a = Nada | N\u00f3 a ( \u00c1rvore a ) ( \u00c1rvore a ) deriving ( Show ) {- >>> mudinha = N\u00f3 3 Nada Nada >>> N\u00f3 1 (N\u00f3 2 (N\u00f3 4 Nada Nada) Nada) (N\u00f3 3 Nada Nada) N\u00f3 1 (N\u00f3 2 (N\u00f3 4 Nada Nada) Nada) (N\u00f3 3 Nada Nada) -} adicionar :: ( Eq a , Ord a ) => a -> \u00c1rvore a -> \u00c1rvore a adicionar novoDado Nada = N\u00f3 novoDado Nada Nada adicionar novoDado \u00e1rvore @ ( N\u00f3 dadoExistente ae ad ) | novoDado == dadoExistente = \u00e1rvore | novoDado < dadoExistente = N\u00f3 dadoExistente ( adicionar novoDado ae ) ad | otherwise = N\u00f3 dadoExistente ad ( adicionar novoDado ad ) {- >>> arv = adicionar 3 (adicionar 4 (adicionar 10 (adicionar 1 (adicionar 2 (adicionar 3 (adicionar 7 Nada)))))) >>> arv N\u00f3 7 (N\u00f3 4 (N\u00f3 3 Nada Nada) Nada) (N\u00f3 10 Nada Nada) >>> impress\u00e3oEmOrdem arv \".3.4.7.10.\" -} impress\u00e3oEmOrdem :: ( Show a ) => \u00c1rvore a -> String impress\u00e3oEmOrdem Nada = \".\" impress\u00e3oEmOrdem ( N\u00f3 dado ae ad ) = impress\u00e3oEmOrdem ae ++ show dado ++ impress\u00e3oEmOrdem ad Exerc\u00edcio Implemente uma impress\u00e3o \"em ordem\" dos n\u00f3s da \u00e1rvore, que recebe uma \u00e1rvore e gera uma string com a resposta. Esta aula \u00e9 fortemente inspirada na video aula Enumeration Types, Show de Dave Sands. \u21a9","title":"Tipos alg\u00e9bricos"},{"location":"types2/algebraic/#tipos-de-dados-algebricos","text":"Em se\u00e7\u00f5es anteriores, vimos que Haskell define diversos tipos de dados, como inteiros, booleanos e strings. Embora possamos usar os tipos b\u00e1sicos para resolver problemas, pode ser mais f\u00e1cil usar um vocabul\u00e1rio espec\u00edfico do problema, por exemplo data, nome, dire\u00e7\u00e3o, etc. Neste caso, podemos criar \"apelidos\" para tipos b\u00e1sicos, usando type . Mas Haskell \u00e9 mais poderoso que isso e permite que defina tipos novos a partir do zero. 1 Por exemplo, lembre-se do problemas discutidos que lidavam com cartas de baralho e como usamos uma dupla de String e Int para representar seus naipes e valores. Com data \u00e9 poss\u00edvel fazer algo melhor.","title":"Tipos de dados alg\u00e9bricos"},{"location":"types2/algebraic/#data","text":"Com a palavra reservada data \u00e9 poss\u00edvel definir um novo tipo de dados (em ingl\u00eas, data ). O seguinte uso define um tipo para os naipes das cartas de um baralho. data Naipe = Copas | Espadas | Ouro | Paus Pela equa\u00e7\u00e3o seguinte, definimos o tipo de dados Naipe (lado esquerdo) como sendo igual a um dos valores do lado direito, dado que o lado direito \u00e9 uma disjun\u00e7\u00e3o. \u00c9 comum dizer que Naipe \u00e9 uma enumera\u00e7\u00e3o dos valores \u00e0 direita da equa\u00e7\u00e3o. Uma vez definido o tipo, podemos perguntar ao Haskell como ele \u00e9 interpretado. > data Naipe = Copas | Espadas | Ouro | Paus > : i Naipe type Naipe :: * data Naipe = Copas | Espadas | Ouro | Paus -- Defined at <interactive>:1:1 > : i Copas type Naipe :: * data Naipe = Copas | ... -- Defined at <interactive>:1:14 > : t Copas Copas :: Naipe Voc\u00ea tamb\u00e9m j\u00e1 pode usar o tipo em sua defini\u00e7\u00f5es, por exemplo: corDoNaipe :: Naipe -> String corDoNaipe Copas = \"Vermelho\" corDoNaipe Ouro = \"Vermelho\" corDoNaipe Paus = \"Preto\" corDoNaipe Espada = \"Preto\" Ou, equivalentemente, no seguinte exemplo. corDoNaipe :: Naipe -> String corDoNaipe n = case n of Copas -> \"Vermelho\" Ouro -> \"Vermelho\" Paus -> \"Preto\" Espada -> \"Preto\" Mas e o seguinte c\u00f3digo? corDoNaipe'' :: Naipe -> String corDoNaipe'' n | n == Copas = \"Vermelho\" | n == Ouro = \"Vermelho\" | n == Paus = \"Preto\" | n == Espada = \"Preto\" Se test\u00e1-lo, ver\u00e1 que n\u00e3o funciona. Um efeito semelhante \u00e9 observado quando fazemos algo mais simples ainda. Prelude > data Naipe = Copas | Espada | Ouro | Paus Prelude > Copas == Copas < interactive >: 2 : 1 : error : \u2022 No instance for ( Eq Naipe ) arising from a use of \u2018 == \u2019 \u2022 In the expression : Copas == Copas In an equation for \u2018 it \u2019 : it = Copas == Copas O problema aqui \u00e9 que Haskell n\u00e3o sabe como testar se dois naipes s\u00e3o iguais! Agora teste o seguinte. Prelude > True == True True Qual a diferen\u00e7a?","title":"data"},{"location":"types2/algebraic/#classes-de-tipos","text":"Observe que o tipo Bool foi definido da mesma forma, exceto por algumas informa\u00e7\u00f5es extra que aparecem quando o tipo \u00e9 descrito. Prelude > : i Bool type Bool :: * data Bool = False | True -- Defined in \u2018GHC.Types\u2019 instance Eq Bool -- Defined in \u2018GHC.Classes\u2019 instance Ord Bool -- Defined in \u2018GHC.Classes\u2019 instance Enum Bool -- Defined in \u2018GHC.Enum\u2019 instance Show Bool -- Defined in \u2018GHC.Show\u2019 instance Read Bool -- Defined in \u2018GHC.Read\u2019 instance Bounded Bool -- Defined in \u2018GHC.Enum\u2019 Mas o que s\u00e3o estas informa\u00e7\u00f5es extra? Fa\u00e7amos um teste, simplesmente avaliando um dos valores de Bool e de Naipe . > True True > Copas < interactive >: 9 : 1 : error : \u2022 No instance for ( Show Naipe ) arising from a use of \u2018 print \u2019 \u2022 In a stmt of an interactive GHCi command : print it O erro aparece porqu\u00ea quando a avalia\u00e7\u00e3o \u00e9 feita, o GHCi tenta imprimir o resultado na tela, e para imprimir o resultado ele tenta obter sua representa\u00e7\u00e3o como String usando a fun\u00e7\u00e3o show . > show True \"True\" > show Copas < interactive >: 11 : 1 : error : \u2022 No instance for ( Show Naipe ) arising from a use of \u2018 show \u2019 \u2022 In the expression : show Copas In an equation for \u2018 it \u2019 : it = show Copas No caso do valor booleano, a fun\u00e7\u00e3o funciona, mas no caso do naipe n\u00e3o! Volte no trecho acima onde descrevemos o valor verdadeiro. Uma das diferen\u00e7as para o naipe era a presen\u00e7a da linha instance Show Bool -- Defined in \u2018GHC.Show\u2019 que basicamente dizia que Bool faz parte da classe de tipos Show , a classe dos tipos que podem ser passados como par\u00e2metro para fun\u00e7\u00e3o show . H\u00e1 v\u00e1rias classes de tipo em Haskell, e voc\u00ea ainda pode criar as suas pr\u00f3prias.","title":"Classes de tipos"},{"location":"types2/algebraic/#tipos-mais-complexos","text":"Mas e se quisermos definir um tipo para representar o valor de uma carta? data Valor = \u00c1s | N\u00famero1 | N\u00famero2 | N\u00famero3 | N\u00famero4 | N\u00famero5 | N\u00famero6 | N\u00famero7 | N\u00famero8 | N\u00famero9 | N\u00famero10 | Valete | Dama | Rei deriving ( Eq , Show , Ord , Enum ) Com esta defini\u00e7\u00e3o \u00e9 poss\u00edvel, por exemplo, comparar os valores das cartas. Mas, convenhamos, \u00e9 uma defini\u00e7\u00e3o horr\u00edvel. Haskell to the rescue! \u00c9 poss\u00edvel definir um valor que seja baseado em outro tipo, como no seguinte exemplo. data Valor = \u00c1s | N\u00famero Int | Valete | Dama | Rei N\u00famero Int define que qualquer combina\u00e7\u00e3o de N\u00famero , denominado o construtor , combinado com um valor do tipo #hs Int , \u00e9 um valor do tipo Valor . > data Valor = \u00c1s | N\u00famero Int | Valete | Dama | Rei deriving ( Eq , Show , Ord ) > as = \u00c1s > valete = Valete > nove = N\u00famero 9 > as \u00c1s > valete Valete > nove N\u00famero 9 Assim como Naipe pode ser usado em um casamento de padr\u00f5es, tamb\u00e9m a defini\u00e7\u00e3o de Valor pode, como no seguinte exemplo. \u00e9Figura :: Valor -> Bool \u00e9Figura ( N\u00famero _ ) -> False \u00e9Figura \u00c1s -> True -- Esta defini\u00e7\u00e3o \u00e9 desnecess\u00e1ria e usada s\u00f3 pra demonstra\u00e7\u00e3o. \u00e9Figura _ -> True","title":"Tipos mais complexos"},{"location":"types2/algebraic/#tipos-mais-complexos-ainda","text":"Combinemos agora os tipos Naipe e Valor em um \u00fanico tipo que representa uma carta de baralho. A instancia\u00e7\u00e3o \u00e9 feita usando-se o construtor. > data Valor = \u00c1s | N\u00famero Int | Valete | Dama | Rei deriving ( Eq , Show , Ord ) > data Naipe = Copas | Espadas | Ouro | Paus deriving ( Show , Eq , Enum , Ord ) > data CartaT = Carta Naipe Valor deriving ( Eq , Show , Ord ) > Carta Paus Rei Carta Paus Rei > Carta Paus ( N\u00famero 3 ) Carta Paus ( N\u00famero 3 ) > Carta Paus ( N\u00famero 3 ) < Carta Paus Rei True > Carta Paus ( N\u00famero 3 ) < Carta Ouro Rei False > k = Carta Paus Rei > k Carta Paus Rei > : t k k :: CartaT > : i k k :: CartaT -- Defined at <interactive>:28:1 Veja que do lado esquerdo da equa\u00e7\u00e3o temos a defini\u00e7\u00e3o de um tipo CartaT e do lado direito temos a defini\u00e7\u00e3o de um construtor Carta para o tipo CartaT . \u00c9 poss\u00edvel solicitar mais informa\u00e7\u00f5es do Haskell tanto sobre o construtor quanto o tipo, mas nem todas as solicita\u00e7\u00f5es fazem sentido. Quanto ao tipo, CartaT , \u00e9 poss\u00edvel pedir informa\u00e7\u00f5es sobre a defini\u00e7\u00e3o, mas n\u00e3o o tipo da defini\u00e7\u00e3o. > : i CartaT type CartaT :: * data CartaT = Carta Naipe Valor -- Defined at <interactive>:26:1 instance [ safe ] Ord CartaT -- Defined at <interactive>:26:75 instance [ safe ] Show CartaT -- Defined at <interactive>:26:70 instance [ safe ] Eq CartaT -- Defined at <interactive>:26:67 > : t CartaT < interactive >: 1 : 1 : error : \u2022 Data constructor not in scope : CartaT \u2022 Perhaps you meant \u2018 Carta \u2019 ( line 26 ) Quanto ao construtor, Carta , \u00e9 poss\u00edvel perguntar as duas coisas. > : i Carta type CartaT :: * data CartaT = Carta Naipe Valor -- Defined at <interactive>:26:15 > : t Carta Carta :: Naipe -> Valor -> CartaT Veja que quanto perguntamos o tipo do construtor, a resposta \u00e9 que \u00e9 uma fun\u00e7\u00e3o que recebe Naipe e Valor e que retorna uma inst\u00e2ncia do tipo CartaT .","title":"Tipos mais complexos ainda"},{"location":"types2/algebraic/#casamento-de-padroes","text":"Para que estes tipos sejam \u00fateis, precisamos us\u00e1-los em fun\u00e7\u00f5es, que \u00e9 direto e \u00f3bvio para os tipos mais simples, como visto anteriormente. corDoNaipe :: Naipe -> String corDoNaipe Copas = \"Vermelho\" corDoNaipe Ouro = \"Vermelho\" corDoNaipe Paus = \"Preto\" corDoNaipe Espada = \"Preto\" J\u00e1 para tipos que usam construtores, os padr\u00f5es devem incluir o construtor, como mostram as fun\u00e7\u00f5es a seguir. naipe :: CartaT -> Naipe naipe ( Carta n _ ) = n valor :: CartaT -> Valor valor ( Carta _ v ) = v valorNum\u00e9rico :: Valor -> Int valorNum\u00e9rico \u00c1s = 1 valorNum\u00e9rico ( N\u00famero i ) = i valorNum\u00e9rico Valete = 11 valorNum\u00e9rico Dama = 12 valorNum\u00e9rico Rei = 13 > valorNum\u00e9rico ( N\u00famero 4 ) 4 > valorNum\u00e9rico Rei 13 Exerc\u00edcios Usando tipos alg\u00e9bricos, defina os seguintes tipos e fun\u00e7\u00f5es relacionados a jogos de cartas Naipe Valor Carta Jogo - lista de cartas (apelido, n\u00e3o tipo alg\u00e9brico) \u00e9Canastra l - fun\u00e7\u00e3o que True se l \u00e9 uma sequ\u00eancia (possivelmente desordenada) de 7 cartas. temCanastra l - fun\u00e7\u00e3o que True se l contem uma sub-lista que \u00e9Canastra Usando tipos alg\u00e9bricos, defina as seguintes fun\u00e7\u00f5es e tipos Temperatura - tipo que pode conter um Tipo (Celsius, Kelvin, Farenheit) e um valor real. tempInCelsius - fun\u00e7\u00e3o que recebe uma temperatura qualquer e retorna uma Temperatura em Celsius. Item para outras temperaturas.","title":"Casamento de Padr\u00f5es"},{"location":"types2/algebraic/#notacao-tipo-record","text":"TODO Records","title":"Nota\u00e7\u00e3o tipo \"record\""},{"location":"types2/algebraic/#maybe","text":"Read \u00e9 uma classe de tipo \u00fatil por permitir que strings sejam usadas lidas e interpretadas como o tipo. O tipo Int e outros n\u00fameros, por exemplo, pertencem a esta classe, o que nos diz que podemos fazer o seguinte: > x = read \"100\" :: Int > x 100 > x = read \"100\" :: Float > x 100.0 Acontece que nem sempre a fun\u00e7\u00e3o ser\u00e1 bem sucedida em interpretar a string, por exemplo: > x = read \"Bolhufas\" :: Int > x *** Exception: Prelude . read : no parse Esta \u00e9 apenas uma de muitas situa\u00e7\u00f5es em que uma exce\u00e7\u00e3o pode ser causada por uma falha na execu\u00e7\u00e3o de alguma fun\u00e7\u00e3o. Outros exemplos s\u00e3o falhas de aloca\u00e7\u00e3o de mem\u00f3ria, de abertura de um arquivo no disco, de comunica\u00e7\u00e3o com outro processo via uma rede de computadores, etc. Nestas situa\u00e7\u00f5es, \u00e9 comum o uso do tipo Maybe a definido como se segue: > import Text.Read > : i Maybe data Maybe a = Nothing | Just a ... Este tipo permite que a fun\u00e7\u00e3o indique um erro ao retornar Nothing ou que um valor x foi recuperado da string usando ao retornar Just x . > x = readMaybe \"Bolhufas\" :: Maybe Int > x Nothing > x = readMaybe \"100\" :: Maybe Int > x Just 100","title":"Maybe"},{"location":"types2/algebraic/#tipos-recursivos","text":"Como pode ver at\u00e9 agora, tipos alg\u00e9bricos tem muitos usos, a agora veremos um dos mais interessantes, na defini\u00e7\u00e3o de tipos recursivos. Considere uma lista, como definida pelo operador cons, : : uma lista \u00e9 a concatena\u00e7\u00e3o de um elemento, a cabe\u00e7a da lista, com uma outra lista, a cauda. Usando tipos alg\u00e9bricos, conseguimos representar listas da seguinte forma: data Lista a = Vazio | Elemento a ( Lista a ) deriving ( Show ) busca :: a -> Lista a -> Bool busca _ Vazio = False busca e ( Elemento x xs ) | e == x = True | busca e xs busca' :: a -> Lista a -> Bool busca' _ Vazio = False busca' e ( Elemento x xs ) = e == x || busca e xs > lV = Vazio > l1 = Elemento 1 ( Vazio ) > l2 = Elemento 2 ( Elemento 1 Vazio ) > lV Vazio > l1 Elemento 1 Vazio > l2 Elemento 2 ( Elemento 1 Vazio ) > busca' 1 lV False > busca' 1 l1 True > busca' 1 l2 True > busca' 2 l1 False Para outro exemplo, considere uma \u00e1rvore bin\u00e1ria, uma estrutura de dados formada por n\u00f3s que armazenam algum dado e apontam para outros dois n\u00f3s, denominados filhos \u00e0 esquerda e \u00e0 direita. data \u00c1rvore a = Nada | N\u00f3 a ( \u00c1rvore a ) ( \u00c1rvore a ) deriving ( Show ) {- >>> mudinha = N\u00f3 3 Nada Nada >>> N\u00f3 1 (N\u00f3 2 (N\u00f3 4 Nada Nada) Nada) (N\u00f3 3 Nada Nada) N\u00f3 1 (N\u00f3 2 (N\u00f3 4 Nada Nada) Nada) (N\u00f3 3 Nada Nada) -} adicionar :: ( Eq a , Ord a ) => a -> \u00c1rvore a -> \u00c1rvore a adicionar novoDado Nada = N\u00f3 novoDado Nada Nada adicionar novoDado \u00e1rvore @ ( N\u00f3 dadoExistente ae ad ) | novoDado == dadoExistente = \u00e1rvore | novoDado < dadoExistente = N\u00f3 dadoExistente ( adicionar novoDado ae ) ad | otherwise = N\u00f3 dadoExistente ad ( adicionar novoDado ad ) {- >>> arv = adicionar 3 (adicionar 4 (adicionar 10 (adicionar 1 (adicionar 2 (adicionar 3 (adicionar 7 Nada)))))) >>> arv N\u00f3 7 (N\u00f3 4 (N\u00f3 3 Nada Nada) Nada) (N\u00f3 10 Nada Nada) >>> impress\u00e3oEmOrdem arv \".3.4.7.10.\" -} impress\u00e3oEmOrdem :: ( Show a ) => \u00c1rvore a -> String impress\u00e3oEmOrdem Nada = \".\" impress\u00e3oEmOrdem ( N\u00f3 dado ae ad ) = impress\u00e3oEmOrdem ae ++ show dado ++ impress\u00e3oEmOrdem ad Exerc\u00edcio Implemente uma impress\u00e3o \"em ordem\" dos n\u00f3s da \u00e1rvore, que recebe uma \u00e1rvore e gera uma string com a resposta. Esta aula \u00e9 fortemente inspirada na video aula Enumeration Types, Show de Dave Sands. \u21a9","title":"Tipos recursivos"},{"location":"types2/lists_again/","text":"Listas Vamos agora estudar listas, pe\u00e7as fundamentais no desenvolvimento de programas usando o paradigma funcional, por serem estruturas de dados que permitem agregar v\u00e1rias informa\u00e7\u00f5es na forma de uma cole\u00e7\u00e3o ordenada de elementos. Por exemplo, [ \"Eu\" , \"amo\" , \"programa\u00e7\u00e3o\" , \"funcional\" ] \u00e9 a cole\u00e7\u00e3o de quatro strings em que o primeiro elemento \u00e9 \"Eu\" , o segundo \"amo\" , o terceiro \"programa\u00e7\u00e3o\" e o quarto e \u00faltimo \"funcional\" . J\u00e1 [ 1 :: Int , 2 :: Int , 3 :: Int ] \u00e9 uma lista de 3 elementos do tipo Int , onde o primeiro elemento \u00e9 1, o segundo 2, e o terceiro 3. \"Mas e as tuplas?\", voc\u00ea pergunta, \"N\u00e3o s\u00e3o exatamente isto?\" Listas x Tuplas Listas tem duas particularidades que as diferenciam de tuplas. Primeiro, enquanto as tuplas ( 1 :: Int , 2 :: Int , 3 :: Int ) e ( 1 :: Int , 2 :: Int , 3 :: Int , 4 :: Int ) tem tipos diferentes, isto \u00e9, uma \u00e9 uma tupla de tr\u00eas inteiros e a outra uma tupla de quatro inteiros, as listas [ 1 :: Int , 2 :: Int , 3 :: Int ] e [ 1 :: Int , 2 :: Int , 3 :: Int , 4 :: Int ] tem exatamente o mesmo tipo, lista de inteiros, ou mais especificamente, [ Int ] . Ou seja, listas com cardinalidades diferentes, mas com elementos do mesmo tipo, s\u00e3o do mesmo tipo. Ali\u00e1s, outra forma de escrever estas listas, enquanto especificando seus tipos, \u00e9 [ 1 , 2 , 3 ] :: [ Int ] e [ 1 , 2 , 3 , 4 ] :: [ Int ] . Segundo, enquanto uma tupla pode ter elementos de tipos diferentes, todos os elementos de uma lista devem ser do mesmo tipo. Ou seja, enquanto \u00e9 poss\u00edvel definir x = ( \"Joao\" , 14 , True ) , n\u00e3o \u00e9 poss\u00edvel definir x = [ \"Joao\" , 14 , True ] . \u00c9 preciso observar contudo que \u00e9 poss\u00edvel construir uma lista [ 1 , 2 , 3 , 4 , 17 , 4.2 ] , mas mas isto s\u00f3 \u00e9 poss\u00edvel porqu\u00ea existe um tipo do qual todos os elementos da lista s\u00e3o derivados, no caso, Fractional . De fato, quando defino este lista, Haskell automaticamente faz o boxing dos cinco primeiros valores para ponto flutuante. * Main > z = [ 1 , 2 , 3 , 4 , 17 , 4.2 ] * Main > z [ 1.0 , 2.0 , 3.0 , 4.0 , 17.0 , 4.2 ] * Main > : t z z :: Fractional a => [ a ] J\u00e1 a tupla ( 1 , 2 , 3 , 4 , 17 , 4.2 ) tem elementos com tipos diferentes. 1 Prelude > : t t t :: ( Num , Num , Num , Num , Num , Fractional ) Uma vez diferenciadas das tuplas, estamos livres para explorar outros aspectos das listas, iniciando por como s\u00e3o constru\u00eddas. Estrutura Dado uma lista qualquer, de qualquer tipo, ela pode ser ou vazia ou n\u00e3o vazia, sendo que a lista vazia \u00e9 representada em Haskell por [] . Listas n\u00e3o vazias s\u00e3o representadas como a concatena\u00e7\u00e3o do primeiro elemento da lista com uma lista com os demais elementos, usando o operador de concatena\u00e7\u00e3o : , ou cons . Por exemplo, a lista dos n\u00fameros 1, 2 e 3 nesta ordem \u00e9 constru\u00edda como 1 : 2 : 3 :[] ; observe que como o 3 \u00e9 o \u00faltimo elemento da lista, a lista que vem depois do cons, com os demais elementos, \u00e9 a lista vazia. Prelude > x = 1 : 2 : 3 :[] Prelude > x [ 1 , 2 , 3 ] Cabe\u00e7a e Cauda Esta divis\u00e3o de uma lista entre primeiro elemento e restante \u00e9 o que chamamos de cabe\u00e7a ( head ) e cauda ( tail ) da lista. No exemplo anterior, 1 : 2 : 3 :[] , 1 \u00e9 a cabe\u00e7a e 2 : 3 :[] a cauda. Haskell inclusive define fun\u00e7\u00f5es para recuperar estas partes de uma lista qualquer. Prelude > head x 1 Prelude > tail x [ 2 , 3 ] A cabe\u00e7a de uma lista de elementos de um tipo \\(a\\) qualquer \u00e9 um elemento do tipo \\(a\\) . J\u00e1 a cauda desta lista \u00e9 tamb\u00e9m uma lista de elementos do tipo \\(a\\) . Logo, podemos subdivid\u00ed-la tamb\u00e9m em uma cabe\u00e7a e uma cauda, no exemplo, 2 e 3 :[] . Prelude > head ( tail x ) 2 Prelude > tail ( tail x ) [ 3 ] Podemos aplicar head e tail mais uma vez na lista, obtendo 3 e [] como resultado. Prelude > head ( tail ( tail x )) 3 Prelude > tail ( tail ( tail x )) [] Mas e se formos al\u00e9m? Neste caso estar\u00edamos tentando identificar o primeiro elemento da lista, mas sendo a lista vazia, isto n\u00e3o \u00e9 poss\u00edvel. Tampouco podemos extrair a lista ap\u00f3s a cabe\u00e7a. Prelude > head [] *** Exception: Prelude . head : empty list Prelude > tail [] *** Exception: Prelude . tail : empty list Logo, qualquer itera\u00e7\u00e3o nos elementos de uma lista, geralmente especificada por uma recurs\u00e3o que extrai a cabe\u00e7a da lista a cada passo, precisa tomar cuidado para n\u00e3o tentar extrair a cabe\u00e7a da lista vazia, como veremos na sess\u00e3o sobre recurs\u00e3o aplicada a listas. Um pouco de a\u00e7\u00facar sint\u00e1tico A especifica\u00e7\u00e3o manual de uma lista usando o operador cons n\u00e3o \u00e9 muito utilizada na pr\u00e1tica, sendo a especifica\u00e7\u00e3o usando colchetes e v\u00edrgulas mais comum, como feito nos primeiros exemplos deste cap\u00edtulo, e \u00e9 inclusive como o pr\u00f3prio Haskell exibe as listas. O efeito final \u00e9 o mesmo, ficando para voc\u00ea a decis\u00e3o qual constru\u00e7\u00e3o usar. 1 :[] \u00e9 igual a [ 1 ] 2 : 1 :[] \u00e9 igual a [ 2 , 1 ] As duas nota\u00e7\u00f5es podem at\u00e9 ser misturadas, como em 1 : 2 : [ 3 , 4 , 5 ] , que \u00e9 equivalente [ 1 , 2 , 3 , 4 , 5 ] . Strings Se o a\u00e7\u00facar sint\u00e1tico dos colchetes n\u00e3o representa economia em termos de digita\u00e7\u00e3o de listas em geral, quando falamos em listas de caracteres a economia \u00e9 clara e o resultado muito mais agrad\u00e1vel. Isto por que para listas de caracteres, como [ 'a' , 'b' , 'c' ] , podemos escrever simplesmente \"abc\" , com exatamente o mesmo efeito, e at\u00e9 misturar com o uso de cons. Prelude > \"abc\" \"abc\" Prelude > [ 'a' , 'b' , 'c' ] \"abc\" Prelude > 'a' : [ 'b' , 'c' ] \"abc\" Prelude > 'a' : \"bc\" \"abc\" [qualquer coisa] Uma lista pode conter elementos de qualquer tipo, desde que todos os elementos sejam do mesmo tipo. Logo, uma lista pode conter tipos primitivos, mas tamb\u00e9m tipos complexos, como tuplas e outras listas. Vejamos alguns exemplos: [ 1 , 2 , 3 ] :: [ Int ] - Lista de inteiros. [[ 1 , 2 , 3 ]] :: [[ Int ]] - Lista de listas de inteiros de inteiros. [[ 1 , 2 , 3 ], [] ,[ 3 , 4 , 5 , 6 , 7 , 8 , 9 ]] :: [[ Int ]] - Lista de listas de inteiros de inteiros. [( 1 , 2 , 3 ),( 3 , 4 , 5 )] :: [( Int , Int , Int )] - Lista de triplas de inteiros. ( \"lala\" ,[ 'l' , 'a' ], 'l' : '\u00e3' : 'o' :[] ) - Tripla de listas de Char. [ \"lala\" ,[ 'l' , 'a' ], 'l' : '\u00e3' : 'o' :[] ] - Lista de listas de Char. [ True , False , True ] :: [ Bool ] - Lista de booleanos. [( 4 , Ouro ),( 5 , Paus )] :: [ Carta ] - Lista de cartas. [( 1 , 2 , 3 ),( 3 )] - Um bug Fun\u00e7\u00f5es \u00fateis Em uma se\u00e7\u00e3o anterior, apresentamos algumas fun\u00e7\u00f5es como \u00fateis na manipula\u00e7\u00e3o de String. Na verdade, todas aquelas fun\u00e7\u00f5es s\u00e3o definidas em termos de listas e, por isso, as revisitaremos aqui juntamente com mais algumas. Operador Opera\u00e7\u00e3o Exemplo ++ Concatena\u00e7\u00e3o de listas > \"foo\" ++ \"bar\" \"foobar\" !! Elemento no \u00edndice > [ 1 , 2 , 3 , 4 ] !! 2 3 reverse Lista ao contr\u00e1rio > reverse [ 1 , 2 , 3 , 4 ] [4,3,2,1] length Comprimento da string > length \"foo bar\" 7 last \u00daltimo elemento da lista > last \"foo bar\" r concat Retorna a concatena\u00e7\u00e3o das listas dentro de uma lista > concat [[ 1 , 2 , 3 , 4 ],[ 5 , 6 , 7 , 8 ]] [1,2,3,4,5,6,7,8] > concat [[[ 1 , 2 , 3 ]],[[ 4 , 5 , 6 ]]] [[ 1 , 2 , 3 ],[ 4 , 5 , 6 ]] elem Verifica se o par\u00e2metro \u00e9 um elemento da lista > elem 'o' \"foo bar\" True null Verifica se a lista \u00e9 vazia > null \"\" True > null [] True > null [ 1 , 2 ] False replicate Constr\u00f3i uma lista pela replica\u00e7\u00e3o de um elemento > replicate 4 ( 1 , 2 ) [( 1 , 2 ),( 1 , 2 ),( 1 , 2 ),( 1 , 2 )] take Sublista iniciando em 0 > take 3 1 : 2 : 3 : 4 : 5 :[] [ 1 , 2 , 3 ] drop Sublista come\u00e7ando em um \u00edndice > drop 3 [ 'f' , 'o' , 'o' , ' ' , 'b' , 'a' , 'r' ] \" bar\" takeWhile Sublista iniciando em 0 e at\u00e9 o primeiro elemento que n\u00e3o satisfaz ao crit\u00e9rio, exclusive > takeWhile ( < 4 ) [ 1 , 2 , 3 , 4 , 5 , 6 ] [ 1 , 2 , 3 ] dropWhile Sublista come\u00e7ando no primeiro elemento que n\u00e3o satisfaz ao crit\u00e9rio, inclusive > dropWhile ( < 4 ) [ 1 , 2 , 3 , 4 , 5 , 6 ] 4 , 5 , 6 splitAt Dupla das sublistas geradas pela divis\u00e3o no \u00edndice especificado > splitAt 3 [ 1 , 2 , 3 , 4 , 5 , 6 ] ([ 1 , 2 , 3 ],[ 4 , 5 , 6 ]) zip Lista de pares com os elementos das duas listas passadas como par\u00e2metro > zip [ 1 , 2 , 3 ] [ 4 , 5 , 6 ] [( 1 , 4 ),( 2 , 5 ),( 3 , 6 )] sum Somat\u00f3rio dos elementos da lista > sum [ 1 , 2 , 3 , 4 , 5 , 6 ] 16 product Produt\u00f3rio dos elementos da lista > product [ 1 , 2 , 3 , 4 , 5 , 6 ] 720 maximum Maior dos elemento lista > maximum [ 1 , 2 , 3 , 4 , 5 , 6 ] 6 minimum Menor dos elementos da lista > minimum [ 1 , 2 , 3 , 4 , 5 , 6 ] 1 Enumera\u00e7\u00e3o Para facilitar a vida dos desenvolvedores, Haskell permite a constru\u00e7\u00e3o de listas por enumera\u00e7\u00e3o, bastando para isso o especificar o primeiro elemento da lista, opcionalmente o segundo, e o \u00faltimo elemento. Por exemplo Prelude > [ 11 , 13 .. 23 ] [ 11 , 13 , 15 , 17 , 19 , 21 , 23 ] Prelude > [ - 15 , - 13 .. 14 ] [ - 15 , - 13 , - 11 , - 9 , - 7 , - 5 , - 3 , - 1 , 1 , 3 , 5 , 7 , 9 , 11 , 13 ] Observe que Haskell determinou um passo de incremento igual a \\(13-11 = 2\\) no primeiro exemplo e \\(-15 - -13 = 2\\) no segundo exemplo, e usou estes passos para gerar as lista. Tamb\u00e9m \u00e9 poss\u00edvel definir um passo negativo, como no pr\u00f3ximo exemplo. Prelude > [ 11 , 9 .. 0 ] [ 11 , 9 , 7 , 5 , 3 , 1 ] Como mencionado, o segundo elemento \u00e9 opcional na enumera\u00e7\u00e3o e caso n\u00e3o especificado, Haskell assume que seja \\(1\\) , como no exemplo a seguir. Prelude > [ 11 .. 23 ] [ 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 ] Prelude > [ 3.5 .. 10 ] [ 3.5 , 4.5 , 5.5 , 6.5 , 7.5 , 8.5 , 9.5 , 10.5 ] Contudo, n\u00e3o \u00e9 poss\u00edvel omitir o segundo elemento se a inten\u00e7\u00e3o for gerar uma lista com valores decrescentes. Prelude > [ 11 .. 0 ] [] A enumera\u00e7\u00e3o pode ser feita para outros tipos que n\u00e3o sejam num\u00e9ricos, bastando que exista uma rela\u00e7\u00e3o de ordem entre os elementos para que Haskell consiga \"incrementar\" a cada passo. Isso existe, por exemplo, entre os caracteres, mas tamb\u00e9m para tipos definidos pelo desenvolvedor. 2 Prelude > [ 'a' .. 'm' ] \"abcdefghijklm\" Prelude > data Naipe = Copas | Espada | Ouro | Paus deriving ( Ord , Eq , Enum , Show ) Prelude > [ Copas .. Ouro ] [ Copas , Espada , Ouro ] Exerc\u00edcio Defina uma fun\u00e7\u00e3o que dado um n\u00famero inteiro x, gere uma lista de 1 a x e de volta a 1. Resolu\u00e7\u00e3o vaiEVolta n = lista ++ drop 1 ( reverse lista ) where lista = [ 1 .. n ] * Main > vaiEVolta 3 [ 1 , 2 , 3 , 2 , 1 ] Defina uma fun\u00e7\u00e3o que calcule o fatorial e um n\u00famero n, usando product e listas por enumera\u00e7\u00e3o. Resolu\u00e7\u00e3o fatorial n = product [ 1 .. n ] Compreens\u00e3o de Listas A compreens\u00e3o de listas \u00e9 uma forma de construir listas pela defini\u00e7\u00e3o de uma regra de constru\u00e7\u00e3o, e \u00e9 muito comum nas linguagens funcionais, incluindo Haskell. Defini\u00e7\u00e3o em fun\u00e7\u00e3o de outra lista Suponha que tenha uma lista de n\u00fameros e que gostaria de gerar uma nova lista em que cada valor da lista original \u00e9 acrescido de 30%. Com compreens\u00e3o de listas, isto pode ser feito muito facilmente usando a compreens\u00e3o de listas [ e * 1.3 | e <- lista ] . Esta compreens\u00e3o diz que ser\u00e1 constru\u00edda uma lista cujos elementos ser\u00e3o da forma e * 1.3 , onde e s\u00e3o os elementos da lista original. Veja o exemplo de execu\u00e7\u00e3o. > lista = [ 10 , 20 , 30 , 40 , 100 ] > [ e * 1.3 | e <- lista ] [ 13.0 , 26.0 , 39.0 , 52.0 , 130.0 ] Sintaxe A compreens\u00e3o de listas \u00e9 baseada na compreens\u00e3o de conjuntos, da teoria de conjuntos da matem\u00e1tica. A seguinte compreens\u00e3o de conjuntos pode ser lida como o conjunto \\(A\\) formado pela aplica\u00e7\u00e3o da fun\u00e7\u00e3o \\(f\\) a todos os valores \\(x\\) tal que \\(x\\) pertence ao conjunto \\(C\\) e para os quais valem os predicados \\(P_i, 1\\leq i \\leq n\\) . \\(A = \\{ f(x) | x \\in C \\land P_1(x) \\land \\ldots \\land P_n(x)\\}\\) A compreens\u00e3o de listas \u00e9 similar a = [ f x | x <- c , p1 x , ... , pn x ] Uma diferen\u00e7a importante \u00e9 que enquanto n\u00e3o h\u00e1 ordem nos conjuntos, h\u00e1 ordem nas listas e a constru\u00e7\u00e3o \u00e9 feita na ordem da lista original. Listas infinitas Assim como \u00e9 poss\u00edvel expressar um conjunto infinito usando compreens\u00e3o de conjuntos, por exemplo o conjunto dos quadrados de todos os n\u00fameros naturais \\(S = \\{e^2 | e \\in \\mathcal{N} \\}\\) , podemos expressar listas infinitas usando enumera\u00e7\u00e3o e compreens\u00e3o de listas como lq = [ e ** 2 | e <- [ 1 .. ]] . \"Mas como \u00e9 poss\u00edvel?\", voc\u00ea me pergunta, afinal, a mem\u00f3ria do computador \u00e9 finita e portanto n\u00e3o poderia armazenar uma lista infinita. Esta \u00e9 uma das m\u00e1gicas de Haskell, conhecida como avalia\u00e7\u00e3o pregui\u00e7osa, e ser\u00e1 vista em detalhes mais adiante. Por enquanto, basta acreditar que, desde que voc\u00ea n\u00e3o tente enumerar todos os elementos, uma lista infinita pode se representada em Haskell. Podemos, inclusive, consultar alguns elementos da lista infinita constru\u00edda acima para, por exemplo, verificar se um certo n\u00famero \u00e9 um quadrado perfeito! > lq = [ e ** 2 | e <- [ 1 .. ]] > elem 4 lq True > elem 16 lq True Observe, contudo, que se um elemento n\u00e3o estiver na lista, a fun\u00e7\u00e3o nunca retornar\u00e1! > elem 3 lq ^ CInterrupted . Exerc\u00edcio Modifique o exemplo acima para limitar a quantidade de elementos que ser\u00e3o buscados na lista de quadrados. Resolu\u00e7\u00e3o Prelude > elem 16 ( take 100 lq ) True Prelude > elem 20 ( take 100 lq ) False Prelude > elem 64 ( take 5 lq ) False Compreens\u00e3o como uma itera\u00e7\u00e3o Sabendo que a fun\u00e7\u00e3o ord do m\u00f3dulo Data.Char converte um caractere para seu valor na tabela ASCII, imagine que voc\u00ea queira converter uma String para uma lista dos valores ASCII correspondentes. Isso pode ser feito trivialmente com compreens\u00e3o de listas. Prelude > import Data.Char ( ord ) Prelude Data . Char > [ ord e | e <- \"abcd,'dasdfa;lkqwoiur\" ] [ 97 , 98 , 99 , 100 , 44 , 39 , 100 , 97 , 115 , 100 , 102 , 97 , 59 , 108 , 107 , 113 , 119 , 111 , 105 , 117 , 114 ] Isto demonstra que a constru\u00e7\u00e3o da lista pode ser usada aplicar uma fun\u00e7\u00e3o a todos os elementos de um \"conjunto\". No pr\u00f3ximo exemplo, usamos esta habilidade para capitalizar de uma String. Prelude Data . Char > import Data.Char ( toUpper ) Prelude Data . Char > [ toUpper e | e <- \"abcd,'dasdfa;lkqwoiur\" ] \"ABCD,'DASDFA;LKQWOIUR\" A lista resultante pode tem tipos complexos como elementos, como no exemplo seguinte, em que compreens\u00e3o gera uma com tuplas com as vers\u00f5es min\u00fascula e em mai\u00fascula de cada letra encontrada na entrada. Prelude Data . Char > [ ( toUpper e , toLower e ) | e <- \"abCD\" ] [( 'A' , 'a' ),( 'B' , 'b' ),( 'C' , 'c' ),( 'D' , 'd' )] Exerc\u00edcio Explique [ ( e , chr (( ord e - ord 'a' + 10 ) mod 26 + (ord 'a'))) | e <- ['a'..'z']] Resolu\u00e7\u00e3o Retorna uma lista de tuplas em que os primeiros elementos s\u00e3o letras e seus pares s\u00e3o letras 10 posi\u00e7\u00f5es adiante no alfabeto, m\u00f3dulo 26. Predicados Imagine agora que voc\u00ea queira construir uma lista com os quadrados dos n\u00fameros naturais m\u00faltiplos de 3 e menores que 100. Neste caso, podemos adicionar um teste aos elementos sendo aplicados na constru\u00e7\u00e3o da lista > [ e ^ 2 | e <- [ 1 .. 100 ], e ` mod ` 3 == 0 ] [ 9 , 36 , 81 , 144 , 225 , 324 , 441 , 576 , 729 , 900 , 1089 , 1296 , 1521 , 1764 , 2025 , 2304 , 2601 , 2916 , 3249 , 3600 , 3969 , 4356 , 4761 , 5184 , 5625 , 6084 , 6561 , 7056 , 7569 , 8100 , 8649 , 9216 , 9801 ] Observe que os predicados em si podem ser t\u00e3o complexos quanto se queira. Prelude Data . Char > [ e ^ 2 | e <- [ 1 .. 100 ], e ` mod ` 3 == 0 , e ^ 2 ` mod ` 4 == 0 ] [ 36 , 144 , 324 , 576 , 900 , 1296 , 1764 , 2304 , 2916 , 3600 , 4356 , 5184 , 6084 , 7056 , 8100 , 9216 ] Exerc\u00edcio Usando compreens\u00e3o de listas, defina uma fun\u00e7\u00e3o que gera a lista dos divisores de um n\u00famero. Resolu\u00e7\u00e3o > divisores x = [ e | e <- [ 1 .. x ], x ` mod ` e == 0 ] > divisores 10 [ 1 , 2 , 5 , 10 ] Usando a fun\u00e7\u00e3o definida acima, defina uma fun\u00e7\u00e3o que teste se um n\u00famero \u00e9 primo. Resolu\u00e7\u00e3o > divisores x = [ e | e <- [ 1 .. x ], x ` mod ` e == 0 ] > primo x = divisores x == [ 1 , x ] > primo 7 True > primo 45 False M\u00faltiplos geradores Uma compreens\u00e3o de listas pode ter mais de um gerador ( <- ), o que faz com que todas as combina\u00e7\u00f5es dos elementos gerados sejam aplicadas \u00e0 fun\u00e7\u00e3o. Por exemplo, a seguinte compreens\u00e3o combina todos os n\u00fameros de 1 a 4 com todos os n\u00fameros de 1 a 4 na constru\u00e7\u00e3o de uma tupla de dois inteiros. > [( x , y ) | x <- [ 1 .. 4 ], y <- [ 1 .. 4 ]] [( 1 , 1 ),( 1 , 2 ),( 1 , 3 ),( 1 , 4 ),( 2 , 1 ),( 2 , 2 ),( 2 , 3 ),( 2 , 4 ),( 3 , 1 ),( 3 , 2 ),( 3 , 3 ),( 3 , 4 ),( 4 , 1 ),( 4 , 2 ),( 4 , 3 ),( 4 , 4 )] Veja que predicados podem ser normalmente aplicados a m\u00faltiplos geradores, como no seguinte exemplo, em que somente as combina\u00e7\u00f5es onde \\(x,y\\) s\u00e3o usadas. > [( x , y ) | x <- [ 1 .. 4 ], y <- [ 1 .. 4 ], x < y ] [( 1 , 2 ),( 1 , 3 ),( 1 , 4 ),( 2 , 3 ),( 2 , 4 ),( 3 , 4 )] \u00c9 importante observar que a ordem dos geradores altera a ordem dos elementos da lista gerada, pois para cada elemento gerado pelo primeiro gerador, ser\u00e1 combinado a cada elemento gerado pelo segundo. > [ ( x , y ) | x <- [ 1 .. 4 ], y <- [ 'a' .. 'd' ]] [( 1 , 'a' ),( 1 , 'b' ),( 1 , 'c' ),( 1 , 'd' ),( 2 , 'a' ),( 2 , 'b' ),( 2 , 'c' ),( 2 , 'd' ),( 3 , 'a' ),( 3 , 'b' ),( 3 , 'c' ),( 3 , 'd' ),( 4 , 'a' ),( 4 , 'b' ),( 4 , 'c' ),( 4 , 'd' )] > [ ( x , y ) | y <- [ 'a' .. 'd' ], x <- [ 1 .. 4 ]] [( 1 , 'a' ),( 2 , 'a' ),( 3 , 'a' ),( 4 , 'a' ),( 1 , 'b' ),( 2 , 'b' ),( 3 , 'b' ),( 4 , 'b' ),( 1 , 'c' ),( 2 , 'c' ),( 3 , 'c' ),( 4 , 'c' ),( 1 , 'd' ),( 2 , 'd' ),( 3 , 'd' ),( 4 , 'd' )] Al\u00e9m disso, \u00e9 poss\u00edvel definir um gerador em termos dos geradores anteriores. Por exemplo > [ ( x , y ) | x <- [ 1 .. 4 ], y <- [ 1 .. x ]] [( 1 , 1 ),( 2 , 1 ),( 2 , 2 ),( 3 , 1 ),( 3 , 2 ),( 3 , 3 ),( 4 , 1 ),( 4 , 2 ),( 4 , 3 ),( 4 , 4 )] Este construto \u00e9 deveras poderoso, pois geradores podem ser aplicados eles pr\u00f3prios a compreens\u00e3o de listas. Outra possibilidade \u00e9 a aplica\u00e7\u00e3o recursiva, como no seguinte c\u00f3digo. partitions [] = [ [] ] partitions ( x : xs ) = [ x : e | e <- partitions xs ] ++ partitions xs Exerc\u00edcio Explique o que a fun\u00e7\u00e3o acima faz, com um exemplo. Casamento de padr\u00f5es Toda lista \u00e9 ou uma lista vazia ou ou um elemento cabe\u00e7a seguido por uma lista cauda. Assim, se cobrir estes dois casos em uma defini\u00e7\u00e3o por casamento de padr\u00f5es, ter\u00e1 coberto \"todos\" os casos! Mas como? Vejamos um exemplo. oQueH\u00e1NaCabe\u00e7a :: ( Show a ) => [ a ] -> String oQueH\u00e1NaCabe\u00e7a [] = \"Nada\" oQueH\u00e1NaCabe\u00e7a ( x : xs ) = \"H\u00e1 \" ++ x Linha 1: n\u00e3o se preocupe esta linha; ela apenas implica que a lista deve ser de valores convert\u00edveis a String Linha 2: esta linha usa um padr\u00e3o constante para testar se a lista \u00e9 vazia, isto \u00e9, [] e, neste caso, retornar a string \"Nada\" como resultado. Linha 3: este \u00e9 o caso mais interessante, pois usa um padr\u00e3o que define uma lista em que x \u00e9 a cabe\u00e7a, concatenada por : a uma cauda xs , e retorna \"H\u00e1 \" seguido do valor casado com x . Observe que foram usados par\u00eanteses na linha 3 para especificar o padr\u00e3o, e n\u00e3o apenas x : xs como seria de se esperar. A verdade \u00e9 que o padr\u00e3o \u00e9 x : xs e os par\u00eantesis s\u00e3o usados apenas para impedir que Haskell primeiro avalie oQueH\u00e1NaCabe\u00e7a x antes de avaliar o operador : e o seu segundo operando. Esta \u00e9 uma das idiossincrasias de Haskell com a qual voc\u00ea simplesmente ter\u00e1 que aprender a conviver para dividir listas entre cabe\u00e7a e cauda em um casamento de padr\u00f5es. Embora estes dois padr\u00f5es, isto \u00e9, lista vazia e cabe\u00e7a seguida de cauda, cubram todas as possibilidades de listas, n\u00e3o quer dizer que n\u00e3o haja melhores op\u00e7\u00f5es, dependendo do que precise extrair da lista. Por exemplo, na pr\u00f3xima fun\u00e7\u00e3o h\u00e1 4 casos de casamento de padr\u00f5es distintos: oQueH\u00e1NaLista :: ( Show a ) => [ a ] -> String oQueH\u00e1NaLista [] = \"Nada\" oQueH\u00e1NaLista [ x ] = \"S\u00f3 \" ++ ( show x ) oQueH\u00e1NaLista [ x1 , x2 ] = \"H\u00e1 \" ++ ( show x1 ) ++ \" e \" ++ ( show x2 ) oQueH\u00e1NaLista ( x : xs ) = \"H\u00e1 \" ++ ( show x ) ++ \" e mais um monte de coisas\" Linha 2: lista vazia; Linha 3: lista com exatamente um elemento, casado com x . Linha 4: lista com exatamente 2 elementos, casados com x1 e x2 . Linha 5: lista com mais de 2 elementos, em que a cabe\u00e7a \u00e9 casada com x e a cauda com xs . Outra forma de obter exatamente o mesmo resultado, usando mais o operador cons , seria a seguinte. oQueH\u00e1NaLista :: ( Show a ) => [ a ] -> String oQueH\u00e1NaLista [] = \"Nada\" oQueH\u00e1NaLista ( x :[] ) = \"S\u00f3 \" ++ ( show x ) oQueH\u00e1NaLista ( x1 : x2 :[] ) = \"H\u00e1 \" ++ ( show x1 ) ++ \" e \" ++ ( show x2 ) oQueH\u00e1NaLista ( x : xs ) = \"H\u00e1 \" ++ ( show x ) ++ \" e mais um monte de coisas\" Dado que strings s\u00e3o apenas listas de Char, estas tamb\u00e9m podem ser decompostas por casamentos de padr\u00f5es. resumo :: String -> String resumo [] -> \"Nada\" resumo [ _ ] -> \"Um\" resumo [ _ , _ ] -> \"Dois\" resumo _ -> \"Muitos\" Assim como listas podem ter elementos mais complexos que tipos primitivos, por exemplo tuplas e listas, tamb\u00e9m os casamentos de padr\u00f5es aplicados a estas listas ser\u00e3o mais complexos. Por exemplo, considere uma lista de tr\u00eas ou mais String, isto \u00e9, uma lista de lista de Char; \u00e9 poss\u00edvel, por exemplo, selecionar a primeira letra de cada uma das tr\u00eas primeiras strings com a seguinte fun\u00e7\u00e3o. iniciais :: [ String ] -> [ Char ] iniciais [] = [] iniciais [( x : _ )] = [ x ] iniciais [( x : _ ),( y : _ )] = [ x , y ] iniciais (( x : _ ) : ( y : _ ) : ( z : _ ) : _ ) = [ x , y , z ] Recurs\u00e3o A recurs\u00e3o \u00e9 essencial no processamento de listas e, de fato, muitas das fun\u00e7\u00f5es listadas na se\u00e7\u00e3o anterior podem e s\u00e3o definidas recursivamente, como a fun\u00e7\u00e3o maximum : \\(maximum~[1,2,3] = max~1 \\left( maximum~[2,3] = max~2 \\left( maximum~[3] = 3 \\right) \\right)\\) Vejamos algumas defini\u00e7\u00f5es. 3 maximum maximum' [] = error \"lista vazia\" maximum' [ h ] = h maximum' ( h : t ) = max h ( maximum' t ) length length' :: [ a ] -> Int length' [] = 0 length' ( x : xs ) = 1 + length' xs last last' :: [ a ] -> a last' [] = error \"List is empty\" last' [ x ] = x last' ( _ : xs ) = last' xs reverse reverse' :: [ a ] -> [ a ] reverse' [] = [] reverse' ( x : xs ) = reverse' xs ++ [ x ] replicate replicate' 0 e = [] replicate' x e = e : replicate' ( x - 1 ) e zip zip' [] _ = [] zip' _ [] = [] zip' ( x : xs ) ( y : ys ) = ( x , y ) : zip' xs ys elem elem' _ [] = False elem' e ( x : xs ) = e == x || elem' e xs ++ maisMais :: [ a ] -> [ a ] -> [ a ] maisMais [] [] = [] maisMais [] y = y maisMais ( x : xs ) y = x : maisMais xs y Exerc\u00edcio Defina a fun\u00e7\u00e3o take Defina a fun\u00e7\u00e3o drop Defina a fun\u00e7\u00e3o uni\u00e3o que recebe duas listas sem repeti\u00e7\u00f5es retorna a concatena\u00e7\u00e3o das listas, sem repeti\u00e7\u00f5es, usando recursividade. Defina a fun\u00e7\u00e3o uni\u00e3o que recebe duas listas sem repeti\u00e7\u00f5es retorna a concatena\u00e7\u00e3o das listas, sem repeti\u00e7\u00f5es, usando compreens\u00e3o de listas. Ordena\u00e7\u00e3o Selection-sort ( https://www.youtube.com/embed/Ns4TPTC8whw ) Defina uma fun\u00e7\u00e3o fr que receba um inteiro i e uma lista de inteiros l e retorne a lista l sem a primeira ocorr\u00eancia de i em l . Defina uma fun\u00e7\u00e3o fm que receba uma lista de inteiros l e retorne o menor inteiro da lista. Defina uma fun\u00e7\u00e3o fs que receba uma lista de inteiros l , escolha o menor inteiro m de l e retorne m concatenado a cabe\u00e7a da lista gerada por fs (fr m l) Merge-Sort ( https://www.youtube.com/embed/XaqR3G_NVoo ) Defina uma fun\u00e7\u00e3o fd que receba uma lista e retorne suas duas metades em uma dupla: metade [ 1 .. 11 ] = ([ 1 , 2 , 3 , 4 , 5 ],[ 6 , 7 , 8 , 9 , 10 , 11 ]) Defina uma fun\u00e7\u00e3o fu que receba duas listas ordenadas e retorne uma lista ordenada com a uni\u00e3o das listas uni\u00e3o [ 1 , 3 , 5 , 7 ] [ 2 , 4 , 6 , 7 ] = [ 1 , 2 , 3 , 5 , 6 , 7 , 7 ] Defina uma fun\u00e7\u00e3o fm que receba uma lista, divida-a na metade usando fd , aplique fm recursivamente em cada metade, e calcule a uni\u00e3o das listas resultantes usando fu . Quick-sort Defina uma fun\u00e7\u00e3o fp que receba uma lista l de inteiros e retorne retorne uma tripla (p,m1,m2) em que p \u00e9 o primeiro elemento da lista l m1 \u00e9 a lista dos elementos em l menores ou iguais a p , exclusive m2 \u00e9 a lista dos elementos em l maiores que p Defina uma fun\u00e7\u00e3o fq que recebe uma lista l , calcule (p,m1,m2) = fp l e retorne fq m1 concatenado a p concatenado a fq m2 . Foi feita uma pequena edi\u00e7\u00e3o na sa\u00edda do comando : t para claridade, pois o resultado real envolvia supertipos, a serem vistos mais adiante. \u21a9 No exemplo, observe o espa\u00e7o entre Copas e .. . \u21a9 Todas as fun\u00e7\u00f5es definidas a seguir tem nome terminado em ``` para evitar colis\u00e3o com as fun\u00e7\u00f5es padr\u00e3o. \u21a9","title":"Listas"},{"location":"types2/lists_again/#listas","text":"Vamos agora estudar listas, pe\u00e7as fundamentais no desenvolvimento de programas usando o paradigma funcional, por serem estruturas de dados que permitem agregar v\u00e1rias informa\u00e7\u00f5es na forma de uma cole\u00e7\u00e3o ordenada de elementos. Por exemplo, [ \"Eu\" , \"amo\" , \"programa\u00e7\u00e3o\" , \"funcional\" ] \u00e9 a cole\u00e7\u00e3o de quatro strings em que o primeiro elemento \u00e9 \"Eu\" , o segundo \"amo\" , o terceiro \"programa\u00e7\u00e3o\" e o quarto e \u00faltimo \"funcional\" . J\u00e1 [ 1 :: Int , 2 :: Int , 3 :: Int ] \u00e9 uma lista de 3 elementos do tipo Int , onde o primeiro elemento \u00e9 1, o segundo 2, e o terceiro 3. \"Mas e as tuplas?\", voc\u00ea pergunta, \"N\u00e3o s\u00e3o exatamente isto?\"","title":"Listas"},{"location":"types2/lists_again/#estrutura","text":"Dado uma lista qualquer, de qualquer tipo, ela pode ser ou vazia ou n\u00e3o vazia, sendo que a lista vazia \u00e9 representada em Haskell por [] . Listas n\u00e3o vazias s\u00e3o representadas como a concatena\u00e7\u00e3o do primeiro elemento da lista com uma lista com os demais elementos, usando o operador de concatena\u00e7\u00e3o : , ou cons . Por exemplo, a lista dos n\u00fameros 1, 2 e 3 nesta ordem \u00e9 constru\u00edda como 1 : 2 : 3 :[] ; observe que como o 3 \u00e9 o \u00faltimo elemento da lista, a lista que vem depois do cons, com os demais elementos, \u00e9 a lista vazia. Prelude > x = 1 : 2 : 3 :[] Prelude > x [ 1 , 2 , 3 ]","title":"Estrutura"},{"location":"types2/lists_again/#funcoes-uteis","text":"Em uma se\u00e7\u00e3o anterior, apresentamos algumas fun\u00e7\u00f5es como \u00fateis na manipula\u00e7\u00e3o de String. Na verdade, todas aquelas fun\u00e7\u00f5es s\u00e3o definidas em termos de listas e, por isso, as revisitaremos aqui juntamente com mais algumas. Operador Opera\u00e7\u00e3o Exemplo ++ Concatena\u00e7\u00e3o de listas > \"foo\" ++ \"bar\" \"foobar\" !! Elemento no \u00edndice > [ 1 , 2 , 3 , 4 ] !! 2 3 reverse Lista ao contr\u00e1rio > reverse [ 1 , 2 , 3 , 4 ] [4,3,2,1] length Comprimento da string > length \"foo bar\" 7 last \u00daltimo elemento da lista > last \"foo bar\" r concat Retorna a concatena\u00e7\u00e3o das listas dentro de uma lista > concat [[ 1 , 2 , 3 , 4 ],[ 5 , 6 , 7 , 8 ]] [1,2,3,4,5,6,7,8] > concat [[[ 1 , 2 , 3 ]],[[ 4 , 5 , 6 ]]] [[ 1 , 2 , 3 ],[ 4 , 5 , 6 ]] elem Verifica se o par\u00e2metro \u00e9 um elemento da lista > elem 'o' \"foo bar\" True null Verifica se a lista \u00e9 vazia > null \"\" True > null [] True > null [ 1 , 2 ] False replicate Constr\u00f3i uma lista pela replica\u00e7\u00e3o de um elemento > replicate 4 ( 1 , 2 ) [( 1 , 2 ),( 1 , 2 ),( 1 , 2 ),( 1 , 2 )] take Sublista iniciando em 0 > take 3 1 : 2 : 3 : 4 : 5 :[] [ 1 , 2 , 3 ] drop Sublista come\u00e7ando em um \u00edndice > drop 3 [ 'f' , 'o' , 'o' , ' ' , 'b' , 'a' , 'r' ] \" bar\" takeWhile Sublista iniciando em 0 e at\u00e9 o primeiro elemento que n\u00e3o satisfaz ao crit\u00e9rio, exclusive > takeWhile ( < 4 ) [ 1 , 2 , 3 , 4 , 5 , 6 ] [ 1 , 2 , 3 ] dropWhile Sublista come\u00e7ando no primeiro elemento que n\u00e3o satisfaz ao crit\u00e9rio, inclusive > dropWhile ( < 4 ) [ 1 , 2 , 3 , 4 , 5 , 6 ] 4 , 5 , 6 splitAt Dupla das sublistas geradas pela divis\u00e3o no \u00edndice especificado > splitAt 3 [ 1 , 2 , 3 , 4 , 5 , 6 ] ([ 1 , 2 , 3 ],[ 4 , 5 , 6 ]) zip Lista de pares com os elementos das duas listas passadas como par\u00e2metro > zip [ 1 , 2 , 3 ] [ 4 , 5 , 6 ] [( 1 , 4 ),( 2 , 5 ),( 3 , 6 )] sum Somat\u00f3rio dos elementos da lista > sum [ 1 , 2 , 3 , 4 , 5 , 6 ] 16 product Produt\u00f3rio dos elementos da lista > product [ 1 , 2 , 3 , 4 , 5 , 6 ] 720 maximum Maior dos elemento lista > maximum [ 1 , 2 , 3 , 4 , 5 , 6 ] 6 minimum Menor dos elementos da lista > minimum [ 1 , 2 , 3 , 4 , 5 , 6 ] 1","title":"Fun\u00e7\u00f5es \u00fateis"},{"location":"types2/lists_again/#enumeracao","text":"Para facilitar a vida dos desenvolvedores, Haskell permite a constru\u00e7\u00e3o de listas por enumera\u00e7\u00e3o, bastando para isso o especificar o primeiro elemento da lista, opcionalmente o segundo, e o \u00faltimo elemento. Por exemplo Prelude > [ 11 , 13 .. 23 ] [ 11 , 13 , 15 , 17 , 19 , 21 , 23 ] Prelude > [ - 15 , - 13 .. 14 ] [ - 15 , - 13 , - 11 , - 9 , - 7 , - 5 , - 3 , - 1 , 1 , 3 , 5 , 7 , 9 , 11 , 13 ] Observe que Haskell determinou um passo de incremento igual a \\(13-11 = 2\\) no primeiro exemplo e \\(-15 - -13 = 2\\) no segundo exemplo, e usou estes passos para gerar as lista. Tamb\u00e9m \u00e9 poss\u00edvel definir um passo negativo, como no pr\u00f3ximo exemplo. Prelude > [ 11 , 9 .. 0 ] [ 11 , 9 , 7 , 5 , 3 , 1 ] Como mencionado, o segundo elemento \u00e9 opcional na enumera\u00e7\u00e3o e caso n\u00e3o especificado, Haskell assume que seja \\(1\\) , como no exemplo a seguir. Prelude > [ 11 .. 23 ] [ 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 ] Prelude > [ 3.5 .. 10 ] [ 3.5 , 4.5 , 5.5 , 6.5 , 7.5 , 8.5 , 9.5 , 10.5 ] Contudo, n\u00e3o \u00e9 poss\u00edvel omitir o segundo elemento se a inten\u00e7\u00e3o for gerar uma lista com valores decrescentes. Prelude > [ 11 .. 0 ] [] A enumera\u00e7\u00e3o pode ser feita para outros tipos que n\u00e3o sejam num\u00e9ricos, bastando que exista uma rela\u00e7\u00e3o de ordem entre os elementos para que Haskell consiga \"incrementar\" a cada passo. Isso existe, por exemplo, entre os caracteres, mas tamb\u00e9m para tipos definidos pelo desenvolvedor. 2 Prelude > [ 'a' .. 'm' ] \"abcdefghijklm\" Prelude > data Naipe = Copas | Espada | Ouro | Paus deriving ( Ord , Eq , Enum , Show ) Prelude > [ Copas .. Ouro ] [ Copas , Espada , Ouro ] Exerc\u00edcio Defina uma fun\u00e7\u00e3o que dado um n\u00famero inteiro x, gere uma lista de 1 a x e de volta a 1. Resolu\u00e7\u00e3o vaiEVolta n = lista ++ drop 1 ( reverse lista ) where lista = [ 1 .. n ] * Main > vaiEVolta 3 [ 1 , 2 , 3 , 2 , 1 ] Defina uma fun\u00e7\u00e3o que calcule o fatorial e um n\u00famero n, usando product e listas por enumera\u00e7\u00e3o. Resolu\u00e7\u00e3o fatorial n = product [ 1 .. n ]","title":"Enumera\u00e7\u00e3o"},{"location":"types2/lists_again/#compreensao-de-listas","text":"A compreens\u00e3o de listas \u00e9 uma forma de construir listas pela defini\u00e7\u00e3o de uma regra de constru\u00e7\u00e3o, e \u00e9 muito comum nas linguagens funcionais, incluindo Haskell.","title":"Compreens\u00e3o de Listas"},{"location":"types2/lists_again/#casamento-de-padroes","text":"Toda lista \u00e9 ou uma lista vazia ou ou um elemento cabe\u00e7a seguido por uma lista cauda. Assim, se cobrir estes dois casos em uma defini\u00e7\u00e3o por casamento de padr\u00f5es, ter\u00e1 coberto \"todos\" os casos! Mas como? Vejamos um exemplo. oQueH\u00e1NaCabe\u00e7a :: ( Show a ) => [ a ] -> String oQueH\u00e1NaCabe\u00e7a [] = \"Nada\" oQueH\u00e1NaCabe\u00e7a ( x : xs ) = \"H\u00e1 \" ++ x Linha 1: n\u00e3o se preocupe esta linha; ela apenas implica que a lista deve ser de valores convert\u00edveis a String Linha 2: esta linha usa um padr\u00e3o constante para testar se a lista \u00e9 vazia, isto \u00e9, [] e, neste caso, retornar a string \"Nada\" como resultado. Linha 3: este \u00e9 o caso mais interessante, pois usa um padr\u00e3o que define uma lista em que x \u00e9 a cabe\u00e7a, concatenada por : a uma cauda xs , e retorna \"H\u00e1 \" seguido do valor casado com x . Observe que foram usados par\u00eanteses na linha 3 para especificar o padr\u00e3o, e n\u00e3o apenas x : xs como seria de se esperar. A verdade \u00e9 que o padr\u00e3o \u00e9 x : xs e os par\u00eantesis s\u00e3o usados apenas para impedir que Haskell primeiro avalie oQueH\u00e1NaCabe\u00e7a x antes de avaliar o operador : e o seu segundo operando. Esta \u00e9 uma das idiossincrasias de Haskell com a qual voc\u00ea simplesmente ter\u00e1 que aprender a conviver para dividir listas entre cabe\u00e7a e cauda em um casamento de padr\u00f5es. Embora estes dois padr\u00f5es, isto \u00e9, lista vazia e cabe\u00e7a seguida de cauda, cubram todas as possibilidades de listas, n\u00e3o quer dizer que n\u00e3o haja melhores op\u00e7\u00f5es, dependendo do que precise extrair da lista. Por exemplo, na pr\u00f3xima fun\u00e7\u00e3o h\u00e1 4 casos de casamento de padr\u00f5es distintos: oQueH\u00e1NaLista :: ( Show a ) => [ a ] -> String oQueH\u00e1NaLista [] = \"Nada\" oQueH\u00e1NaLista [ x ] = \"S\u00f3 \" ++ ( show x ) oQueH\u00e1NaLista [ x1 , x2 ] = \"H\u00e1 \" ++ ( show x1 ) ++ \" e \" ++ ( show x2 ) oQueH\u00e1NaLista ( x : xs ) = \"H\u00e1 \" ++ ( show x ) ++ \" e mais um monte de coisas\" Linha 2: lista vazia; Linha 3: lista com exatamente um elemento, casado com x . Linha 4: lista com exatamente 2 elementos, casados com x1 e x2 . Linha 5: lista com mais de 2 elementos, em que a cabe\u00e7a \u00e9 casada com x e a cauda com xs . Outra forma de obter exatamente o mesmo resultado, usando mais o operador cons , seria a seguinte. oQueH\u00e1NaLista :: ( Show a ) => [ a ] -> String oQueH\u00e1NaLista [] = \"Nada\" oQueH\u00e1NaLista ( x :[] ) = \"S\u00f3 \" ++ ( show x ) oQueH\u00e1NaLista ( x1 : x2 :[] ) = \"H\u00e1 \" ++ ( show x1 ) ++ \" e \" ++ ( show x2 ) oQueH\u00e1NaLista ( x : xs ) = \"H\u00e1 \" ++ ( show x ) ++ \" e mais um monte de coisas\" Dado que strings s\u00e3o apenas listas de Char, estas tamb\u00e9m podem ser decompostas por casamentos de padr\u00f5es. resumo :: String -> String resumo [] -> \"Nada\" resumo [ _ ] -> \"Um\" resumo [ _ , _ ] -> \"Dois\" resumo _ -> \"Muitos\" Assim como listas podem ter elementos mais complexos que tipos primitivos, por exemplo tuplas e listas, tamb\u00e9m os casamentos de padr\u00f5es aplicados a estas listas ser\u00e3o mais complexos. Por exemplo, considere uma lista de tr\u00eas ou mais String, isto \u00e9, uma lista de lista de Char; \u00e9 poss\u00edvel, por exemplo, selecionar a primeira letra de cada uma das tr\u00eas primeiras strings com a seguinte fun\u00e7\u00e3o. iniciais :: [ String ] -> [ Char ] iniciais [] = [] iniciais [( x : _ )] = [ x ] iniciais [( x : _ ),( y : _ )] = [ x , y ] iniciais (( x : _ ) : ( y : _ ) : ( z : _ ) : _ ) = [ x , y , z ]","title":"Casamento de padr\u00f5es"},{"location":"types2/lists_again/#recursao","text":"A recurs\u00e3o \u00e9 essencial no processamento de listas e, de fato, muitas das fun\u00e7\u00f5es listadas na se\u00e7\u00e3o anterior podem e s\u00e3o definidas recursivamente, como a fun\u00e7\u00e3o maximum : \\(maximum~[1,2,3] = max~1 \\left( maximum~[2,3] = max~2 \\left( maximum~[3] = 3 \\right) \\right)\\) Vejamos algumas defini\u00e7\u00f5es. 3 maximum maximum' [] = error \"lista vazia\" maximum' [ h ] = h maximum' ( h : t ) = max h ( maximum' t ) length length' :: [ a ] -> Int length' [] = 0 length' ( x : xs ) = 1 + length' xs last last' :: [ a ] -> a last' [] = error \"List is empty\" last' [ x ] = x last' ( _ : xs ) = last' xs reverse reverse' :: [ a ] -> [ a ] reverse' [] = [] reverse' ( x : xs ) = reverse' xs ++ [ x ] replicate replicate' 0 e = [] replicate' x e = e : replicate' ( x - 1 ) e zip zip' [] _ = [] zip' _ [] = [] zip' ( x : xs ) ( y : ys ) = ( x , y ) : zip' xs ys elem elem' _ [] = False elem' e ( x : xs ) = e == x || elem' e xs ++ maisMais :: [ a ] -> [ a ] -> [ a ] maisMais [] [] = [] maisMais [] y = y maisMais ( x : xs ) y = x : maisMais xs y Exerc\u00edcio Defina a fun\u00e7\u00e3o take Defina a fun\u00e7\u00e3o drop Defina a fun\u00e7\u00e3o uni\u00e3o que recebe duas listas sem repeti\u00e7\u00f5es retorna a concatena\u00e7\u00e3o das listas, sem repeti\u00e7\u00f5es, usando recursividade. Defina a fun\u00e7\u00e3o uni\u00e3o que recebe duas listas sem repeti\u00e7\u00f5es retorna a concatena\u00e7\u00e3o das listas, sem repeti\u00e7\u00f5es, usando compreens\u00e3o de listas. Ordena\u00e7\u00e3o Selection-sort ( https://www.youtube.com/embed/Ns4TPTC8whw ) Defina uma fun\u00e7\u00e3o fr que receba um inteiro i e uma lista de inteiros l e retorne a lista l sem a primeira ocorr\u00eancia de i em l . Defina uma fun\u00e7\u00e3o fm que receba uma lista de inteiros l e retorne o menor inteiro da lista. Defina uma fun\u00e7\u00e3o fs que receba uma lista de inteiros l , escolha o menor inteiro m de l e retorne m concatenado a cabe\u00e7a da lista gerada por fs (fr m l) Merge-Sort ( https://www.youtube.com/embed/XaqR3G_NVoo ) Defina uma fun\u00e7\u00e3o fd que receba uma lista e retorne suas duas metades em uma dupla: metade [ 1 .. 11 ] = ([ 1 , 2 , 3 , 4 , 5 ],[ 6 , 7 , 8 , 9 , 10 , 11 ]) Defina uma fun\u00e7\u00e3o fu que receba duas listas ordenadas e retorne uma lista ordenada com a uni\u00e3o das listas uni\u00e3o [ 1 , 3 , 5 , 7 ] [ 2 , 4 , 6 , 7 ] = [ 1 , 2 , 3 , 5 , 6 , 7 , 7 ] Defina uma fun\u00e7\u00e3o fm que receba uma lista, divida-a na metade usando fd , aplique fm recursivamente em cada metade, e calcule a uni\u00e3o das listas resultantes usando fu . Quick-sort Defina uma fun\u00e7\u00e3o fp que receba uma lista l de inteiros e retorne retorne uma tripla (p,m1,m2) em que p \u00e9 o primeiro elemento da lista l m1 \u00e9 a lista dos elementos em l menores ou iguais a p , exclusive m2 \u00e9 a lista dos elementos em l maiores que p Defina uma fun\u00e7\u00e3o fq que recebe uma lista l , calcule (p,m1,m2) = fp l e retorne fq m1 concatenado a p concatenado a fq m2 . Foi feita uma pequena edi\u00e7\u00e3o na sa\u00edda do comando : t para claridade, pois o resultado real envolvia supertipos, a serem vistos mais adiante. \u21a9 No exemplo, observe o espa\u00e7o entre Copas e .. . \u21a9 Todas as fun\u00e7\u00f5es definidas a seguir tem nome terminado em ``` para evitar colis\u00e3o com as fun\u00e7\u00f5es padr\u00e3o. \u21a9","title":"Recurs\u00e3o"},{"location":"types2/type_variables/","text":"Polimorfismo Observe o funcionamento da fun\u00e7\u00e3o head nos seguintes exemplos. > head [( 1 , 2 ),( 3 , 4 ),( 5 , 6 )] ( 1 , 2 ) > head [ 1 , 2 , 3 , 4 ] 1 > head \"abcd\" 'a' Independentemente do tipo dos elementos da lista e, portanto, da lista, head consistentemente retorna o primeiro elemento da lista passada como par\u00e2metro. Isso acontece porqu\u00ea a fun\u00e7\u00e3o head \u00e9 o que chamamos de polim\u00f3rfica , literalmente, com muitos formas, e pode atuar sobre listas de diversos tipos. Fun\u00e7\u00f5es polim\u00f3rficas s\u00e3o declaradas usando vari\u00e1veis de tipo em vez de tipos espec\u00edficos para os par\u00e2metros, como fizemos at\u00e9 agora. A fun\u00e7\u00e3o head , por exemplo, tem declara\u00e7\u00e3o de tipo head :: [ a ] -> a , 1 onde a \u00e9 a vari\u00e1vel de tipo. Esta declara\u00e7\u00e3o implica que a fun\u00e7\u00e3o recebe como par\u00e2metro uma lista de elementos de um tipo qualquer a e que retorna um elemento do mesmo tipo a . V\u00e1rias vari\u00e1veis de tipos podem aparecer em uma mesma declara\u00e7\u00e3o, como em snd :: ( a , b ) -> b , que define que o resultado da fun\u00e7\u00e3o \u00e9 do mesmo tipo do segundo elemento da dupla passada como par\u00e2metros, ou zip :: [ a ] -> [ b ] -> [( a , b )] , que combina o tipo dos par\u00e2metros de entrada em uma tupla dos mesmos tipos no resultado da fun\u00e7\u00e3o. Observe que vari\u00e1veis de tipo devem come\u00e7ar com uma letra min\u00fascula e, geralmente, s\u00e3o recebem nomes a , b , c ... , mas fora isso, podem ter qualquer nome, o que literalmente permite que fun\u00e7\u00f5es tenham uma infinitude de nomes. Declara\u00e7\u00f5es tamb\u00e9m podem misturar vari\u00e1veis de tipo com tipos normais, como em length :: [ a ] -> Int , que define que o comprimento de uma lista de qualquer tipo ser\u00e1 sempre do tipo Int , e take :: Int -> [ a ] -> [ a ] . Enquanto algumas fun\u00e7\u00f5es tem vari\u00e1veis de tipo completamente livres, isto \u00e9, podem ser instanciadas com qualquer tipo, outras imp\u00f5em certas restri\u00e7\u00f5es nos tipos na forma de classes de tipo . Por exemplo, a fun\u00e7\u00e3o sort recebe uma lista de dados e retorna uma lista com os mesmos dados, ordenados. Para implementar a ordena\u00e7\u00e3o, \u00e9 preciso que os elementos da lista possam ser comparados uns com os outros, o que \u00e9 determinado pela pertin\u00eancia do tipo \u00e0 classe de tipos Ord . A declara\u00e7\u00e3o da fun\u00e7\u00e3o fica ent\u00e3o assim: sort :: Ord a => [ a ] -> [ a ] . 2 Uma mesma vari\u00e1vel de tipo pode pertencer a m\u00faltiplas classes e diferentes vari\u00e1veis podem pertencer a classes diferentes, como nas seguintes declara\u00e7\u00f5es: quickSort :: Ord a => [ a ] -> [ a ] quickSort [] = [] quickSort ( x : xs ) = quickSort ( filter ( <= x ) xs ) ++ [ x ] ++ quickSort ( filter ( > x ) xs ) sortAndPrint :: ( Show a , Ord a ) => [ a ] -> [ String ] sortAndPrint l = map show ( quickSort l ) > quickSort [ 10 , 9 .. 1 ] [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] > sortAndPrint [ 10 , 9 .. 1 ] [ \"1\" , \"2\" , \"3\" , \"4\" , \"5\" , \"6\" , \"7\" , \"8\" , \"9\" , \"10\" ] Este tipo de polimorfismo, em que o tipo n\u00e3o tem qualquer restri\u00e7\u00e3o, \u00e9 denominado param\u00e9trico . \u21a9 Este tipo de polimorfismo \u00e9 denominado ad-hoc . \u21a9","title":"Polimorfismo"},{"location":"types2/type_variables/#polimorfismo","text":"Observe o funcionamento da fun\u00e7\u00e3o head nos seguintes exemplos. > head [( 1 , 2 ),( 3 , 4 ),( 5 , 6 )] ( 1 , 2 ) > head [ 1 , 2 , 3 , 4 ] 1 > head \"abcd\" 'a' Independentemente do tipo dos elementos da lista e, portanto, da lista, head consistentemente retorna o primeiro elemento da lista passada como par\u00e2metro. Isso acontece porqu\u00ea a fun\u00e7\u00e3o head \u00e9 o que chamamos de polim\u00f3rfica , literalmente, com muitos formas, e pode atuar sobre listas de diversos tipos. Fun\u00e7\u00f5es polim\u00f3rficas s\u00e3o declaradas usando vari\u00e1veis de tipo em vez de tipos espec\u00edficos para os par\u00e2metros, como fizemos at\u00e9 agora. A fun\u00e7\u00e3o head , por exemplo, tem declara\u00e7\u00e3o de tipo head :: [ a ] -> a , 1 onde a \u00e9 a vari\u00e1vel de tipo. Esta declara\u00e7\u00e3o implica que a fun\u00e7\u00e3o recebe como par\u00e2metro uma lista de elementos de um tipo qualquer a e que retorna um elemento do mesmo tipo a . V\u00e1rias vari\u00e1veis de tipos podem aparecer em uma mesma declara\u00e7\u00e3o, como em snd :: ( a , b ) -> b , que define que o resultado da fun\u00e7\u00e3o \u00e9 do mesmo tipo do segundo elemento da dupla passada como par\u00e2metros, ou zip :: [ a ] -> [ b ] -> [( a , b )] , que combina o tipo dos par\u00e2metros de entrada em uma tupla dos mesmos tipos no resultado da fun\u00e7\u00e3o. Observe que vari\u00e1veis de tipo devem come\u00e7ar com uma letra min\u00fascula e, geralmente, s\u00e3o recebem nomes a , b , c ... , mas fora isso, podem ter qualquer nome, o que literalmente permite que fun\u00e7\u00f5es tenham uma infinitude de nomes. Declara\u00e7\u00f5es tamb\u00e9m podem misturar vari\u00e1veis de tipo com tipos normais, como em length :: [ a ] -> Int , que define que o comprimento de uma lista de qualquer tipo ser\u00e1 sempre do tipo Int , e take :: Int -> [ a ] -> [ a ] . Enquanto algumas fun\u00e7\u00f5es tem vari\u00e1veis de tipo completamente livres, isto \u00e9, podem ser instanciadas com qualquer tipo, outras imp\u00f5em certas restri\u00e7\u00f5es nos tipos na forma de classes de tipo . Por exemplo, a fun\u00e7\u00e3o sort recebe uma lista de dados e retorna uma lista com os mesmos dados, ordenados. Para implementar a ordena\u00e7\u00e3o, \u00e9 preciso que os elementos da lista possam ser comparados uns com os outros, o que \u00e9 determinado pela pertin\u00eancia do tipo \u00e0 classe de tipos Ord . A declara\u00e7\u00e3o da fun\u00e7\u00e3o fica ent\u00e3o assim: sort :: Ord a => [ a ] -> [ a ] . 2 Uma mesma vari\u00e1vel de tipo pode pertencer a m\u00faltiplas classes e diferentes vari\u00e1veis podem pertencer a classes diferentes, como nas seguintes declara\u00e7\u00f5es: quickSort :: Ord a => [ a ] -> [ a ] quickSort [] = [] quickSort ( x : xs ) = quickSort ( filter ( <= x ) xs ) ++ [ x ] ++ quickSort ( filter ( > x ) xs ) sortAndPrint :: ( Show a , Ord a ) => [ a ] -> [ String ] sortAndPrint l = map show ( quickSort l ) > quickSort [ 10 , 9 .. 1 ] [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] > sortAndPrint [ 10 , 9 .. 1 ] [ \"1\" , \"2\" , \"3\" , \"4\" , \"5\" , \"6\" , \"7\" , \"8\" , \"9\" , \"10\" ] Este tipo de polimorfismo, em que o tipo n\u00e3o tem qualquer restri\u00e7\u00e3o, \u00e9 denominado param\u00e9trico . \u21a9 Este tipo de polimorfismo \u00e9 denominado ad-hoc . \u21a9","title":"Polimorfismo"},{"location":"types2/userdefined/","text":"Defini\u00e7\u00e3o de novos tipos A palavra reservada type permite que definamos apelidos para tipos no Haskell, tornando o c\u00f3digo mais leg\u00edvel. Por exemplo, podemos definir um tipo Inteiro similar ao tipo Int e fun\u00e7\u00f5es associadas ao tipo. type Inteiro = Int somaInteiros :: Inteiro -> Inteiro -> Inteiro somaInteiros a b = a + b O uso da fun\u00e7\u00e3o \u00e9 como esperado. * Main > somaInteiros 1 2 3 * Main > somaInteiros ( 1 :: Inteiro ) ( 2 :: Inteiro ) 3 Tuplas como tipos Como visto anteriormente, a palavra reservada type permite que definamos apelidos para tipos no Haskell. Pois tuplas tamb\u00e9m podem ser associadas a tipos, por exemplo, podemos definir que Pessoa \u00e9 o tipo definido na se\u00e7\u00e3o anterior, i.e., uma tupla dos campos nome, telefone, CPF e endere\u00e7o. type Pessoa = ( String , String , String , String ) fazPessoa :: String -> String -> String -> String -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> String pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> String pegaTelefone ( _ , telefone , _ , _ ) = telefone pegaCPF :: Pessoa -> String pegaCPF ( _ , _ , c , _ ) = c pegaEndere\u00e7o :: Pessoa -> String pegaEndere\u00e7o ( _ , _ , _ , e ) = e trocaTelefone :: Pessoa -> String -> Pessoa trocaTelefone p novoTelefone = fazPessoa ( pegaNome p ) novoTelefone ( pegaCPF p ) ( pegaEndere\u00e7o p ) Se perguntarmos ao Haskell qual o tipo da tupla gerada pela fun\u00e7\u00e3o fazPessoa , ele responder\u00e1 Pessoa . > : t fazPessoa fazPessoa :: String -> String -> String -> String -> Pessoa > p = fazPessoa \"Jose\" \"Tel\" \"CPF\" \"End\" > : t p p :: Pessoa Podemos ir al\u00e9m e definir tipos usando outros tipos estruturados. Por exemplo: type Nome = ( String , String , String ) type Telefone = ( String , String ) type CPF = String type Endere\u00e7o = ( String , String , String ) type Pessoa = ( Nome , Telefone , CPF , Endere\u00e7o ) fazPessoa :: Nome -> Telefone -> CPF -> Endere\u00e7o -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> Nome pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> Telefone pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone :: Pessoa -> Telefone -> Pessoa trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) Neste caso > p = fazPessoa ( \"Jos\u00e9\" , \"da\" , \"Silva\" ) ( \"ddd\" , \"numero\" ) \"CPF\" ( \"Rua da Couves\" , \"143\" , \"Brasil\" ) > p (( \"Jos \\233 \" , \"da\" , \"Silva\" ),( \"ddd\" , \"numero\" ), \"CPF\" ,( \"Rua da Couves\" , \"143\" , \"Brasil\" )) > : t p p :: Pessoa > n = pegaNome p > n ( \"Jos \\233 \" , \"da\" , \"Silva\" ) > : t n n :: Nome Vejamos outro exemplo; sejam datas, tuplas de 3 inteiros: dia, m\u00eas e ano. Assim, 25 de dezembro de 1999 \u00e9 ( 25 , 12 , 1999 ) . Dado duas datas v\u00e1lidas, uma opera\u00e7\u00e3o interessante \u00e9 testar se uma data \u00e9 menor que outra. type Data = ( Int , Int , Int ) dataEhMenor :: ( Int , Int , Int ) -> ( Int , Int , Int ) -> Bool dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) dataEhMenor' :: Data -> Data -> Bool dataEhMenor' ( de , me , ae ) ( dd , md , ad ) = if ae < ad then True else if me < md then True else if de < dd then True else False Mas esta fun\u00e7\u00e3o pode ser descartada com a escolha da defini\u00e7\u00e3o de data, pois tuplas s\u00e3o naturalmente orden\u00e1veis. Data V\u00e1lida Defina um tipo para representar datas como tuplas. Defina uma fun\u00e7\u00e3o dataValida que receba uma data e retorne True se a data for v\u00e1lida e False se for inv\u00e1lida. Por exemplo, 38 de onzembro de 2021 \u00e9 uma data inv\u00e1lida, assim como 29 de fevereiro de 2017, mas dia primeiro de Janeiro de 2000 \u00e9 v\u00e1lida. Isto \u00e9, dataValida ( 38 , 13 , 2021 ) == False dataValida ( 29 , 02 , 2017 ) == False dataValida ( 1 , 1 , 2000 ) == True Resolu\u00e7\u00e3o type Data = ( Int , Int , Int ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) {- >>> bissexto 3 False >>> bissexto 20 True >>> bissexto 100 False >>> bissexto 2000 True -} bissexto :: Integral a => a -> Bool bissexto x | mod x 400 == 0 = True | mod x 100 == 0 = False | otherwise = mod x 4 == 0 {- >>> dataValida (1,1,2001) True >>> dataValida (1,13,2001) False >>> dataValida (29,2,2000) True >>> dataValida (29,2,1999) -} dataValida :: ( Int , Int , Int ) -> Bool dataValida ( d , m , a ) = anoValido a && mesValido m && diaValido d m ( bissexto a ) {- >>> diaValido 2 1 False True >>> diaValido 2 1 True True >>> diaValido 29 2 False False >>> diaValido 29 2 True True -} diaValido :: Int -> Int -> Bool -> Bool diaValido d m bi = d > 0 && d <= numDias m bi {- >>> numDias 3 False 31 >>> numDias 2 True 29 >>> numDias 2 False 28 -} numDias :: Int -> Bool -> Int numDias m bi | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = if bi then 29 else 28 | otherwise = 30 {- >>> mesValido 4 True >>> mesValido 13 False -} mesValido :: Int -> Bool mesValido m = m > 0 && m < 13 {- >>> anoValido 3000 True -} anoValido :: Int -> Bool anoValido a = a > 0 :type e :info O GHC \u00e9 uma ferramenta poderosa no aprendizado da linguagem Haskell por possuir uma s\u00e9rie de comandos que permitem extrair informa\u00e7\u00f5es sobre tipos e fun\u00e7\u00f5es definidas. Usando o comando : info (ou simplesmente : i ), por exemplo, podemos perguntar ao ghci o que ele sabe sobre o tipo Inteiro , ao que ser\u00e1 respondido que \u00e9 o tipo inteiro \u00e9 um apelido para Int , definido no arquivo scratch.hs, no meu caso. * Main > : i Inteiro type Inteiro :: * type Inteiro = Int -- Defined at scratch.hs:82:1 J\u00e1 o comando : type (ou : t ) pode ser usado para identificar o tipo de fun\u00e7\u00f5es, por exemplo: * Main > somaInteiros 1 2 3 * Main > : i somaInteiros somaInteiros :: Inteiro -> Inteiro -> Inteiro * Main > : t 1 :: Inteiro 1 :: Inteiro :: Inteiro Estes comandos podem ser aplicados a quaisquer defini\u00e7\u00f5es, n\u00e3o somente \u00e0s suas. Por exemplo, podemos solicitar informa\u00e7\u00f5es sobre o tipo Num , com seguinte resultado. * Main > : i Num type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ( - ) :: a -> a -> a ( * ) :: a -> a -> a negate :: a -> a abs :: a -> a signum :: a -> a fromInteger :: Integer -> a {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-} -- Defined in \u2018GHC.Num\u2019 instance Num Word -- Defined in \u2018GHC.Num\u2019 instance Num Integer -- Defined in \u2018GHC.Num\u2019 instance Num Int -- Defined in \u2018GHC.Num\u2019 instance Num Float -- Defined in \u2018GHC.Float\u2019 instance Num Double -- Defined in \u2018GHC.Float\u2019 Algumas das informa\u00e7\u00f5es apresentadas podem ainda n\u00e3o fazer sentido para voc\u00ea, mas de forma geral podemos resum\u00ed-las como implicando que algumas opera\u00e7\u00f5es, como + , - e abs se aplicam ao tipo Num , e que outros tipos, como Float e Integer s\u00e3o inst\u00e2ncias de Num . Se aplicarmos o mesmo comando ao operador + , descobriremos que ele \u00e9 uma fun\u00e7\u00e3o infixa por padr\u00e3o ( INFIXl ), associativo \u00e0 esquerda ( infixL ), e com prioridade 6. * Main > : i ( + ) type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ... -- Defined in \u2018GHC.Num\u2019 infixl 6 + Tamb\u00e9m vemos que o estas defini\u00e7\u00f5es s\u00e3o parde do GHC.Num, mas o que \u00e9 o GHC.Num?","title":"Novos"},{"location":"types2/userdefined/#definicao-de-novos-tipos","text":"A palavra reservada type permite que definamos apelidos para tipos no Haskell, tornando o c\u00f3digo mais leg\u00edvel. Por exemplo, podemos definir um tipo Inteiro similar ao tipo Int e fun\u00e7\u00f5es associadas ao tipo. type Inteiro = Int somaInteiros :: Inteiro -> Inteiro -> Inteiro somaInteiros a b = a + b O uso da fun\u00e7\u00e3o \u00e9 como esperado. * Main > somaInteiros 1 2 3 * Main > somaInteiros ( 1 :: Inteiro ) ( 2 :: Inteiro ) 3","title":"Defini\u00e7\u00e3o de novos tipos"},{"location":"types2/userdefined/#tuplas-como-tipos","text":"Como visto anteriormente, a palavra reservada type permite que definamos apelidos para tipos no Haskell. Pois tuplas tamb\u00e9m podem ser associadas a tipos, por exemplo, podemos definir que Pessoa \u00e9 o tipo definido na se\u00e7\u00e3o anterior, i.e., uma tupla dos campos nome, telefone, CPF e endere\u00e7o. type Pessoa = ( String , String , String , String ) fazPessoa :: String -> String -> String -> String -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> String pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> String pegaTelefone ( _ , telefone , _ , _ ) = telefone pegaCPF :: Pessoa -> String pegaCPF ( _ , _ , c , _ ) = c pegaEndere\u00e7o :: Pessoa -> String pegaEndere\u00e7o ( _ , _ , _ , e ) = e trocaTelefone :: Pessoa -> String -> Pessoa trocaTelefone p novoTelefone = fazPessoa ( pegaNome p ) novoTelefone ( pegaCPF p ) ( pegaEndere\u00e7o p ) Se perguntarmos ao Haskell qual o tipo da tupla gerada pela fun\u00e7\u00e3o fazPessoa , ele responder\u00e1 Pessoa . > : t fazPessoa fazPessoa :: String -> String -> String -> String -> Pessoa > p = fazPessoa \"Jose\" \"Tel\" \"CPF\" \"End\" > : t p p :: Pessoa Podemos ir al\u00e9m e definir tipos usando outros tipos estruturados. Por exemplo: type Nome = ( String , String , String ) type Telefone = ( String , String ) type CPF = String type Endere\u00e7o = ( String , String , String ) type Pessoa = ( Nome , Telefone , CPF , Endere\u00e7o ) fazPessoa :: Nome -> Telefone -> CPF -> Endere\u00e7o -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> Nome pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> Telefone pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone :: Pessoa -> Telefone -> Pessoa trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) Neste caso > p = fazPessoa ( \"Jos\u00e9\" , \"da\" , \"Silva\" ) ( \"ddd\" , \"numero\" ) \"CPF\" ( \"Rua da Couves\" , \"143\" , \"Brasil\" ) > p (( \"Jos \\233 \" , \"da\" , \"Silva\" ),( \"ddd\" , \"numero\" ), \"CPF\" ,( \"Rua da Couves\" , \"143\" , \"Brasil\" )) > : t p p :: Pessoa > n = pegaNome p > n ( \"Jos \\233 \" , \"da\" , \"Silva\" ) > : t n n :: Nome Vejamos outro exemplo; sejam datas, tuplas de 3 inteiros: dia, m\u00eas e ano. Assim, 25 de dezembro de 1999 \u00e9 ( 25 , 12 , 1999 ) . Dado duas datas v\u00e1lidas, uma opera\u00e7\u00e3o interessante \u00e9 testar se uma data \u00e9 menor que outra. type Data = ( Int , Int , Int ) dataEhMenor :: ( Int , Int , Int ) -> ( Int , Int , Int ) -> Bool dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) dataEhMenor' :: Data -> Data -> Bool dataEhMenor' ( de , me , ae ) ( dd , md , ad ) = if ae < ad then True else if me < md then True else if de < dd then True else False Mas esta fun\u00e7\u00e3o pode ser descartada com a escolha da defini\u00e7\u00e3o de data, pois tuplas s\u00e3o naturalmente orden\u00e1veis. Data V\u00e1lida Defina um tipo para representar datas como tuplas. Defina uma fun\u00e7\u00e3o dataValida que receba uma data e retorne True se a data for v\u00e1lida e False se for inv\u00e1lida. Por exemplo, 38 de onzembro de 2021 \u00e9 uma data inv\u00e1lida, assim como 29 de fevereiro de 2017, mas dia primeiro de Janeiro de 2000 \u00e9 v\u00e1lida. Isto \u00e9, dataValida ( 38 , 13 , 2021 ) == False dataValida ( 29 , 02 , 2017 ) == False dataValida ( 1 , 1 , 2000 ) == True Resolu\u00e7\u00e3o type Data = ( Int , Int , Int ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) {- >>> bissexto 3 False >>> bissexto 20 True >>> bissexto 100 False >>> bissexto 2000 True -} bissexto :: Integral a => a -> Bool bissexto x | mod x 400 == 0 = True | mod x 100 == 0 = False | otherwise = mod x 4 == 0 {- >>> dataValida (1,1,2001) True >>> dataValida (1,13,2001) False >>> dataValida (29,2,2000) True >>> dataValida (29,2,1999) -} dataValida :: ( Int , Int , Int ) -> Bool dataValida ( d , m , a ) = anoValido a && mesValido m && diaValido d m ( bissexto a ) {- >>> diaValido 2 1 False True >>> diaValido 2 1 True True >>> diaValido 29 2 False False >>> diaValido 29 2 True True -} diaValido :: Int -> Int -> Bool -> Bool diaValido d m bi = d > 0 && d <= numDias m bi {- >>> numDias 3 False 31 >>> numDias 2 True 29 >>> numDias 2 False 28 -} numDias :: Int -> Bool -> Int numDias m bi | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = if bi then 29 else 28 | otherwise = 30 {- >>> mesValido 4 True >>> mesValido 13 False -} mesValido :: Int -> Bool mesValido m = m > 0 && m < 13 {- >>> anoValido 3000 True -} anoValido :: Int -> Bool anoValido a = a > 0","title":"Tuplas como tipos"},{"location":"types2/userdefined/#type-e-info","text":"O GHC \u00e9 uma ferramenta poderosa no aprendizado da linguagem Haskell por possuir uma s\u00e9rie de comandos que permitem extrair informa\u00e7\u00f5es sobre tipos e fun\u00e7\u00f5es definidas. Usando o comando : info (ou simplesmente : i ), por exemplo, podemos perguntar ao ghci o que ele sabe sobre o tipo Inteiro , ao que ser\u00e1 respondido que \u00e9 o tipo inteiro \u00e9 um apelido para Int , definido no arquivo scratch.hs, no meu caso. * Main > : i Inteiro type Inteiro :: * type Inteiro = Int -- Defined at scratch.hs:82:1 J\u00e1 o comando : type (ou : t ) pode ser usado para identificar o tipo de fun\u00e7\u00f5es, por exemplo: * Main > somaInteiros 1 2 3 * Main > : i somaInteiros somaInteiros :: Inteiro -> Inteiro -> Inteiro * Main > : t 1 :: Inteiro 1 :: Inteiro :: Inteiro Estes comandos podem ser aplicados a quaisquer defini\u00e7\u00f5es, n\u00e3o somente \u00e0s suas. Por exemplo, podemos solicitar informa\u00e7\u00f5es sobre o tipo Num , com seguinte resultado. * Main > : i Num type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ( - ) :: a -> a -> a ( * ) :: a -> a -> a negate :: a -> a abs :: a -> a signum :: a -> a fromInteger :: Integer -> a {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-} -- Defined in \u2018GHC.Num\u2019 instance Num Word -- Defined in \u2018GHC.Num\u2019 instance Num Integer -- Defined in \u2018GHC.Num\u2019 instance Num Int -- Defined in \u2018GHC.Num\u2019 instance Num Float -- Defined in \u2018GHC.Float\u2019 instance Num Double -- Defined in \u2018GHC.Float\u2019 Algumas das informa\u00e7\u00f5es apresentadas podem ainda n\u00e3o fazer sentido para voc\u00ea, mas de forma geral podemos resum\u00ed-las como implicando que algumas opera\u00e7\u00f5es, como + , - e abs se aplicam ao tipo Num , e que outros tipos, como Float e Integer s\u00e3o inst\u00e2ncias de Num . Se aplicarmos o mesmo comando ao operador + , descobriremos que ele \u00e9 uma fun\u00e7\u00e3o infixa por padr\u00e3o ( INFIXl ), associativo \u00e0 esquerda ( infixL ), e com prioridade 6. * Main > : i ( + ) type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ... -- Defined in \u2018GHC.Num\u2019 infixl 6 + Tamb\u00e9m vemos que o estas defini\u00e7\u00f5es s\u00e3o parde do GHC.Num, mas o que \u00e9 o GHC.Num?","title":":type e :info"}]}