{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Notas de Aula em Programa\u00e7\u00e3o Funcional","title":"Notas de Aula em <br> Programa\u00e7\u00e3o Funcional"},{"location":"#notas-de-aula-em-programacao-funcional","text":"","title":"Notas de Aula em  Programa\u00e7\u00e3o Funcional"},{"location":"algebraic_data_types/","text":"Tipos de dados alg\u00e9bricos Em se\u00e7\u00f5es anteriores, vimos que Haskell define diversos tipos de dados, como inteiros, booleanos e strings. Embora possamos usar os tipos b\u00e1sicos para resolver problemas, pode ser mais f\u00e1cil usar um vocabul\u00e1rio espec\u00edfico do problema, por exemplo data, nome, dire\u00e7\u00e3o, etc. Neste caso, podemos criar \"apelidos\" para tipos b\u00e1sicos, usando type . Mas Haskell \u00e9 mais poderoso que isso e permite que defina tipos novos a partir do zero. 1 Por exemplo, lembre-se do problemas discutidos que lidavam com cartas de baralho e como usamos uma dupla de String e Int para representar seus naipes e valores. Com data \u00e9 poss\u00edvel fazer algo melhor. data Com a palavra reservada data \u00e9 poss\u00edvel definir um novo tipo de dados (em ingl\u00eas, data ). O seguinte uso define um tipo para os naipes das cartas de um baralho. data Naipe = Copas | Espadas | Ouro | Paus Pela equa\u00e7\u00e3o seguinte, definimos o tipo de dados Naipe (lado esquerdo) como sendo igual a um dos valores do lado direito, dado que o lado direito \u00e9 uma disjun\u00e7\u00e3o. \u00c9 comum dizer que Naipe \u00e9 uma enumera\u00e7\u00e3o dos valores \u00e0 direita da equa\u00e7\u00e3o. Uma vez definido o tipo, podemos perguntar ao Haskell como ele \u00e9 interpretado. > data Naipe = Copas | Espadas | Ouro | Paus > : i Naipe type Naipe :: * data Naipe = Copas | Espadas | Ouro | Paus -- Defined at <interactive>:1:1 > : i Copas type Naipe :: * data Naipe = Copas | ... -- Defined at <interactive>:1:14 > : t Copas Copas :: Naipe Voc\u00ea tamb\u00e9m j\u00e1 pode usar o tipo em sua defini\u00e7\u00f5es, por exemplo: corDoNaipe :: Naipe -> String corDoNaipe Copas = \"Vermelho\" corDoNaipe Ouro = \"Vermelho\" corDoNaipe Paus = \"Preto\" corDoNaipe Espada = \"Preto\" Ou, equivalentemente, no seguinte exemplo. corDoNaipe :: Naipe -> String corDoNaipe n = case n of Copas -> \"Vermelho\" Ouro -> \"Vermelho\" Paus -> \"Preto\" Espada -> \"Preto\" Mas e o seguinte c\u00f3digo? corDoNaipe'' :: Naipe -> String corDoNaipe'' n | n == Copas = \"Vermelho\" | n == Ouro = \"Vermelho\" | n == Paus = \"Preto\" | n == Espada = \"Preto\" Se test\u00e1-lo, ver\u00e1 que n\u00e3o funciona. Um efeito semelhante \u00e9 observado quando fazemos algo mais simples ainda. Prelude > data Naipe = Copas | Espada | Ouro | Paus Prelude > Copas == Copas < interactive >: 2 : 1 : error : \u2022 No instance for ( Eq Naipe ) arising from a use of \u2018 == \u2019 \u2022 In the expression : Copas == Copas In an equation for \u2018 it \u2019 : it = Copas == Copas O problema aqui \u00e9 que Haskell n\u00e3o sabe como testar se dois naipes s\u00e3o iguais! Agora teste o seguinte. Prelude > True == True True Qual a diferen\u00e7a? Classes de tipos Observe que o tipo Bool foi definido da mesma forma, exceto por algumas informa\u00e7\u00f5es extra que aparecem quando o tipo \u00e9 descrito. Prelude > : i Bool type Bool :: * data Bool = False | True -- Defined in \u2018GHC.Types\u2019 instance Eq Bool -- Defined in \u2018GHC.Classes\u2019 instance Ord Bool -- Defined in \u2018GHC.Classes\u2019 instance Enum Bool -- Defined in \u2018GHC.Enum\u2019 instance Show Bool -- Defined in \u2018GHC.Show\u2019 instance Read Bool -- Defined in \u2018GHC.Read\u2019 instance Bounded Bool -- Defined in \u2018GHC.Enum\u2019 Mas o que s\u00e3o estas informa\u00e7\u00f5es extra? Fa\u00e7amos um teste, simplesmente avaliando um dos valores de Bool e de Naipe . > True True > Copas < interactive >: 9 : 1 : error : \u2022 No instance for ( Show Naipe ) arising from a use of \u2018 print \u2019 \u2022 In a stmt of an interactive GHCi command : print it O erro aparece porqu\u00ea quando a avalia\u00e7\u00e3o \u00e9 feita, o GHCi tenta imprimir o resultado na tela, e para imprimir o resultado ele tenta obter sua representa\u00e7\u00e3o como String usando a fun\u00e7\u00e3o show . > show True \"True\" > show Copas < interactive >: 11 : 1 : error : \u2022 No instance for ( Show Naipe ) arising from a use of \u2018 show \u2019 \u2022 In the expression : show Copas In an equation for \u2018 it \u2019 : it = show Copas No caso do valor booleano, a fun\u00e7\u00e3o funciona, mas no caso do naipe n\u00e3o! Volte no trecho acima onde descrevemos o valor verdadeiro. Uma das diferen\u00e7as para o naipe era a presen\u00e7a da linha instance Show Bool -- Defined in \u2018GHC.Show\u2019 que basicamente dizia que Bool faz parte da classe de tipos Show , a classe dos tipos que podem ser passados como par\u00e2metro para fun\u00e7\u00e3o show . H\u00e1 v\u00e1rias classes de tipo em Haskell, e voc\u00ea ainda pode criar as suas pr\u00f3prias. Show No caso do exemplo anterior, \u00e9 poss\u00edvel incluir o tipo naipe na classe em quest\u00e3o de uma forma manual definindo uma s\u00e9rie de fun\u00e7\u00f5es necess\u00e1rias ao Show ( : i Show ). Mas h\u00e1 um atalho que diz que todas as fun\u00e7\u00f5es necess\u00e1rias devem ser constru\u00eddas segundo um padr\u00e3o, que neste caso basicamente quer dizer que o valor em String \u00e9 simplesmente o texto usado na declara\u00e7\u00e3o. Para fazer isso, basta modificar a defini\u00e7\u00e3o da seguinte forma. data Naipe = Copas | Espadas | Ouro | Paus deriving ( Show ) Assim, podemos refazer as consultas e testes feitas anteriormente. Prelude > data Naipe = Copas | Espadas | Ouro | Paus deriving ( Show ) Prelude > : i Naipe type Naipe :: * data Naipe = Copas | Espadas | Ouro | Paus -- Defined at <interactive>:12:1 instance [ safe ] Show Naipe -- Defined at <interactive>:12:54 Prelude > show Copas \"Copas\" Prelude > Copas Copas Eq Assim como Show , Eq \u00e9 uma classe de tipo que define que todos os membros da class devem ter definidas algumas opera\u00e7\u00f5es, em espec\u00edfico, os operadores ( == ) e ( /= ) , como : i Eq mostra: > : i Eq type Eq :: * -> Constraint class Eq a where ( == ) :: a -> a -> Bool ( /= ) :: a -> a -> Bool {-# MINIMAL (==) | (/=) #-} ... Ord Por sua vez, Ord \u00e9 uma classe de tipo que define capacidades de compara\u00e7\u00e3o entre elementos de um tipo, como : i Ord mostra: > : i Ord type Ord :: * -> Constraint class Eq a => Ord a where compare :: a -> a -> Ordering ( < ) :: a -> a -> Bool ( <= ) :: a -> a -> Bool ( > ) :: a -> a -> Bool ( >= ) :: a -> a -> Bool max :: a -> a -> a min :: a -> a -> a {-# MINIMAL compare | (<=) #-} ... Observe que para que um tipo pertencer a Ord ele tamb\u00e9m deve pertencer a Eq . Enum Finalmente, Enum define a capacidade de, dado um valor de um certo tipo, determinar antecessores e sucessores, bem como construir listas por enumera\u00e7\u00e3o. > : i Enum type Enum :: * -> Constraint class Enum a where succ :: a -> a pred :: a -> a toEnum :: Int -> a fromEnum :: a -> Int enumFrom :: a -> [ a ] enumFromThen :: a -> a -> [ a ] enumFromTo :: a -> a -> [ a ] enumFromThenTo :: a -> a -> a -> [ a ] {-# MINIMAL toEnum, fromEnum #-} ... Read TODO read \"100\" :: Int Defini\u00e7\u00e3o completa Definindo o tipo para o naipe com todas estas classes de tipo, teremos um tipo bem interessante, que pode ser impresso na tela, comparado e usado para gerar listas por enumera\u00e7\u00e3o. > data Naipe = Copas | Espadas | Ouro | Paus deriving ( Show , Eq , Enum , Ord ) > [ Copas .. Paus ] [ Copas , Espadas , Ouro , Paus ] > pred Ouro Espadas Contudo, h\u00e1 limita\u00e7\u00f5es para o que se pode fazer com esta defini\u00e7\u00e3o, como demonstrado pelo pr\u00f3ximo exemplo. > pred Copas *** Exception: pred { Naipe } : tried to take ` pred' of first tag in enumeration CallStack ( from HasCallStack ) : error , called at < interactive >: 9 : 62 in interactive :Ghci1 Tipos mais complexos Mas e se quisermos definir um tipo para representar o valor de uma carta? data Valor = \u00c1s | N\u00famero1 | N\u00famero2 | N\u00famero3 | N\u00famero4 | N\u00famero5 | N\u00famero6 | N\u00famero7 | N\u00famero8 | N\u00famero9 | N\u00famero10 | Valete | Dama | Rei deriving ( Eq , Show , Ord , Enum ) Com esta defini\u00e7\u00e3o \u00e9 poss\u00edvel, por exemplo, comparar os valores das cartas. Mas, convenhamos, \u00e9 uma defini\u00e7\u00e3o horr\u00edvel. Haskell to the rescue! \u00c9 poss\u00edvel definir um valor que seja baseado em outro tipo, como no seguinte exemplo. data Valor = \u00c1s | N\u00famero Int | Valete | Dama | Rei N\u00famero Int define que qualquer combina\u00e7\u00e3o de N\u00famero , denominado o construtor , combinado com um valor do tipo #hs Int , \u00e9 um valor do tipo Valor . > data Valor = \u00c1s | N\u00famero Int | Valete | Dama | Rei deriving ( Eq , Show , Ord ) > as = \u00c1s > valete = Valete > nove = N\u00famero 9 > as \u00c1s > valete Valete > nove N\u00famero 9 Assim como Naipe pode ser usado em um casamento de padr\u00f5es, tamb\u00e9m a defini\u00e7\u00e3o de Valor pode, como no seguinte exemplo. \u00e9Figura :: Valor -> Bool \u00e9Figura ( N\u00famero _ ) -> False \u00e9Figura \u00c1s -> True -- Esta defini\u00e7\u00e3o \u00e9 desnecess\u00e1ria e usada s\u00f3 pra demonstra\u00e7\u00e3o. \u00e9Figura _ -> True Ord e Eq Como na defini\u00e7\u00e3o de Valor tanto Ord e Eq foram usados, Haskell deve ser capaz de comparar todas as possibilidades de valores. Assim, por exemplo, \u00c1s \u00e9 menor que qualquer n\u00famero, que \u00e9 menor que qualquer outra figura. Tamb\u00e9m quaisquer dois n\u00fameros podem ser comparados, sendo resultado determinado pela compara\u00e7\u00e3o dos respectivos inteiros. > data Valor = \u00c1s | N\u00famero Int | Valete | Dama | Rei deriving ( Eq , Show , Ord ) > N\u00famero 3 < N\u00famero 4 True > N\u00famero 3 == N\u00famero 4 False > \u00c1s < N\u00famero 10 True > \u00c1s < Rei True Observe que a defini\u00e7\u00e3o n\u00e3o inclui Enum , para entender porqu\u00ea, tente determinar qual seria o sucessor de \u00c1s e o antecessor de Valete . Como n\u00e3o \u00e9 poss\u00edvel determinar estes valores, o compilador nem permite que Enum seja usado. > data Valor = \u00c1s | N\u00famero Int | Valete | Dama | Rei deriving ( Eq , Show , Ord , Enum ) < interactive >: 21 : 79 : error : \u2022 Can't make a derived instance of \u2018 Enum Valor \u2019 : \u2018 Valor \u2019 must be an enumeration type ( an enumeration consists of one or more nullary , non - GADT constructors ) \u2022 In the data declaration for \u2018 Valor \u2019 Tipos mais complexos ainda Combinemos agora os tipos Naipe e Valor em um \u00fanico tipo que representa uma carta de baralho. A instancia\u00e7\u00e3o \u00e9 feita usando-se o construtor. > data Valor = \u00c1s | N\u00famero Int | Valete | Dama | Rei deriving ( Eq , Show , Ord ) > data Naipe = Copas | Espadas | Ouro | Paus deriving ( Show , Eq , Enum , Ord ) > data CartaT = Carta Naipe Valor deriving ( Eq , Show , Ord ) > Carta Paus Rei Carta Paus Rei > Carta Paus ( N\u00famero 3 ) Carta Paus ( N\u00famero 3 ) > Carta Paus ( N\u00famero 3 ) < Carta Paus Rei True > Carta Paus ( N\u00famero 3 ) < Carta Ouro Rei False > k = Carta Paus Rei > k Carta Paus Rei > : t k k :: CartaT > : i k k :: CartaT -- Defined at <interactive>:28:1 Veja que do lado esquerdo da equa\u00e7\u00e3o temos a defini\u00e7\u00e3o de um tipo CartaT e do lado direito temos a defini\u00e7\u00e3o de um construtor Carta para o tipo CartaT . \u00c9 poss\u00edvel solicitar mais informa\u00e7\u00f5es do Haskell tanto sobre o construtor quanto o tipo, mas nem todas as solicita\u00e7\u00f5es fazem sentido. Quanto ao tipo, CartaT , \u00e9 poss\u00edvel pedir informa\u00e7\u00f5es sobre a defini\u00e7\u00e3o, mas n\u00e3o o tipo da defini\u00e7\u00e3o. > : i CartaT type CartaT :: * data CartaT = Carta Naipe Valor -- Defined at <interactive>:26:1 instance [ safe ] Ord CartaT -- Defined at <interactive>:26:75 instance [ safe ] Show CartaT -- Defined at <interactive>:26:70 instance [ safe ] Eq CartaT -- Defined at <interactive>:26:67 > : t CartaT < interactive >: 1 : 1 : error : \u2022 Data constructor not in scope : CartaT \u2022 Perhaps you meant \u2018 Carta \u2019 ( line 26 ) Quanto ao construtor, Carta , \u00e9 poss\u00edvel perguntar as duas coisas. > : i Carta type CartaT :: * data CartaT = Carta Naipe Valor -- Defined at <interactive>:26:15 > : t Carta Carta :: Naipe -> Valor -> CartaT Veja que quanto perguntamos o tipo do construtor, a resposta \u00e9 que \u00e9 uma fun\u00e7\u00e3o que recebe Naipe e Valor e que retorna uma inst\u00e2ncia do tipo CartaT . Punning Uma vez que esteja claro que tipo e construtores s\u00e3o coisas diferentes, \u00e9 preciso dizer que seus contextos geralmente s\u00e3o diferentes e que, por isso, \u00e9 poss\u00edvel que ambos tenham o mesmo nome. De fato, esta \u00e9 uma abordagem comum na defini\u00e7\u00e3o de tipos alg\u00e9bricos em Haskell, denominada punning . > data Carta = Carta Naipe Valor deriving ( Eq , Show , Ord ) Prelude > a = Carta Copas \u00c1s Prelude > : i a a :: Carta -- Defined at <interactive>:39:1 Prelude > : t a a :: Carta Prelude > : i Carta type Carta :: * data Carta = Carta Naipe Valor -- Defined at <interactive>:38:1 instance [ safe ] Ord Carta -- Defined at <interactive>:38:74 instance [ safe ] Show Carta -- Defined at <interactive>:38:69 instance [ safe ] Eq Carta -- Defined at <interactive>:38:66 Prelude > : t Carta Carta :: Naipe -> Valor -> Carta Casamento de Padr\u00f5es Para que estes tipos sejam \u00fateis, precisamos us\u00e1-los em fun\u00e7\u00f5es, que \u00e9 direto e \u00f3bvio para os tipos mais simples, como visto anteriormente. corDoNaipe :: Naipe -> String corDoNaipe Copas = \"Vermelho\" corDoNaipe Ouro = \"Vermelho\" corDoNaipe Paus = \"Preto\" corDoNaipe Espada = \"Preto\" J\u00e1 para tipos que usam construtores, os padr\u00f5es devem incluir o construtor, como mostram as fun\u00e7\u00f5es a seguir. naipe :: CartaT -> Naipe naipe ( Carta n _ ) = n valor :: CartaT -> Valor valor ( Carta _ v ) = v valorNum\u00e9rico :: Valor -> Int valorNum\u00e9rico \u00c1s = 1 valorNum\u00e9rico ( N\u00famero i ) = i valorNum\u00e9rico Valete = 11 valorNum\u00e9rico Dama = 12 valorNum\u00e9rico Rei = 13 > valorNum\u00e9rico ( N\u00famero 4 ) 4 > valorNum\u00e9rico Rei 13 Exerc\u00edcios Usando tipos alg\u00e9bricos, defina os seguintes tipos e fun\u00e7\u00f5es relacionados a jogos de cartas Naipe Valor Carta Jogo - lista de cartas (apelido, n\u00e3o tipo alg\u00e9brico) \u00e9Canastra l - fun\u00e7\u00e3o que True se l \u00e9 uma sequ\u00eancia (possivelmente desordenada) de 7 cartas. temCanastra l - fun\u00e7\u00e3o que True se l contem uma sub-lista que \u00e9Canastra Usando tipos alg\u00e9bricos, defina as seguintes fun\u00e7\u00f5es e tipos Temperatura - tipo que pode conter um Tipo (Celsius, Kelvin, Farenheit) e um valor real. tempInCelsius - fun\u00e7\u00e3o que recebe uma temperatura qualquer e retorna uma Temperatura em Celsius. Item para outras temperaturas. Compreens\u00e3o de listas Imagine queira selecionar todas as cartas num\u00e9ricas de uma lista l de Carta. Usando compreens\u00e3o de listas, voce pode filtrar estes elementos simplesmente como [ e | N\u00famero e <- l ] . Isto \u00e9, o pr\u00f3prio gerador entende que somente tipos que casem com o construtor N\u00famero dever\u00e3o ser considerados. Nota\u00e7\u00e3o tipo \"record\" TODO Records Maybe Read \u00e9 uma classe de tipo \u00fatil por permitir que strings sejam usadas lidas e interpretadas como o tipo. O tipo Int e outros n\u00fameros, por exemplo, pertencem a esta classe, o que nos diz que podemos fazer o seguinte: > x = read \"100\" :: Int > x 100 > x = read \"100\" :: Float > x 100.0 Acontece que nem sempre a fun\u00e7\u00e3o ser\u00e1 bem sucedida em interpretar a string, por exemplo: > x = read \"Bolhufas\" :: Int > x *** Exception: Prelude . read : no parse Esta \u00e9 apenas uma de muitas situa\u00e7\u00f5es em que uma exce\u00e7\u00e3o pode ser causada por uma falha na execu\u00e7\u00e3o de alguma fun\u00e7\u00e3o. Outros exemplos s\u00e3o falhas de aloca\u00e7\u00e3o de mem\u00f3ria, de abertura de um arquivo no disco, de comunica\u00e7\u00e3o com outro processo via uma rede de computadores, etc. Nestas situa\u00e7\u00f5es, \u00e9 comum o uso do tipo Maybe a definido como se segue: > import Text.Read > : i Maybe data Maybe a = Nothing | Just a ... Este tipo permite que a fun\u00e7\u00e3o indique um erro ao retornar Nothing ou que um valor x foi recuperado da string usando ao retornar Just x . > x = readMaybe \"Bolhufas\" :: Maybe Int > x Nothing > x = readMaybe \"100\" :: Maybe Int > x Just 100 Tipos recursivos Como pode ver at\u00e9 agora, tipos alg\u00e9bricos tem muitos usos, a agora veremos um dos mais interessantes, na defini\u00e7\u00e3o de tipos recursivos. Considere uma lista, como definida pelo operador cons, : : uma lista \u00e9 a concatena\u00e7\u00e3o de um elemento, a cabe\u00e7a da lista, com uma outra lista, a cauda. Usando tipos alg\u00e9bricos, conseguimos representar listas da seguinte forma: data Lista a = Vazio | Elemento a ( Lista a ) deriving ( Show ) busca :: a -> Lista a -> Bool busca _ Vazio = False busca e ( Elemento x xs ) | e == x = True | busca e xs busca' :: a -> Lista a -> Bool busca' _ Vazio = False busca' e ( Elemento x xs ) = e == x || busca e xs > lV = Vazio > l1 = Elemento 1 ( Vazio ) > l2 = Elemento 2 ( Elemento 1 Vazio ) > lV Vazio > l1 Elemento 1 Vazio > l2 Elemento 2 ( Elemento 1 Vazio ) > busca' 1 lV False > busca' 1 l1 True > busca' 1 l2 True > busca' 2 l1 False Para outro exemplo, considere uma \u00e1rvore bin\u00e1ria, uma estrutura de dados formada por n\u00f3s que armazenam algum dado e apontam para outros dois n\u00f3s, denominados filhos \u00e0 esquerda e \u00e0 direita. data \u00c1rvore a = Nada | N\u00f3 a ( \u00c1rvore a ) ( \u00c1rvore a ) deriving ( Show ) {- >>> mudinha = N\u00f3 3 Nada Nada >>> N\u00f3 1 (N\u00f3 2 (N\u00f3 4 Nada Nada) Nada) (N\u00f3 3 Nada Nada) N\u00f3 1 (N\u00f3 2 (N\u00f3 4 Nada Nada) Nada) (N\u00f3 3 Nada Nada) -} adicionar :: ( Eq a , Ord a ) => a -> \u00c1rvore a -> \u00c1rvore a adicionar novoDado Nada = N\u00f3 novoDado Nada Nada adicionar novoDado \u00e1rvore @ ( N\u00f3 dadoExistente ae ad ) | novoDado == dadoExistente = \u00e1rvore | novoDado < dadoExistente = N\u00f3 dadoExistente ( adicionar novoDado ae ) ad | otherwise = N\u00f3 dadoExistente ad ( adicionar novoDado ad ) {- >>> arv = adicionar 3 (adicionar 4 (adicionar 10 (adicionar 1 (adicionar 2 (adicionar 3 (adicionar 7 Nada)))))) >>> arv N\u00f3 7 (N\u00f3 4 (N\u00f3 3 Nada Nada) Nada) (N\u00f3 10 Nada Nada) >>> impress\u00e3oEmOrdem arv \".3.4.7.10.\" -} impress\u00e3oEmOrdem :: ( Show a ) => \u00c1rvore a -> String impress\u00e3oEmOrdem Nada = \".\" impress\u00e3oEmOrdem ( N\u00f3 dado ae ad ) = impress\u00e3oEmOrdem ae ++ show dado ++ impress\u00e3oEmOrdem ad Exerc\u00edcio Implemente uma impress\u00e3o \"em ordem\" dos n\u00f3s da \u00e1rvore, que recebe uma \u00e1rvore e gera uma string com a resposta. Esta aula \u00e9 fortemente inspirada na video aula Enumeration Types, Show de Dave Sands. \u21a9","title":"Tipos alg\u00e9bricos"},{"location":"algebraic_data_types/#tipos-de-dados-algebricos","text":"Em se\u00e7\u00f5es anteriores, vimos que Haskell define diversos tipos de dados, como inteiros, booleanos e strings. Embora possamos usar os tipos b\u00e1sicos para resolver problemas, pode ser mais f\u00e1cil usar um vocabul\u00e1rio espec\u00edfico do problema, por exemplo data, nome, dire\u00e7\u00e3o, etc. Neste caso, podemos criar \"apelidos\" para tipos b\u00e1sicos, usando type . Mas Haskell \u00e9 mais poderoso que isso e permite que defina tipos novos a partir do zero. 1 Por exemplo, lembre-se do problemas discutidos que lidavam com cartas de baralho e como usamos uma dupla de String e Int para representar seus naipes e valores. Com data \u00e9 poss\u00edvel fazer algo melhor.","title":"Tipos de dados alg\u00e9bricos"},{"location":"algebraic_data_types/#data","text":"Com a palavra reservada data \u00e9 poss\u00edvel definir um novo tipo de dados (em ingl\u00eas, data ). O seguinte uso define um tipo para os naipes das cartas de um baralho. data Naipe = Copas | Espadas | Ouro | Paus Pela equa\u00e7\u00e3o seguinte, definimos o tipo de dados Naipe (lado esquerdo) como sendo igual a um dos valores do lado direito, dado que o lado direito \u00e9 uma disjun\u00e7\u00e3o. \u00c9 comum dizer que Naipe \u00e9 uma enumera\u00e7\u00e3o dos valores \u00e0 direita da equa\u00e7\u00e3o. Uma vez definido o tipo, podemos perguntar ao Haskell como ele \u00e9 interpretado. > data Naipe = Copas | Espadas | Ouro | Paus > : i Naipe type Naipe :: * data Naipe = Copas | Espadas | Ouro | Paus -- Defined at <interactive>:1:1 > : i Copas type Naipe :: * data Naipe = Copas | ... -- Defined at <interactive>:1:14 > : t Copas Copas :: Naipe Voc\u00ea tamb\u00e9m j\u00e1 pode usar o tipo em sua defini\u00e7\u00f5es, por exemplo: corDoNaipe :: Naipe -> String corDoNaipe Copas = \"Vermelho\" corDoNaipe Ouro = \"Vermelho\" corDoNaipe Paus = \"Preto\" corDoNaipe Espada = \"Preto\" Ou, equivalentemente, no seguinte exemplo. corDoNaipe :: Naipe -> String corDoNaipe n = case n of Copas -> \"Vermelho\" Ouro -> \"Vermelho\" Paus -> \"Preto\" Espada -> \"Preto\" Mas e o seguinte c\u00f3digo? corDoNaipe'' :: Naipe -> String corDoNaipe'' n | n == Copas = \"Vermelho\" | n == Ouro = \"Vermelho\" | n == Paus = \"Preto\" | n == Espada = \"Preto\" Se test\u00e1-lo, ver\u00e1 que n\u00e3o funciona. Um efeito semelhante \u00e9 observado quando fazemos algo mais simples ainda. Prelude > data Naipe = Copas | Espada | Ouro | Paus Prelude > Copas == Copas < interactive >: 2 : 1 : error : \u2022 No instance for ( Eq Naipe ) arising from a use of \u2018 == \u2019 \u2022 In the expression : Copas == Copas In an equation for \u2018 it \u2019 : it = Copas == Copas O problema aqui \u00e9 que Haskell n\u00e3o sabe como testar se dois naipes s\u00e3o iguais! Agora teste o seguinte. Prelude > True == True True Qual a diferen\u00e7a?","title":"data"},{"location":"algebraic_data_types/#classes-de-tipos","text":"Observe que o tipo Bool foi definido da mesma forma, exceto por algumas informa\u00e7\u00f5es extra que aparecem quando o tipo \u00e9 descrito. Prelude > : i Bool type Bool :: * data Bool = False | True -- Defined in \u2018GHC.Types\u2019 instance Eq Bool -- Defined in \u2018GHC.Classes\u2019 instance Ord Bool -- Defined in \u2018GHC.Classes\u2019 instance Enum Bool -- Defined in \u2018GHC.Enum\u2019 instance Show Bool -- Defined in \u2018GHC.Show\u2019 instance Read Bool -- Defined in \u2018GHC.Read\u2019 instance Bounded Bool -- Defined in \u2018GHC.Enum\u2019 Mas o que s\u00e3o estas informa\u00e7\u00f5es extra? Fa\u00e7amos um teste, simplesmente avaliando um dos valores de Bool e de Naipe . > True True > Copas < interactive >: 9 : 1 : error : \u2022 No instance for ( Show Naipe ) arising from a use of \u2018 print \u2019 \u2022 In a stmt of an interactive GHCi command : print it O erro aparece porqu\u00ea quando a avalia\u00e7\u00e3o \u00e9 feita, o GHCi tenta imprimir o resultado na tela, e para imprimir o resultado ele tenta obter sua representa\u00e7\u00e3o como String usando a fun\u00e7\u00e3o show . > show True \"True\" > show Copas < interactive >: 11 : 1 : error : \u2022 No instance for ( Show Naipe ) arising from a use of \u2018 show \u2019 \u2022 In the expression : show Copas In an equation for \u2018 it \u2019 : it = show Copas No caso do valor booleano, a fun\u00e7\u00e3o funciona, mas no caso do naipe n\u00e3o! Volte no trecho acima onde descrevemos o valor verdadeiro. Uma das diferen\u00e7as para o naipe era a presen\u00e7a da linha instance Show Bool -- Defined in \u2018GHC.Show\u2019 que basicamente dizia que Bool faz parte da classe de tipos Show , a classe dos tipos que podem ser passados como par\u00e2metro para fun\u00e7\u00e3o show . H\u00e1 v\u00e1rias classes de tipo em Haskell, e voc\u00ea ainda pode criar as suas pr\u00f3prias.","title":"Classes de tipos"},{"location":"algebraic_data_types/#tipos-mais-complexos","text":"Mas e se quisermos definir um tipo para representar o valor de uma carta? data Valor = \u00c1s | N\u00famero1 | N\u00famero2 | N\u00famero3 | N\u00famero4 | N\u00famero5 | N\u00famero6 | N\u00famero7 | N\u00famero8 | N\u00famero9 | N\u00famero10 | Valete | Dama | Rei deriving ( Eq , Show , Ord , Enum ) Com esta defini\u00e7\u00e3o \u00e9 poss\u00edvel, por exemplo, comparar os valores das cartas. Mas, convenhamos, \u00e9 uma defini\u00e7\u00e3o horr\u00edvel. Haskell to the rescue! \u00c9 poss\u00edvel definir um valor que seja baseado em outro tipo, como no seguinte exemplo. data Valor = \u00c1s | N\u00famero Int | Valete | Dama | Rei N\u00famero Int define que qualquer combina\u00e7\u00e3o de N\u00famero , denominado o construtor , combinado com um valor do tipo #hs Int , \u00e9 um valor do tipo Valor . > data Valor = \u00c1s | N\u00famero Int | Valete | Dama | Rei deriving ( Eq , Show , Ord ) > as = \u00c1s > valete = Valete > nove = N\u00famero 9 > as \u00c1s > valete Valete > nove N\u00famero 9 Assim como Naipe pode ser usado em um casamento de padr\u00f5es, tamb\u00e9m a defini\u00e7\u00e3o de Valor pode, como no seguinte exemplo. \u00e9Figura :: Valor -> Bool \u00e9Figura ( N\u00famero _ ) -> False \u00e9Figura \u00c1s -> True -- Esta defini\u00e7\u00e3o \u00e9 desnecess\u00e1ria e usada s\u00f3 pra demonstra\u00e7\u00e3o. \u00e9Figura _ -> True","title":"Tipos mais complexos"},{"location":"algebraic_data_types/#tipos-mais-complexos-ainda","text":"Combinemos agora os tipos Naipe e Valor em um \u00fanico tipo que representa uma carta de baralho. A instancia\u00e7\u00e3o \u00e9 feita usando-se o construtor. > data Valor = \u00c1s | N\u00famero Int | Valete | Dama | Rei deriving ( Eq , Show , Ord ) > data Naipe = Copas | Espadas | Ouro | Paus deriving ( Show , Eq , Enum , Ord ) > data CartaT = Carta Naipe Valor deriving ( Eq , Show , Ord ) > Carta Paus Rei Carta Paus Rei > Carta Paus ( N\u00famero 3 ) Carta Paus ( N\u00famero 3 ) > Carta Paus ( N\u00famero 3 ) < Carta Paus Rei True > Carta Paus ( N\u00famero 3 ) < Carta Ouro Rei False > k = Carta Paus Rei > k Carta Paus Rei > : t k k :: CartaT > : i k k :: CartaT -- Defined at <interactive>:28:1 Veja que do lado esquerdo da equa\u00e7\u00e3o temos a defini\u00e7\u00e3o de um tipo CartaT e do lado direito temos a defini\u00e7\u00e3o de um construtor Carta para o tipo CartaT . \u00c9 poss\u00edvel solicitar mais informa\u00e7\u00f5es do Haskell tanto sobre o construtor quanto o tipo, mas nem todas as solicita\u00e7\u00f5es fazem sentido. Quanto ao tipo, CartaT , \u00e9 poss\u00edvel pedir informa\u00e7\u00f5es sobre a defini\u00e7\u00e3o, mas n\u00e3o o tipo da defini\u00e7\u00e3o. > : i CartaT type CartaT :: * data CartaT = Carta Naipe Valor -- Defined at <interactive>:26:1 instance [ safe ] Ord CartaT -- Defined at <interactive>:26:75 instance [ safe ] Show CartaT -- Defined at <interactive>:26:70 instance [ safe ] Eq CartaT -- Defined at <interactive>:26:67 > : t CartaT < interactive >: 1 : 1 : error : \u2022 Data constructor not in scope : CartaT \u2022 Perhaps you meant \u2018 Carta \u2019 ( line 26 ) Quanto ao construtor, Carta , \u00e9 poss\u00edvel perguntar as duas coisas. > : i Carta type CartaT :: * data CartaT = Carta Naipe Valor -- Defined at <interactive>:26:15 > : t Carta Carta :: Naipe -> Valor -> CartaT Veja que quanto perguntamos o tipo do construtor, a resposta \u00e9 que \u00e9 uma fun\u00e7\u00e3o que recebe Naipe e Valor e que retorna uma inst\u00e2ncia do tipo CartaT .","title":"Tipos mais complexos ainda"},{"location":"algebraic_data_types/#casamento-de-padroes","text":"Para que estes tipos sejam \u00fateis, precisamos us\u00e1-los em fun\u00e7\u00f5es, que \u00e9 direto e \u00f3bvio para os tipos mais simples, como visto anteriormente. corDoNaipe :: Naipe -> String corDoNaipe Copas = \"Vermelho\" corDoNaipe Ouro = \"Vermelho\" corDoNaipe Paus = \"Preto\" corDoNaipe Espada = \"Preto\" J\u00e1 para tipos que usam construtores, os padr\u00f5es devem incluir o construtor, como mostram as fun\u00e7\u00f5es a seguir. naipe :: CartaT -> Naipe naipe ( Carta n _ ) = n valor :: CartaT -> Valor valor ( Carta _ v ) = v valorNum\u00e9rico :: Valor -> Int valorNum\u00e9rico \u00c1s = 1 valorNum\u00e9rico ( N\u00famero i ) = i valorNum\u00e9rico Valete = 11 valorNum\u00e9rico Dama = 12 valorNum\u00e9rico Rei = 13 > valorNum\u00e9rico ( N\u00famero 4 ) 4 > valorNum\u00e9rico Rei 13 Exerc\u00edcios Usando tipos alg\u00e9bricos, defina os seguintes tipos e fun\u00e7\u00f5es relacionados a jogos de cartas Naipe Valor Carta Jogo - lista de cartas (apelido, n\u00e3o tipo alg\u00e9brico) \u00e9Canastra l - fun\u00e7\u00e3o que True se l \u00e9 uma sequ\u00eancia (possivelmente desordenada) de 7 cartas. temCanastra l - fun\u00e7\u00e3o que True se l contem uma sub-lista que \u00e9Canastra Usando tipos alg\u00e9bricos, defina as seguintes fun\u00e7\u00f5es e tipos Temperatura - tipo que pode conter um Tipo (Celsius, Kelvin, Farenheit) e um valor real. tempInCelsius - fun\u00e7\u00e3o que recebe uma temperatura qualquer e retorna uma Temperatura em Celsius. Item para outras temperaturas.","title":"Casamento de Padr\u00f5es"},{"location":"algebraic_data_types/#notacao-tipo-record","text":"TODO Records","title":"Nota\u00e7\u00e3o tipo \"record\""},{"location":"algebraic_data_types/#maybe","text":"Read \u00e9 uma classe de tipo \u00fatil por permitir que strings sejam usadas lidas e interpretadas como o tipo. O tipo Int e outros n\u00fameros, por exemplo, pertencem a esta classe, o que nos diz que podemos fazer o seguinte: > x = read \"100\" :: Int > x 100 > x = read \"100\" :: Float > x 100.0 Acontece que nem sempre a fun\u00e7\u00e3o ser\u00e1 bem sucedida em interpretar a string, por exemplo: > x = read \"Bolhufas\" :: Int > x *** Exception: Prelude . read : no parse Esta \u00e9 apenas uma de muitas situa\u00e7\u00f5es em que uma exce\u00e7\u00e3o pode ser causada por uma falha na execu\u00e7\u00e3o de alguma fun\u00e7\u00e3o. Outros exemplos s\u00e3o falhas de aloca\u00e7\u00e3o de mem\u00f3ria, de abertura de um arquivo no disco, de comunica\u00e7\u00e3o com outro processo via uma rede de computadores, etc. Nestas situa\u00e7\u00f5es, \u00e9 comum o uso do tipo Maybe a definido como se segue: > import Text.Read > : i Maybe data Maybe a = Nothing | Just a ... Este tipo permite que a fun\u00e7\u00e3o indique um erro ao retornar Nothing ou que um valor x foi recuperado da string usando ao retornar Just x . > x = readMaybe \"Bolhufas\" :: Maybe Int > x Nothing > x = readMaybe \"100\" :: Maybe Int > x Just 100","title":"Maybe"},{"location":"algebraic_data_types/#tipos-recursivos","text":"Como pode ver at\u00e9 agora, tipos alg\u00e9bricos tem muitos usos, a agora veremos um dos mais interessantes, na defini\u00e7\u00e3o de tipos recursivos. Considere uma lista, como definida pelo operador cons, : : uma lista \u00e9 a concatena\u00e7\u00e3o de um elemento, a cabe\u00e7a da lista, com uma outra lista, a cauda. Usando tipos alg\u00e9bricos, conseguimos representar listas da seguinte forma: data Lista a = Vazio | Elemento a ( Lista a ) deriving ( Show ) busca :: a -> Lista a -> Bool busca _ Vazio = False busca e ( Elemento x xs ) | e == x = True | busca e xs busca' :: a -> Lista a -> Bool busca' _ Vazio = False busca' e ( Elemento x xs ) = e == x || busca e xs > lV = Vazio > l1 = Elemento 1 ( Vazio ) > l2 = Elemento 2 ( Elemento 1 Vazio ) > lV Vazio > l1 Elemento 1 Vazio > l2 Elemento 2 ( Elemento 1 Vazio ) > busca' 1 lV False > busca' 1 l1 True > busca' 1 l2 True > busca' 2 l1 False Para outro exemplo, considere uma \u00e1rvore bin\u00e1ria, uma estrutura de dados formada por n\u00f3s que armazenam algum dado e apontam para outros dois n\u00f3s, denominados filhos \u00e0 esquerda e \u00e0 direita. data \u00c1rvore a = Nada | N\u00f3 a ( \u00c1rvore a ) ( \u00c1rvore a ) deriving ( Show ) {- >>> mudinha = N\u00f3 3 Nada Nada >>> N\u00f3 1 (N\u00f3 2 (N\u00f3 4 Nada Nada) Nada) (N\u00f3 3 Nada Nada) N\u00f3 1 (N\u00f3 2 (N\u00f3 4 Nada Nada) Nada) (N\u00f3 3 Nada Nada) -} adicionar :: ( Eq a , Ord a ) => a -> \u00c1rvore a -> \u00c1rvore a adicionar novoDado Nada = N\u00f3 novoDado Nada Nada adicionar novoDado \u00e1rvore @ ( N\u00f3 dadoExistente ae ad ) | novoDado == dadoExistente = \u00e1rvore | novoDado < dadoExistente = N\u00f3 dadoExistente ( adicionar novoDado ae ) ad | otherwise = N\u00f3 dadoExistente ad ( adicionar novoDado ad ) {- >>> arv = adicionar 3 (adicionar 4 (adicionar 10 (adicionar 1 (adicionar 2 (adicionar 3 (adicionar 7 Nada)))))) >>> arv N\u00f3 7 (N\u00f3 4 (N\u00f3 3 Nada Nada) Nada) (N\u00f3 10 Nada Nada) >>> impress\u00e3oEmOrdem arv \".3.4.7.10.\" -} impress\u00e3oEmOrdem :: ( Show a ) => \u00c1rvore a -> String impress\u00e3oEmOrdem Nada = \".\" impress\u00e3oEmOrdem ( N\u00f3 dado ae ad ) = impress\u00e3oEmOrdem ae ++ show dado ++ impress\u00e3oEmOrdem ad Exerc\u00edcio Implemente uma impress\u00e3o \"em ordem\" dos n\u00f3s da \u00e1rvore, que recebe uma \u00e1rvore e gera uma string com a resposta. Esta aula \u00e9 fortemente inspirada na video aula Enumeration Types, Show de Dave Sands. \u21a9","title":"Tipos recursivos"},{"location":"comments/","text":"Observa\u00e7\u00f5es Cheat sheet https://hackage.haskell.org/package/CheatSheet-1.7/src/CheatSheet.pdf Exerc\u00edcios da Semana 2 Par\u00eanteses desnecess\u00e1rios Todo if em um then e um else Diferentemente de outras linguagens, onde o if \u00e9 usado para determinar se uma computa\u00e7\u00e3o deve acontecer e o else \u00e9 um atalho para quando h\u00e1 duas op\u00e7\u00f5es, e portanto o else n\u00e3o \u00e9 necess\u00e1rio, em Haskell o if \u00e9 usado para determinar qual computa\u00e7\u00e3o deve acontecer, ou seja, sempre h\u00e1 duas op\u00e7\u00f5es . C if ( x > 3 ) //If sem else: compila. y = \"maior\" ; //Se x <= 3, y continua com o valor anterior, seja qual for. Haskell let y = if x > 3 then \"maior\" -- If sem else: n\u00e3o compila! Qual o valor de `y` se `x <= 3`? Por isso o if do Haskell deve ser comparado ao operador tern\u00e1rio do C, n\u00e3o com o if . C y = x > 3 ? \"maior\" : \"menor\" ; Haskell let y = if x > 3 then \"maior\" else \"menor\" ((b1+b2)/2) * h -> (b1+b2)/2 * h n\u00e3o h\u00e1 d\u00favida para o compilador que a divis\u00e3o deve ocorrer primeiro, pois os operadores tem a mesma preced\u00eancia e ambos s\u00e3o associativos \u00e0 esquerda. sqrt ((b*b)+ (c*c)) -> sqrt (b*b + c*c) n\u00e3o h\u00e1 d\u00favida para o compilador que a divis\u00e3o deve ocorrer primeiro, pois os operadores tem preced\u00eancias diferentes. Informa\u00e7\u00e3o sobre preced\u00eancia e associatividade pode ser derivadas via : info . Prelude > : info * type Num :: * -> Constraint class Num a where ... ( * ) :: a -> a -> a ... infixl 7 * -- Infixo com associatividade a esquerda (l) e Preced\u00eancia 7. Prelude > : info / type Fractional :: * -> Constraint class Num a => Fractional a where ( / ) :: a -> a -> a ... infixl 7 / -- Infixo com associatividade a esquerda (l) e Preced\u00eancia 7. Prelude > : info + type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ... infixl 6 + -- Infixo com associatividade a esquerda (l) e Preced\u00eancia 6. maiorDeTres a b c = if a > b && a > c then a else if b > a && b > c then b else c Dif\u00edcil leitura. Quebrar linhas. estaoOrdenados a b c = if ( a > b && b > c ) then True else False if < cond > then True else False -> < cond > estaoOrdenados a b c = a > b && b > c sqrt (( a ^ 2 ) + ( b ^ 2 )) Par\u00eanteses s\u00f3 s\u00e3o necess\u00e1rios para deixar expl\u00edcito o que \u00e9 par\u00e2metro. sqrt (( a ^ 2 ) + ( b ^ 2 )) Fun\u00e7\u00f5es e par\u00e2metros s\u00e3o separados por espa\u00e7o. sqrt (( a ^ 2 ) + ( b ^ 2 )) sqrt (( a ^ 2 ) + ( b ^ 2 )) Operadores tem preced\u00eancias; pot\u00eancia tem preced\u00eancia maior que adi\u00e7\u00e3o sqrt ( a ^ 2 + b ^ 2 ) sqrt a ^ 2 + b ^ 2 Fun\u00e7\u00f5es tem preced\u00eancia sobre operadores. sqrt a ^ 2 + b ^ 2 == ( sqrt a ^ 2 ) + b ^ 2 Exerc\u00edcios da semana 3 Erros Para indicar uma condi\u00e7\u00e3o de erro, use \"error\". Por exemplo, em uma solu\u00e7\u00e3o eu encontrei o seguinte | otherwise = ( 99 , \"error\" ) mas o ideal seria | otherwise = error \"mensagem de erro\" . Prova 1 M\u00e1ximo Toda recurs\u00e3o deve ter um caso base, sen\u00e3o a recurs\u00e3o n\u00e3o para. No seguinte trecho, s\u00f3 temos dois casos. Um if-then-else me parece mais leg\u00edvel. ```#!hs m\u00e1ximo (x:xs) | (x > m\u00e1ximo xs) = x | otherwise = m\u00e1ximo xs ### Ra\u00edzes * ```#!hs Prelude> 4/2*2 4.0 Prelude> 4/(2*2) 1.0 ValorFinal A idade precisa levar m\u00eas e dia em considera\u00e7\u00e3o.","title":"Erros comuns"},{"location":"comments/#observacoes","text":"","title":"Observa\u00e7\u00f5es"},{"location":"comments/#cheat-sheet","text":"https://hackage.haskell.org/package/CheatSheet-1.7/src/CheatSheet.pdf","title":"Cheat sheet"},{"location":"comments/#exercicios-da-semana-2","text":"","title":"Exerc\u00edcios da Semana 2"},{"location":"comments/#exercicios-da-semana-3","text":"","title":"Exerc\u00edcios da semana 3"},{"location":"comments/#erros","text":"Para indicar uma condi\u00e7\u00e3o de erro, use \"error\". Por exemplo, em uma solu\u00e7\u00e3o eu encontrei o seguinte | otherwise = ( 99 , \"error\" ) mas o ideal seria | otherwise = error \"mensagem de erro\" .","title":"Erros"},{"location":"comments/#prova-1","text":"","title":"Prova 1"},{"location":"comments/#maximo","text":"Toda recurs\u00e3o deve ter um caso base, sen\u00e3o a recurs\u00e3o n\u00e3o para. No seguinte trecho, s\u00f3 temos dois casos. Um if-then-else me parece mais leg\u00edvel. ```#!hs m\u00e1ximo (x:xs) | (x > m\u00e1ximo xs) = x | otherwise = m\u00e1ximo xs ### Ra\u00edzes * ```#!hs Prelude> 4/2*2 4.0 Prelude> 4/(2*2) 1.0","title":"M\u00e1ximo"},{"location":"comments/#valorfinal","text":"A idade precisa levar m\u00eas e dia em considera\u00e7\u00e3o.","title":"ValorFinal"},{"location":"functions/","text":"Fun\u00e7\u00f5es Agora que j\u00e1 vimos exemplos extremamente simples, vejamos alguns um pouco mais interessantes, como uma fun\u00e7\u00e3o que soma os n\u00fameros de x a y , inclusive. A t\u00edtulo de compara\u00e7\u00e3o, vejamos primeiro a fun\u00e7\u00e3o em linguagem C. int soma ( int x , int y ) { int total = 0 ; for ( int i = x ; i <= y ; i ++ ) total = total + i ; return total ; } soma ( 1 , 10 ); Em Haskell, temos diversas op\u00e7\u00f5es para obter o mesmo resultado, por exemplo, usando uma fun\u00e7\u00e3o recursiva... somaDeAte x y = if x < y then x + somaDeAte ( x + 1 ) y else x somaDeAte 1 10 ... ou a fun\u00e7\u00e3o j\u00e1 existente sum , que recebe uma lista de n\u00fameros, neste caso criada pelo operador .. sum [ 1 .. 10 ] Observe que a sintaxe do uso das fun\u00e7\u00f5es, contudo, \u00e9 diferente; em Haskell, usa-se o nome da fun\u00e7\u00e3o, seguido dos par\u00e2metros, com espa\u00e7o os separando. J\u00e1 a defini\u00e7\u00e3o de fun\u00e7\u00f5es segue algumas estruturas b\u00e1sicas, sendo a mais simples a defini\u00e7\u00e3o via equa\u00e7\u00e3o . Equa\u00e7\u00f5es Por exemplo, consideremos uma fun\u00e7\u00e3o que soma dois n\u00fameros. Em Haskell, ela \u00e9 definida simplesmente como soma x y = x + y e usada como soma 3 5 . Exerc\u00edcio: Soma Defina a fun\u00e7\u00e3o soma e a use, de acordo com a imagem. 1 Como outro exemplo, definamos uma fun\u00e7\u00e3o que retorna o sucessor de um inteiro como sucessor x = x + 1 . Com estas duas fun\u00e7\u00f5es, podemos inclusive compor fun\u00e7\u00f5es, no melhor estilo \\(g(f(x))\\) , por exemplo: sucessor ( soma 3 4 ) ou sucessor ( sucessor ( sucessor 4 )) . Exerc\u00edcio: Composi\u00e7\u00e3o Defina uma fun\u00e7\u00e3o que multiplique 3 n\u00fameros, isto \u00e9, dados \\(x\\) , \\(y\\) e \\(z\\) , calcule \\(x*y*z\\) . Calcule \\((1 + (3 * 2 * 3)) + (5 * 3 * 2)\\) usando as fun\u00e7\u00f5es de soma e multiplica\u00e7\u00e3o definidas. Resolu\u00e7\u00e3o Defina as fun\u00e7\u00f5es soma x y = x + y mult3 x y z = x * y * z Invoque soma ( soma 1 ( mult3 3 2 3 )) ( mult3 5 3 2 ) . Observe que os par\u00eanteses s\u00e3o necess\u00e1rios para delimitar os par\u00e2metros de cada uma das invoca\u00e7\u00f5es. Exerc\u00edcio: m\u00e9dia de 3 n\u00fameros Defina uma fun\u00e7\u00e3o que calcule a m\u00e9dia de 3 n\u00fameros Resolu\u00e7\u00e3o media x y z = ( x + y + z ) / 3 Exerc\u00edcio: \u00e1rea das figuras Defina uma fun\u00e7\u00e3o o c\u00e1lculo da \u00e1rea de cada figura geom\u00e9trica. Resolu\u00e7\u00e3o areaQuad a = a * a areaRet a b = a * b areaCirc r = pi * r * r areaTri a h = ( a * h ) / 2 areaTra a b h = ( a + b ) / 2 * h Se voc\u00ea se logar no Repl.it, poder\u00e1 salvar seus arquivos online e edit\u00e1-los de qualquer lugar, como no exemplo dado no exerc\u00edcio. \u21a9","title":"Primeiras fun\u00e7\u00f5es"},{"location":"functions/#funcoes","text":"Agora que j\u00e1 vimos exemplos extremamente simples, vejamos alguns um pouco mais interessantes, como uma fun\u00e7\u00e3o que soma os n\u00fameros de x a y , inclusive. A t\u00edtulo de compara\u00e7\u00e3o, vejamos primeiro a fun\u00e7\u00e3o em linguagem C. int soma ( int x , int y ) { int total = 0 ; for ( int i = x ; i <= y ; i ++ ) total = total + i ; return total ; } soma ( 1 , 10 ); Em Haskell, temos diversas op\u00e7\u00f5es para obter o mesmo resultado, por exemplo, usando uma fun\u00e7\u00e3o recursiva... somaDeAte x y = if x < y then x + somaDeAte ( x + 1 ) y else x somaDeAte 1 10 ... ou a fun\u00e7\u00e3o j\u00e1 existente sum , que recebe uma lista de n\u00fameros, neste caso criada pelo operador .. sum [ 1 .. 10 ] Observe que a sintaxe do uso das fun\u00e7\u00f5es, contudo, \u00e9 diferente; em Haskell, usa-se o nome da fun\u00e7\u00e3o, seguido dos par\u00e2metros, com espa\u00e7o os separando. J\u00e1 a defini\u00e7\u00e3o de fun\u00e7\u00f5es segue algumas estruturas b\u00e1sicas, sendo a mais simples a defini\u00e7\u00e3o via equa\u00e7\u00e3o .","title":"Fun\u00e7\u00f5es"},{"location":"functions/#equacoes","text":"Por exemplo, consideremos uma fun\u00e7\u00e3o que soma dois n\u00fameros. Em Haskell, ela \u00e9 definida simplesmente como soma x y = x + y e usada como soma 3 5 . Exerc\u00edcio: Soma Defina a fun\u00e7\u00e3o soma e a use, de acordo com a imagem. 1 Como outro exemplo, definamos uma fun\u00e7\u00e3o que retorna o sucessor de um inteiro como sucessor x = x + 1 . Com estas duas fun\u00e7\u00f5es, podemos inclusive compor fun\u00e7\u00f5es, no melhor estilo \\(g(f(x))\\) , por exemplo: sucessor ( soma 3 4 ) ou sucessor ( sucessor ( sucessor 4 )) . Exerc\u00edcio: Composi\u00e7\u00e3o Defina uma fun\u00e7\u00e3o que multiplique 3 n\u00fameros, isto \u00e9, dados \\(x\\) , \\(y\\) e \\(z\\) , calcule \\(x*y*z\\) . Calcule \\((1 + (3 * 2 * 3)) + (5 * 3 * 2)\\) usando as fun\u00e7\u00f5es de soma e multiplica\u00e7\u00e3o definidas. Resolu\u00e7\u00e3o Defina as fun\u00e7\u00f5es soma x y = x + y mult3 x y z = x * y * z Invoque soma ( soma 1 ( mult3 3 2 3 )) ( mult3 5 3 2 ) . Observe que os par\u00eanteses s\u00e3o necess\u00e1rios para delimitar os par\u00e2metros de cada uma das invoca\u00e7\u00f5es. Exerc\u00edcio: m\u00e9dia de 3 n\u00fameros Defina uma fun\u00e7\u00e3o que calcule a m\u00e9dia de 3 n\u00fameros Resolu\u00e7\u00e3o media x y z = ( x + y + z ) / 3 Exerc\u00edcio: \u00e1rea das figuras Defina uma fun\u00e7\u00e3o o c\u00e1lculo da \u00e1rea de cada figura geom\u00e9trica. Resolu\u00e7\u00e3o areaQuad a = a * a areaRet a b = a * b areaCirc r = pi * r * r areaTri a h = ( a * h ) / 2 areaTra a b h = ( a + b ) / 2 * h Se voc\u00ea se logar no Repl.it, poder\u00e1 salvar seus arquivos online e edit\u00e1-los de qualquer lugar, como no exemplo dado no exerc\u00edcio. \u21a9","title":"Equa\u00e7\u00f5es"},{"location":"guards/","text":"Vamos definir uma fun\u00e7\u00e3o que retorne o nome do m\u00eas, dado o seu n\u00famero. Seria poss\u00edvel escreve esta fun\u00e7\u00e3o com if aninhados, assim. nomeMes m = if m == 1 then \"JAN\" else if m == 2 then \"FEB\" else if m == 3 then \"MAR\" ... else if m == 11 then \"NOV\" else \"DEZ\" Esta estrutura, contudo, pode ser simplificada com o uso guardas , uma op\u00e7\u00e3o que faz sentido quando os par\u00e2metros de uma fun\u00e7\u00e3o podem ser classificados em grupos. Guardas tem a seguinte sintaxe, onde o otherwise \u00e9 opcional e serve para cobrir todos os outros casos . nomeFuncao arg1 ... argN | < condicao1 > = < definicao1 > | < condicao2 > = < definicao2 > ... | < condicaoM > = < definicaoM > | [ otherwise ] = < definicaoO > Especificamente, o exemplo do c\u00e1lculo do nome dos meses ficaria assim: nomeMes m | m == 1 = \"JAN\" | m == 2 = \"FEV\" | m == 3 = \"MAR\" | m == 4 = \"ABR\" | m == 5 = \"MAI\" | m == 6 = \"JUN\" | m == 7 = \"JUL\" | m == 8 = \"AGO\" | m == 9 = \"SET\" | m == 10 = \"OUT\" | m == 11 = \"NOV\" | m == 12 = \"DEZ\" | m == 13 = \"ONZ\" Outras observa\u00e7\u00f5es tamb\u00e9m s\u00e3o importantes. Primeiro, as condi\u00e7\u00f5es podem ser mais complexas que um simples teste, podendo incluir m\u00faltiplos testes e computa\u00e7\u00f5es; a \u00fanica condi\u00e7\u00e3o \u00e9 que retorne um booleano. Vejamos uma fun\u00e7\u00e3o que calcula o maior entre tr\u00eas n\u00fameros. maiorDeTres a b c | a >= b && a >= c = a | b >= c = b | otherwise = c Segundo, as condi\u00e7\u00f5es s\u00e3o testadas de cima para baixo e isso \u00e9 importante porqu\u00ea alguns par\u00e2metros podem satisfazer mais de uma condi\u00e7\u00e3o. Vejamos novamente o caso do c\u00e1lculo de anos bissextos. {- >>>bissexto 5 False >>>bissexto 200 False >>>bissexto 2000 True >>>bissexto 1996 True >>>bissexto 1900 False -} bissexto x | mod x 4 /= 0 = False -- N\u00e3o divis\u00edveis por 4 | mod x 400 == 0 = True -- Divis\u00edveis por 4 e por 400 | mod x 100 == 0 = False -- Divis\u00edveis por 4, n\u00e3o por 400, e por 100 | otherwise = True -- Divis\u00edveis por 4, e n\u00e3o por 100 Observe que se a terceira e segunda guardas fossem invertidas, o ano 1900 seria considerado bissexto, quando na verdade ele n\u00e3o \u00e9. Exerc\u00edcio Escreva uma fun\u00e7\u00e3o que receba um n\u00famero representando um m\u00eas, um n\u00famero de 1 a 12, e retorne a quantidade de dias no m\u00eas. Assuma que fevereiro sempre tem 28 dias. Resolu\u00e7\u00e3o diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 \u00cdndice de massa corporal O \u00edndice de massa corporal, IMC, \u00e9 calculado como o peso dividido pelo quadrado da altura. Um IMC abaixo de 18,5, inclusive, \u00e9 considerado baixo e acima de 30 \u00e9 considerado alto; aqueles no intervalo s\u00e3o considerados normais. Defina uma fun\u00e7\u00e3o que, dados peso e altura, decida se o IMC correspondente \u00e9 Baixo, Normal ou Alto. Resolu\u00e7\u00e3o imc p a | p / a ^ 2 <= 18.5 = \"Baixo\" | p / a ^ 2 <= 25.0 = \"Normal\" | p / a ^ 2 <= 30.0 = \"Alto\" | otherwise = error \"N\u00e3o sei o que dizer\" otherwise \u00e9 verdade Uma curiosidade sobre o uso de guardas \u00e9 que o caso final, que pega todas as outras op\u00e7\u00f5es, poderia ser definido como um guarda em que a condi\u00e7\u00e3o \u00e9 sempre verdadeira, como no seguinte exemplo: maiorDeTres a b c | a >= b && a >= c = a | b >= c = b | True = c De fato, se usarmos o ghci para obtermos mais informa\u00e7\u00f5es sobre otherwise , veremos que \u00e9 uma constante, cujo valor \u00e9 True . Isso serve para ilustrar o poder da linguagem, que tem um conjunto reduzido de palavras chave que \u00e9 estendida usando suas funcionalidades b\u00e1sicas. Prelude> :i otherwise otherwise :: Bool -- Defined in \u2018GHC.Base\u2019 Prelude> otherwise True Ainda sobre guardas, quando a condi\u00e7\u00e3o testada \u00e9 de igualdade dos par\u00e2metros com algum valor, temos uma terceira forma de definir fun\u00e7\u00f5es que precisam testar v\u00e1rios casos, al\u00e9m de usar if - then - else e guardas: Casamento de padr\u00f5es .","title":"Guardas!"},{"location":"haskell101/","text":"A primeira vers\u00e3o da linguagem Haskell, cujo nome \u00e9 uma homenagem ao matem\u00e1tico e l\u00f3gico Haskell B. Curry , apareceu em 1987 do esfor\u00e7o para se consolidar v\u00e1rios avan\u00e7os propostos no paradigma funcional, sendo famosa por ser uma linguagem funcional pura , de prop\u00f3sito geral e por ter caracter\u00edsticas marcantes como avalia\u00e7\u00e3o pregui\u00e7osa , e tipagem est\u00e1tica , forte e por infer\u00eancia , como discutiremos mais adiante. Mais do que uma linguagem, Haskell era uma especifica\u00e7\u00e3o, ou s\u00e9rie de especifica\u00e7\u00f5es, tendo tido v\u00e1rias implementa\u00e7\u00f5es distintas. A vers\u00e3o de 98 foi um marco da linguagem, sendo uma vers\u00e3o considerada est\u00e1vel. Nesta \u00e9poca surgiu o Glasgow Haskell Compiler (GHC), que se tornou o compilador Haskell \"padr\u00e3o\". A vers\u00e3o seguinte da linguagem come\u00e7ou a ser especificada em 2006 e anunciada em 2009, a Haskell 2010. Dentre os principais avan\u00e7os desta vers\u00e3o est\u00e1 a possibilidade de interagir com c\u00f3digo escrito em outras linguagens, via a foreign function interface (FFI). Mas chega de hist\u00f3ria e vamos colocar a m\u00e3o na massa vendo alguns exemplos extremamente simples da linguagem. Exemplos simples Para exemplos mais complexos, voc\u00ea dever\u00e1 instalar o compilador Haskell na sua m\u00e1quina, seguindo as instru\u00e7\u00f5es espec\u00edficas, 2 mas para pequenos experimentos e exerc\u00edcios, podemos usar o Repl.It 1 . Do lado direito do s\u00edtio, na \u00e1rea marcada em vermelho, digite ghci seguido de Enter . Agora digite as express\u00f5es a seguir. 1 + 1 True && True 100 / 10 ( 10 + 4 ) * 50 3 * ( - 2 ) 2 * - 1 Estas express\u00f5es fazem uso de operadores comuns e se comportam exatamente como voc\u00ea esperaria, depois de ter aprendido a programar em qualquer linguagem, em qualquer paradigma. Operadores s\u00e3o a\u00e7\u00facar sint\u00e1tico para fun\u00e7\u00f5es, a alma da programa\u00e7\u00e3o funcional. REPL \u00e9 o acr\u00f4nimo para Read, Evaluate, Print, Loop. \u21a9 Instru\u00e7\u00f5es de como instalar o GHC s\u00e3o espec\u00edficas para cada sistema operacional. Por isso, consulte o s\u00edtio https://www.haskell.org/platform/ para instalar o Haskell na sua m\u00e1quina. \u21a9","title":"1+1"},{"location":"highorder/","text":"Fun\u00e7\u00f5es de ordem superior Quando estudamos linguagens de programa\u00e7\u00e3o, \u00e9 comum denominar como cidad\u00e3os de primeira classe (do ingl\u00eas, first class citizens ) as entidades que podem ser atribu\u00eddas a vari\u00e1veis, passadas como par\u00e2metro, retornadas como resultado ou operadas de forma geral. Em Haskell, fun\u00e7\u00f5es s\u00e3o cidad\u00e3s de primeira classe! Vejamos um exemplo em que uma fun\u00e7\u00e3o \u00e9 associada a uma vari\u00e1vel, o que efetivamente torna esta vari\u00e1vel uma fun\u00e7\u00e3o! Prelude > f x y = x + y Prelude > g = f Prelude > g 1 2 3 Outro conceito relacionado \u00e9 o das fun\u00e7\u00f5es de ordem superior , aquelas fun\u00e7\u00f5es que ou recebem como par\u00e2metro ou retornam como resultado outras fun\u00e7\u00f5es, e que s\u00f3 podem existir em linguagens em que fun\u00e7\u00f5es s\u00e3o cidad\u00e3s de primeira classe. Vejamos um exemplo de uma fun\u00e7\u00e3o de ordem superior que aplica uma outra fun\u00e7\u00e3o, recebida como par\u00e2metro, aos seus outros par\u00e2metros. somar :: Int -> Int -> Int somar x y = x + y multiplicar :: Int -> Int -> Int multiplicar x y = x * y dividir :: Int -> Int -> Int dividir x y = x ` div ` y operar :: ( Int -> Int -> Int ) -> Int -> Int -> Int operar f x y = f x y -- >>> operar somar 3 4 -- 7 -- >>> operar multiplicar 3 4 -- 12 -- >>> operar dividir 3 4 -- 0 Observe que a fun\u00e7\u00e3o operar tem como primeiro par\u00e2metro formal #!f , que \u00e9 do tipo ( Int -> Int -> Int ) , isto \u00e9, uma fun\u00e7\u00e3o que recebe dois inteiros e retorna um inteiro. Esta fun\u00e7\u00e3o f \u00e9 aplicada aos demais par\u00e2metros de de operar para calcular o resultado. Fun\u00e7\u00f5es de alta ordem s\u00e3o \u00fateis em diversas situa\u00e7\u00f5es, por exemplo, como forma de criar um comportamento configur\u00e1vel no seu c\u00f3digo, e s\u00e3o frequentes na biblioteca da linguagem Haskell, dentre as quais destacamos map , filter , e diversos tipos de fold . map Seja uma lista de inteiros sobre a qual voc\u00ea queira executar diversas transforma\u00e7\u00f5es, por exemplo, multiplicar todos os valores por 10, somar 3, testar se par ou achar o m\u00f3dulo por 3. Voc\u00ea pode come\u00e7ar definindo fun\u00e7\u00f5es que fazem transforma\u00e7\u00f5es em um \u00fanico elemento e, para cada uma, uma fun\u00e7\u00e3o correspondente para listas. multiplicarPor10 :: Int -> Int multiplicarPor10 x = x * 10 multiplicarPor10Lista :: [ Int ] -> [ Int ] multiplicarPor10Lista l = [ multiplicarPor10 e | e <- l ] -- >>>multiplicarPor10Lista [2..5] -- [20,30,40,50] somar3 :: Int -> Int somar3 x = x + 3 somar3Lista :: [ Int ] -> [ Int ] somar3Lista l = [ somar3 e | e <- l ] -- >>>somar3Lista [2..5] -- [5,6,7,8] \u00e9Par :: Int -> Bool \u00e9Par x = even x \u00e9ParLista :: [ Int ] -> [ Bool ] \u00e9ParLista l = [ \u00e9Par e | e <- l ] -- >>>\u00e9ParLista [2..5] -- [True,False,True,False] mod3 :: Int -> Int mod3 x = x ` mod ` 3 mod3Lista :: [ Int ] -> [ Int ] mod3Lista l = [ mod3 e | e <- l ] -- >>>mod3Lista [2..5] -- [2,0,1,2] Se voc\u00ea observar as fun\u00e7\u00f5es para as listas perceber\u00e1 que todas tem uma mesma estrutura. Gra\u00e7as \u00e0s fun\u00e7\u00f5es de ordem superior, voc\u00ea pode aproveitar este fato e criar uma fun\u00e7\u00e3o, gen\u00e9rica, que sirva para aplicar qualquer das transforma\u00e7\u00f5es desejadas. Como as fun\u00e7\u00f5es acima, nossa fun\u00e7\u00e3o gen\u00e9rica recebe uma lista de um tipo a e resultar\u00e1 em uma lista de um tipo b . Por iso, chamemos nossa fun\u00e7\u00e3o de mapeie , pois com ela mapearemos cada valor da lista de entrada para a lista de resultado. Al\u00e9m da lista de entrada, mapeie mas tamb\u00e9m receber\u00e1 uma fun\u00e7\u00e3o com tipo a -> b , a ser aplicada nas transforma\u00e7\u00f5es. mapeie :: ( a -> b ) -> [ a ] -> [ b ] mapeie f xs = [ f x | x <- xs ] Uma vez definida a fun\u00e7\u00e3o, sua invoca\u00e7\u00e3o \u00e9 trivial. > mapeie multiplicarPor10 [ 1 .. 10 ] [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 ] > mapeie somar3 [ 1 .. 10 ] [ 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] > mapeie \u00e9Par [ 1 .. 10 ] [ False , True , False , True , False , True , False , True , False , True ] > mapeie mod3 [ 1 .. 10 ] [ 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 ] A fun\u00e7\u00e3o mapeie , na verdade, serve para aplicar qualquer fun\u00e7\u00e3o que transforme a para b em uma lista de elementos do tipo a , resultando em uma lista de elementos do tipo b . Esta fun\u00e7\u00e3o \u00e9 t\u00e3o \u00fatil, que j\u00e1 existe na biblioteca do Haskell e de qualquer linguagem de programa\u00e7\u00e3o funcional (e mesmo outras, como Python e Java). > : i map map :: ( a -> b ) -> [ a ] -> [ b ] -- Defined in \u2018GHC.Base\u2019 fold (redu\u00e7\u00e3o) Um outro procedimento recorrente sobre dados \u00e9 a redu\u00e7\u00e3o ou sumariza\u00e7\u00e3o de um conjunto para um \u00fanico valor, como \u00e9 feito pelas fun\u00e7\u00f5es product e sum nos seguintes exemplos. > sum [ 1 .. 10 ] 55 > product [ 1 .. 3 ] 6 Vamos tentar generalizar estas duas fun\u00e7\u00f5es usando uma fun\u00e7\u00e3o de ordem superior. Isto \u00e9, definimos uma fun\u00e7\u00e3o de ordem superior que receba um operador, como ( + ) e ( * ) , e aplique a uma lista de inteiros calculando resumo dos elementos da lista, como o somat\u00f3rio ou o produt\u00f3rio no caso dos operadores ( + ) e ( * ) . Comecemos por redefinir sum e product para entender melhor suas estruturas. sum' :: [ Int ] -> Int sum' [] = 0 sum' ( n : ns ) = n + sum' ns Podemos pensar na fun\u00e7\u00e3o sum' como gerando uma express\u00e3o formada pelos elementos da lista mais o valor 0, separados pelo operador + , por exemplo, sum' [ 1 , 2 , 3 ] = 1 + 2 + 3 + 0 e sum' [ 7 , 9 , 14 ] = 7 + 9 + 14 + 0 . Observe que o valor 0 \u00e9 escolhido como resultado do caso base, 0, pois ele n\u00e3o afeta o somat\u00f3rio, isto \u00e9, 0 \u00e9 o elemento neutro (ou identidade) da adi\u00e7\u00e3o. product' :: [ Int ] -> Int product' [] = 1 product' ( n : ns ) = n * product' ns No caso de product , embora a estrutura seja a mesma, alteramos o caso base para 1, o elemento neutro da multiplica\u00e7\u00e3o. Assim, por mais estranho que possa parecer, o produt\u00f3rio de uma lista vazia \u00e9 definido como 1. 1 A express\u00e3o gerada pela fun\u00e7\u00e3o \u00e9 semelhante, isto \u00e9, product' [ 1 , 2 , 3 ] = 1 * 2 * 3 * 1 e product' [ 7 , 9 , 14 ] = 7 * 9 * 14 * 1 . Podemos ent\u00e3o generalizar a fun\u00e7\u00e3o como uma recurs\u00e3o em que o caso gen\u00e9rico \u00e9 a do operador especificado e o caso base retorna o elemento neutro da opera\u00e7\u00e3o. O tipo da fun\u00e7\u00e3o \u00e9 claro; ela deve receber um operar, que \u00e9 uma fun\u00e7\u00e3o que recebe dois inteiros e retorna um inteiro, a lista de inteiros para aplicar o operador, e retornar um resultado tamb\u00e9m inteiro. A recurs\u00e3o consistir\u00e1 em um caso gen\u00e9rico, que aplica o operador \u00e0 cabe\u00e7a da lista e ao resultado da invoca\u00e7\u00e3o recursivo na cauda, e de um caso base que retorne o elemento neutro da opera\u00e7\u00e3o. Mas como saber qual \u00e9 o elemento neutro? resumir :: ( Int -> Int -> Int ) -> [ Int ] -> Int resumir f [] = ?? resumir f ( n : ns ) = n ` f ` ( resumir f ns ) N\u00e3o nos resta alternativa sen\u00e3o passar o pr\u00f3prio elemento neutro na invoca\u00e7\u00e3o da fun\u00e7\u00e3o, resultando na seguinte defini\u00e7\u00e3o. resumir :: ( Int -> Int -> Int ) -> Int -> [ Int ] -> Int resumir f i [] = i resumir f i ( n : ns ) = n ` f ` ( resumir f i ns ) -- >>> resumir somar 0 [1..5] -- 15 -- >>> resumir multiplicar 1 [1..5] -- 120 Uma varia\u00e7\u00e3o ligeiramente diferente, alterando a chamada recursiva, gera os mesmos resultados. resumir' :: ( Int -> Int -> Int ) -> Int -> [ Int ] -> Int resumir' f i [] = i resumir' f i ( n : ns ) = resumir' f ( i ` f ` n ) ns -- >>> resumir somar 0 [1..5] -- 15 -- >>> resumir' multiplicar 1 [1..5] -- 120 A diferen\u00e7a aqui \u00e9 que em vez da recurs\u00e3o passar o elemento neutro adiante para ser usado no caso base, intocado, o elemento neutro \u00e9 usado de cara e operado com a cabe\u00e7a da lista; o resultado desta opera\u00e7\u00e3o \u00e9 que \u00e9 ent\u00e3o passado para a chamada recursiva at\u00e9 que, no caso base, seja retornado como o resultado da fun\u00e7\u00e3o. Uma outra forma de ver isso \u00e9 comparando as express\u00f5es geradas pelas duas declara\u00e7\u00f5es. Neste caso, consideraremos operador o e um elemento neutro i , mas, desta vez, observemos tamb\u00e9m a ordem em que as opera\u00e7\u00f5es ser\u00e3o efetivamente executadas, denotando a ordem por meio de par\u00eanteses. Fun\u00e7\u00e3o resumir o i [ 1 , 2 , 3 ] resumir' o i [ 1 , 2 , 3 ] Express\u00e3o 1 ` o ` ( 2 ` o ` ( 3 ` o ` i )) (( i ` o ` 1 ) ` o ` 2 ) ` o ` 3 \u00c1rvore `o` / \\ 1 `o` / \\ 2 `o` / \\ 3 i `o` / \\ `o` 1 / \\ `o` 2 / \\ i 1 Pelas express\u00f5es vemos que os operadores s\u00e3o tratados como associativo \u00e0 direita, no caso de resumir , e \u00e0 direita, no caso de resumir' , e a associatividade tem implica\u00e7\u00f5es profundas no c\u00e1lculo de uma express\u00e3o. Considere a opera\u00e7\u00e3o de multiplica\u00e7\u00e3o; por ser associativa, isto \u00e9, associativa \u00e0 direita e \u00e0 esquerda, \\(1*2*3*4 = ((1*2)*3)*4 = 1*(2*(3*4)) = 24\\) . Agora considere a divis\u00e3o; por ser associativa \u00e0 esquerda \\(1/2/3/4 = ((1/2)/3)/4 = (0,5/3)/4 = 0,167/4 = 0.0146 \\neq 1/(2/(3/4)) = 1/(2/0,75) = 1/2,67 = 0,375\\) Esta diferen\u00e7a precisa ficar bem clara, pois estas duas fun\u00e7\u00f5es s\u00e3o usadas muito frequentemente em Haskell, sendo definidas (de forma mais geral) na biblioteca como foldX . foldl e foldr Fold \u00e9 o termo usado para descrever a opera\u00e7\u00e3o de dobrar a lista sobre si mesma, combinando os elementos at\u00e9 que s\u00f3 sobre um valor. Outro nome usado frequentemente \u00e9 reduce , que inclusive nomeia fun\u00e7\u00f5es semelhantes em outras linguagens. Haskell tem v\u00e1rias vers\u00f5es de fold , mas as duas mais b\u00e1sicas s\u00e3o foldl e foldr , sendo que diferen\u00e7a no nome vem do fato das fun\u00e7\u00f5es assumirem que a fun\u00e7\u00e3o passada como par\u00e2metro \u00e9 associativa a direita (como +, *) ou a esquerda (como +, *, /, -). > foldr ( + ) 0 [ 1 , 3 , 5 ] 9 > foldl ( + ) 0 [ 1 , 3 , 5 ] 9 > foldr div 1 [ 100 , 10 , 2 ] 20 > foldl div 1 [ 100 , 10 , 2 ] 0 Assim, os exemplos acima podem ser vistos como se segue, evidenciando por qu\u00ea o resultado da divis\u00e3o inteira \u00e9 diferente nas duas chamadas. foldr ( + ) 0 [ 1 , 3 , 5 ] = 1 + ( 3 + ( 5 + ( 0 ))) = 1 + ( 3 + ( 5 )) = 1 + ( 8 ) = 9 foldl ( + ) 0 [ 1 , 3 , 5 ] = (( 0 + 1 ) + 3 ) + 5 = (( 1 ) + 3 ) + 5 = ( 4 ) + 5 = 9 foldr div 1 [ 100 , 10 , 2 ] = 100 ` div ` ( 10 ` div ` ( 2 ` div ` ( 1 ))) = 100 ` div ` ( 10 ` div ` ( 2 )) = 100 ` div ` ( 5 ) = 20 foldl div 1 [ 100 , 10 , 2 ] = (( 1 ` div ` 100 ) ` div ` 10 ) ` div ` 2 = (( 0 ) ` div ` 10 ) ` div ` 2 = ( 0 ) ` div ` 2 = 0 Outra distin\u00e7\u00e3o a ser feita entre as duas fun\u00e7\u00f5es \u00e9 o fato de uma usar muito mais recursos que a outra durante a computa\u00e7\u00e3o, mas voltaremos a discutir isso quando falarmos sobre recurs\u00e3o de cauda. foldl1 e foldr1 Para invocar as fun\u00e7\u00f5es foldl e foldr \u00e9 necess\u00e1rio especificar o valor a ser usado \"na ponta\" do c\u00e1lculo, isto \u00e9, como primeiro elemento no caso de foldl e como \u00faltimo elemento no caso de foldr . Se n\u00e3o houver um valor que naturalmente se encaixe, sempre pode-se usar ou o primeiro ou o \u00faltimo elemento da pr\u00f3pria lista, desde que esta n\u00e3o seja vazia. \u00c9 exatamente isso que as fun\u00e7\u00f5es foldl1 e foldr1 fazem. Se usadas nas mesmas listas dos exemplos anteriores, temos os seguintes resultados. foldr1 ( + ) [ 1 , 3 , 5 ] = 1 + ( 3 + ( 5 )) = 1 + ( 8 ) = 9 foldl1 ( + ) [ 1 , 3 , 5 ] = (( 1 ) + 3 ) + 5 = ( 4 ) + 5 = 9 foldr1 div [ 100 , 10 , 2 ] = 100 ` div ` ( 10 ` div ` ( 2 )) = 100 ` div ` ( 5 ) = 20 foldl1 div [ 100 , 10 , 2 ] = ( 100 ` div ` 10 ) ` div ` 2 = ( 10 ) ` div ` 2 = 5 Foldable Todos os exemplos usados at\u00e9 agora foram sobre listas de n\u00fameros, mas a especifica\u00e7\u00e3o das fun\u00e7\u00f5es de redu\u00e7\u00e3o n\u00e3o faz esta exig\u00eancia. Destrinchemos o exemplo de foldr . > : t foldr foldr :: Foldable t => ( a -> b -> b ) -> b -> t a -> b De forma geral, a defini\u00e7\u00e3o diz que a fun\u00e7\u00e3o passada como primeiro par\u00e2metro deve receber um par\u00e2metro do tipo vari\u00e1vel a e outro b e que o resultado deve ser do tipo b . Na pr\u00e1tica, esta defini\u00e7\u00e3o permite que usemos fun\u00e7\u00f5es assim\u00e9tricas como par\u00e2metro, isto \u00e9, que tenha par\u00e2metros de tipos distintos. Assimetria Na execu\u00e7\u00e3o seguinte a fun\u00e7\u00e3o foi definida para testar se o n\u00famero passado como par\u00e2metro \u00e9 maior que 5 e combinar a resposta com outras anteriores, na forma de um booleano. > maiorque5 i b = b && ( i > 5 ) > foldr maiorque5 True [ 1 , 2 , 3 , 4 ] False > foldr maiorque5 True [ 1 , 2 , 3 , 4 , 6 ] False > foldr maiorque5 True [ 6 .. 10 ] True A defini\u00e7\u00e3o de foldr tamb\u00e9m diz que o valor inicial da fun\u00e7\u00e3o deve ser do tipo b , mas que a lista de valores deve encapsular um valor do tipo a ; o encapsulamento \u00e9 feito por elementos da classe Foldable . Listas s\u00e3o Foldable (como um : i [] pode rapidamente demonstrar), mas n\u00e3o s\u00e3o as \u00fanicas estruturas deste tipo. At\u00e9 mesmo tipos alg\u00e9bricos recursivos, dependendo de suas defini\u00e7\u00f5es, podem satisfazer este crit\u00e9rio. Por exemplo, podemos definir uma \u00e1rvore que se \"dobra\" em uma travessia por em ordem dos seus elementos e usar o folds para encontrar o maior valor da lista, como no exemplo a seguir. import Data.Foldable as F data \u00c1rvore a = Nada | N\u00f3 a ( \u00c1rvore a ) ( \u00c1rvore a ) deriving ( Show , Eq , Read ) instance F . Foldable \u00c1rvore where foldMap f Nada = mempty foldMap f ( N\u00f3 a ae ad ) = F . foldMap f ae ` mappend ` f a ` mappend ` F . foldMap f ad foldr f acc Nada = acc foldr f acc ( N\u00f3 a ae ad ) = foldr f ( f a ( foldr f acc ad )) ae {- >>>arv = N\u00f3 1 (N\u00f3 2 (N\u00f3 4 Nada Nada) Nada) (N\u00f3 3 Nada Nada) >>> foldr (+) 0 arv 10 >>>arv2 = N\u00f3 \"a\" (N\u00f3 \"b\" (N\u00f3 \"c\" Nada Nada) Nada) (N\u00f3 \"d\" Nada Nada) >>> foldr (++) \"\" arv2 \"cbad\" -} Considere a seguinte \u00e1rvore: N\u00f3 1 / \\ N\u00f3 2 N\u00f3 3 / \\ / \\ N\u00f3 4 Nada Nada Nada / \\ Nada Nada Ou, Haskell, arv = N\u00f3 1 ( N\u00f3 2 ( N\u00f3 4 Nada Nada ) Nada ) ( N\u00f3 3 Nada Nada ) . Fold tem o seguinte efeito. > foldr ( + ) 0 arv 10 O poder desta abordagem est\u00e1 na genericidade na cria\u00e7\u00e3o da \u00e1rvore, que tamb\u00e9m pode armazenar outros dados e ser dobrada termos de outra opera\u00e7\u00e3o, por exemplo String e ++ : > arv2 = N\u00f3 \"a\" ( N\u00f3 \"b\" ( N\u00f3 \"c\" Nada Nada ) Nada ) ( N\u00f3 \"d\" Nada Nada ) > foldr ( ++ ) \"\" arv2 \"cbad\" Para mais detalhes, visite http://learnyouahaskell.com/functors-applicative-functors-and-monoids#monoids TODO Expandir sobre foldable e traversable. filter e all A fun\u00e7\u00e3o filter recebe como par\u00e2metros um predicado e uma lista e retorna como resultado um lista com todos os elementos da lista original que satisfazem ao predicado. J\u00e1 fun\u00e7\u00e3o all retorna a lista dos elementos que satisfazem ao predicado. Estas fun\u00e7\u00f5es podem ser definidas e usadas como a seguir. filter :: ( a -> Bool ) -> [ a ] -> [ a ] filter p xs = [ x | x <- xs , p x ] all :: ( a -> Bool ) -> [ a ] -> Bool all p [] = True all p ( x : xs ) = p x && all p xs > f x = x > 10 > filter f [ 1 .. 15 ] [ 11 , 12 , 13 , 14 , 15 ] > all f [ 1 .. 15 ] False > all f [ 11 .. 15 ] True Enquanto n\u00e3o impressionantes, estas fun\u00e7\u00f5es podem ser usadas para demonstrar uma outra funcionalidade de Haskell. Observe as seguintes invoca\u00e7\u00f5es. > filter ( > 10 ) [ 1 .. 15 ] [ 11 , 12 , 13 , 14 , 15 ] > filter ( 10 > ) [ 1 .. 15 ] [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] > all ( > 10 ) [ 1 .. 15 ] False > all ( > 10 ) [ 11 .. 15 ] False Os predicados definidos como ( > 10 ) e ( 10 > ) s\u00e3o exemplos de Currying . Currying (aplica\u00e7\u00e3o parcial) Em outras linguagens, fun\u00e7\u00f5es s\u00e3o normalmente definidas com sintaxe semelhante \u00e0 f :: ( a , b ) -> c , isto \u00e9, o nome da fun\u00e7\u00e3o, seguido de um tupla de tipos de par\u00e2metros, e de um tipo de resultado. Isso \u00e9 verdade para C, Java, Pascal, etc. Currying \u00e9 o processo pelo qual uma fun\u00e7\u00e3o deste tipo \u00e9 transformada em uma fun\u00e7\u00e3o do tipo f :: a -> (( b ) -> c ) , ou seja, uma fun\u00e7\u00e3o que recebe somente um par\u00e2metro e retorna uma outra fun\u00e7\u00e3o que recebe os demais par\u00e2metros e retorna, ao o mesmo tipo que a primeira fun\u00e7\u00e3o. O processo pode ser feito para fun\u00e7\u00f5es mais complexas, exatamente da mesma forma, por exemplo transformando f :: ( a , b , c ) -> d em f :: a -> (( b , c ) -> d ) , e tamb\u00e9m aplicado recursivamente levando, levando a fun\u00e7\u00e3o f :: a -> ( b -> ( c -> d )) , que pode ser simplificado de forma n\u00e3o amb\u00edgua para f :: a -> b -> c -> d , que \u00e9 forma usada pelo Haskell. Isso quer dizer que quando voc\u00ea define uma fun\u00e7\u00e3o em Haskell, voce especifica o tipo usando a forma Curryed , mesmo que defina a fun\u00e7\u00e3o da forma tradicional. Acontece que o pr\u00f3prio Haskell, por baixo dos panos, transforma a sua fun\u00e7\u00e3o no correspondente ao tipo, o que permite que voc\u00ea fa\u00e7a coisas muito legais, como no exemplo a seguir. > 1 + 2 3 > ( 1 + ) 2 3 Esta t\u00e9cnica \u00e9 conhecida como aplica\u00e7\u00e3o parcial, e serve para derivar fun\u00e7\u00f5es mais especializadas. > f = ( 1 + ) > f 2 3 Estas fun\u00e7\u00f5es derivadas s\u00e3o como quaisquer outras fun\u00e7\u00f5es, e podem ser usadas por exemplo em maps e filters. > f = ( 1 + ) > map f [ 1 , 2 , 3 ] [ 2 , 3 , 4 ] > f = ( == 10 ) > map f [ 1 , 10 , 2 , 10 , 3 , 10 ] [ False , True , False , True , False , True ] > filter f [ 1 , 10 , 2 , 10 , 3 , 10 ] [ 10 , 10 , 10 ] Lambda Operador $ (aplica\u00e7\u00e3o) Operador . (composi\u00e7\u00e3o) Sumariza\u00e7\u00e3o soma [] = 0 soma ( x : xs ) = x + soma xs eL\u00f3gico [] = True eL\u00f3gico [ x : xs ] = x && eL\u00f3gico xs sortOn :: Ord b => (a -> b) -> [a] -> [a]# Sort a list by comparing the results of a key function applied to each element. sortOn f is equivalent to sortBy (comparing f), but has the performance advantage of only evaluating f once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform. all https://hoogle.haskell.org/?q=all Why is an empty sum 0 and an empty product 1? \u21a9","title":"Fun\u00e7\u00f5es de ordem superior"},{"location":"highorder/#funcoes-de-ordem-superior","text":"Quando estudamos linguagens de programa\u00e7\u00e3o, \u00e9 comum denominar como cidad\u00e3os de primeira classe (do ingl\u00eas, first class citizens ) as entidades que podem ser atribu\u00eddas a vari\u00e1veis, passadas como par\u00e2metro, retornadas como resultado ou operadas de forma geral. Em Haskell, fun\u00e7\u00f5es s\u00e3o cidad\u00e3s de primeira classe! Vejamos um exemplo em que uma fun\u00e7\u00e3o \u00e9 associada a uma vari\u00e1vel, o que efetivamente torna esta vari\u00e1vel uma fun\u00e7\u00e3o! Prelude > f x y = x + y Prelude > g = f Prelude > g 1 2 3 Outro conceito relacionado \u00e9 o das fun\u00e7\u00f5es de ordem superior , aquelas fun\u00e7\u00f5es que ou recebem como par\u00e2metro ou retornam como resultado outras fun\u00e7\u00f5es, e que s\u00f3 podem existir em linguagens em que fun\u00e7\u00f5es s\u00e3o cidad\u00e3s de primeira classe. Vejamos um exemplo de uma fun\u00e7\u00e3o de ordem superior que aplica uma outra fun\u00e7\u00e3o, recebida como par\u00e2metro, aos seus outros par\u00e2metros. somar :: Int -> Int -> Int somar x y = x + y multiplicar :: Int -> Int -> Int multiplicar x y = x * y dividir :: Int -> Int -> Int dividir x y = x ` div ` y operar :: ( Int -> Int -> Int ) -> Int -> Int -> Int operar f x y = f x y -- >>> operar somar 3 4 -- 7 -- >>> operar multiplicar 3 4 -- 12 -- >>> operar dividir 3 4 -- 0 Observe que a fun\u00e7\u00e3o operar tem como primeiro par\u00e2metro formal #!f , que \u00e9 do tipo ( Int -> Int -> Int ) , isto \u00e9, uma fun\u00e7\u00e3o que recebe dois inteiros e retorna um inteiro. Esta fun\u00e7\u00e3o f \u00e9 aplicada aos demais par\u00e2metros de de operar para calcular o resultado. Fun\u00e7\u00f5es de alta ordem s\u00e3o \u00fateis em diversas situa\u00e7\u00f5es, por exemplo, como forma de criar um comportamento configur\u00e1vel no seu c\u00f3digo, e s\u00e3o frequentes na biblioteca da linguagem Haskell, dentre as quais destacamos map , filter , e diversos tipos de fold .","title":"Fun\u00e7\u00f5es de ordem superior"},{"location":"highorder/#map","text":"Seja uma lista de inteiros sobre a qual voc\u00ea queira executar diversas transforma\u00e7\u00f5es, por exemplo, multiplicar todos os valores por 10, somar 3, testar se par ou achar o m\u00f3dulo por 3. Voc\u00ea pode come\u00e7ar definindo fun\u00e7\u00f5es que fazem transforma\u00e7\u00f5es em um \u00fanico elemento e, para cada uma, uma fun\u00e7\u00e3o correspondente para listas. multiplicarPor10 :: Int -> Int multiplicarPor10 x = x * 10 multiplicarPor10Lista :: [ Int ] -> [ Int ] multiplicarPor10Lista l = [ multiplicarPor10 e | e <- l ] -- >>>multiplicarPor10Lista [2..5] -- [20,30,40,50] somar3 :: Int -> Int somar3 x = x + 3 somar3Lista :: [ Int ] -> [ Int ] somar3Lista l = [ somar3 e | e <- l ] -- >>>somar3Lista [2..5] -- [5,6,7,8] \u00e9Par :: Int -> Bool \u00e9Par x = even x \u00e9ParLista :: [ Int ] -> [ Bool ] \u00e9ParLista l = [ \u00e9Par e | e <- l ] -- >>>\u00e9ParLista [2..5] -- [True,False,True,False] mod3 :: Int -> Int mod3 x = x ` mod ` 3 mod3Lista :: [ Int ] -> [ Int ] mod3Lista l = [ mod3 e | e <- l ] -- >>>mod3Lista [2..5] -- [2,0,1,2] Se voc\u00ea observar as fun\u00e7\u00f5es para as listas perceber\u00e1 que todas tem uma mesma estrutura. Gra\u00e7as \u00e0s fun\u00e7\u00f5es de ordem superior, voc\u00ea pode aproveitar este fato e criar uma fun\u00e7\u00e3o, gen\u00e9rica, que sirva para aplicar qualquer das transforma\u00e7\u00f5es desejadas. Como as fun\u00e7\u00f5es acima, nossa fun\u00e7\u00e3o gen\u00e9rica recebe uma lista de um tipo a e resultar\u00e1 em uma lista de um tipo b . Por iso, chamemos nossa fun\u00e7\u00e3o de mapeie , pois com ela mapearemos cada valor da lista de entrada para a lista de resultado. Al\u00e9m da lista de entrada, mapeie mas tamb\u00e9m receber\u00e1 uma fun\u00e7\u00e3o com tipo a -> b , a ser aplicada nas transforma\u00e7\u00f5es. mapeie :: ( a -> b ) -> [ a ] -> [ b ] mapeie f xs = [ f x | x <- xs ] Uma vez definida a fun\u00e7\u00e3o, sua invoca\u00e7\u00e3o \u00e9 trivial. > mapeie multiplicarPor10 [ 1 .. 10 ] [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 ] > mapeie somar3 [ 1 .. 10 ] [ 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ] > mapeie \u00e9Par [ 1 .. 10 ] [ False , True , False , True , False , True , False , True , False , True ] > mapeie mod3 [ 1 .. 10 ] [ 1 , 2 , 0 , 1 , 2 , 0 , 1 , 2 , 0 , 1 ] A fun\u00e7\u00e3o mapeie , na verdade, serve para aplicar qualquer fun\u00e7\u00e3o que transforme a para b em uma lista de elementos do tipo a , resultando em uma lista de elementos do tipo b . Esta fun\u00e7\u00e3o \u00e9 t\u00e3o \u00fatil, que j\u00e1 existe na biblioteca do Haskell e de qualquer linguagem de programa\u00e7\u00e3o funcional (e mesmo outras, como Python e Java). > : i map map :: ( a -> b ) -> [ a ] -> [ b ] -- Defined in \u2018GHC.Base\u2019","title":"map"},{"location":"highorder/#fold-reducao","text":"Um outro procedimento recorrente sobre dados \u00e9 a redu\u00e7\u00e3o ou sumariza\u00e7\u00e3o de um conjunto para um \u00fanico valor, como \u00e9 feito pelas fun\u00e7\u00f5es product e sum nos seguintes exemplos. > sum [ 1 .. 10 ] 55 > product [ 1 .. 3 ] 6 Vamos tentar generalizar estas duas fun\u00e7\u00f5es usando uma fun\u00e7\u00e3o de ordem superior. Isto \u00e9, definimos uma fun\u00e7\u00e3o de ordem superior que receba um operador, como ( + ) e ( * ) , e aplique a uma lista de inteiros calculando resumo dos elementos da lista, como o somat\u00f3rio ou o produt\u00f3rio no caso dos operadores ( + ) e ( * ) . Comecemos por redefinir sum e product para entender melhor suas estruturas. sum' :: [ Int ] -> Int sum' [] = 0 sum' ( n : ns ) = n + sum' ns Podemos pensar na fun\u00e7\u00e3o sum' como gerando uma express\u00e3o formada pelos elementos da lista mais o valor 0, separados pelo operador + , por exemplo, sum' [ 1 , 2 , 3 ] = 1 + 2 + 3 + 0 e sum' [ 7 , 9 , 14 ] = 7 + 9 + 14 + 0 . Observe que o valor 0 \u00e9 escolhido como resultado do caso base, 0, pois ele n\u00e3o afeta o somat\u00f3rio, isto \u00e9, 0 \u00e9 o elemento neutro (ou identidade) da adi\u00e7\u00e3o. product' :: [ Int ] -> Int product' [] = 1 product' ( n : ns ) = n * product' ns No caso de product , embora a estrutura seja a mesma, alteramos o caso base para 1, o elemento neutro da multiplica\u00e7\u00e3o. Assim, por mais estranho que possa parecer, o produt\u00f3rio de uma lista vazia \u00e9 definido como 1. 1 A express\u00e3o gerada pela fun\u00e7\u00e3o \u00e9 semelhante, isto \u00e9, product' [ 1 , 2 , 3 ] = 1 * 2 * 3 * 1 e product' [ 7 , 9 , 14 ] = 7 * 9 * 14 * 1 . Podemos ent\u00e3o generalizar a fun\u00e7\u00e3o como uma recurs\u00e3o em que o caso gen\u00e9rico \u00e9 a do operador especificado e o caso base retorna o elemento neutro da opera\u00e7\u00e3o. O tipo da fun\u00e7\u00e3o \u00e9 claro; ela deve receber um operar, que \u00e9 uma fun\u00e7\u00e3o que recebe dois inteiros e retorna um inteiro, a lista de inteiros para aplicar o operador, e retornar um resultado tamb\u00e9m inteiro. A recurs\u00e3o consistir\u00e1 em um caso gen\u00e9rico, que aplica o operador \u00e0 cabe\u00e7a da lista e ao resultado da invoca\u00e7\u00e3o recursivo na cauda, e de um caso base que retorne o elemento neutro da opera\u00e7\u00e3o. Mas como saber qual \u00e9 o elemento neutro? resumir :: ( Int -> Int -> Int ) -> [ Int ] -> Int resumir f [] = ?? resumir f ( n : ns ) = n ` f ` ( resumir f ns ) N\u00e3o nos resta alternativa sen\u00e3o passar o pr\u00f3prio elemento neutro na invoca\u00e7\u00e3o da fun\u00e7\u00e3o, resultando na seguinte defini\u00e7\u00e3o. resumir :: ( Int -> Int -> Int ) -> Int -> [ Int ] -> Int resumir f i [] = i resumir f i ( n : ns ) = n ` f ` ( resumir f i ns ) -- >>> resumir somar 0 [1..5] -- 15 -- >>> resumir multiplicar 1 [1..5] -- 120 Uma varia\u00e7\u00e3o ligeiramente diferente, alterando a chamada recursiva, gera os mesmos resultados. resumir' :: ( Int -> Int -> Int ) -> Int -> [ Int ] -> Int resumir' f i [] = i resumir' f i ( n : ns ) = resumir' f ( i ` f ` n ) ns -- >>> resumir somar 0 [1..5] -- 15 -- >>> resumir' multiplicar 1 [1..5] -- 120 A diferen\u00e7a aqui \u00e9 que em vez da recurs\u00e3o passar o elemento neutro adiante para ser usado no caso base, intocado, o elemento neutro \u00e9 usado de cara e operado com a cabe\u00e7a da lista; o resultado desta opera\u00e7\u00e3o \u00e9 que \u00e9 ent\u00e3o passado para a chamada recursiva at\u00e9 que, no caso base, seja retornado como o resultado da fun\u00e7\u00e3o. Uma outra forma de ver isso \u00e9 comparando as express\u00f5es geradas pelas duas declara\u00e7\u00f5es. Neste caso, consideraremos operador o e um elemento neutro i , mas, desta vez, observemos tamb\u00e9m a ordem em que as opera\u00e7\u00f5es ser\u00e3o efetivamente executadas, denotando a ordem por meio de par\u00eanteses. Fun\u00e7\u00e3o resumir o i [ 1 , 2 , 3 ] resumir' o i [ 1 , 2 , 3 ] Express\u00e3o 1 ` o ` ( 2 ` o ` ( 3 ` o ` i )) (( i ` o ` 1 ) ` o ` 2 ) ` o ` 3 \u00c1rvore `o` / \\ 1 `o` / \\ 2 `o` / \\ 3 i `o` / \\ `o` 1 / \\ `o` 2 / \\ i 1 Pelas express\u00f5es vemos que os operadores s\u00e3o tratados como associativo \u00e0 direita, no caso de resumir , e \u00e0 direita, no caso de resumir' , e a associatividade tem implica\u00e7\u00f5es profundas no c\u00e1lculo de uma express\u00e3o. Considere a opera\u00e7\u00e3o de multiplica\u00e7\u00e3o; por ser associativa, isto \u00e9, associativa \u00e0 direita e \u00e0 esquerda, \\(1*2*3*4 = ((1*2)*3)*4 = 1*(2*(3*4)) = 24\\) . Agora considere a divis\u00e3o; por ser associativa \u00e0 esquerda \\(1/2/3/4 = ((1/2)/3)/4 = (0,5/3)/4 = 0,167/4 = 0.0146 \\neq 1/(2/(3/4)) = 1/(2/0,75) = 1/2,67 = 0,375\\) Esta diferen\u00e7a precisa ficar bem clara, pois estas duas fun\u00e7\u00f5es s\u00e3o usadas muito frequentemente em Haskell, sendo definidas (de forma mais geral) na biblioteca como foldX .","title":"fold (redu\u00e7\u00e3o)"},{"location":"highorder/#filter-e-all","text":"A fun\u00e7\u00e3o filter recebe como par\u00e2metros um predicado e uma lista e retorna como resultado um lista com todos os elementos da lista original que satisfazem ao predicado. J\u00e1 fun\u00e7\u00e3o all retorna a lista dos elementos que satisfazem ao predicado. Estas fun\u00e7\u00f5es podem ser definidas e usadas como a seguir. filter :: ( a -> Bool ) -> [ a ] -> [ a ] filter p xs = [ x | x <- xs , p x ] all :: ( a -> Bool ) -> [ a ] -> Bool all p [] = True all p ( x : xs ) = p x && all p xs > f x = x > 10 > filter f [ 1 .. 15 ] [ 11 , 12 , 13 , 14 , 15 ] > all f [ 1 .. 15 ] False > all f [ 11 .. 15 ] True Enquanto n\u00e3o impressionantes, estas fun\u00e7\u00f5es podem ser usadas para demonstrar uma outra funcionalidade de Haskell. Observe as seguintes invoca\u00e7\u00f5es. > filter ( > 10 ) [ 1 .. 15 ] [ 11 , 12 , 13 , 14 , 15 ] > filter ( 10 > ) [ 1 .. 15 ] [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] > all ( > 10 ) [ 1 .. 15 ] False > all ( > 10 ) [ 11 .. 15 ] False Os predicados definidos como ( > 10 ) e ( 10 > ) s\u00e3o exemplos de Currying .","title":"filter e all"},{"location":"highorder/#currying-aplicacao-parcial","text":"Em outras linguagens, fun\u00e7\u00f5es s\u00e3o normalmente definidas com sintaxe semelhante \u00e0 f :: ( a , b ) -> c , isto \u00e9, o nome da fun\u00e7\u00e3o, seguido de um tupla de tipos de par\u00e2metros, e de um tipo de resultado. Isso \u00e9 verdade para C, Java, Pascal, etc. Currying \u00e9 o processo pelo qual uma fun\u00e7\u00e3o deste tipo \u00e9 transformada em uma fun\u00e7\u00e3o do tipo f :: a -> (( b ) -> c ) , ou seja, uma fun\u00e7\u00e3o que recebe somente um par\u00e2metro e retorna uma outra fun\u00e7\u00e3o que recebe os demais par\u00e2metros e retorna, ao o mesmo tipo que a primeira fun\u00e7\u00e3o. O processo pode ser feito para fun\u00e7\u00f5es mais complexas, exatamente da mesma forma, por exemplo transformando f :: ( a , b , c ) -> d em f :: a -> (( b , c ) -> d ) , e tamb\u00e9m aplicado recursivamente levando, levando a fun\u00e7\u00e3o f :: a -> ( b -> ( c -> d )) , que pode ser simplificado de forma n\u00e3o amb\u00edgua para f :: a -> b -> c -> d , que \u00e9 forma usada pelo Haskell. Isso quer dizer que quando voc\u00ea define uma fun\u00e7\u00e3o em Haskell, voce especifica o tipo usando a forma Curryed , mesmo que defina a fun\u00e7\u00e3o da forma tradicional. Acontece que o pr\u00f3prio Haskell, por baixo dos panos, transforma a sua fun\u00e7\u00e3o no correspondente ao tipo, o que permite que voc\u00ea fa\u00e7a coisas muito legais, como no exemplo a seguir. > 1 + 2 3 > ( 1 + ) 2 3 Esta t\u00e9cnica \u00e9 conhecida como aplica\u00e7\u00e3o parcial, e serve para derivar fun\u00e7\u00f5es mais especializadas. > f = ( 1 + ) > f 2 3 Estas fun\u00e7\u00f5es derivadas s\u00e3o como quaisquer outras fun\u00e7\u00f5es, e podem ser usadas por exemplo em maps e filters. > f = ( 1 + ) > map f [ 1 , 2 , 3 ] [ 2 , 3 , 4 ] > f = ( == 10 ) > map f [ 1 , 10 , 2 , 10 , 3 , 10 ] [ False , True , False , True , False , True ] > filter f [ 1 , 10 , 2 , 10 , 3 , 10 ] [ 10 , 10 , 10 ]","title":"Currying (aplica\u00e7\u00e3o parcial)"},{"location":"highorder/#lambda","text":"","title":"Lambda"},{"location":"highorder/#operador-aplicacao","text":"","title":"Operador $ (aplica\u00e7\u00e3o)"},{"location":"highorder/#operador-composicao","text":"Sumariza\u00e7\u00e3o soma [] = 0 soma ( x : xs ) = x + soma xs eL\u00f3gico [] = True eL\u00f3gico [ x : xs ] = x && eL\u00f3gico xs sortOn :: Ord b => (a -> b) -> [a] -> [a]# Sort a list by comparing the results of a key function applied to each element. sortOn f is equivalent to sortBy (comparing f), but has the performance advantage of only evaluating f once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform. all https://hoogle.haskell.org/?q=all Why is an empty sum 0 and an empty product 1? \u21a9","title":"Operador . (composi\u00e7\u00e3o)"},{"location":"ifthenelse/","text":"Voc\u00ea como saberia calcular o maior de dois n\u00fameros \\(a\\) e \\(b\\) sem usar um teste do tipo se ent\u00e3o sen\u00e3o ? \u00c9 bem interessante; assuma \\(M\\) maior e \\(m\\) menor entre \\(a\\) e \\(b\\) . \\[\\begin{eqnarray} M &=& (M + M)/2 \\nonumber \\\\ &=& (M + m + M - m)/2 \\nonumber \\\\ &=& (M + m + (M-m))/2 \\nonumber \\\\ &=& (M + n + \\|M-m\\|)/2 \\nonumber \\\\ &=& (a + b + \\|a - b\\|)/2 \\nonumber \\end{eqnarray}\\] Em outras palavras, o maior entre dois n\u00fameros \\(a\\) e \\(b\\) \u00e9 igual \u00e0 m\u00e9dia dos n\u00fameros \\(a\\) e \\(b\\) , mais a metade da diferen\u00e7a entre \\(a\\) e \\(b\\) . Logo, em Haskell, temos maior x y = ( x + y + ( abs ( x - y ))) / 2 Estou certo de que voc\u00ea concordar\u00e1 que calcular o maior entre dois n\u00fameros deveria ser muito mais simples que isso, especialmente porqu\u00ea naquele abs provavelmente h\u00e1 um if escondido. \\[ f(a,b)= \\begin{cases} a,& \\text{if } a\\geq b\\\\ b, & \\text{otherwise} \\end{cases} \\] Mas como faz\u00ea-lo em Haskell, isto \u00e9, como testar uma condi\u00e7\u00e3o sobre os valores para decidir a forma correta de computar o resultado? Usando uma express\u00e3o de sele\u00e7\u00e3o, isto \u00e9, if ... then ... else ... Veja o exemplo da escolha do maior n\u00famero. maior x y = if x > y then x else y Observe que, diferentemente de outras linguagens em que se pode usar o if para decidir entre fazer ou n\u00e3o uma computa\u00e7\u00e3o, o if do Haskell serve para decidir entre duas computa\u00e7\u00f5es. Isto \u00e9, o if deve sempre ser seguido do then e do else . Observe tamb\u00e9m que o if pode estar em qualquer parte da express\u00e3o, porqu\u00ea este construto \u00e9 tamb\u00e9m uma express\u00e3o. Por exemplo, imagine que queira somar um n\u00famero inteiro com o valor absoluto de outro n\u00famero, sem usar o abs . somaEstranha x y = x + ( if y < 0 then - y else y ) Com esta defini\u00e7\u00e3o, tanto somaEstranha 1 2 quanto somaEstranha 1 (-2) resultam em 3. Mas este exemplo \u00e9 muito estranho, ent\u00e3o pensemos em um mais \u00fatil. Exerc\u00edcio Implemente uma fun\u00e7\u00e3o que calcule se um ano \u00e9 bissexto sabendo que: Se o n\u00e3o \u00e9 m\u00faltiplo de 4, n\u00e3o \u00e9 bissexto. Se \u00e9 m\u00faltiplo de 4 e n\u00e3o \u00e9 m\u00faltiplo de 100, ent\u00e3o \u00e9 bissexto. Se \u00e9 m\u00faltiplo de 100 e n\u00e3o \u00e9 m\u00faltiplo de 400, ent\u00e3o n\u00e3o \u00e9 bissexto. Se \u00e9 m\u00faltiplo de 400, ent\u00e3o \u00e9 bissexto. Resolu\u00e7\u00e3o bissexto x = if mod x 4 /= 0 then False else if mod x 100 /= 0 then True else if mod x 400 == 0 then True else False Aninhar if assim pode funcionar, mas leva a estruturas estranhas e dif\u00edceis de serem lidas. H\u00e1 formas melhores de se lidar com m\u00faltiplas possibilidades de computa\u00e7\u00e3o.","title":"Se ent\u00e3o, sen\u00e3o"},{"location":"intro/","text":"Introdu\u00e7\u00e3o Embora este curso assuma que voc\u00ea j\u00e1 saiba programar em alguma linguagem, ou exatamente por isso, \u00e9 importante que fa\u00e7amos uma revis\u00e3o de algumas ideias b\u00e1sicas de programa\u00e7\u00e3o antes de mergulharmos no paradigma funcional, para que possamos melhor posicionar este paradigma com em rela\u00e7\u00e3o aos demais. Paradigmas de Programa\u00e7\u00e3o Programar um computador consiste em comunicar ao computador instru\u00e7\u00f5es para que ele resolva problemas. E a comunica\u00e7\u00e3o entre duas entidades s\u00f3 \u00e9 poss\u00edvel se usarem uma linguagem em comum, isto \u00e9, dominada pelas duas partes. Comunica\u00e7\u00e3o A\u00e7\u00e3o ou efeito de comunicar, de transmitir ou de receber ideias, conhecimento, mensagens etc., buscando compartilhar informa\u00e7\u00f5es. 1 Comunica\u00e7\u00e3o Linguagens naturais Linguagens de programa\u00e7\u00e3o Quando humanos se comunicam, usam uma linguagens naturais , como o portugu\u00eas, libras, ou canton\u00eas. Linguagens naturais s\u00e3o altamente expressivas, cheias de nuances e depend\u00eancias do contexto, o que lhes confere grande poder, mas tamb\u00e9m a grande fraqueza de permitirem a constru\u00e7\u00e3o de mensagens amb\u00edguas. A comunica\u00e7\u00e3o entre computadores ou computares e humanos, contudo, precisa ser feita de forma precisa, e por isso linguagens naturais n\u00e3o s\u00e3o boas neste contexto, apesar do grande esfor\u00e7o dispendido e da evolu\u00e7\u00e3o do processamento de linguagens naturais, como as \"alexas\" e \"siris\" do mundo podem provar. A comunica\u00e7\u00e3o entre computadores \u00e9 feita por um protocolo de comunica\u00e7\u00e3o, assunto para outro curso. J\u00e1 a comunica\u00e7\u00e3o entre humanos e computadores, na programa\u00e7\u00e3o do computador, \u00e9 feita por meio de linguagens de programa\u00e7\u00e3o , que s\u00e3o muito mais restritas que as linguagens naturais e, por isso, n\u00e3o amb\u00edguas. Linguagem de Programa\u00e7\u00e3o A linguagem de programa\u00e7\u00e3o \u00e9 um m\u00e9todo padronizado, formado por um conjunto de regras sint\u00e1ticas e sem\u00e2nticas, de implementa\u00e7\u00e3o de um c\u00f3digo fonte - que pode ser compilado e transformado em um programa de computador, ou usado como script interpretado - que informar\u00e1 instru\u00e7\u00f5es de processamento ao computador. 2 A n\u00e3o ambiguidade das linguagens de programa\u00e7\u00e3o do fato de terem uma sintaxe e sem\u00e2nticas precisas, descritas por uma gram\u00e1tica tamb\u00e9m precisa. Sintaxe A sintaxe de uma linguagem descreve o que constitui um programa estruturalmente correto e \u00e9 definida por uma gram\u00e1tica. Sem\u00e2ntica O significado de um programa \u00e9 definido por sua sem\u00e2ntica, ou seja, por regras que definem como as instru\u00e7\u00f5es especificado devem ser interpretadas. Serem precisas n\u00e3o quer dizer que as linguagens sejam simples, como demonstra claramente a seguinte imagem, que \u00e9 um programa \u00e9 um \"hello world\" na linguagem Piet . Tamb\u00e9m n\u00e3o quer dizer que sejam limitadas. De fato, h\u00e1 milhares linguagens de programa\u00e7\u00e3o por a\u00ed, e contando, com diferentes caracter\u00edsticas que as tornam mais mais ou menos apropriadas para resolver diferentes problemas. Mas mesmo apesar de t\u00e3o grande n\u00famero, as linguagens podem ser classificadas em grandes fam\u00edlias ou paradigmas. Imperativo x Descritivo Imperativo x Descritivo Imperativo: como Descritivo: o qu\u00ea Os primeiros \"computadores\" eram m\u00e1quinas que computavam mecanicamente seus resultados. Uma segunda gera\u00e7\u00e3o, da qual destacamos o ENIAC (circa 1955), eram computadores sem parte mec\u00e2nicas, programados por conex\u00f5es el\u00e9tricas de suas diversas partes. O pr\u00f3ximo passo, foram computadores que interpretavam c\u00f3digo escrito em uma linguagem de programa\u00e7\u00e3o. Estas primeiras linguagens eram todas imperativas , no sentido de que ditavam ao computador uma sequ\u00eancia de instru\u00e7\u00f5es a serem seguidas para se chegar a um resultado. Isto \u00e9, estas linguagens permitiam ao programador dizer como realizar uma computa\u00e7\u00e3o. Imperativo leia a linha 1 do arquivo separe a linha por espa\u00e7os pegue a segunda parte da linha converta a parte para n\u00famero se o n\u00famero for maior que 15, escreva na tela leia a pr\u00f3xima linha do arquivo volte para o passo 2 Este paradigma tem suas ra\u00edzes no modelo computacional cl\u00e1ssico de von Neumann e na m\u00e1quina de Turing Em contrapartida a este modelo, surgiram mais tarde linguagens declarativas , em que o programado diz o qu\u00ea deve ser computado e o computador se encarrega de achar um \"como\". Descritivo selecione todas as linhas em que a segunda parte \u00e9 maior que 15 Com uma an\u00e1lise r\u00e1pida das linguagens mais conhecidas, voce deve reconhecer a maior parte como imperativas, por exemplo, C, Java, e Python. J\u00e1 dentre as linguagens declarativas, se destacam SQL, LINQ, e Prolog. Ortogonalmente ao foco em no \"como x o qu\u00ea\", podemos nos focar em como as estas instru\u00e7\u00f5es s\u00e3o organizadas mais em um n\u00edvel mais alto, de onde se destacam quatro paradigmas principais: procedimental , orientado a objetos , l\u00f3gico e funcional . 3 Procedimental Linguagens que usam o paradigma procedimental organizam instru\u00e7\u00f5es em blocos, denominados procedimentos, de onde vem o nome, ou fun\u00e7\u00f5es. A ideia \u00e9 que o c\u00f3digo seja modularizado para separar funcionalidades e tornar o c\u00f3digo mais compreens\u00edvel e manuten\u00edvel. Cada fun\u00e7\u00e3o deve executar uma opera\u00e7\u00e3o bem espec\u00edfica, fun\u00e7\u00f5es associadas s\u00e3o colocadas em um mesmo arquivo, e arquivos associados s\u00e3o colocados em um mesmo namespace . O c\u00f3digo seguinte, em C, mostra a fun\u00e7\u00e3o main , ponto de entrada do programa e de onde a fun\u00e7\u00e3o printf , importada de stdio.h , \u00e9 invocada. #include <stdio.h> int main () { printf ( \"Hello, World!\" ); return 0 ; } Al\u00e9m da linguagem C, outros exemplos \u00f3bvios deste paradigma s\u00e3o as linguagens Pascal, Fortran e Python. Contudo, mesmo linguagens como Java e C++ podem ser consideradas procedurais, uma vez que organizam a computa\u00e7\u00e3o em m\u00e9todos, que s\u00e3o nada mais que fun\u00e7\u00f5es. Mas como m\u00e9todos est\u00e3o fortemente associados a classes e suas inst\u00e2ncias, os objetos, estas linguagens s\u00e3o melhor classificadas como orientadas a objetos. Orientado a Objetos Na orienta\u00e7\u00e3o a objetos, o foco est\u00e1 n\u00e3o na execu\u00e7\u00e3o passo a passo de fun\u00e7\u00f5es, mas na organiza\u00e7\u00e3o de dados e fun\u00e7\u00f5es associadas em objetos. Embora esta organiza\u00e7\u00e3o possa ser feita em qualquer qualquer linguagem estruturada, a sintaxe das linguagens orientadas a objeto facilita e tornam mais natural este trabalho. Dois conceitos b\u00e1sicos na orienta\u00e7\u00e3o a objetos s\u00e3o as classes e os objetos . Classes s\u00e3o abstra\u00e7\u00f5es de tipos de coisas encontrados no mundo real, ou seja, receitas de estruturas de dados e definem quais os dados devem ser considerados em conjunto para representar um objeto e quais as a\u00e7\u00f5es associadas a este objeto. Por exemplo, se no mundo real cachorros tem uma data de nascimento e um nome, e s\u00e3o capazes de latir, uma classe que represente cachorros pode ser definida assim em Java. class Cachorro { int diaNascimento ; int mesNascimento ; int anoNascimento ; String nome ; void latir ( int quantidade ) { for ( int i = 0 ; i < quantidade ; i ++ ) System . out . println ( nome + \": Au!\" ); } } J\u00e1 um objeto \u00e9 uma inst\u00e2ncia de uma classe, uma representa\u00e7\u00e3o de um tipo mas de uma coisa em si. Um c\u00e3o qualquer poderia ser representado assim Cachorro cachorro1 = new Cachorro ( 25 , 12 , 2020 , \"Napole\u00e3o\" ); cachorro1 . latir ( 3 ); e a execu\u00e7\u00e3o deste c\u00f3digo resultaria em Napole\u00e3o: Au! Napole\u00e3o: Au! Napole\u00e3o: Au! Observe que o \".\" em cachorro1.latir(3) quer dizer \"executar a fun\u00e7\u00e3o latir no objeto cachorro1 \", o que leva \u00e0 string Napole\u00e3o a aparecer antes de cada latido. Duas coisas poder ser ditas sobre este \".\". Primeiro, que ele n\u00e3o \u00e9 necess\u00e1rio, o objeto em si poderia ser passado como par\u00e2metro para uma fun\u00e7\u00e3o latir que recebesse o objeto al\u00e9m da quantidade de latidos; de fato, em Python, a classe seria definida como a seguir class Cachorro : diaNascimento mesNascimento anoNascimento nome def latir ( self , quantidade ): for i in range ( 0 , quantidade ): print ( self . nome + \": Au!\" ) o que implica que o \".\" \u00e9 o s\u00f3 a\u00e7\u00facar sint\u00e1tico para a execu\u00e7\u00e3o de uma fun\u00e7\u00e3o, o que nos leva ao segundo ponto. Na orienta\u00e7\u00e3o a objetos conceitual, n\u00e3o se fala em invoca\u00e7\u00e3o de fun\u00e7\u00f5es mas de sinais sendo transmitidos entre objetos: envie mensagem para o 2 \"somar-se com 3\", ao que o objeto 2 responderia com uma mensagem \"refer\u00eancia ao objeto 4\". Em Smalltalk, esta intera\u00e7\u00e3o seria escrita assim: x := 2 + 3 . Grande parte do poder da orienta\u00e7\u00e3o objetos est\u00e1 no encapsulamento do como opera\u00e7\u00f5es s\u00e3o executadas, nos m\u00e9todos. Uma outra ordem de encapsulamento, de outro tipo, \u00e9 encontrada no paradigma l\u00f3gico. L\u00f3gico No paradigma l\u00f3gico, voc\u00ea declara-se fatos b\u00e1sicos e regras sobre como os fatos se relacionam e pergunta ao programa se certos fatos s\u00e3o ou n\u00e3o s\u00e3o verdade. Por exemplo, como fatos, podemos declarar eh_maior_que ( gato , rato ). eh_maior_que ( leao , gato ). eh_maior_que ( elefante , leao ). eh_maior_que ( elefante , moto ). eh_maior_que ( legal , cachorro ). que vale a transitividade eh_maior_que ( A , B ) :- eh_maior_que ( A , C ), eh_maior_que ( C , B ). e, finalmente, perguntar se elefante \u00e9 maior rato eh_maior_que ( elefante , rato ). ao que seremos respondidos com um \"sim\". Voc\u00ea consegue imaginar quantas linhas de c\u00f3digo voc\u00ea precisaria para expressar a mesma l\u00f3gica acima em uma linguagem como C ou Java? Apesar do claro poder deste paradigma, o mesmo tem poucos representantes, como Prolog e Mercury, e mesmo que exista v\u00e1rios compiladores do primeiro, o uso comercial do paradigma \u00e9 bem limitado. Funcional A programa\u00e7\u00e3o, como indicado pelo nome, \u00e9 focada na organiza\u00e7\u00e3o do processamento em termos de fun\u00e7\u00f5es, mas de uma forma diferente da programa\u00e7\u00e3o procedimental. De forma geral, fun\u00e7\u00f5es s\u00e3o blocos de c\u00f3digo criadas essencialmente para se obter reusabilidade : uma vez definidas, as fun\u00e7\u00f5es podem ser invocadas repetidas vezes para executar a mesma tarefa sobre diferentes par\u00e2metros , sempre retornando um resultado. 4 Mas enquanto na programa\u00e7\u00e3o procedimental a invoca\u00e7\u00e3o de uma fun\u00e7\u00e3o pode retornar diferentes resultados mesmo quando os par\u00e2metros s\u00e3o os mesmos, na programa\u00e7\u00e3o funcional, fun\u00e7\u00f5es s\u00e3o como na matem\u00e1tica, isto \u00e9, mapeiam uma entrada para exatamente uma sa\u00edda, sempre. Isto \u00e9, fun\u00e7\u00f5es resolvem o problema sem se basear em nada al\u00e9m dos par\u00e2metros passados e sem efeitos colaterais. Mas e as fun\u00e7\u00f5es que tem efeitos colaterais? Estas n\u00e3o s\u00e3o fun\u00e7\u00f5es \"de verdade\" e n\u00e3o \u00e9 a toa que outro nome usado para os blocos de c\u00f3digo \u00e9 procedimento e que para discernir entre fun\u00e7\u00f5es que tem efeitos colaterais e que n\u00e3o n\u00e3o, chamamos de puras as do segundo tipo. Vejamos alguns exemplos. As fun\u00e7\u00f5es seguintes, definidas em Erlang, calculam A+B , A*C e (A+B)*(A+B) e, independentemente de quantas vezes voc\u00ea o fizer, add(2,3) sempre retornar\u00e1 5 . add ( A , B ) -> A + B . mult ( A , B ) -> A * B . mult_add ( A , B ) -> mult ( add ( A , B ), add ( A , B )). Agora observe a fun\u00e7\u00e3o seguinte, escritas em Python; a cada invoca\u00e7\u00e3o, a vari\u00e1vel acc tem seu valor alterado e mesmo que invocada com a mesma entrada, o resultado da fun\u00e7\u00e3o \u00e9 sempre diferente. Os efeitos externos \u00e0 fun\u00e7\u00e3o, e.g., a altera\u00e7\u00e3o da vari\u00e1vel acc , \u00e9 conhecido efeito colateral . Programa\u00e7\u00e3o funcional n\u00e3o tem tem efeitos colaterais por que trata vari\u00e1veis n\u00e3o como \u00e1reas de mem\u00f3ria alter\u00e1veis, mas como inc\u00f3gnitas, como na matem\u00e1tica. Pelo menos esta \u00e9 a ideia de programa\u00e7\u00e3o funcional pura, que \u00e9 essencialmente a escrita de longu\u00edssimas equa\u00e7\u00f5es. Acontece que devido \u00e0 complexidade inerente do uso de programa\u00e7\u00e3o funcional pura, sem efeitos colaterais, i.e., sem muta\u00e7\u00e3o de estados, muitas linguagens n\u00e3o s\u00e3o puramente funcionais. A raz\u00e3o mais comum para efeitos colaterais \u00e9 a realiza\u00e7\u00e3o de Entrada/Sa\u00edda. Por exemplo, ao invocar print no Python, o terminal tem seu estado alterado, e cada nova invoca\u00e7\u00e3o altera mais o estado. Assim, podemos dividir as linguagens e funcionais puras, funcionais n\u00e3o puras e n\u00e3o funcionais, mas mesmo dentro das n\u00e3o funcionais, h\u00e1 aquelas com elementos de programa\u00e7\u00e3o funcional. \"Funcionalidades\" Muitas linguagens modernas, como Python e JavaScript, embora n\u00e3o estritamente funcionais, tem diversos elementos de programa\u00e7\u00e3o funcional, eu diretamente na linguagem ou via frameworks . Python, por exemplo, v\u00e1rias funcionalidades caracter\u00edsticas do paradigma funcional, embora seja poss\u00edvel ignor\u00e1-las por completo. Por exemplo, imagine que voc\u00ea queira criar uma lista com o quadrado de todos os n\u00fameros de 1 a x . Voc\u00ea pode optar por um for cl\u00e1ssico ... def quads ( x ): lista = [] for i in range ( 1 , x ): lista . append ( i * i ) return lista ... ou uma compreens\u00e3o de listas , como nos exemplos a seguir. def quads2 ( x ): return [ e ** 2 for e in range ( 1 , x )] Al\u00e9m disso, h\u00e1 linguagens funcionais que tamb\u00e9m se enquadram em outros paradigmas e que podem ser consideradas h\u00edbridas, ou multi-paradigma. Multi-paradigmas Muitas linguagens modernas podem ser classificadas ao mesmo tempo em muitos paradigmas, por exemplo, a linguagem Scala \u00e9 ao mesmo tempo funcional e orientada a objetos, sendo muito dif\u00edcil us\u00e1-la sem fazer uso desta caracter\u00edstica. object HelloWorld { def main ( args : Array [ String ]) : Unit = { println ( \"Hello, world!\" ) } } Para cada servi\u00e7o, uma ferramenta! Em cada paradigma, encontramos vantagens e desvantagens. Como desenvolvedores de tecnologia, nada mais justo que voc\u00eas conhe\u00e7am todos os paradigmas e que possam, assim, escolher aquele paradigma e, dentro dele, aquela linguagem que permite resolver o seu problema da forma mais eficiente, isto \u00e9, rapidamente, com menor custo e com melhor qualidade. Mas quanto ao paradigma funciona, em especial, \u00e9 importante compreend\u00ea-lo pois muitas de suas funcionalidades tem sido incorporadas a outras linguagens, como compreens\u00e3o de listas em Python, fun\u00e7\u00f5es lambda em Java e C++, e processamento ass\u00edncrono pode ser visto como uma forma de avalia\u00e7\u00e3o pregui\u00e7osa em diversas linguagens. Vejamos estes outras pontos importantes do paradigma: Sem efeitos colaterais: executando um programa, de repente voc\u00ea percebe que uma certa vari\u00e1vel tem um valor estranho e fica se perguntando quem foi que atribuiu tal valor; efeitos colaterais s\u00e3o a origem de boa parte dos bugs e elimin\u00e1-los, ou ao menos reduz\u00ed-los, permite que voc\u00ea identifique rapidamente onde altera\u00e7\u00f5es poderiam ter acontecido. Camadas de abstra\u00e7\u00e3o: fun\u00e7\u00f5es podem ser compostas levando a programas verdadeiramente complexos, permitindo que abstra\u00e7\u00f5es sejam definidas em diversas camadas. Al\u00e9m disso, \u00e9 poss\u00edvel, em teoria, ser provar a corretude de fun\u00e7\u00f5es e, mesmo que na pr\u00e1tica isso n\u00e3o se realize, h\u00e1 ferramentas que conseguem usar esta ideia para lhe ajudar a encontrar bugs. Processamento paralelo eficiente: a aus\u00eancia de efeitos colaterais tamb\u00e9m implica que fun\u00e7\u00f5es sem depend\u00eancias podem ser executadas em paralelo, sem se preocupar com qualquer sincroniza\u00e7\u00e3o, isto \u00e9, sem mutexes e vari\u00e1veis de condi\u00e7\u00e3o, etc. Avalia\u00e7\u00e3o pregui\u00e7osa: fun\u00e7\u00f5es s\u00f3 precisam realmente ser executadas se seus resultados s\u00e3o necess\u00e1rios e o compilador consegue atrasar a execu\u00e7\u00e3o de fun\u00e7\u00f5es enquanto poss\u00edvel. Recurs\u00e3o de calda: alguns problemas podem ser descritos muito facilmente como uma recurs\u00e3o que com uma itera\u00e7\u00e3o, mas linguagens tradicionais tem um limite no tamanho das pilhas de fun\u00e7\u00e3o; linguagens funcionais conseguem, em certas condi\u00e7\u00f5es, usar recurs\u00e3o infinita, contornando esta limita\u00e7\u00e3o. Fun\u00e7\u00f5es de alta ordem: fun\u00e7\u00f5es podem receber outras fun\u00e7\u00f5es como par\u00e2metro e com isso podemos compor fun\u00e7\u00f5es, por exemplo para implementar orienta\u00e7\u00e3o a objetos. Escolha o seu veneno Como j\u00e1 ficou \u00f3bvio, h\u00e1 muitas, muitas linguagens de programa\u00e7\u00e3o por a\u00ed e \u00e9 poss\u00edvel escrever c\u00f3digo bom em cada um delas, assim como \u00e9 poss\u00edvel escrever c\u00f3digo ruim em cada uma delas. Tamb\u00e9m \u00e9 poss\u00edvel escrever usando orienta\u00e7\u00e3o a objetos ou funcionalmente em cada uma delas, mas embora seja poss\u00edvel , h\u00e1 aquelas linguagens que suportam melhor cada um dos paradigmas. Dentre estas, h\u00e1 diversas op\u00e7\u00f5es de linguagens que podemos usar para estudar o paradigma funcional, por exemplo: Scheme Lisp ML F# Erlang Elixir Haskell Clojure Neste curso, veremos princ\u00edpios gerais e que, em teoria, poderiam ser aplicados em qualquer destas linguagens. Contudo, como a sintaxe pode variar muito de uma linguagem para outra, precisaremos nos focar em uma \u00fanica linguagem, mesmo que, frequentemente, apresente exemplos em outras. Assim, nosso foco aqui ser\u00e1 em Haskell, uma linguagem funcional madura e est\u00e1vel. Recomenda\u00e7\u00f5es Sobre a hist\u00f3ria das linguagens de programa\u00e7\u00e3o Sobre porqu\u00ea PF n\u00e3o \u00e9 mais comum Comunica\u00e7\u00e3o \u21a9 Linguagem de Programa\u00e7\u00e3o \u21a9 Programming Language Families \u21a9 void \u00e9 simplesmente um resultado que diz que o resultado n\u00e3o importa. \u21a9","title":"Introdu\u00e7\u00e3o"},{"location":"intro/#introducao","text":"Embora este curso assuma que voc\u00ea j\u00e1 saiba programar em alguma linguagem, ou exatamente por isso, \u00e9 importante que fa\u00e7amos uma revis\u00e3o de algumas ideias b\u00e1sicas de programa\u00e7\u00e3o antes de mergulharmos no paradigma funcional, para que possamos melhor posicionar este paradigma com em rela\u00e7\u00e3o aos demais.","title":"Introdu\u00e7\u00e3o"},{"location":"intro/#paradigmas-de-programacao","text":"Programar um computador consiste em comunicar ao computador instru\u00e7\u00f5es para que ele resolva problemas. E a comunica\u00e7\u00e3o entre duas entidades s\u00f3 \u00e9 poss\u00edvel se usarem uma linguagem em comum, isto \u00e9, dominada pelas duas partes. Comunica\u00e7\u00e3o A\u00e7\u00e3o ou efeito de comunicar, de transmitir ou de receber ideias, conhecimento, mensagens etc., buscando compartilhar informa\u00e7\u00f5es. 1 Comunica\u00e7\u00e3o Linguagens naturais Linguagens de programa\u00e7\u00e3o Quando humanos se comunicam, usam uma linguagens naturais , como o portugu\u00eas, libras, ou canton\u00eas. Linguagens naturais s\u00e3o altamente expressivas, cheias de nuances e depend\u00eancias do contexto, o que lhes confere grande poder, mas tamb\u00e9m a grande fraqueza de permitirem a constru\u00e7\u00e3o de mensagens amb\u00edguas. A comunica\u00e7\u00e3o entre computadores ou computares e humanos, contudo, precisa ser feita de forma precisa, e por isso linguagens naturais n\u00e3o s\u00e3o boas neste contexto, apesar do grande esfor\u00e7o dispendido e da evolu\u00e7\u00e3o do processamento de linguagens naturais, como as \"alexas\" e \"siris\" do mundo podem provar. A comunica\u00e7\u00e3o entre computadores \u00e9 feita por um protocolo de comunica\u00e7\u00e3o, assunto para outro curso. J\u00e1 a comunica\u00e7\u00e3o entre humanos e computadores, na programa\u00e7\u00e3o do computador, \u00e9 feita por meio de linguagens de programa\u00e7\u00e3o , que s\u00e3o muito mais restritas que as linguagens naturais e, por isso, n\u00e3o amb\u00edguas. Linguagem de Programa\u00e7\u00e3o A linguagem de programa\u00e7\u00e3o \u00e9 um m\u00e9todo padronizado, formado por um conjunto de regras sint\u00e1ticas e sem\u00e2nticas, de implementa\u00e7\u00e3o de um c\u00f3digo fonte - que pode ser compilado e transformado em um programa de computador, ou usado como script interpretado - que informar\u00e1 instru\u00e7\u00f5es de processamento ao computador. 2 A n\u00e3o ambiguidade das linguagens de programa\u00e7\u00e3o do fato de terem uma sintaxe e sem\u00e2nticas precisas, descritas por uma gram\u00e1tica tamb\u00e9m precisa. Sintaxe A sintaxe de uma linguagem descreve o que constitui um programa estruturalmente correto e \u00e9 definida por uma gram\u00e1tica. Sem\u00e2ntica O significado de um programa \u00e9 definido por sua sem\u00e2ntica, ou seja, por regras que definem como as instru\u00e7\u00f5es especificado devem ser interpretadas. Serem precisas n\u00e3o quer dizer que as linguagens sejam simples, como demonstra claramente a seguinte imagem, que \u00e9 um programa \u00e9 um \"hello world\" na linguagem Piet . Tamb\u00e9m n\u00e3o quer dizer que sejam limitadas. De fato, h\u00e1 milhares linguagens de programa\u00e7\u00e3o por a\u00ed, e contando, com diferentes caracter\u00edsticas que as tornam mais mais ou menos apropriadas para resolver diferentes problemas. Mas mesmo apesar de t\u00e3o grande n\u00famero, as linguagens podem ser classificadas em grandes fam\u00edlias ou paradigmas.","title":"Paradigmas de Programa\u00e7\u00e3o"},{"location":"intro/#imperativo-x-descritivo","text":"Imperativo x Descritivo Imperativo: como Descritivo: o qu\u00ea Os primeiros \"computadores\" eram m\u00e1quinas que computavam mecanicamente seus resultados. Uma segunda gera\u00e7\u00e3o, da qual destacamos o ENIAC (circa 1955), eram computadores sem parte mec\u00e2nicas, programados por conex\u00f5es el\u00e9tricas de suas diversas partes. O pr\u00f3ximo passo, foram computadores que interpretavam c\u00f3digo escrito em uma linguagem de programa\u00e7\u00e3o. Estas primeiras linguagens eram todas imperativas , no sentido de que ditavam ao computador uma sequ\u00eancia de instru\u00e7\u00f5es a serem seguidas para se chegar a um resultado. Isto \u00e9, estas linguagens permitiam ao programador dizer como realizar uma computa\u00e7\u00e3o. Imperativo leia a linha 1 do arquivo separe a linha por espa\u00e7os pegue a segunda parte da linha converta a parte para n\u00famero se o n\u00famero for maior que 15, escreva na tela leia a pr\u00f3xima linha do arquivo volte para o passo 2 Este paradigma tem suas ra\u00edzes no modelo computacional cl\u00e1ssico de von Neumann e na m\u00e1quina de Turing Em contrapartida a este modelo, surgiram mais tarde linguagens declarativas , em que o programado diz o qu\u00ea deve ser computado e o computador se encarrega de achar um \"como\". Descritivo selecione todas as linhas em que a segunda parte \u00e9 maior que 15 Com uma an\u00e1lise r\u00e1pida das linguagens mais conhecidas, voce deve reconhecer a maior parte como imperativas, por exemplo, C, Java, e Python. J\u00e1 dentre as linguagens declarativas, se destacam SQL, LINQ, e Prolog. Ortogonalmente ao foco em no \"como x o qu\u00ea\", podemos nos focar em como as estas instru\u00e7\u00f5es s\u00e3o organizadas mais em um n\u00edvel mais alto, de onde se destacam quatro paradigmas principais: procedimental , orientado a objetos , l\u00f3gico e funcional . 3","title":"Imperativo x Descritivo"},{"location":"intro/#procedimental","text":"Linguagens que usam o paradigma procedimental organizam instru\u00e7\u00f5es em blocos, denominados procedimentos, de onde vem o nome, ou fun\u00e7\u00f5es. A ideia \u00e9 que o c\u00f3digo seja modularizado para separar funcionalidades e tornar o c\u00f3digo mais compreens\u00edvel e manuten\u00edvel. Cada fun\u00e7\u00e3o deve executar uma opera\u00e7\u00e3o bem espec\u00edfica, fun\u00e7\u00f5es associadas s\u00e3o colocadas em um mesmo arquivo, e arquivos associados s\u00e3o colocados em um mesmo namespace . O c\u00f3digo seguinte, em C, mostra a fun\u00e7\u00e3o main , ponto de entrada do programa e de onde a fun\u00e7\u00e3o printf , importada de stdio.h , \u00e9 invocada. #include <stdio.h> int main () { printf ( \"Hello, World!\" ); return 0 ; } Al\u00e9m da linguagem C, outros exemplos \u00f3bvios deste paradigma s\u00e3o as linguagens Pascal, Fortran e Python. Contudo, mesmo linguagens como Java e C++ podem ser consideradas procedurais, uma vez que organizam a computa\u00e7\u00e3o em m\u00e9todos, que s\u00e3o nada mais que fun\u00e7\u00f5es. Mas como m\u00e9todos est\u00e3o fortemente associados a classes e suas inst\u00e2ncias, os objetos, estas linguagens s\u00e3o melhor classificadas como orientadas a objetos.","title":"Procedimental"},{"location":"intro/#orientado-a-objetos","text":"Na orienta\u00e7\u00e3o a objetos, o foco est\u00e1 n\u00e3o na execu\u00e7\u00e3o passo a passo de fun\u00e7\u00f5es, mas na organiza\u00e7\u00e3o de dados e fun\u00e7\u00f5es associadas em objetos. Embora esta organiza\u00e7\u00e3o possa ser feita em qualquer qualquer linguagem estruturada, a sintaxe das linguagens orientadas a objeto facilita e tornam mais natural este trabalho. Dois conceitos b\u00e1sicos na orienta\u00e7\u00e3o a objetos s\u00e3o as classes e os objetos . Classes s\u00e3o abstra\u00e7\u00f5es de tipos de coisas encontrados no mundo real, ou seja, receitas de estruturas de dados e definem quais os dados devem ser considerados em conjunto para representar um objeto e quais as a\u00e7\u00f5es associadas a este objeto. Por exemplo, se no mundo real cachorros tem uma data de nascimento e um nome, e s\u00e3o capazes de latir, uma classe que represente cachorros pode ser definida assim em Java. class Cachorro { int diaNascimento ; int mesNascimento ; int anoNascimento ; String nome ; void latir ( int quantidade ) { for ( int i = 0 ; i < quantidade ; i ++ ) System . out . println ( nome + \": Au!\" ); } } J\u00e1 um objeto \u00e9 uma inst\u00e2ncia de uma classe, uma representa\u00e7\u00e3o de um tipo mas de uma coisa em si. Um c\u00e3o qualquer poderia ser representado assim Cachorro cachorro1 = new Cachorro ( 25 , 12 , 2020 , \"Napole\u00e3o\" ); cachorro1 . latir ( 3 ); e a execu\u00e7\u00e3o deste c\u00f3digo resultaria em Napole\u00e3o: Au! Napole\u00e3o: Au! Napole\u00e3o: Au! Observe que o \".\" em cachorro1.latir(3) quer dizer \"executar a fun\u00e7\u00e3o latir no objeto cachorro1 \", o que leva \u00e0 string Napole\u00e3o a aparecer antes de cada latido. Duas coisas poder ser ditas sobre este \".\". Primeiro, que ele n\u00e3o \u00e9 necess\u00e1rio, o objeto em si poderia ser passado como par\u00e2metro para uma fun\u00e7\u00e3o latir que recebesse o objeto al\u00e9m da quantidade de latidos; de fato, em Python, a classe seria definida como a seguir class Cachorro : diaNascimento mesNascimento anoNascimento nome def latir ( self , quantidade ): for i in range ( 0 , quantidade ): print ( self . nome + \": Au!\" ) o que implica que o \".\" \u00e9 o s\u00f3 a\u00e7\u00facar sint\u00e1tico para a execu\u00e7\u00e3o de uma fun\u00e7\u00e3o, o que nos leva ao segundo ponto. Na orienta\u00e7\u00e3o a objetos conceitual, n\u00e3o se fala em invoca\u00e7\u00e3o de fun\u00e7\u00f5es mas de sinais sendo transmitidos entre objetos: envie mensagem para o 2 \"somar-se com 3\", ao que o objeto 2 responderia com uma mensagem \"refer\u00eancia ao objeto 4\". Em Smalltalk, esta intera\u00e7\u00e3o seria escrita assim: x := 2 + 3 . Grande parte do poder da orienta\u00e7\u00e3o objetos est\u00e1 no encapsulamento do como opera\u00e7\u00f5es s\u00e3o executadas, nos m\u00e9todos. Uma outra ordem de encapsulamento, de outro tipo, \u00e9 encontrada no paradigma l\u00f3gico.","title":"Orientado a Objetos"},{"location":"intro/#logico","text":"No paradigma l\u00f3gico, voc\u00ea declara-se fatos b\u00e1sicos e regras sobre como os fatos se relacionam e pergunta ao programa se certos fatos s\u00e3o ou n\u00e3o s\u00e3o verdade. Por exemplo, como fatos, podemos declarar eh_maior_que ( gato , rato ). eh_maior_que ( leao , gato ). eh_maior_que ( elefante , leao ). eh_maior_que ( elefante , moto ). eh_maior_que ( legal , cachorro ). que vale a transitividade eh_maior_que ( A , B ) :- eh_maior_que ( A , C ), eh_maior_que ( C , B ). e, finalmente, perguntar se elefante \u00e9 maior rato eh_maior_que ( elefante , rato ). ao que seremos respondidos com um \"sim\". Voc\u00ea consegue imaginar quantas linhas de c\u00f3digo voc\u00ea precisaria para expressar a mesma l\u00f3gica acima em uma linguagem como C ou Java? Apesar do claro poder deste paradigma, o mesmo tem poucos representantes, como Prolog e Mercury, e mesmo que exista v\u00e1rios compiladores do primeiro, o uso comercial do paradigma \u00e9 bem limitado.","title":"L\u00f3gico"},{"location":"intro/#funcional","text":"A programa\u00e7\u00e3o, como indicado pelo nome, \u00e9 focada na organiza\u00e7\u00e3o do processamento em termos de fun\u00e7\u00f5es, mas de uma forma diferente da programa\u00e7\u00e3o procedimental. De forma geral, fun\u00e7\u00f5es s\u00e3o blocos de c\u00f3digo criadas essencialmente para se obter reusabilidade : uma vez definidas, as fun\u00e7\u00f5es podem ser invocadas repetidas vezes para executar a mesma tarefa sobre diferentes par\u00e2metros , sempre retornando um resultado. 4 Mas enquanto na programa\u00e7\u00e3o procedimental a invoca\u00e7\u00e3o de uma fun\u00e7\u00e3o pode retornar diferentes resultados mesmo quando os par\u00e2metros s\u00e3o os mesmos, na programa\u00e7\u00e3o funcional, fun\u00e7\u00f5es s\u00e3o como na matem\u00e1tica, isto \u00e9, mapeiam uma entrada para exatamente uma sa\u00edda, sempre. Isto \u00e9, fun\u00e7\u00f5es resolvem o problema sem se basear em nada al\u00e9m dos par\u00e2metros passados e sem efeitos colaterais. Mas e as fun\u00e7\u00f5es que tem efeitos colaterais? Estas n\u00e3o s\u00e3o fun\u00e7\u00f5es \"de verdade\" e n\u00e3o \u00e9 a toa que outro nome usado para os blocos de c\u00f3digo \u00e9 procedimento e que para discernir entre fun\u00e7\u00f5es que tem efeitos colaterais e que n\u00e3o n\u00e3o, chamamos de puras as do segundo tipo. Vejamos alguns exemplos. As fun\u00e7\u00f5es seguintes, definidas em Erlang, calculam A+B , A*C e (A+B)*(A+B) e, independentemente de quantas vezes voc\u00ea o fizer, add(2,3) sempre retornar\u00e1 5 . add ( A , B ) -> A + B . mult ( A , B ) -> A * B . mult_add ( A , B ) -> mult ( add ( A , B ), add ( A , B )). Agora observe a fun\u00e7\u00e3o seguinte, escritas em Python; a cada invoca\u00e7\u00e3o, a vari\u00e1vel acc tem seu valor alterado e mesmo que invocada com a mesma entrada, o resultado da fun\u00e7\u00e3o \u00e9 sempre diferente. Os efeitos externos \u00e0 fun\u00e7\u00e3o, e.g., a altera\u00e7\u00e3o da vari\u00e1vel acc , \u00e9 conhecido efeito colateral . Programa\u00e7\u00e3o funcional n\u00e3o tem tem efeitos colaterais por que trata vari\u00e1veis n\u00e3o como \u00e1reas de mem\u00f3ria alter\u00e1veis, mas como inc\u00f3gnitas, como na matem\u00e1tica. Pelo menos esta \u00e9 a ideia de programa\u00e7\u00e3o funcional pura, que \u00e9 essencialmente a escrita de longu\u00edssimas equa\u00e7\u00f5es. Acontece que devido \u00e0 complexidade inerente do uso de programa\u00e7\u00e3o funcional pura, sem efeitos colaterais, i.e., sem muta\u00e7\u00e3o de estados, muitas linguagens n\u00e3o s\u00e3o puramente funcionais. A raz\u00e3o mais comum para efeitos colaterais \u00e9 a realiza\u00e7\u00e3o de Entrada/Sa\u00edda. Por exemplo, ao invocar print no Python, o terminal tem seu estado alterado, e cada nova invoca\u00e7\u00e3o altera mais o estado. Assim, podemos dividir as linguagens e funcionais puras, funcionais n\u00e3o puras e n\u00e3o funcionais, mas mesmo dentro das n\u00e3o funcionais, h\u00e1 aquelas com elementos de programa\u00e7\u00e3o funcional.","title":"Funcional"},{"location":"intro/#multi-paradigmas","text":"Muitas linguagens modernas podem ser classificadas ao mesmo tempo em muitos paradigmas, por exemplo, a linguagem Scala \u00e9 ao mesmo tempo funcional e orientada a objetos, sendo muito dif\u00edcil us\u00e1-la sem fazer uso desta caracter\u00edstica. object HelloWorld { def main ( args : Array [ String ]) : Unit = { println ( \"Hello, world!\" ) } }","title":"Multi-paradigmas"},{"location":"intro/#para-cada-servico-uma-ferramenta","text":"Em cada paradigma, encontramos vantagens e desvantagens. Como desenvolvedores de tecnologia, nada mais justo que voc\u00eas conhe\u00e7am todos os paradigmas e que possam, assim, escolher aquele paradigma e, dentro dele, aquela linguagem que permite resolver o seu problema da forma mais eficiente, isto \u00e9, rapidamente, com menor custo e com melhor qualidade. Mas quanto ao paradigma funciona, em especial, \u00e9 importante compreend\u00ea-lo pois muitas de suas funcionalidades tem sido incorporadas a outras linguagens, como compreens\u00e3o de listas em Python, fun\u00e7\u00f5es lambda em Java e C++, e processamento ass\u00edncrono pode ser visto como uma forma de avalia\u00e7\u00e3o pregui\u00e7osa em diversas linguagens. Vejamos estes outras pontos importantes do paradigma: Sem efeitos colaterais: executando um programa, de repente voc\u00ea percebe que uma certa vari\u00e1vel tem um valor estranho e fica se perguntando quem foi que atribuiu tal valor; efeitos colaterais s\u00e3o a origem de boa parte dos bugs e elimin\u00e1-los, ou ao menos reduz\u00ed-los, permite que voc\u00ea identifique rapidamente onde altera\u00e7\u00f5es poderiam ter acontecido. Camadas de abstra\u00e7\u00e3o: fun\u00e7\u00f5es podem ser compostas levando a programas verdadeiramente complexos, permitindo que abstra\u00e7\u00f5es sejam definidas em diversas camadas. Al\u00e9m disso, \u00e9 poss\u00edvel, em teoria, ser provar a corretude de fun\u00e7\u00f5es e, mesmo que na pr\u00e1tica isso n\u00e3o se realize, h\u00e1 ferramentas que conseguem usar esta ideia para lhe ajudar a encontrar bugs. Processamento paralelo eficiente: a aus\u00eancia de efeitos colaterais tamb\u00e9m implica que fun\u00e7\u00f5es sem depend\u00eancias podem ser executadas em paralelo, sem se preocupar com qualquer sincroniza\u00e7\u00e3o, isto \u00e9, sem mutexes e vari\u00e1veis de condi\u00e7\u00e3o, etc. Avalia\u00e7\u00e3o pregui\u00e7osa: fun\u00e7\u00f5es s\u00f3 precisam realmente ser executadas se seus resultados s\u00e3o necess\u00e1rios e o compilador consegue atrasar a execu\u00e7\u00e3o de fun\u00e7\u00f5es enquanto poss\u00edvel. Recurs\u00e3o de calda: alguns problemas podem ser descritos muito facilmente como uma recurs\u00e3o que com uma itera\u00e7\u00e3o, mas linguagens tradicionais tem um limite no tamanho das pilhas de fun\u00e7\u00e3o; linguagens funcionais conseguem, em certas condi\u00e7\u00f5es, usar recurs\u00e3o infinita, contornando esta limita\u00e7\u00e3o. Fun\u00e7\u00f5es de alta ordem: fun\u00e7\u00f5es podem receber outras fun\u00e7\u00f5es como par\u00e2metro e com isso podemos compor fun\u00e7\u00f5es, por exemplo para implementar orienta\u00e7\u00e3o a objetos.","title":"Para cada servi\u00e7o, uma ferramenta!"},{"location":"intro/#escolha-o-seu-veneno","text":"Como j\u00e1 ficou \u00f3bvio, h\u00e1 muitas, muitas linguagens de programa\u00e7\u00e3o por a\u00ed e \u00e9 poss\u00edvel escrever c\u00f3digo bom em cada um delas, assim como \u00e9 poss\u00edvel escrever c\u00f3digo ruim em cada uma delas. Tamb\u00e9m \u00e9 poss\u00edvel escrever usando orienta\u00e7\u00e3o a objetos ou funcionalmente em cada uma delas, mas embora seja poss\u00edvel , h\u00e1 aquelas linguagens que suportam melhor cada um dos paradigmas. Dentre estas, h\u00e1 diversas op\u00e7\u00f5es de linguagens que podemos usar para estudar o paradigma funcional, por exemplo: Scheme Lisp ML F# Erlang Elixir Haskell Clojure Neste curso, veremos princ\u00edpios gerais e que, em teoria, poderiam ser aplicados em qualquer destas linguagens. Contudo, como a sintaxe pode variar muito de uma linguagem para outra, precisaremos nos focar em uma \u00fanica linguagem, mesmo que, frequentemente, apresente exemplos em outras. Assim, nosso foco aqui ser\u00e1 em Haskell, uma linguagem funcional madura e est\u00e1vel.","title":"Escolha o seu veneno"},{"location":"intro/#recomendacoes","text":"Sobre a hist\u00f3ria das linguagens de programa\u00e7\u00e3o Sobre porqu\u00ea PF n\u00e3o \u00e9 mais comum Comunica\u00e7\u00e3o \u21a9 Linguagem de Programa\u00e7\u00e3o \u21a9 Programming Language Families \u21a9 void \u00e9 simplesmente um resultado que diz que o resultado n\u00e3o importa. \u21a9","title":"Recomenda\u00e7\u00f5es"},{"location":"io/","text":"Entrada e Sa\u00edda Hello, world!","title":"Entrada e Sa\u00edda"},{"location":"io/#entrada-e-saida","text":"Hello, world!","title":"Entrada e Sa\u00edda"},{"location":"lambda/","text":"C\u00e1lculo \\(\\lambda\\) O c\u00e1lculo \\(\\lambda\\) ( \\(\\lambda\\) -calculus) \u00e9 um sistema formal para express\u00e3o computa\u00e7\u00e3o desenvolvido pelo matem\u00e1tico Alonzo Church em 1930 e que serve de base para o paradigma de programa\u00e7\u00e3o funcional. O formalismo em si \u00e9 muito simples e consiste na descri\u00e7\u00e3o da computa\u00e7\u00e3o executada na forma de termos lambda, que podem dos seguintes tipos: constante: por exemplo, 4; 1 vari\u00e1vel: por exemplo, \\(x\\) ; abstra\u00e7\u00e3o: se \\(t\\) \u00e9 um termo \\(\\lambda\\) e \\(x\\) \u00e9 uma vari\u00e1vel, ent\u00e3o \\((\\lambda x.t)\\) \u00e9 uma abstra\u00e7\u00e3o, que define uma fun\u00e7\u00e3o onde \\(x\\) \u00e9 um par\u00e2metro a ser aplicado em \\(t\\) , por exemplo, a abstra\u00e7\u00e3o \\(\\lambda x.x*x\\) \u00e9 fun\u00e7\u00e3o \\(f(x) = x^2\\) ; aplica\u00e7\u00e3o: se \\(t\\) e \\(s\\) s\u00e3o termos, ent\u00e3o \\((ts)\\) \u00e9 uma aplica\u00e7\u00e3o, que representa a invoca\u00e7\u00e3o da fun\u00e7\u00e3o \\(t\\) com par\u00e2metro \\(s\\) , por exemplo, \\(((\\lambda x.x*x)3)\\) corresponde a invoca\u00e7\u00e3o de \\(f(3)\\) , onde \\(f(x) = x^2\\) . O c\u00e1lculo da computa\u00e7\u00e3o acontece pela aplica\u00e7\u00e3o sucessiva de certas regras de transforma\u00e7\u00e3o que reduzem (\"simplificam\") os termos at\u00e9 que um resultado seja obtido. As redu\u00e7\u00f5es \\(\\beta\\) s\u00e3o as mais importantes no contexto do nosso estudo, pois elas reduzem uma aplica\u00e7\u00f5es. Por exemplo, seja o termo lambda \\((\\lambda x.2 \\times x)5\\) ; a redu\u00e7\u00e3o \\(\\beta\\) reduz o termo pela termo resultante da substitui\u00e7\u00e3o de todas as ocorr\u00eancias de \\(x\\) por 5, que pode ser novamente substitu\u00eddo pela aplica\u00e7\u00e3o do operador \\(\\times\\) , isto \u00e9 \\[ \\begin{eqnarray} (\\lambda x.2 \\times x)5 &\\rightarrow_\\beta& 5 \\times 2 \\\\ &\\rightarrow& 10\\\\ \\end{eqnarray} \\] Algo muito importante na \\(\\beta\\) redu\u00e7\u00e3o \u00e9 que qualquer termo pode ser usado na substitui\u00e7\u00e3o de uma vari\u00e1vel, mesmo um termo que represente outra fun\u00e7\u00e3o, como na redu\u00e7\u00e3o seguinte. \\[ \\begin{eqnarray} (\\lambda f.f~5) (\\lambda x.x + 1) &\\rightarrow_\\beta& (\\lambda x.x + 1)5\\\\ &\\rightarrow_\\beta& 5 + 1\\\\ &\\rightarrow& 6\\\\ \\end{eqnarray} \\] Isso \u00e9 o que se denomina considerar fun\u00e7\u00f5es como cidad\u00e3os de primeira classe (do ingl\u00eas, first class citizens ), algo equivalente a dizer que fun\u00e7\u00f5es tamb\u00e9m tamb\u00e9m s\u00e3o dados. Em termos mais complexos, haver\u00e3o m\u00faltiplas possibilidades de redu\u00e7\u00e3o \\(\\beta\\) , como no exemplo seguinte, onde h\u00e1 duas possibilidades. Fa\u00e7amos primeiro a redu\u00e7\u00e3o da express\u00e3o mais interna. \\[ \\begin{eqnarray} (\\lambda x.\\lambda y.x + ((\\lambda x.x - 3) y)) 5~6 &\\rightarrow_\\beta& (\\lambda x.\\lambda y.x + (y - 3)) 5~6\\\\ &\\rightarrow_\\beta& (\\lambda y.5 + (y - 3)) 6 \\\\ &\\rightarrow_\\beta& 5 + (6 - 3) \\\\ &\\rightarrow& 5 + 3\\\\ &\\rightarrow& 8\\\\ \\end{eqnarray} \\] A outra possibilidade \u00e9 fazer a redu\u00e7\u00e3o primeiro da express\u00e3o mais externa, mas neste caso \u00e9 necess\u00e1rio observar que h\u00e1 dois \\(x\\) distintos no termo, e que somente um ser\u00e1 substitu\u00eddo por 5. \\[ \\begin{eqnarray} (\\lambda x.\\lambda y.x + ((\\lambda x.x - 3) y)) 5~6 &\\rightarrow_\\beta& (\\lambda y.5 + ((\\lambda x.x - 3) y))6 \\\\ &\\rightarrow_\\beta& 5 + ((\\lambda x.x - 3) 6) \\\\ &\\rightarrow_\\beta& 5 + (6 - 3) \\\\ &\\rightarrow& 5 + 3 \\\\ &\\rightarrow& 8 \\end{eqnarray} \\] Apesar da ordem de redu\u00e7\u00e3o diferente, o resultado deve ser obviamente o mesmo. Exerc\u00edcio Reduza o termo lambda \\(((\\lambda x.(\\lambda y. x + y)5) ((\\lambda y.y-3)7))\\) Resolu\u00e7\u00e3o 9 Rela\u00e7\u00e3o com Haskell \"Mas por qu\u00ea complicar tanto?\", voc\u00ea me pergunta; \"Haskell n\u00e3o \u00e9 complicado o suficiente para voc\u00ea?\" O objetivo n\u00e3o \u00e9 complicar, mas mostrar como o c\u00e1lculo \\(\\lambda\\) \u00e9 poderoso para representar computa\u00e7\u00f5es e, por conseguinte, como o Haskell tamb\u00e9m \u00e9. De fato, os conceitos discutidos at\u00e9 agora s\u00e3o a base das seguintes funcionalidades do Haskell. Fun\u00e7\u00f5es de alta ordem Fun\u00e7\u00f5es lambda (fun\u00e7\u00f5es an\u00f4nimas) Currying Avalia\u00e7\u00e3o pregui\u00e7osa Na verdade este n\u00e3o \u00e9 um termo lambda, mas uma simplifica\u00e7\u00e3o de como um termo lambda poderia ser usado para representar uma constante, n\u00e3o somente num\u00e9rica mas tamb\u00e9m, por exemplo, booleanos. A forma purista do c\u00e1lculo \\(\\lambda\\) seria muito complicada para este curso. \u21a9","title":"C\u00e1lculo \u03bb"},{"location":"lambda/#calculo-lambda","text":"O c\u00e1lculo \\(\\lambda\\) ( \\(\\lambda\\) -calculus) \u00e9 um sistema formal para express\u00e3o computa\u00e7\u00e3o desenvolvido pelo matem\u00e1tico Alonzo Church em 1930 e que serve de base para o paradigma de programa\u00e7\u00e3o funcional. O formalismo em si \u00e9 muito simples e consiste na descri\u00e7\u00e3o da computa\u00e7\u00e3o executada na forma de termos lambda, que podem dos seguintes tipos: constante: por exemplo, 4; 1 vari\u00e1vel: por exemplo, \\(x\\) ; abstra\u00e7\u00e3o: se \\(t\\) \u00e9 um termo \\(\\lambda\\) e \\(x\\) \u00e9 uma vari\u00e1vel, ent\u00e3o \\((\\lambda x.t)\\) \u00e9 uma abstra\u00e7\u00e3o, que define uma fun\u00e7\u00e3o onde \\(x\\) \u00e9 um par\u00e2metro a ser aplicado em \\(t\\) , por exemplo, a abstra\u00e7\u00e3o \\(\\lambda x.x*x\\) \u00e9 fun\u00e7\u00e3o \\(f(x) = x^2\\) ; aplica\u00e7\u00e3o: se \\(t\\) e \\(s\\) s\u00e3o termos, ent\u00e3o \\((ts)\\) \u00e9 uma aplica\u00e7\u00e3o, que representa a invoca\u00e7\u00e3o da fun\u00e7\u00e3o \\(t\\) com par\u00e2metro \\(s\\) , por exemplo, \\(((\\lambda x.x*x)3)\\) corresponde a invoca\u00e7\u00e3o de \\(f(3)\\) , onde \\(f(x) = x^2\\) . O c\u00e1lculo da computa\u00e7\u00e3o acontece pela aplica\u00e7\u00e3o sucessiva de certas regras de transforma\u00e7\u00e3o que reduzem (\"simplificam\") os termos at\u00e9 que um resultado seja obtido. As redu\u00e7\u00f5es \\(\\beta\\) s\u00e3o as mais importantes no contexto do nosso estudo, pois elas reduzem uma aplica\u00e7\u00f5es. Por exemplo, seja o termo lambda \\((\\lambda x.2 \\times x)5\\) ; a redu\u00e7\u00e3o \\(\\beta\\) reduz o termo pela termo resultante da substitui\u00e7\u00e3o de todas as ocorr\u00eancias de \\(x\\) por 5, que pode ser novamente substitu\u00eddo pela aplica\u00e7\u00e3o do operador \\(\\times\\) , isto \u00e9 \\[ \\begin{eqnarray} (\\lambda x.2 \\times x)5 &\\rightarrow_\\beta& 5 \\times 2 \\\\ &\\rightarrow& 10\\\\ \\end{eqnarray} \\] Algo muito importante na \\(\\beta\\) redu\u00e7\u00e3o \u00e9 que qualquer termo pode ser usado na substitui\u00e7\u00e3o de uma vari\u00e1vel, mesmo um termo que represente outra fun\u00e7\u00e3o, como na redu\u00e7\u00e3o seguinte. \\[ \\begin{eqnarray} (\\lambda f.f~5) (\\lambda x.x + 1) &\\rightarrow_\\beta& (\\lambda x.x + 1)5\\\\ &\\rightarrow_\\beta& 5 + 1\\\\ &\\rightarrow& 6\\\\ \\end{eqnarray} \\] Isso \u00e9 o que se denomina considerar fun\u00e7\u00f5es como cidad\u00e3os de primeira classe (do ingl\u00eas, first class citizens ), algo equivalente a dizer que fun\u00e7\u00f5es tamb\u00e9m tamb\u00e9m s\u00e3o dados. Em termos mais complexos, haver\u00e3o m\u00faltiplas possibilidades de redu\u00e7\u00e3o \\(\\beta\\) , como no exemplo seguinte, onde h\u00e1 duas possibilidades. Fa\u00e7amos primeiro a redu\u00e7\u00e3o da express\u00e3o mais interna. \\[ \\begin{eqnarray} (\\lambda x.\\lambda y.x + ((\\lambda x.x - 3) y)) 5~6 &\\rightarrow_\\beta& (\\lambda x.\\lambda y.x + (y - 3)) 5~6\\\\ &\\rightarrow_\\beta& (\\lambda y.5 + (y - 3)) 6 \\\\ &\\rightarrow_\\beta& 5 + (6 - 3) \\\\ &\\rightarrow& 5 + 3\\\\ &\\rightarrow& 8\\\\ \\end{eqnarray} \\] A outra possibilidade \u00e9 fazer a redu\u00e7\u00e3o primeiro da express\u00e3o mais externa, mas neste caso \u00e9 necess\u00e1rio observar que h\u00e1 dois \\(x\\) distintos no termo, e que somente um ser\u00e1 substitu\u00eddo por 5. \\[ \\begin{eqnarray} (\\lambda x.\\lambda y.x + ((\\lambda x.x - 3) y)) 5~6 &\\rightarrow_\\beta& (\\lambda y.5 + ((\\lambda x.x - 3) y))6 \\\\ &\\rightarrow_\\beta& 5 + ((\\lambda x.x - 3) 6) \\\\ &\\rightarrow_\\beta& 5 + (6 - 3) \\\\ &\\rightarrow& 5 + 3 \\\\ &\\rightarrow& 8 \\end{eqnarray} \\] Apesar da ordem de redu\u00e7\u00e3o diferente, o resultado deve ser obviamente o mesmo. Exerc\u00edcio Reduza o termo lambda \\(((\\lambda x.(\\lambda y. x + y)5) ((\\lambda y.y-3)7))\\) Resolu\u00e7\u00e3o 9","title":"C\u00e1lculo  \\(\\lambda\\)"},{"location":"lambda/#relacao-com-haskell","text":"\"Mas por qu\u00ea complicar tanto?\", voc\u00ea me pergunta; \"Haskell n\u00e3o \u00e9 complicado o suficiente para voc\u00ea?\" O objetivo n\u00e3o \u00e9 complicar, mas mostrar como o c\u00e1lculo \\(\\lambda\\) \u00e9 poderoso para representar computa\u00e7\u00f5es e, por conseguinte, como o Haskell tamb\u00e9m \u00e9. De fato, os conceitos discutidos at\u00e9 agora s\u00e3o a base das seguintes funcionalidades do Haskell. Fun\u00e7\u00f5es de alta ordem Fun\u00e7\u00f5es lambda (fun\u00e7\u00f5es an\u00f4nimas) Currying Avalia\u00e7\u00e3o pregui\u00e7osa Na verdade este n\u00e3o \u00e9 um termo lambda, mas uma simplifica\u00e7\u00e3o de como um termo lambda poderia ser usado para representar uma constante, n\u00e3o somente num\u00e9rica mas tamb\u00e9m, por exemplo, booleanos. A forma purista do c\u00e1lculo \\(\\lambda\\) seria muito complicada para este curso. \u21a9","title":"Rela\u00e7\u00e3o com Haskell"},{"location":"lazy/","text":"Avalia\u00e7\u00e3o Pregui\u00e7osa Considere o seguinte c\u00f3digo novamente. imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" where imc' = p / a ^ 2 O uso de where na defini\u00e7\u00e3o, al\u00e9m de melhorar a legibilidade do c\u00f3digo, d\u00e1 ao compilador Haskell a oportunidade de usar uma de suas mais importantes funcionalidades, a avalia\u00e7\u00e3o pregui\u00e7osa . Quando a fun\u00e7\u00e3o imc \u00e9 invocada, imc' n\u00e3o \u00e9 calculada at\u00e9 que a primeira guarda seja testada. Isso acontece porqu\u00ea pela avalia\u00e7\u00e3o pregui\u00e7osa do Haskell, a avalia\u00e7\u00e3o acontece apenas quando necess\u00e1ria . Para demonstrar esta funcionalidade, vamos usar a fun\u00e7\u00e3o trace , que imprime uma mensagem na tela a cada computa\u00e7\u00e3o de imc' import Debug.Trace ( trace ) imc :: Double -> Double -> String imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" | otherwise = \"Muito, muito alto\" where imc' = trace \"hmmm... \" ( p / a ^ 2 ) Agora atribu\u00edmos uma invoca\u00e7\u00e3o da fun\u00e7\u00e3o a y e verificamos que somente quando tentamos ver o valor de de y \u00e9 que o c\u00e1lculo \u00e9 realmente feito. * Main > y = imc 90 1.8 * Main > y \"hmmm... Alto\" Al\u00e9m disso, a avalia\u00e7\u00e3o acontece no m\u00e1ximo uma vez , o que quer dizer que se a primeira guarda falha e a segunda deve ser testada, imc' n\u00e3o \u00e9 recomputada, pois o Haskell se lembra do valor j\u00e1 calculado para os mesmos par\u00e2metros. import Debug.Trace ( trace ) imc :: Double -> Double -> String imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" | otherwise = \"Muito, muito alto\" where imc' = trace \"hmmm... \" ( p / a ^ 2 ) Na pr\u00f3xima execu\u00e7\u00e3o, mesmo o resultado tendo sido gerado pela terceira guarda, veja que imc' s\u00f3 foi executado uma vez. * Main > imc 90 1.8 \"hmmm... Alto\" Outro princ\u00edpio da avalia\u00e7\u00e3o pregui\u00e7osa \u00e9 que se deve avaliar somente o necess\u00e1rio . Observe a pr\u00f3xima defini\u00e7\u00e3o, onde m\u00faltiplos where s\u00e3o usados (onde todas as defini\u00e7\u00f5es est\u00e3o perfeitamente indentadas.) imc p a | imc' <= baixo = \"Baixo\" | imc' <= normal = \"Normal\" | imc' <= alto = \"Alto\" where imc' = trace \"hmmm... \" ( p / a ^ 2 ) baixo = trace \"b\" ( 18.5 ) normal = trace \"n\" ( 25.0 ) alto = trace \"a\" ( 30.0 ) Dependendo da chamada, os valores de normal e alto nunca ser\u00e3o avaliados. * Main > imc 90 1.8 \"hmmm... b n a Alto\" * Main > imc 70 1.8 \"hmmm... b n Normal\" Pr\u00f3s A avalia\u00e7\u00e3o pregui\u00e7osa \u00e9 imprescind\u00edvel para algumas funcionalidades do Haskell, como a capacidade de expressar uma lista infinita no pr\u00f3ximo trecho de c\u00f3digo. Se a lista tivesse que ser constru\u00edda antes de se poder acessar seu in\u00edcio, as chamadas nunca terminariam. * Main > x = [ 1 , 3 .. ] * Main > take 2 x [ 1 , 3 ] * Main > take 4 x [ 1 , 3 , 5 , 7 ] * Main > take 20 x [ 1 , 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 , 19 , 21 , 23 , 25 , 27 , 29 , 31 , 33 , 35 , 37 , 39 ] Mesmo quando as chamadas terminal, pode ser que o tempo de execu\u00e7\u00e3o seja alto demais. Por exemplo, considere a lista dos elementos da s\u00e9rie de Fibonacci geradas por uma defini\u00e7\u00e3o recursiva. fibWhere 0 = 0 fibWhere 1 = 1 fibWhere n = prev + prevPrev where prev = fibWhere ( n - 1 ) prevPrev = fibWhere ( n - 2 ) Se voc\u00ea invocar esta fun\u00e7\u00e3o para calcular fib 5 , ter\u00e1 uma resposta rapidamente. Se tentar com 20 ou 30, ter\u00e1 que esperar um pouco. Mas se tentar com fib 300 , ter\u00e1 que esperar por muito tempo at\u00e9 que veja algum progresso. Ainda assim, a seguinte chamada termina quase que imediatamente! * Main > length [ fib n | n <- [ 1 .. 300 ]] 300 * Main > x = [ fib n | n <- [ 1 .. 300 ]] * Main > take 1 x [ 1 ] * Main > take 3 x [ 1 , 1 , 2 ] Isso acontece pois para se saber o comprimento da lista n\u00e3o \u00e9 necess\u00e1rio conhecer o valor dos elementos, apenas como s\u00e3o definidos. O Haskell ent\u00e3o gera uma lista de \"invoca\u00e7\u00f5es\" da fun\u00e7\u00e3o fib , mas n\u00e3o chega a executar as invoca\u00e7\u00f5es enquanto precisar. Contras Como uma moeda sempre tem duas faces, vejamos o lado ruim da avalia\u00e7\u00e3o pregui\u00e7osa. Em vez de uma fun\u00e7\u00e3o custosa como a Fibonacci recursiva, se construirmos uma lista de somat\u00f3rios de \\(2i + 2*+1, 0\\leq 1 \\leq 100\\) , ou seja, 0+1, 2+3, 4+5,... * Main > x = [ 2 * i + 2 * i + 1 | i <- [ 0 .. 100 ]] * Main > take 3 x [ 1 , 5 , 9 ] * Main > take 5 x [ 1 , 5 , 9 , 13 , 17 ] * Main > last x 401 * Main > length x 101 Sem a avalia\u00e7\u00e3o pregui\u00e7osa, ter\u00edamos uma lista de 100 inteiros, sendo o maior 401, que cabe facilmente em um array de bytes. Contudo, com a avalia\u00e7\u00e3o pregui\u00e7osa, temos uma lista de express\u00f5es que indicam duas multiplica\u00e7\u00f5es e duas somas, certamente mais espa\u00e7osas que a alternativa anterior. A principal consequ\u00eancia disto \u00e9 que, embora leve \u00e0 economia de computa\u00e7\u00e3o, \u00e0s vezes a avalia\u00e7\u00e3o pregui\u00e7osa leva ao uso exagerado de espa\u00e7o. Al\u00e9m disso, computa\u00e7\u00f5es pesadas invocadas em um per\u00edodo de pouca atividade no sistema podem ser executadas mais tarde, quando o sistema est\u00e1 sobrecarregado, aumentando a variabilidade do tempo de execu\u00e7\u00e3o e dificultando a previs\u00e3o de t\u00e9rmino da computa\u00e7\u00e3o. Como funciona A computa\u00e7\u00e3o de uma fun\u00e7\u00e3o em Haskell pode ser entendida em termos da reescrita de express\u00f5es, da ordem de reescrita e do compartilhamento de resultados pr\u00e9vios. \u00c9 tamb\u00e9m baseado nestes mecanismos que a avalia\u00e7\u00e3o pregui\u00e7osa se torna poss\u00edvel. Reescrita H\u00e1 diferentes tipos de reescrita em Haskell. O tipo mais simples \u00e9 a redu\u00e7\u00e3o em que uma express\u00e3o \u00e9 substitu\u00edda por outra, equivalente, mas mais simples. Por exemplo, a express\u00e3o 2 + 2 pode ser reescrita como #hs 4 . Outra forma de reescrita \u00e9 o desdobramento ( unfolding ), em que o lado esquerdo de uma equa\u00e7\u00e3o \u00e9 substitu\u00eddo pelo lado direito. Por exemplo, quando invocamos 1 + head [ 1 , 2 , 3 ] , Haskell tenta achar uma defini\u00e7\u00e3o da fun\u00e7\u00e3o head que case com a invoca\u00e7\u00e3o. Suponha que exista uma defini\u00e7\u00e3o head ( x : _ ) = x ; neste caso, head ( x : _ ) = x \u00e9 reescrito como 1 e head [ 1 , 2 , 3 ] \u00e9 reescrito como 1, levando a express\u00e3o inicial a ser reduzida a 1 + 1 , onde uma redu\u00e7\u00e3o \u00e9 aplicada, levando a 2 . Ordem de reescrita Uma vez entendido que express\u00f5es podem ser reescritas, surge a d\u00favida do que substituir primeiro, quando houver m\u00faltiplas op\u00e7\u00f5es. Por exemplo, se temos a seguinte invoca\u00e7\u00e3o head (( 1 + 1 ) : ( 2 + 2 ) :[] ) ent\u00e3o podemos reduzir 1 + 1 para 1, ou 2 + 2 para 4, ou head (( 1 + 1 ) : ( 2 + 2 ) :[] ) para ( 1 + 1 ) . Haskell escolhe sempre a redu\u00e7\u00e3o mais \"externa\" ( outermost reduction ou avalia\u00e7\u00e3o call-by-name ), no caso, a terceira op\u00e7\u00e3o acima. Isso faz com que 2 + 2 nunca seja reduzido, economizando recursos. Esta abordagem n\u00e3o \u00e9 muito comum, nem mesmo entre outras linguagens funcionais, que usam uma avalia\u00e7\u00e3o gulosa ( call-by-value ou eager ). Compartilhamento Outro aspecto importante no processo de redu\u00e7\u00e3o \u00e9 o fato de que Haskell identifica express\u00f5es repetidas e compartilha o resultado da avalia\u00e7\u00e3o de uma inst\u00e2ncia com as outras. Por exemplo, a seguinte express\u00e3o aparece no seu c\u00f3digo, ( head x ) : ( head y ) : ( head x ) : [] , ent\u00e3o Haskell sabe que as duas apari\u00e7\u00f5es de head x levar\u00e3o ao mesmo valor, gra\u00e7as \u00e0 aus\u00eancia de efeitos colaterais. As express\u00f5es s\u00e3o substitu\u00eddas por uma refer\u00eancia para a express\u00e3o, que uma vez resolvida, \u00e9 substitu\u00edda na express\u00e3o original. A avalia\u00e7\u00e3o pregui\u00e7osa pode ser entendida como a combina\u00e7\u00e3o da reescrita do tipo call-by-name com o compartilhamento, sendo tamb\u00e9m conhecida como call-by-need .","title":"Que pregui\u00e7a"},{"location":"lazy/#avaliacao-preguicosa","text":"Considere o seguinte c\u00f3digo novamente. imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" where imc' = p / a ^ 2 O uso de where na defini\u00e7\u00e3o, al\u00e9m de melhorar a legibilidade do c\u00f3digo, d\u00e1 ao compilador Haskell a oportunidade de usar uma de suas mais importantes funcionalidades, a avalia\u00e7\u00e3o pregui\u00e7osa . Quando a fun\u00e7\u00e3o imc \u00e9 invocada, imc' n\u00e3o \u00e9 calculada at\u00e9 que a primeira guarda seja testada. Isso acontece porqu\u00ea pela avalia\u00e7\u00e3o pregui\u00e7osa do Haskell, a avalia\u00e7\u00e3o acontece apenas quando necess\u00e1ria . Para demonstrar esta funcionalidade, vamos usar a fun\u00e7\u00e3o trace , que imprime uma mensagem na tela a cada computa\u00e7\u00e3o de imc' import Debug.Trace ( trace ) imc :: Double -> Double -> String imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" | otherwise = \"Muito, muito alto\" where imc' = trace \"hmmm... \" ( p / a ^ 2 ) Agora atribu\u00edmos uma invoca\u00e7\u00e3o da fun\u00e7\u00e3o a y e verificamos que somente quando tentamos ver o valor de de y \u00e9 que o c\u00e1lculo \u00e9 realmente feito. * Main > y = imc 90 1.8 * Main > y \"hmmm... Alto\" Al\u00e9m disso, a avalia\u00e7\u00e3o acontece no m\u00e1ximo uma vez , o que quer dizer que se a primeira guarda falha e a segunda deve ser testada, imc' n\u00e3o \u00e9 recomputada, pois o Haskell se lembra do valor j\u00e1 calculado para os mesmos par\u00e2metros. import Debug.Trace ( trace ) imc :: Double -> Double -> String imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" | otherwise = \"Muito, muito alto\" where imc' = trace \"hmmm... \" ( p / a ^ 2 ) Na pr\u00f3xima execu\u00e7\u00e3o, mesmo o resultado tendo sido gerado pela terceira guarda, veja que imc' s\u00f3 foi executado uma vez. * Main > imc 90 1.8 \"hmmm... Alto\" Outro princ\u00edpio da avalia\u00e7\u00e3o pregui\u00e7osa \u00e9 que se deve avaliar somente o necess\u00e1rio . Observe a pr\u00f3xima defini\u00e7\u00e3o, onde m\u00faltiplos where s\u00e3o usados (onde todas as defini\u00e7\u00f5es est\u00e3o perfeitamente indentadas.) imc p a | imc' <= baixo = \"Baixo\" | imc' <= normal = \"Normal\" | imc' <= alto = \"Alto\" where imc' = trace \"hmmm... \" ( p / a ^ 2 ) baixo = trace \"b\" ( 18.5 ) normal = trace \"n\" ( 25.0 ) alto = trace \"a\" ( 30.0 ) Dependendo da chamada, os valores de normal e alto nunca ser\u00e3o avaliados. * Main > imc 90 1.8 \"hmmm... b n a Alto\" * Main > imc 70 1.8 \"hmmm... b n Normal\"","title":"Avalia\u00e7\u00e3o Pregui\u00e7osa"},{"location":"lazy/#como-funciona","text":"A computa\u00e7\u00e3o de uma fun\u00e7\u00e3o em Haskell pode ser entendida em termos da reescrita de express\u00f5es, da ordem de reescrita e do compartilhamento de resultados pr\u00e9vios. \u00c9 tamb\u00e9m baseado nestes mecanismos que a avalia\u00e7\u00e3o pregui\u00e7osa se torna poss\u00edvel.","title":"Como funciona"},{"location":"lazy/#reescrita","text":"H\u00e1 diferentes tipos de reescrita em Haskell. O tipo mais simples \u00e9 a redu\u00e7\u00e3o em que uma express\u00e3o \u00e9 substitu\u00edda por outra, equivalente, mas mais simples. Por exemplo, a express\u00e3o 2 + 2 pode ser reescrita como #hs 4 . Outra forma de reescrita \u00e9 o desdobramento ( unfolding ), em que o lado esquerdo de uma equa\u00e7\u00e3o \u00e9 substitu\u00eddo pelo lado direito. Por exemplo, quando invocamos 1 + head [ 1 , 2 , 3 ] , Haskell tenta achar uma defini\u00e7\u00e3o da fun\u00e7\u00e3o head que case com a invoca\u00e7\u00e3o. Suponha que exista uma defini\u00e7\u00e3o head ( x : _ ) = x ; neste caso, head ( x : _ ) = x \u00e9 reescrito como 1 e head [ 1 , 2 , 3 ] \u00e9 reescrito como 1, levando a express\u00e3o inicial a ser reduzida a 1 + 1 , onde uma redu\u00e7\u00e3o \u00e9 aplicada, levando a 2 .","title":"Reescrita"},{"location":"lazy/#ordem-de-reescrita","text":"Uma vez entendido que express\u00f5es podem ser reescritas, surge a d\u00favida do que substituir primeiro, quando houver m\u00faltiplas op\u00e7\u00f5es. Por exemplo, se temos a seguinte invoca\u00e7\u00e3o head (( 1 + 1 ) : ( 2 + 2 ) :[] ) ent\u00e3o podemos reduzir 1 + 1 para 1, ou 2 + 2 para 4, ou head (( 1 + 1 ) : ( 2 + 2 ) :[] ) para ( 1 + 1 ) . Haskell escolhe sempre a redu\u00e7\u00e3o mais \"externa\" ( outermost reduction ou avalia\u00e7\u00e3o call-by-name ), no caso, a terceira op\u00e7\u00e3o acima. Isso faz com que 2 + 2 nunca seja reduzido, economizando recursos. Esta abordagem n\u00e3o \u00e9 muito comum, nem mesmo entre outras linguagens funcionais, que usam uma avalia\u00e7\u00e3o gulosa ( call-by-value ou eager ).","title":"Ordem de reescrita"},{"location":"lazy/#compartilhamento","text":"Outro aspecto importante no processo de redu\u00e7\u00e3o \u00e9 o fato de que Haskell identifica express\u00f5es repetidas e compartilha o resultado da avalia\u00e7\u00e3o de uma inst\u00e2ncia com as outras. Por exemplo, a seguinte express\u00e3o aparece no seu c\u00f3digo, ( head x ) : ( head y ) : ( head x ) : [] , ent\u00e3o Haskell sabe que as duas apari\u00e7\u00f5es de head x levar\u00e3o ao mesmo valor, gra\u00e7as \u00e0 aus\u00eancia de efeitos colaterais. As express\u00f5es s\u00e3o substitu\u00eddas por uma refer\u00eancia para a express\u00e3o, que uma vez resolvida, \u00e9 substitu\u00edda na express\u00e3o original. A avalia\u00e7\u00e3o pregui\u00e7osa pode ser entendida como a combina\u00e7\u00e3o da reescrita do tipo call-by-name com o compartilhamento, sendo tamb\u00e9m conhecida como call-by-need .","title":"Compartilhamento"},{"location":"lists/","text":"Listas Vamos agora estudar listas, pe\u00e7as fundamentais no desenvolvimento de programas usando o paradigma funcional, por serem estruturas de dados que permitem agregar v\u00e1rias informa\u00e7\u00f5es na forma de uma cole\u00e7\u00e3o ordenada de elementos. Por exemplo, [ \"Eu\" , \"amo\" , \"programa\u00e7\u00e3o\" , \"funcional\" ] \u00e9 a cole\u00e7\u00e3o de quatro strings em que o primeiro elemento \u00e9 \"Eu\" , o segundo \"amo\" , o terceiro \"programa\u00e7\u00e3o\" e o quarto e \u00faltimo \"funcional\" . J\u00e1 [ 1 :: Int , 2 :: Int , 3 :: Int ] \u00e9 uma lista de 3 elementos do tipo Int , onde o primeiro elemento \u00e9 1, o segundo 2, e o terceiro 3. \"Mas e as tuplas?\", voc\u00ea pergunta, \"N\u00e3o s\u00e3o exatamente isto?\" Listas x Tuplas Listas tem duas particularidades que as diferenciam de tuplas. Primeiro, enquanto as tuplas ( 1 :: Int , 2 :: Int , 3 :: Int ) e ( 1 :: Int , 2 :: Int , 3 :: Int , 4 :: Int ) tem tipos diferentes, isto \u00e9, uma \u00e9 uma tupla de tr\u00eas inteiros e a outra uma tupla de quatro inteiros, as listas [ 1 :: Int , 2 :: Int , 3 :: Int ] e [ 1 :: Int , 2 :: Int , 3 :: Int , 4 :: Int ] tem exatamente o mesmo tipo, lista de inteiros, ou mais especificamente, [ Int ] . Ou seja, listas com cardinalidades diferentes, mas com elementos do mesmo tipo, s\u00e3o do mesmo tipo. Ali\u00e1s, outra forma de escrever estas listas, enquanto especificando seus tipos, \u00e9 [ 1 , 2 , 3 ] :: [ Int ] e [ 1 , 2 , 3 , 4 ] :: [ Int ] . Segundo, enquanto uma tupla pode ter elementos de tipos diferentes, todos os elementos de uma lista devem ser do mesmo tipo. Ou seja, enquanto \u00e9 poss\u00edvel definir x = ( \"Joao\" , 14 , True ) , n\u00e3o \u00e9 poss\u00edvel definir x = [ \"Joao\" , 14 , True ] . \u00c9 preciso observar contudo que \u00e9 poss\u00edvel construir uma lista [ 1 , 2 , 3 , 4 , 17 , 4.2 ] , mas mas isto s\u00f3 \u00e9 poss\u00edvel porqu\u00ea existe um tipo do qual todos os elementos da lista s\u00e3o derivados, no caso, Fractional . De fato, quando defino este lista, Haskell automaticamente faz o boxing dos cinco primeiros valores para ponto flutuante. * Main > z = [ 1 , 2 , 3 , 4 , 17 , 4.2 ] * Main > z [ 1.0 , 2.0 , 3.0 , 4.0 , 17.0 , 4.2 ] * Main > : t z z :: Fractional a => [ a ] J\u00e1 a tupla ( 1 , 2 , 3 , 4 , 17 , 4.2 ) tem elementos com tipos diferentes. 1 Prelude > : t t t :: ( Num , Num , Num , Num , Num , Fractional ) Uma vez diferenciadas das tuplas, estamos livres para explorar outros aspectos das listas, iniciando por como s\u00e3o constru\u00eddas. Estrutura Dado uma lista qualquer, de qualquer tipo, ela pode ser ou vazia ou n\u00e3o vazia, sendo que a lista vazia \u00e9 representada em Haskell por [] . Listas n\u00e3o vazias s\u00e3o representadas como a concatena\u00e7\u00e3o do primeiro elemento da lista com uma lista com os demais elementos, usando o operador de concatena\u00e7\u00e3o : , ou cons . Por exemplo, a lista dos n\u00fameros 1, 2 e 3 nesta ordem \u00e9 constru\u00edda como 1 : 2 : 3 :[] ; observe que como o 3 \u00e9 o \u00faltimo elemento da lista, a lista que vem depois do cons, com os demais elementos, \u00e9 a lista vazia. Prelude > x = 1 : 2 : 3 :[] Prelude > x [ 1 , 2 , 3 ] Cabe\u00e7a e Cauda Esta divis\u00e3o de uma lista entre primeiro elemento e restante \u00e9 o que chamamos de cabe\u00e7a ( head ) e cauda ( tail ) da lista. No exemplo anterior, 1 : 2 : 3 :[] , 1 \u00e9 a cabe\u00e7a e 2 : 3 :[] a cauda. Haskell inclusive define fun\u00e7\u00f5es para recuperar estas partes de uma lista qualquer. Prelude > head x 1 Prelude > tail x [ 2 , 3 ] A cabe\u00e7a de uma lista de elementos de um tipo \\(a\\) qualquer \u00e9 um elemento do tipo \\(a\\) . J\u00e1 a cauda desta lista \u00e9 tamb\u00e9m uma lista de elementos do tipo \\(a\\) . Logo, podemos subdivid\u00ed-la tamb\u00e9m em uma cabe\u00e7a e uma cauda, no exemplo, 2 e 3 :[] . Prelude > head ( tail x ) 2 Prelude > tail ( tail x ) [ 3 ] Podemos aplicar head e tail mais uma vez na lista, obtendo 3 e [] como resultado. Prelude > head ( tail ( tail x )) 3 Prelude > tail ( tail ( tail x )) [] Mas e se formos al\u00e9m? Neste caso estar\u00edamos tentando identificar o primeiro elemento da lista, mas sendo a lista vazia, isto n\u00e3o \u00e9 poss\u00edvel. Tampouco podemos extrair a lista ap\u00f3s a cabe\u00e7a. Prelude > head [] *** Exception: Prelude . head : empty list Prelude > tail [] *** Exception: Prelude . tail : empty list Logo, qualquer itera\u00e7\u00e3o nos elementos de uma lista, geralmente especificada por uma recurs\u00e3o que extrai a cabe\u00e7a da lista a cada passo, precisa tomar cuidado para n\u00e3o tentar extrair a cabe\u00e7a da lista vazia, como veremos na sess\u00e3o sobre recurs\u00e3o aplicada a listas. Um pouco de a\u00e7\u00facar sint\u00e1tico A especifica\u00e7\u00e3o manual de uma lista usando o operador cons n\u00e3o \u00e9 muito utilizada na pr\u00e1tica, sendo a especifica\u00e7\u00e3o usando colchetes e v\u00edrgulas mais comum, como feito nos primeiros exemplos deste cap\u00edtulo, e \u00e9 inclusive como o pr\u00f3prio Haskell exibe as listas. O efeito final \u00e9 o mesmo, ficando para voc\u00ea a decis\u00e3o qual constru\u00e7\u00e3o usar. 1 :[] \u00e9 igual a [ 1 ] 2 : 1 :[] \u00e9 igual a [ 2 , 1 ] As duas nota\u00e7\u00f5es podem at\u00e9 ser misturadas, como em 1 : 2 : [ 3 , 4 , 5 ] , que \u00e9 equivalente [ 1 , 2 , 3 , 4 , 5 ] . Strings Se o a\u00e7\u00facar sint\u00e1tico dos colchetes n\u00e3o representa economia em termos de digita\u00e7\u00e3o de listas em geral, quando falamos em listas de caracteres a economia \u00e9 clara e o resultado muito mais agrad\u00e1vel. Isto por que para listas de caracteres, como [ 'a' , 'b' , 'c' ] , podemos escrever simplesmente \"abc\" , com exatamente o mesmo efeito, e at\u00e9 misturar com o uso de cons. Prelude > \"abc\" \"abc\" Prelude > [ 'a' , 'b' , 'c' ] \"abc\" Prelude > 'a' : [ 'b' , 'c' ] \"abc\" Prelude > 'a' : \"bc\" \"abc\" [qualquer coisa] Uma lista pode conter elementos de qualquer tipo, desde que todos os elementos sejam do mesmo tipo. Logo, uma lista pode conter tipos primitivos, mas tamb\u00e9m tipos complexos, como tuplas e outras listas. Vejamos alguns exemplos: [ 1 , 2 , 3 ] :: [ Int ] - Lista de inteiros. [[ 1 , 2 , 3 ]] :: [[ Int ]] - Lista de listas de inteiros de inteiros. [[ 1 , 2 , 3 ], [] ,[ 3 , 4 , 5 , 6 , 7 , 8 , 9 ]] :: [[ Int ]] - Lista de listas de inteiros de inteiros. [( 1 , 2 , 3 ),( 3 , 4 , 5 )] :: [( Int , Int , Int )] - Lista de triplas de inteiros. ( \"lala\" ,[ 'l' , 'a' ], 'l' : '\u00e3' : 'o' :[] ) - Tripla de listas de Char. [ \"lala\" ,[ 'l' , 'a' ], 'l' : '\u00e3' : 'o' :[] ] - Lista de listas de Char. [ True , False , True ] :: [ Bool ] - Lista de booleanos. [( 4 , Ouro ),( 5 , Paus )] :: [ Carta ] - Lista de cartas. [( 1 , 2 , 3 ),( 3 )] - Um bug Fun\u00e7\u00f5es \u00fateis Em uma se\u00e7\u00e3o anterior, apresentamos algumas fun\u00e7\u00f5es como \u00fateis na manipula\u00e7\u00e3o de String. Na verdade, todas aquelas fun\u00e7\u00f5es s\u00e3o definidas em termos de listas e, por isso, as revisitaremos aqui juntamente com mais algumas. Operador Opera\u00e7\u00e3o Exemplo ++ Concatena\u00e7\u00e3o de listas > \"foo\" ++ \"bar\" \"foobar\" !! Elemento no \u00edndice > [ 1 , 2 , 3 , 4 ] !! 2 3 reverse Lista ao contr\u00e1rio > reverse [ 1 , 2 , 3 , 4 ] [4,3,2,1] length Comprimento da string > length \"foo bar\" 7 last \u00daltimo elemento da lista > last \"foo bar\" r concat Retorna a concatena\u00e7\u00e3o das listas dentro de uma lista > concat [[ 1 , 2 , 3 , 4 ],[ 5 , 6 , 7 , 8 ]] [1,2,3,4,5,6,7,8] > concat [[[ 1 , 2 , 3 ]],[[ 4 , 5 , 6 ]]] [[ 1 , 2 , 3 ],[ 4 , 5 , 6 ]] elem Verifica se o par\u00e2metro \u00e9 um elemento da lista > elem 'o' \"foo bar\" True null Verifica se a lista \u00e9 vazia > null \"\" True > null [] True > null [ 1 , 2 ] False replicate Constr\u00f3i uma lista pela replica\u00e7\u00e3o de um elemento > replicate 4 ( 1 , 2 ) [( 1 , 2 ),( 1 , 2 ),( 1 , 2 ),( 1 , 2 )] take Sublista iniciando em 0 > take 3 1 : 2 : 3 : 4 : 5 :[] [ 1 , 2 , 3 ] drop Sublista come\u00e7ando em um \u00edndice > drop 3 [ 'f' , 'o' , 'o' , ' ' , 'b' , 'a' , 'r' ] \" bar\" takeWhile Sublista iniciando em 0 e at\u00e9 o primeiro elemento que n\u00e3o satisfaz ao crit\u00e9rio, exclusive > takeWhile ( < 4 ) [ 1 , 2 , 3 , 4 , 5 , 6 ] [ 1 , 2 , 3 ] dropWhile Sublista come\u00e7ando no primeiro elemento que n\u00e3o satisfaz ao crit\u00e9rio, inclusive > dropWhile ( < 4 ) [ 1 , 2 , 3 , 4 , 5 , 6 ] 4 , 5 , 6 splitAt Dupla das sublistas geradas pela divis\u00e3o no \u00edndice especificado > splitAt 3 [ 1 , 2 , 3 , 4 , 5 , 6 ] ([ 1 , 2 , 3 ],[ 4 , 5 , 6 ]) zip Lista de pares com os elementos das duas listas passadas como par\u00e2metro > zip [ 1 , 2 , 3 ] [ 4 , 5 , 6 ] [( 1 , 4 ),( 2 , 5 ),( 3 , 6 )] sum Somat\u00f3rio dos elementos da lista > sum [ 1 , 2 , 3 , 4 , 5 , 6 ] 16 product Produt\u00f3rio dos elementos da lista > product [ 1 , 2 , 3 , 4 , 5 , 6 ] 720 maximum Maior dos elemento lista > maximum [ 1 , 2 , 3 , 4 , 5 , 6 ] 6 minimum Menor dos elementos da lista > minimum [ 1 , 2 , 3 , 4 , 5 , 6 ] 1 Enumera\u00e7\u00e3o Para facilitar a vida dos desenvolvedores, Haskell permite a constru\u00e7\u00e3o de listas por enumera\u00e7\u00e3o, bastando para isso o especificar o primeiro elemento da lista, opcionalmente o segundo, e o \u00faltimo elemento. Por exemplo Prelude > [ 11 , 13 .. 23 ] [ 11 , 13 , 15 , 17 , 19 , 21 , 23 ] Prelude > [ - 15 , - 13 .. 14 ] [ - 15 , - 13 , - 11 , - 9 , - 7 , - 5 , - 3 , - 1 , 1 , 3 , 5 , 7 , 9 , 11 , 13 ] Observe que Haskell determinou um passo de incremento igual a \\(13-11 = 2\\) no primeiro exemplo e \\(-15 - -13 = 2\\) no segundo exemplo, e usou estes passos para gerar as lista. Tamb\u00e9m \u00e9 poss\u00edvel definir um passo negativo, como no pr\u00f3ximo exemplo. Prelude > [ 11 , 9 .. 0 ] [ 11 , 9 , 7 , 5 , 3 , 1 ] Como mencionado, o segundo elemento \u00e9 opcional na enumera\u00e7\u00e3o e caso n\u00e3o especificado, Haskell assume que seja \\(1\\) , como no exemplo a seguir. Prelude > [ 11 .. 23 ] [ 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 ] Prelude > [ 3.5 .. 10 ] [ 3.5 , 4.5 , 5.5 , 6.5 , 7.5 , 8.5 , 9.5 , 10.5 ] Contudo, n\u00e3o \u00e9 poss\u00edvel omitir o segundo elemento se a inten\u00e7\u00e3o for gerar uma lista com valores decrescentes. Prelude > [ 11 .. 0 ] [] A enumera\u00e7\u00e3o pode ser feita para outros tipos que n\u00e3o sejam num\u00e9ricos, bastando que exista uma rela\u00e7\u00e3o de ordem entre os elementos para que Haskell consiga \"incrementar\" a cada passo. Isso existe, por exemplo, entre os caracteres, mas tamb\u00e9m para tipos definidos pelo desenvolvedor. 2 Prelude > [ 'a' .. 'm' ] \"abcdefghijklm\" Prelude > data Naipe = Copas | Espada | Ouro | Paus deriving ( Ord , Eq , Enum , Show ) Prelude > [ Copas .. Ouro ] [ Copas , Espada , Ouro ] Exerc\u00edcio Defina uma fun\u00e7\u00e3o que dado um n\u00famero inteiro x, gere uma lista de 1 a x e de volta a 1. Resolu\u00e7\u00e3o vaiEVolta n = lista ++ drop 1 ( reverse lista ) where lista = [ 1 .. n ] * Main > vaiEVolta 3 [ 1 , 2 , 3 , 2 , 1 ] Defina uma fun\u00e7\u00e3o que calcule o fatorial e um n\u00famero n, usando product e listas por enumera\u00e7\u00e3o. Resolu\u00e7\u00e3o fatorial n = product [ 1 .. n ] Compreens\u00e3o de Listas A compreens\u00e3o de listas \u00e9 uma forma de construir listas pela defini\u00e7\u00e3o de uma regra de constru\u00e7\u00e3o, e \u00e9 muito comum nas linguagens funcionais, incluindo Haskell. Defini\u00e7\u00e3o em fun\u00e7\u00e3o de outra lista Suponha que tenha uma lista de n\u00fameros e que gostaria de gerar uma nova lista em que cada valor da lista original \u00e9 acrescido de 30%. Com compreens\u00e3o de listas, isto pode ser feito muito facilmente usando a compreens\u00e3o de listas [ e * 1.3 | e <- lista ] . Esta compreens\u00e3o diz que ser\u00e1 constru\u00edda uma lista cujos elementos ser\u00e3o da forma e * 1.3 , onde e s\u00e3o os elementos da lista original. Veja o exemplo de execu\u00e7\u00e3o. > lista = [ 10 , 20 , 30 , 40 , 100 ] > [ e * 1.3 | e <- lista ] [ 13.0 , 26.0 , 39.0 , 52.0 , 130.0 ] Sintaxe A compreens\u00e3o de listas \u00e9 baseada na compreens\u00e3o de conjuntos, da teoria de conjuntos da matem\u00e1tica. A seguinte compreens\u00e3o de conjuntos pode ser lida como o conjunto \\(A\\) formado pela aplica\u00e7\u00e3o da fun\u00e7\u00e3o \\(f\\) a todos os valores \\(x\\) tal que \\(x\\) pertence ao conjunto \\(C\\) e para os quais valem os predicados \\(P_i, 1\\leq i \\leq n\\) . \\(A = \\{ f(x) | x \\in C \\land P_1(x) \\land \\ldots \\land P_n(x)\\}\\) A compreens\u00e3o de listas \u00e9 similar a = [ f x | x <- c , p1 x , ... , pn x ] Uma diferen\u00e7a importante \u00e9 que enquanto n\u00e3o h\u00e1 ordem nos conjuntos, h\u00e1 ordem nas listas e a constru\u00e7\u00e3o \u00e9 feita na ordem da lista original. Listas infinitas Assim como \u00e9 poss\u00edvel expressar um conjunto infinito usando compreens\u00e3o de conjuntos, por exemplo o conjunto dos quadrados de todos os n\u00fameros naturais \\(S = \\{e^2 | e \\in \\mathcal{N} \\}\\) , podemos expressar listas infinitas usando enumera\u00e7\u00e3o e compreens\u00e3o de listas como lq = [ e ** 2 | e <- [ 1 .. ]] . \"Mas como \u00e9 poss\u00edvel?\", voc\u00ea me pergunta, afinal, a mem\u00f3ria do computador \u00e9 finita e portanto n\u00e3o poderia armazenar uma lista infinita. Esta \u00e9 uma das m\u00e1gicas de Haskell, conhecida como avalia\u00e7\u00e3o pregui\u00e7osa, e ser\u00e1 vista em detalhes mais adiante. Por enquanto, basta acreditar que, desde que voc\u00ea n\u00e3o tente enumerar todos os elementos, uma lista infinita pode se representada em Haskell. Podemos, inclusive, consultar alguns elementos da lista infinita constru\u00edda acima para, por exemplo, verificar se um certo n\u00famero \u00e9 um quadrado perfeito! > lq = [ e ** 2 | e <- [ 1 .. ]] > elem 4 lq True > elem 16 lq True Observe, contudo, que se um elemento n\u00e3o estiver na lista, a fun\u00e7\u00e3o nunca retornar\u00e1! > elem 3 lq ^ CInterrupted . Exerc\u00edcio Modifique o exemplo acima para limitar a quantidade de elementos que ser\u00e3o buscados na lista de quadrados. Resolu\u00e7\u00e3o Prelude > elem 16 ( take 100 lq ) True Prelude > elem 20 ( take 100 lq ) False Prelude > elem 64 ( take 5 lq ) False Compreens\u00e3o como uma itera\u00e7\u00e3o Sabendo que a fun\u00e7\u00e3o ord do m\u00f3dulo Data.Char converte um caractere para seu valor na tabela ASCII, imagine que voc\u00ea queira converter uma String para uma lista dos valores ASCII correspondentes. Isso pode ser feito trivialmente com compreens\u00e3o de listas. Prelude > import Data.Char ( ord ) Prelude Data . Char > [ ord e | e <- \"abcd,'dasdfa;lkqwoiur\" ] [ 97 , 98 , 99 , 100 , 44 , 39 , 100 , 97 , 115 , 100 , 102 , 97 , 59 , 108 , 107 , 113 , 119 , 111 , 105 , 117 , 114 ] Isto demonstra que a constru\u00e7\u00e3o da lista pode ser usada aplicar uma fun\u00e7\u00e3o a todos os elementos de um \"conjunto\". No pr\u00f3ximo exemplo, usamos esta habilidade para capitalizar de uma String. Prelude Data . Char > import Data.Char ( toUpper ) Prelude Data . Char > [ toUpper e | e <- \"abcd,'dasdfa;lkqwoiur\" ] \"ABCD,'DASDFA;LKQWOIUR\" A lista resultante pode tem tipos complexos como elementos, como no exemplo seguinte, em que compreens\u00e3o gera uma com tuplas com as vers\u00f5es min\u00fascula e em mai\u00fascula de cada letra encontrada na entrada. Prelude Data . Char > [ ( toUpper e , toLower e ) | e <- \"abCD\" ] [( 'A' , 'a' ),( 'B' , 'b' ),( 'C' , 'c' ),( 'D' , 'd' )] Exerc\u00edcio Explique [ ( e , chr (( ord e - ord 'a' + 10 ) mod 26 + (ord 'a'))) | e <- ['a'..'z']] Resolu\u00e7\u00e3o Retorna uma lista de tuplas em que os primeiros elementos s\u00e3o letras e seus pares s\u00e3o letras 10 posi\u00e7\u00f5es adiante no alfabeto, m\u00f3dulo 26. Predicados Imagine agora que voc\u00ea queira construir uma lista com os quadrados dos n\u00fameros naturais m\u00faltiplos de 3 e menores que 100. Neste caso, podemos adicionar um teste aos elementos sendo aplicados na constru\u00e7\u00e3o da lista > [ e ^ 2 | e <- [ 1 .. 100 ], e ` mod ` 3 == 0 ] [ 9 , 36 , 81 , 144 , 225 , 324 , 441 , 576 , 729 , 900 , 1089 , 1296 , 1521 , 1764 , 2025 , 2304 , 2601 , 2916 , 3249 , 3600 , 3969 , 4356 , 4761 , 5184 , 5625 , 6084 , 6561 , 7056 , 7569 , 8100 , 8649 , 9216 , 9801 ] Observe que os predicados em si podem ser t\u00e3o complexos quanto se queira. Prelude Data . Char > [ e ^ 2 | e <- [ 1 .. 100 ], e ` mod ` 3 == 0 , e ^ 2 ` mod ` 4 == 0 ] [ 36 , 144 , 324 , 576 , 900 , 1296 , 1764 , 2304 , 2916 , 3600 , 4356 , 5184 , 6084 , 7056 , 8100 , 9216 ] Exerc\u00edcio Usando compreens\u00e3o de listas, defina uma fun\u00e7\u00e3o que gera a lista dos divisores de um n\u00famero. Resolu\u00e7\u00e3o > divisores x = [ e | e <- [ 1 .. x ], x ` mod ` e == 0 ] > divisores 10 [ 1 , 2 , 5 , 10 ] Usando a fun\u00e7\u00e3o definida acima, defina uma fun\u00e7\u00e3o que teste se um n\u00famero \u00e9 primo. Resolu\u00e7\u00e3o > divisores x = [ e | e <- [ 1 .. x ], x ` mod ` e == 0 ] > primo x = divisores x == [ 1 , x ] > primo 7 True > primo 45 False M\u00faltiplos geradores Uma compreens\u00e3o de listas pode ter mais de um gerador ( <- ), o que faz com que todas as combina\u00e7\u00f5es dos elementos gerados sejam aplicadas \u00e0 fun\u00e7\u00e3o. Por exemplo, a seguinte compreens\u00e3o combina todos os n\u00fameros de 1 a 4 com todos os n\u00fameros de 1 a 4 na constru\u00e7\u00e3o de uma tupla de dois inteiros. > [( x , y ) | x <- [ 1 .. 4 ], y <- [ 1 .. 4 ]] [( 1 , 1 ),( 1 , 2 ),( 1 , 3 ),( 1 , 4 ),( 2 , 1 ),( 2 , 2 ),( 2 , 3 ),( 2 , 4 ),( 3 , 1 ),( 3 , 2 ),( 3 , 3 ),( 3 , 4 ),( 4 , 1 ),( 4 , 2 ),( 4 , 3 ),( 4 , 4 )] Veja que predicados podem ser normalmente aplicados a m\u00faltiplos geradores, como no seguinte exemplo, em que somente as combina\u00e7\u00f5es onde \\(x,y\\) s\u00e3o usadas. > [( x , y ) | x <- [ 1 .. 4 ], y <- [ 1 .. 4 ], x < y ] [( 1 , 2 ),( 1 , 3 ),( 1 , 4 ),( 2 , 3 ),( 2 , 4 ),( 3 , 4 )] \u00c9 importante observar que a ordem dos geradores altera a ordem dos elementos da lista gerada, pois para cada elemento gerado pelo primeiro gerador, ser\u00e1 combinado a cada elemento gerado pelo segundo. > [ ( x , y ) | x <- [ 1 .. 4 ], y <- [ 'a' .. 'd' ]] [( 1 , 'a' ),( 1 , 'b' ),( 1 , 'c' ),( 1 , 'd' ),( 2 , 'a' ),( 2 , 'b' ),( 2 , 'c' ),( 2 , 'd' ),( 3 , 'a' ),( 3 , 'b' ),( 3 , 'c' ),( 3 , 'd' ),( 4 , 'a' ),( 4 , 'b' ),( 4 , 'c' ),( 4 , 'd' )] > [ ( x , y ) | y <- [ 'a' .. 'd' ], x <- [ 1 .. 4 ]] [( 1 , 'a' ),( 2 , 'a' ),( 3 , 'a' ),( 4 , 'a' ),( 1 , 'b' ),( 2 , 'b' ),( 3 , 'b' ),( 4 , 'b' ),( 1 , 'c' ),( 2 , 'c' ),( 3 , 'c' ),( 4 , 'c' ),( 1 , 'd' ),( 2 , 'd' ),( 3 , 'd' ),( 4 , 'd' )] Al\u00e9m disso, \u00e9 poss\u00edvel definir um gerador em termos dos geradores anteriores. Por exemplo > [ ( x , y ) | x <- [ 1 .. 4 ], y <- [ 1 .. x ]] [( 1 , 1 ),( 2 , 1 ),( 2 , 2 ),( 3 , 1 ),( 3 , 2 ),( 3 , 3 ),( 4 , 1 ),( 4 , 2 ),( 4 , 3 ),( 4 , 4 )] Este construto \u00e9 deveras poderoso, pois geradores podem ser aplicados eles pr\u00f3prios a compreens\u00e3o de listas. Outra possibilidade \u00e9 a aplica\u00e7\u00e3o recursiva, como no seguinte c\u00f3digo. partitions [] = [ [] ] partitions ( x : xs ) = [ x : e | e <- partitions xs ] ++ partitions xs Exerc\u00edcio Explique o que a fun\u00e7\u00e3o acima faz, com um exemplo. Casamento de padr\u00f5es Toda lista \u00e9 ou uma lista vazia ou ou um elemento cabe\u00e7a seguido por uma lista cauda. Assim, se cobrir estes dois casos em uma defini\u00e7\u00e3o por casamento de padr\u00f5es, ter\u00e1 coberto \"todos\" os casos! Mas como? Vejamos um exemplo. oQueH\u00e1NaCabe\u00e7a :: ( Show a ) => [ a ] -> String oQueH\u00e1NaCabe\u00e7a [] = \"Nada\" oQueH\u00e1NaCabe\u00e7a ( x : xs ) = \"H\u00e1 \" ++ x Linha 1: n\u00e3o se preocupe esta linha; ela apenas implica que a lista deve ser de valores convert\u00edveis a String Linha 2: esta linha usa um padr\u00e3o constante para testar se a lista \u00e9 vazia, isto \u00e9, [] e, neste caso, retornar a string \"Nada\" como resultado. Linha 3: este \u00e9 o caso mais interessante, pois usa um padr\u00e3o que define uma lista em que x \u00e9 a cabe\u00e7a, concatenada por : a uma cauda xs , e retorna \"H\u00e1 \" seguido do valor casado com x . Observe que foram usados par\u00eanteses na linha 3 para especificar o padr\u00e3o, e n\u00e3o apenas x : xs como seria de se esperar. A verdade \u00e9 que o padr\u00e3o \u00e9 x : xs e os par\u00eantesis s\u00e3o usados apenas para impedir que Haskell primeiro avalie oQueH\u00e1NaCabe\u00e7a x antes de avaliar o operador : e o seu segundo operando. Esta \u00e9 uma das idiossincrasias de Haskell com a qual voc\u00ea simplesmente ter\u00e1 que aprender a conviver para dividir listas entre cabe\u00e7a e cauda em um casamento de padr\u00f5es. Embora estes dois padr\u00f5es, isto \u00e9, lista vazia e cabe\u00e7a seguida de cauda, cubram todas as possibilidades de listas, n\u00e3o quer dizer que n\u00e3o haja melhores op\u00e7\u00f5es, dependendo do que precise extrair da lista. Por exemplo, na pr\u00f3xima fun\u00e7\u00e3o h\u00e1 4 casos de casamento de padr\u00f5es distintos: oQueH\u00e1NaLista :: ( Show a ) => [ a ] -> String oQueH\u00e1NaLista [] = \"Nada\" oQueH\u00e1NaLista [ x ] = \"S\u00f3 \" ++ ( show x ) oQueH\u00e1NaLista [ x1 , x2 ] = \"H\u00e1 \" ++ ( show x1 ) ++ \" e \" ++ ( show x2 ) oQueH\u00e1NaLista ( x : xs ) = \"H\u00e1 \" ++ ( show x ) ++ \" e mais um monte de coisas\" Linha 2: lista vazia; Linha 3: lista com exatamente um elemento, casado com x . Linha 4: lista com exatamente 2 elementos, casados com x1 e x2 . Linha 5: lista com mais de 2 elementos, em que a cabe\u00e7a \u00e9 casada com x e a cauda com xs . Outra forma de obter exatamente o mesmo resultado, usando mais o operador cons , seria a seguinte. oQueH\u00e1NaLista :: ( Show a ) => [ a ] -> String oQueH\u00e1NaLista [] = \"Nada\" oQueH\u00e1NaLista ( x :[] ) = \"S\u00f3 \" ++ ( show x ) oQueH\u00e1NaLista ( x1 : x2 :[] ) = \"H\u00e1 \" ++ ( show x1 ) ++ \" e \" ++ ( show x2 ) oQueH\u00e1NaLista ( x : xs ) = \"H\u00e1 \" ++ ( show x ) ++ \" e mais um monte de coisas\" Dado que strings s\u00e3o apenas listas de Char, estas tamb\u00e9m podem ser decompostas por casamentos de padr\u00f5es. resumo :: String -> String resumo [] -> \"Nada\" resumo [ _ ] -> \"Um\" resumo [ _ , _ ] -> \"Dois\" resumo _ -> \"Muitos\" Assim como listas podem ter elementos mais complexos que tipos primitivos, por exemplo tuplas e listas, tamb\u00e9m os casamentos de padr\u00f5es aplicados a estas listas ser\u00e3o mais complexos. Por exemplo, considere uma lista de tr\u00eas ou mais String, isto \u00e9, uma lista de lista de Char; \u00e9 poss\u00edvel, por exemplo, selecionar a primeira letra de cada uma das tr\u00eas primeiras strings com a seguinte fun\u00e7\u00e3o. iniciais :: [ String ] -> [ Char ] iniciais [] = [] iniciais [( x : _ )] = [ x ] iniciais [( x : _ ),( y : _ )] = [ x , y ] iniciais (( x : _ ) : ( y : _ ) : ( z : _ ) : _ ) = [ x , y , z ] Recurs\u00e3o A recurs\u00e3o \u00e9 essencial no processamento de listas e, de fato, muitas das fun\u00e7\u00f5es listadas na se\u00e7\u00e3o anterior podem e s\u00e3o definidas recursivamente, como a fun\u00e7\u00e3o maximum : \\(maximum~[1,2,3] = max~1 \\left( maximum~[2,3] = max~2 \\left( maximum~[3] = 3 \\right) \\right)\\) Vejamos algumas defini\u00e7\u00f5es. 3 maximum maximum' [] = error \"lista vazia\" maximum' [ h ] = h maximum' ( h : t ) = max h ( maximum' t ) length length' :: [ a ] -> Int length' [] = 0 length' ( x : xs ) = 1 + length' xs last last' :: [ a ] -> a last' [] = error \"List is empty\" last' [ x ] = x last' ( _ : xs ) = last' xs reverse reverse' :: [ a ] -> [ a ] reverse' [] = [] reverse' ( x : xs ) = reverse' xs ++ [ x ] replicate replicate' 0 e = [] replicate' x e = e : replicate' ( x - 1 ) e zip zip' [] _ = [] zip' _ [] = [] zip' ( x : xs ) ( y : ys ) = ( x , y ) : zip' xs ys elem elem' _ [] = False elem' e ( x : xs ) = e == x || elem' e xs ++ maisMais :: [ a ] -> [ a ] -> [ a ] maisMais [] [] = [] maisMais [] y = y maisMais ( x : xs ) y = x : maisMais xs y Exerc\u00edcio Defina a fun\u00e7\u00e3o take Defina a fun\u00e7\u00e3o drop Defina a fun\u00e7\u00e3o uni\u00e3o que recebe duas listas sem repeti\u00e7\u00f5es retorna a concatena\u00e7\u00e3o das listas, sem repeti\u00e7\u00f5es, usando recursividade. Defina a fun\u00e7\u00e3o uni\u00e3o que recebe duas listas sem repeti\u00e7\u00f5es retorna a concatena\u00e7\u00e3o das listas, sem repeti\u00e7\u00f5es, usando compreens\u00e3o de listas. Ordena\u00e7\u00e3o Selection-sort ( https://www.youtube.com/embed/Ns4TPTC8whw ) Defina uma fun\u00e7\u00e3o fr que receba um inteiro i e uma lista de inteiros l e retorne a lista l sem a primeira ocorr\u00eancia de i em l . Defina uma fun\u00e7\u00e3o fm que receba uma lista de inteiros l e retorne o menor inteiro da lista. Defina uma fun\u00e7\u00e3o fs que receba uma lista de inteiros l , escolha o menor inteiro m de l e retorne m concatenado a cabe\u00e7a da lista gerada por fs (fr m l) Merge-Sort ( https://www.youtube.com/embed/XaqR3G_NVoo ) Defina uma fun\u00e7\u00e3o fd que receba uma lista e retorne suas duas metades em uma dupla: metade [ 1 .. 11 ] = ([ 1 , 2 , 3 , 4 , 5 ],[ 6 , 7 , 8 , 9 , 10 , 11 ]) Defina uma fun\u00e7\u00e3o fu que receba duas listas ordenadas e retorne uma lista ordenada com a uni\u00e3o das listas uni\u00e3o [ 1 , 3 , 5 , 7 ] [ 2 , 4 , 6 , 7 ] = [ 1 , 2 , 3 , 5 , 6 , 7 , 7 ] Defina uma fun\u00e7\u00e3o fm que receba uma lista, divida-a na metade usando fd , aplique fm recursivamente em cada metade, e calcule a uni\u00e3o das listas resultantes usando fu . Quick-sort Defina uma fun\u00e7\u00e3o fp que receba uma lista l de inteiros e retorne retorne uma tripla (p,m1,m2) em que p \u00e9 o primeiro elemento da lista l m1 \u00e9 a lista dos elementos em l menores ou iguais a p , exclusive m2 \u00e9 a lista dos elementos em l maiores que p Defina uma fun\u00e7\u00e3o fq que recebe uma lista l , calcule (p,m1,m2) = fp l e retorne fq m1 concatenado a p concatenado a fq m2 . Foi feita uma pequena edi\u00e7\u00e3o na sa\u00edda do comando : t para claridade, pois o resultado real envolvia supertipos, a serem vistos mais adiante. \u21a9 No exemplo, observe o espa\u00e7o entre Copas e .. . \u21a9 Todas as fun\u00e7\u00f5es definidas a seguir tem nome terminado em ``` para evitar colis\u00e3o com as fun\u00e7\u00f5es padr\u00e3o. \u21a9","title":"Listas"},{"location":"lists/#listas","text":"Vamos agora estudar listas, pe\u00e7as fundamentais no desenvolvimento de programas usando o paradigma funcional, por serem estruturas de dados que permitem agregar v\u00e1rias informa\u00e7\u00f5es na forma de uma cole\u00e7\u00e3o ordenada de elementos. Por exemplo, [ \"Eu\" , \"amo\" , \"programa\u00e7\u00e3o\" , \"funcional\" ] \u00e9 a cole\u00e7\u00e3o de quatro strings em que o primeiro elemento \u00e9 \"Eu\" , o segundo \"amo\" , o terceiro \"programa\u00e7\u00e3o\" e o quarto e \u00faltimo \"funcional\" . J\u00e1 [ 1 :: Int , 2 :: Int , 3 :: Int ] \u00e9 uma lista de 3 elementos do tipo Int , onde o primeiro elemento \u00e9 1, o segundo 2, e o terceiro 3. \"Mas e as tuplas?\", voc\u00ea pergunta, \"N\u00e3o s\u00e3o exatamente isto?\"","title":"Listas"},{"location":"lists/#estrutura","text":"Dado uma lista qualquer, de qualquer tipo, ela pode ser ou vazia ou n\u00e3o vazia, sendo que a lista vazia \u00e9 representada em Haskell por [] . Listas n\u00e3o vazias s\u00e3o representadas como a concatena\u00e7\u00e3o do primeiro elemento da lista com uma lista com os demais elementos, usando o operador de concatena\u00e7\u00e3o : , ou cons . Por exemplo, a lista dos n\u00fameros 1, 2 e 3 nesta ordem \u00e9 constru\u00edda como 1 : 2 : 3 :[] ; observe que como o 3 \u00e9 o \u00faltimo elemento da lista, a lista que vem depois do cons, com os demais elementos, \u00e9 a lista vazia. Prelude > x = 1 : 2 : 3 :[] Prelude > x [ 1 , 2 , 3 ]","title":"Estrutura"},{"location":"lists/#funcoes-uteis","text":"Em uma se\u00e7\u00e3o anterior, apresentamos algumas fun\u00e7\u00f5es como \u00fateis na manipula\u00e7\u00e3o de String. Na verdade, todas aquelas fun\u00e7\u00f5es s\u00e3o definidas em termos de listas e, por isso, as revisitaremos aqui juntamente com mais algumas. Operador Opera\u00e7\u00e3o Exemplo ++ Concatena\u00e7\u00e3o de listas > \"foo\" ++ \"bar\" \"foobar\" !! Elemento no \u00edndice > [ 1 , 2 , 3 , 4 ] !! 2 3 reverse Lista ao contr\u00e1rio > reverse [ 1 , 2 , 3 , 4 ] [4,3,2,1] length Comprimento da string > length \"foo bar\" 7 last \u00daltimo elemento da lista > last \"foo bar\" r concat Retorna a concatena\u00e7\u00e3o das listas dentro de uma lista > concat [[ 1 , 2 , 3 , 4 ],[ 5 , 6 , 7 , 8 ]] [1,2,3,4,5,6,7,8] > concat [[[ 1 , 2 , 3 ]],[[ 4 , 5 , 6 ]]] [[ 1 , 2 , 3 ],[ 4 , 5 , 6 ]] elem Verifica se o par\u00e2metro \u00e9 um elemento da lista > elem 'o' \"foo bar\" True null Verifica se a lista \u00e9 vazia > null \"\" True > null [] True > null [ 1 , 2 ] False replicate Constr\u00f3i uma lista pela replica\u00e7\u00e3o de um elemento > replicate 4 ( 1 , 2 ) [( 1 , 2 ),( 1 , 2 ),( 1 , 2 ),( 1 , 2 )] take Sublista iniciando em 0 > take 3 1 : 2 : 3 : 4 : 5 :[] [ 1 , 2 , 3 ] drop Sublista come\u00e7ando em um \u00edndice > drop 3 [ 'f' , 'o' , 'o' , ' ' , 'b' , 'a' , 'r' ] \" bar\" takeWhile Sublista iniciando em 0 e at\u00e9 o primeiro elemento que n\u00e3o satisfaz ao crit\u00e9rio, exclusive > takeWhile ( < 4 ) [ 1 , 2 , 3 , 4 , 5 , 6 ] [ 1 , 2 , 3 ] dropWhile Sublista come\u00e7ando no primeiro elemento que n\u00e3o satisfaz ao crit\u00e9rio, inclusive > dropWhile ( < 4 ) [ 1 , 2 , 3 , 4 , 5 , 6 ] 4 , 5 , 6 splitAt Dupla das sublistas geradas pela divis\u00e3o no \u00edndice especificado > splitAt 3 [ 1 , 2 , 3 , 4 , 5 , 6 ] ([ 1 , 2 , 3 ],[ 4 , 5 , 6 ]) zip Lista de pares com os elementos das duas listas passadas como par\u00e2metro > zip [ 1 , 2 , 3 ] [ 4 , 5 , 6 ] [( 1 , 4 ),( 2 , 5 ),( 3 , 6 )] sum Somat\u00f3rio dos elementos da lista > sum [ 1 , 2 , 3 , 4 , 5 , 6 ] 16 product Produt\u00f3rio dos elementos da lista > product [ 1 , 2 , 3 , 4 , 5 , 6 ] 720 maximum Maior dos elemento lista > maximum [ 1 , 2 , 3 , 4 , 5 , 6 ] 6 minimum Menor dos elementos da lista > minimum [ 1 , 2 , 3 , 4 , 5 , 6 ] 1","title":"Fun\u00e7\u00f5es \u00fateis"},{"location":"lists/#enumeracao","text":"Para facilitar a vida dos desenvolvedores, Haskell permite a constru\u00e7\u00e3o de listas por enumera\u00e7\u00e3o, bastando para isso o especificar o primeiro elemento da lista, opcionalmente o segundo, e o \u00faltimo elemento. Por exemplo Prelude > [ 11 , 13 .. 23 ] [ 11 , 13 , 15 , 17 , 19 , 21 , 23 ] Prelude > [ - 15 , - 13 .. 14 ] [ - 15 , - 13 , - 11 , - 9 , - 7 , - 5 , - 3 , - 1 , 1 , 3 , 5 , 7 , 9 , 11 , 13 ] Observe que Haskell determinou um passo de incremento igual a \\(13-11 = 2\\) no primeiro exemplo e \\(-15 - -13 = 2\\) no segundo exemplo, e usou estes passos para gerar as lista. Tamb\u00e9m \u00e9 poss\u00edvel definir um passo negativo, como no pr\u00f3ximo exemplo. Prelude > [ 11 , 9 .. 0 ] [ 11 , 9 , 7 , 5 , 3 , 1 ] Como mencionado, o segundo elemento \u00e9 opcional na enumera\u00e7\u00e3o e caso n\u00e3o especificado, Haskell assume que seja \\(1\\) , como no exemplo a seguir. Prelude > [ 11 .. 23 ] [ 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 ] Prelude > [ 3.5 .. 10 ] [ 3.5 , 4.5 , 5.5 , 6.5 , 7.5 , 8.5 , 9.5 , 10.5 ] Contudo, n\u00e3o \u00e9 poss\u00edvel omitir o segundo elemento se a inten\u00e7\u00e3o for gerar uma lista com valores decrescentes. Prelude > [ 11 .. 0 ] [] A enumera\u00e7\u00e3o pode ser feita para outros tipos que n\u00e3o sejam num\u00e9ricos, bastando que exista uma rela\u00e7\u00e3o de ordem entre os elementos para que Haskell consiga \"incrementar\" a cada passo. Isso existe, por exemplo, entre os caracteres, mas tamb\u00e9m para tipos definidos pelo desenvolvedor. 2 Prelude > [ 'a' .. 'm' ] \"abcdefghijklm\" Prelude > data Naipe = Copas | Espada | Ouro | Paus deriving ( Ord , Eq , Enum , Show ) Prelude > [ Copas .. Ouro ] [ Copas , Espada , Ouro ] Exerc\u00edcio Defina uma fun\u00e7\u00e3o que dado um n\u00famero inteiro x, gere uma lista de 1 a x e de volta a 1. Resolu\u00e7\u00e3o vaiEVolta n = lista ++ drop 1 ( reverse lista ) where lista = [ 1 .. n ] * Main > vaiEVolta 3 [ 1 , 2 , 3 , 2 , 1 ] Defina uma fun\u00e7\u00e3o que calcule o fatorial e um n\u00famero n, usando product e listas por enumera\u00e7\u00e3o. Resolu\u00e7\u00e3o fatorial n = product [ 1 .. n ]","title":"Enumera\u00e7\u00e3o"},{"location":"lists/#compreensao-de-listas","text":"A compreens\u00e3o de listas \u00e9 uma forma de construir listas pela defini\u00e7\u00e3o de uma regra de constru\u00e7\u00e3o, e \u00e9 muito comum nas linguagens funcionais, incluindo Haskell.","title":"Compreens\u00e3o de Listas"},{"location":"lists/#casamento-de-padroes","text":"Toda lista \u00e9 ou uma lista vazia ou ou um elemento cabe\u00e7a seguido por uma lista cauda. Assim, se cobrir estes dois casos em uma defini\u00e7\u00e3o por casamento de padr\u00f5es, ter\u00e1 coberto \"todos\" os casos! Mas como? Vejamos um exemplo. oQueH\u00e1NaCabe\u00e7a :: ( Show a ) => [ a ] -> String oQueH\u00e1NaCabe\u00e7a [] = \"Nada\" oQueH\u00e1NaCabe\u00e7a ( x : xs ) = \"H\u00e1 \" ++ x Linha 1: n\u00e3o se preocupe esta linha; ela apenas implica que a lista deve ser de valores convert\u00edveis a String Linha 2: esta linha usa um padr\u00e3o constante para testar se a lista \u00e9 vazia, isto \u00e9, [] e, neste caso, retornar a string \"Nada\" como resultado. Linha 3: este \u00e9 o caso mais interessante, pois usa um padr\u00e3o que define uma lista em que x \u00e9 a cabe\u00e7a, concatenada por : a uma cauda xs , e retorna \"H\u00e1 \" seguido do valor casado com x . Observe que foram usados par\u00eanteses na linha 3 para especificar o padr\u00e3o, e n\u00e3o apenas x : xs como seria de se esperar. A verdade \u00e9 que o padr\u00e3o \u00e9 x : xs e os par\u00eantesis s\u00e3o usados apenas para impedir que Haskell primeiro avalie oQueH\u00e1NaCabe\u00e7a x antes de avaliar o operador : e o seu segundo operando. Esta \u00e9 uma das idiossincrasias de Haskell com a qual voc\u00ea simplesmente ter\u00e1 que aprender a conviver para dividir listas entre cabe\u00e7a e cauda em um casamento de padr\u00f5es. Embora estes dois padr\u00f5es, isto \u00e9, lista vazia e cabe\u00e7a seguida de cauda, cubram todas as possibilidades de listas, n\u00e3o quer dizer que n\u00e3o haja melhores op\u00e7\u00f5es, dependendo do que precise extrair da lista. Por exemplo, na pr\u00f3xima fun\u00e7\u00e3o h\u00e1 4 casos de casamento de padr\u00f5es distintos: oQueH\u00e1NaLista :: ( Show a ) => [ a ] -> String oQueH\u00e1NaLista [] = \"Nada\" oQueH\u00e1NaLista [ x ] = \"S\u00f3 \" ++ ( show x ) oQueH\u00e1NaLista [ x1 , x2 ] = \"H\u00e1 \" ++ ( show x1 ) ++ \" e \" ++ ( show x2 ) oQueH\u00e1NaLista ( x : xs ) = \"H\u00e1 \" ++ ( show x ) ++ \" e mais um monte de coisas\" Linha 2: lista vazia; Linha 3: lista com exatamente um elemento, casado com x . Linha 4: lista com exatamente 2 elementos, casados com x1 e x2 . Linha 5: lista com mais de 2 elementos, em que a cabe\u00e7a \u00e9 casada com x e a cauda com xs . Outra forma de obter exatamente o mesmo resultado, usando mais o operador cons , seria a seguinte. oQueH\u00e1NaLista :: ( Show a ) => [ a ] -> String oQueH\u00e1NaLista [] = \"Nada\" oQueH\u00e1NaLista ( x :[] ) = \"S\u00f3 \" ++ ( show x ) oQueH\u00e1NaLista ( x1 : x2 :[] ) = \"H\u00e1 \" ++ ( show x1 ) ++ \" e \" ++ ( show x2 ) oQueH\u00e1NaLista ( x : xs ) = \"H\u00e1 \" ++ ( show x ) ++ \" e mais um monte de coisas\" Dado que strings s\u00e3o apenas listas de Char, estas tamb\u00e9m podem ser decompostas por casamentos de padr\u00f5es. resumo :: String -> String resumo [] -> \"Nada\" resumo [ _ ] -> \"Um\" resumo [ _ , _ ] -> \"Dois\" resumo _ -> \"Muitos\" Assim como listas podem ter elementos mais complexos que tipos primitivos, por exemplo tuplas e listas, tamb\u00e9m os casamentos de padr\u00f5es aplicados a estas listas ser\u00e3o mais complexos. Por exemplo, considere uma lista de tr\u00eas ou mais String, isto \u00e9, uma lista de lista de Char; \u00e9 poss\u00edvel, por exemplo, selecionar a primeira letra de cada uma das tr\u00eas primeiras strings com a seguinte fun\u00e7\u00e3o. iniciais :: [ String ] -> [ Char ] iniciais [] = [] iniciais [( x : _ )] = [ x ] iniciais [( x : _ ),( y : _ )] = [ x , y ] iniciais (( x : _ ) : ( y : _ ) : ( z : _ ) : _ ) = [ x , y , z ]","title":"Casamento de padr\u00f5es"},{"location":"lists/#recursao","text":"A recurs\u00e3o \u00e9 essencial no processamento de listas e, de fato, muitas das fun\u00e7\u00f5es listadas na se\u00e7\u00e3o anterior podem e s\u00e3o definidas recursivamente, como a fun\u00e7\u00e3o maximum : \\(maximum~[1,2,3] = max~1 \\left( maximum~[2,3] = max~2 \\left( maximum~[3] = 3 \\right) \\right)\\) Vejamos algumas defini\u00e7\u00f5es. 3 maximum maximum' [] = error \"lista vazia\" maximum' [ h ] = h maximum' ( h : t ) = max h ( maximum' t ) length length' :: [ a ] -> Int length' [] = 0 length' ( x : xs ) = 1 + length' xs last last' :: [ a ] -> a last' [] = error \"List is empty\" last' [ x ] = x last' ( _ : xs ) = last' xs reverse reverse' :: [ a ] -> [ a ] reverse' [] = [] reverse' ( x : xs ) = reverse' xs ++ [ x ] replicate replicate' 0 e = [] replicate' x e = e : replicate' ( x - 1 ) e zip zip' [] _ = [] zip' _ [] = [] zip' ( x : xs ) ( y : ys ) = ( x , y ) : zip' xs ys elem elem' _ [] = False elem' e ( x : xs ) = e == x || elem' e xs ++ maisMais :: [ a ] -> [ a ] -> [ a ] maisMais [] [] = [] maisMais [] y = y maisMais ( x : xs ) y = x : maisMais xs y Exerc\u00edcio Defina a fun\u00e7\u00e3o take Defina a fun\u00e7\u00e3o drop Defina a fun\u00e7\u00e3o uni\u00e3o que recebe duas listas sem repeti\u00e7\u00f5es retorna a concatena\u00e7\u00e3o das listas, sem repeti\u00e7\u00f5es, usando recursividade. Defina a fun\u00e7\u00e3o uni\u00e3o que recebe duas listas sem repeti\u00e7\u00f5es retorna a concatena\u00e7\u00e3o das listas, sem repeti\u00e7\u00f5es, usando compreens\u00e3o de listas. Ordena\u00e7\u00e3o Selection-sort ( https://www.youtube.com/embed/Ns4TPTC8whw ) Defina uma fun\u00e7\u00e3o fr que receba um inteiro i e uma lista de inteiros l e retorne a lista l sem a primeira ocorr\u00eancia de i em l . Defina uma fun\u00e7\u00e3o fm que receba uma lista de inteiros l e retorne o menor inteiro da lista. Defina uma fun\u00e7\u00e3o fs que receba uma lista de inteiros l , escolha o menor inteiro m de l e retorne m concatenado a cabe\u00e7a da lista gerada por fs (fr m l) Merge-Sort ( https://www.youtube.com/embed/XaqR3G_NVoo ) Defina uma fun\u00e7\u00e3o fd que receba uma lista e retorne suas duas metades em uma dupla: metade [ 1 .. 11 ] = ([ 1 , 2 , 3 , 4 , 5 ],[ 6 , 7 , 8 , 9 , 10 , 11 ]) Defina uma fun\u00e7\u00e3o fu que receba duas listas ordenadas e retorne uma lista ordenada com a uni\u00e3o das listas uni\u00e3o [ 1 , 3 , 5 , 7 ] [ 2 , 4 , 6 , 7 ] = [ 1 , 2 , 3 , 5 , 6 , 7 , 7 ] Defina uma fun\u00e7\u00e3o fm que receba uma lista, divida-a na metade usando fd , aplique fm recursivamente em cada metade, e calcule a uni\u00e3o das listas resultantes usando fu . Quick-sort Defina uma fun\u00e7\u00e3o fp que receba uma lista l de inteiros e retorne retorne uma tripla (p,m1,m2) em que p \u00e9 o primeiro elemento da lista l m1 \u00e9 a lista dos elementos em l menores ou iguais a p , exclusive m2 \u00e9 a lista dos elementos em l maiores que p Defina uma fun\u00e7\u00e3o fq que recebe uma lista l , calcule (p,m1,m2) = fp l e retorne fq m1 concatenado a p concatenado a fq m2 . Foi feita uma pequena edi\u00e7\u00e3o na sa\u00edda do comando : t para claridade, pois o resultado real envolvia supertipos, a serem vistos mais adiante. \u21a9 No exemplo, observe o espa\u00e7o entre Copas e .. . \u21a9 Todas as fun\u00e7\u00f5es definidas a seguir tem nome terminado em ``` para evitar colis\u00e3o com as fun\u00e7\u00f5es padr\u00e3o. \u21a9","title":"Recurs\u00e3o"},{"location":"pattern_matching/","text":"Casamento de Padr\u00f5es Quando especificamos a lista de par\u00e2metros formais que uma fun\u00e7\u00e3o recebe, estamos dizendo ao compilador que os par\u00e2metros passados na invoca\u00e7\u00e3o da fun\u00e7\u00e3o devem ser associados aos par\u00e2metros formais. Por exemplo, considere a seguinte defini\u00e7\u00e3o de uma fun\u00e7\u00e3o que soma dois pontos soma2n x y = x + y e sua invoca\u00e7\u00e3o. > soma2n 3 4 7 Quando a invoca\u00e7\u00e3o acontece, o valor 3 \u00e9 associado a x e 4 a y . O mesmo acontece para qualquer tipo de par\u00e2metro passado, mesmo tuplas e, como veremos depois, listas. Por exemplo, considere a soma de dois pontos em um espa\u00e7o bidimensional, em que pontos s\u00e3o especificados como tuplas de aridade 2. type Ponto = ( Integer , Integer ) soma2v :: Ponto -> Ponto -> Ponto soma2v ponto1 ponto2 = ( fst ponto1 + fst ponto2 , snd ponto1 + snd ponto2 ) Um dos problemas deste c\u00f3digo \u00e9 a necessidade de usar fst e snd para extrair os componentes das tuplas. Mas como vimos na se\u00e7\u00e3o sobre tuplas , \u00e9 poss\u00edvel associar as componentes das tuplas diretamente a vari\u00e1veis. Por exemplo, considere a defini\u00e7\u00e3o alternativa para soma2v . type Ponto = ( Integer , Integer ) soma2v :: Ponto -> Ponto -> Ponto soma2v ( x1 , y1 ) ( x2 , y2 ) = ( x1 + x2 , y1 + y2 ) Observe que, na linha 4, as coordenadas dos pontos passados s\u00e3o associados \u00e0s vari\u00e1veis x1, y1, x2 e y2 . O termo correto para o que est\u00e1 acontecendo ali \u00e9 casamento de padr\u00f5es . Tipos de Padr\u00e3o O casamento de padr\u00f5es \u00e9 o processo pelo qual os valores em uma express\u00e3o s\u00e3o decompostos e associados aos elementos de um padr\u00e3o . Em outras palavras, dada uma express\u00e3o e um padr\u00e3o, \u00e9 feita uma tentativa de decomposi\u00e7\u00e3o da express\u00e3o de acordo com o especificado pelo padr\u00e3o. Se a decomposi\u00e7\u00e3o \u00e9 bem sucedida, isto \u00e9, se a express\u00e3o e o padr\u00e3o tem exatamente o mesmo tipo e se constantes especificadas no padr\u00e3o tem o mesmo valor na mesma posi\u00e7\u00e3o da express\u00e3o, ent\u00e3o o casamento \u00e9 bem sucedido ; caso contr\u00e1rio, o casamento fracassa . \u00c9 mais f\u00e1cil entender a descri\u00e7\u00e3o de casamento de padr\u00f5es acima usando exemplos. Para isso, vamos dividir os padr\u00f5es em alguns tipos e analisar exemplos de cada um destes tipos. Constante Considere a seguinte tabela, com suas colunas padr\u00e3o , cujas entradas s\u00e3o constantes , valor , cujas cujas entradas queremos tentar casar com o padr\u00e3o, e resultado , que informa o resultado do casamento. Padr\u00e3o Valor Resultado 10 10 Sucesso 10 20 Fracasso 10 'C' Erro True False Fracasso False False Sucesso Para cada linha, imagine uma fun\u00e7\u00e3o definida como a seguir, mas onde o s\u00edmbolo \u2588 \u00e9 substitu\u00eddo pelo padr\u00e3o minhaFun\u00e7\u00e3o \u2588 = \"Sucesso!\" e que voc\u00ea esteja invocando a fun\u00e7\u00e3o no ghci assim como a seguir, mas onde o s\u00edmbolo \u2593 \u00e9 substitu\u00eddo pelo valor. Prelude > minhaFun\u00e7\u00e3o \u2593 Por exemplo, para a primeira linha, a fun\u00e7\u00e3o fica assim minhaFun\u00e7\u00e3o 10 = \"Sucesso!\" e a invoca\u00e7\u00e3o fica assim. Prelude > minhaFun\u00e7\u00e3o 10 Quando a invoca\u00e7\u00e3o \u00e9 feita, o ghci pega o valor passado, 10, e tenta cas\u00e1-lo com o padr\u00e3o especificado na defini\u00e7\u00e3o de minhaFun\u00e7\u00e3o, 10. Neste caso, h\u00e1 um casamento entre o valor e o padr\u00e3o. * Main > minhaFuncao 10 \"Deu certo\" J\u00e1 para a segunda linha, n\u00e3o h\u00e1 um casamento, pois o valor 10 n\u00e3o pode ser decomposto como a constante 20, e o ghci reclama com um erro que n\u00e3o vem ao caso agora. * Main > minhaFuncao 20 \"*** Exception: scratch.hs:87:1-28: Non-exhaustive patterns in function minhaFuncao Vari\u00e1vel Se em vez de constantes a coluna padr\u00e3o tivesse como elementos uma vari\u00e1vel, ent\u00e3o o casamento sempre seria bem sucedido. Neste caso, a coluna associa\u00e7\u00f5es 1 mostra quais os valores associados \u00e0 cada vari\u00e1vel do padr\u00e3o. Padr\u00e3o Valor Resultado Associa\u00e7\u00e3o x 10 Sucesso x = 10 x 20 Sucesso x = 20 x 'C' Sucesso x = 'C' x False Sucesso x = False x (1,2,3) Sucesso x = (1,2,3) Curinga Como j\u00e1 mencionado antes, _ na defini\u00e7\u00e3o de uma fun\u00e7\u00e3o funciona como uma vari\u00e1vel, mas cujo valor \u00e9 descartado, isto \u00e9, n\u00e3o \u00e9 associado a uma vari\u00e1vel. Isto \u00e9 na verdade um casamento em que o padr\u00e3o \u00e9 um curinga , que \u00e9 sempre bem sucedido mas que n\u00e3o gera uma associa\u00e7\u00e3o. Padr\u00e3o Valor Resultado _ 10 Sucesso _ 20 Sucesso _ 'C' Sucesso _ False Sucesso _ (1,2,3) Sucesso Tupla Como demonstrado no exemplo da fun\u00e7\u00e3o soma2v , tuplas podem ser usados como padr\u00e3o, permitindo decompor uma tupla usada como valor. O casamento de tuplas no valor e no padr\u00e3o pode levar aos seguintes resultados, observando que o casamento de padr\u00f5es \u00e9 aplicado recursivamente em cada elemento da tupla. Sucesso se a tupla padr\u00e3o tiver a mesma aridade que a tupla valores e cada elemento da tupla padr\u00e3o casa com o elemento correspondente da tupla valor. Fracasso se a tupla padr\u00e3o tiver a mesma aridade que a tupla valore e algum elemento da tupla padr\u00e3o n\u00e3o casa com o elemento correspondente da tupla valor. Resulta em um erro de tipo se a tupla de padr\u00f5es n\u00e3o tiver a mesma aridade que a tupla de valores ou algum elemento da tupla de padr\u00f5es resultar um erro de tipo no casamento com o elemento correspondente da tupla de valores. Padr\u00e3o Valor Resultado Associa\u00e7\u00e3o (x,y) (1,2) Sucesso x = 1 e y = 2 (1,y) (1,2) Sucesso y = 2 (1,y) (2,2) Fracasso (_,y) (1,2) Sucesso y = 2 (_,y) (10,2) Sucesso y = 2 ('X',y) ('X',2) Sucesso y = 2 (x,y) (1,(2,3)) Sucesso x = 1; y = (2,3) (_, (_,y)) (1,(2,3)) Sucesso y = 3 (x,y) (1,(2,3),3) Erro de tipo (1,y) ('x',(2,3)) Erro de tipo x (1,2) Sucesso x = (1,2) (x,y) 1 Erro de tipo Listas Por completude, precisamos mencionar que o casamento funciona tamb\u00e9m para listas, mas deixaremos para mais tarde esta discuss\u00e3o, quando nos focarmos em listas. Mais de um padr\u00e3o Nos exemplos vistos nas tabelas, temos sempre um valor e um padr\u00e3o, mas fun\u00e7\u00f5es podem ter diversos par\u00e2metros. Neste caso, o casamento de padr\u00f5es acontece para cada um dos par\u00e2metros passados na invoca\u00e7\u00e3o da fun\u00e7\u00e3o, da esquerda para a direita. Por exemplo, considerando a seguinte defini\u00e7\u00e3o minhaFun\u00e7\u00e3o'' ( a , b ) (( c , d ), _ , f ) g = a + b + c + d + f + fst g + snd g invoca\u00e7\u00e3o * Main > minhaFun\u00e7\u00e3o'' ( 1 , 2 ) (( 3 , 4 ), 5 , 6 ) ( 7 , 8 ) 31 Isto \u00e9, temos as seguintes associa\u00e7\u00f5es a = 1, b = 2, c = 3, d = 4, f = 6, g = (7,8) . Defini\u00e7\u00e3o de Fun\u00e7\u00f5es Al\u00e9m de decompor os par\u00e2metros passados para um fun\u00e7\u00e3o e como mencionado anteriormente , casamento de padr\u00f5es pode ser usado na defini\u00e7\u00e3o de fun\u00e7\u00f5es para simplificar testes via if-then-else e guardas nos par\u00e2metros da fun\u00e7\u00e3o. Neste caso, a fun\u00e7\u00e3o \u00e9 definida como uma sequ\u00eancia de equa\u00e7\u00f5es em que s\u00e3o feitas tentativas sucessivas de casamento de padr\u00f5es, na ordem das defini\u00e7\u00f5es. O resultado da invoca\u00e7\u00e3o da fun\u00e7\u00e3o \u00e9 dado pela primeira equa\u00e7\u00e3o em que houver um casamento bem sucedido e todas as guardas forem satisfeitas. Se ao final n\u00e3o houver casamento ou se as guardas n\u00e3o forem satisfeitas, ocorre um erro de execu\u00e7\u00e3o . Para come\u00e7ar, vejamos uma defini\u00e7\u00e3o sem guardas, revisitando a fun\u00e7\u00e3o nomeMes . Usando casamento de padr\u00f5es constantes, ela ficaria assim: nomeMes 1 = \"JAN\" nomeMes 2 = \"FEB\" nomeMes 3 = \"ABR\" nomeMes 4 = \"MAR\" nomeMes 5 = \"MAI\" nomeMes 6 = \"JUN\" nomeMes 7 = \"JUL\" nomeMes 8 = \"AGO\" nomeMes 9 = \"SET\" nomeMes 10 = \"OUT\" nomeMes 11 = \"NOV\" nomeMes 12 = \"DEZ\" Esta fun\u00e7\u00e3o funciona especificamente para valores na faixa [1,12] e retornar\u00e1 um erro para qualquer valor fora da mesma. * Main > nomeMes 13 \"*** Exception: scratch.hs:(112,1)-(123,18): Non-exhaustive patterns in function nomeMes \u00c9 poss\u00edvel usar uma defini\u00e7\u00e3o gen\u00e9rica catch-all para casar com valores n\u00e3o espec\u00edficos usando um padr\u00e3o vari\u00e1vel. Por exemplo, a defini\u00e7\u00e3o da fun\u00e7\u00e3o fatorial tem um tratamento especial para 0, via padr\u00e3o constante, e um caso gen\u00e9rico para qualquer outro n\u00famero, via padr\u00e3o vari\u00e1vel. fatorial 0 = 1 fatorial n = n * fatorial ( n - 1 ) Mas esta defini\u00e7\u00e3o de fatorial tem um problema, que aparece ao se tentar calcular o fatorial de n\u00fameros negativos, que s\u00e3o indefinidos. Neste caso, precisamos impedir que n\u00fameros negativos sejam aceitos pela fun\u00e7\u00e3o, lan\u00e7ando erros. fatorial 0 = 1 fatorial n | n > 0 = n * fatorial ( n - 1 ) | otherwise = error \"Indefinido\" fatorial' 0 = 1 fatorial' n | n > 0 = n * fat ( n - 1 ) fatorial' _ = error \"Indefinido\" Com o seguinte resultado * Main > fat ( - 1 ) *** Exception: Indefinido O exemplo seguinte mostra o uso de padr\u00f5es curinga, constantes e vari\u00e1veis, combinados com guardas e, um caso especial, gerando um erro. Voc\u00ea consegue determinar o que a fun\u00e7\u00e3o faz? pr\u00f3ximos3 :: Int -> Char -> ( Int , Int , Int ) pr\u00f3ximos3 0 _ = ( - 1 , 0 , 1 ) pr\u00f3ximos3 n 'd' | n > 0 = ( n - 1 , n - 2 , n - 3 ) | n < 0 = ( n + 1 , n + 2 , n + 3 ) pr\u00f3ximos3 n 'a' | n < 0 = ( n - 1 , n - 2 , n - 3 ) | n > 0 = ( n + 1 , n + 2 , n + 3 ) pr\u00f3ximos3 _ _ = error \"Use d ou a\" Vejamos outros exemplos, do m\u00f3dulo prelude do Haskell. Primeiro, a fun\u00e7\u00e3o not , que nega o valor passado. not :: Bool -> Bool not True = False not False = True Vejamos agora diferentes defini\u00e7\u00f5es do operador && . Observe que como o operador \u00e9 infixo, a defini\u00e7\u00e3o das equa\u00e7\u00f5es segue esta nota\u00e7\u00e3o, mesmo que a defini\u00e7\u00e3o do prot\u00f3tipo n\u00e3o siga. A primeira defini\u00e7\u00e3o usa somente constantes como padr\u00e3o. Esta defini\u00e7\u00e3o est\u00e1 correta, mas \u00e9 mais complexa do que o necess\u00e1rio, j\u00e1 que somente a primeira equa\u00e7\u00e3o resulta em True . ( && ) Bool -> Bool -> Bool True && True = True True && False = False False && True = False False && False = False Uma vers\u00e3o simplificada pelo uso de padr\u00f5es curinga, seria a seguinte. Observe como ela \u00e9 mais leg\u00edvel. ( && ) Bool -> Bool -> Bool True && True = True _ && _ = False Finalmente, uma terceira vers\u00e3o que usa um padr\u00e3o vari\u00e1vel e um curinga tamb\u00e9m poderia ser usada. ( && ) Bool -> Bool -> Bool True && b = b False && _ = False Como exemplo do casamento em padr\u00f5es em tuplas, relembre as defini\u00e7\u00f5es de fst e snd . fst ( x , _ ) = x snd ( _ , y ) = y Tamb\u00e9m podemos pensar no tipo Pessoa e fun\u00e7\u00f5es associadas, definidos anteriormente. Neste caso, como ficaria uma fun\u00e7\u00e3o que extra\u00edsse apenas o sobrenome de uma pessoa? type Nome = ( String , String , String ) type Telefone = ( String , String ) type CPF = String type Endere\u00e7o = ( String , String , String ) type Pessoa = ( Nome , Telefone , CPF , Endere\u00e7o ) fazPessoa :: Nome -> Telefone -> CPF -> Endere\u00e7o -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> Nome pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> Telefone pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone :: Pessoa -> Telefone -> Pessoa trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) Exerc\u00edcio Seguindo os moldes da defini\u00e7\u00e3o do operador && , defina o operador l\u00f3gico ou || de tr\u00eas formas diferentes. Seguindo os moldes da defini\u00e7\u00e3o do operador && , defina o operador l\u00f3gico ou || de tr\u00eas formas diferentes. Defina 3 fun\u00e7\u00f5es, usando if - then - else , guardas e casamento de padr\u00f5es, que calculem os n\u00fameros da s\u00e9rie de Fibonacci, a saber Fib(1) = 1 Fib(2) = 1 Fib(n) = Fib(n-1) + Fib(n-2) Resolu\u00e7\u00e3o ```hs Surprise! ``` case - of Esta estrutura se assemelha ao switch de linguagens como C e Java, e tem a seguinte sintaxe, onde os padr\u00f5es devem estar perfeitamente alinhados. case expression of pattern -> result pattern -> result pattern -> result Por exemplo, vamos definir uma fun\u00e7\u00e3o que retorne o nome do m\u00eas, dado o seu n\u00famero. Seria poss\u00edvel escreve esta fun\u00e7\u00e3o com if aninhados, assim. nome_mes m = if m == 1 then \"JAN\" else if m == 2 then \"FEB\" else if m == 3 then \"MAR\" ... else if m == 11 then \"NOV\" else \"DEZ\" Usando guardas, ficaria assim: nome_mes m | m == 1 = \"JAN\" | m == 2 = \"FEB\" | m == 3 = \"MAR\" ... | m == 11 = \"NOV\" | otherwise \"DEZ\" Usando case - of , a nomeMes m = case m of 1 -> \"JAN\" m of 2 -> \"FEB\" m of 3 -> \"MAR\" ... m of 11 -> \"NOV\" m of 12 -> \"DEZ\" \u00c9 importante notar que \u00e9 poss\u00edvel aninhar case-of . A fun\u00e7\u00e3o pr\u00f3ximos3 poderia ser reescrita assim. Observe o alinhamento dentro do segundo case. pr\u00f3ximos3''' :: Int -> Char -> ( Int , Int , Int ) pr\u00f3ximos3''' n dir = case n of 0 -> ( - 1 , 0 , 1 ) _ -> case dir of 'd' -> if n > 0 then ( n - 1 , n - 2 , n - 3 ) else ( n + 1 , n + 2 , n + 3 ) 'a' -> if n < 0 then ( n - 1 , n - 2 , n - 3 ) else ( n + 1 , n + 2 , n + 3 ) _ -> error \"Use d ou a\" O termo em ingl\u00eas \u00e9 bind . \u21a9","title":"Padr\u00f5es"},{"location":"pattern_matching/#casamento-de-padroes","text":"Quando especificamos a lista de par\u00e2metros formais que uma fun\u00e7\u00e3o recebe, estamos dizendo ao compilador que os par\u00e2metros passados na invoca\u00e7\u00e3o da fun\u00e7\u00e3o devem ser associados aos par\u00e2metros formais. Por exemplo, considere a seguinte defini\u00e7\u00e3o de uma fun\u00e7\u00e3o que soma dois pontos soma2n x y = x + y e sua invoca\u00e7\u00e3o. > soma2n 3 4 7 Quando a invoca\u00e7\u00e3o acontece, o valor 3 \u00e9 associado a x e 4 a y . O mesmo acontece para qualquer tipo de par\u00e2metro passado, mesmo tuplas e, como veremos depois, listas. Por exemplo, considere a soma de dois pontos em um espa\u00e7o bidimensional, em que pontos s\u00e3o especificados como tuplas de aridade 2. type Ponto = ( Integer , Integer ) soma2v :: Ponto -> Ponto -> Ponto soma2v ponto1 ponto2 = ( fst ponto1 + fst ponto2 , snd ponto1 + snd ponto2 ) Um dos problemas deste c\u00f3digo \u00e9 a necessidade de usar fst e snd para extrair os componentes das tuplas. Mas como vimos na se\u00e7\u00e3o sobre tuplas , \u00e9 poss\u00edvel associar as componentes das tuplas diretamente a vari\u00e1veis. Por exemplo, considere a defini\u00e7\u00e3o alternativa para soma2v . type Ponto = ( Integer , Integer ) soma2v :: Ponto -> Ponto -> Ponto soma2v ( x1 , y1 ) ( x2 , y2 ) = ( x1 + x2 , y1 + y2 ) Observe que, na linha 4, as coordenadas dos pontos passados s\u00e3o associados \u00e0s vari\u00e1veis x1, y1, x2 e y2 . O termo correto para o que est\u00e1 acontecendo ali \u00e9 casamento de padr\u00f5es .","title":"Casamento de Padr\u00f5es"},{"location":"pattern_matching/#tipos-de-padrao","text":"O casamento de padr\u00f5es \u00e9 o processo pelo qual os valores em uma express\u00e3o s\u00e3o decompostos e associados aos elementos de um padr\u00e3o . Em outras palavras, dada uma express\u00e3o e um padr\u00e3o, \u00e9 feita uma tentativa de decomposi\u00e7\u00e3o da express\u00e3o de acordo com o especificado pelo padr\u00e3o. Se a decomposi\u00e7\u00e3o \u00e9 bem sucedida, isto \u00e9, se a express\u00e3o e o padr\u00e3o tem exatamente o mesmo tipo e se constantes especificadas no padr\u00e3o tem o mesmo valor na mesma posi\u00e7\u00e3o da express\u00e3o, ent\u00e3o o casamento \u00e9 bem sucedido ; caso contr\u00e1rio, o casamento fracassa . \u00c9 mais f\u00e1cil entender a descri\u00e7\u00e3o de casamento de padr\u00f5es acima usando exemplos. Para isso, vamos dividir os padr\u00f5es em alguns tipos e analisar exemplos de cada um destes tipos.","title":"Tipos de Padr\u00e3o"},{"location":"pattern_matching/#definicao-de-funcoes","text":"Al\u00e9m de decompor os par\u00e2metros passados para um fun\u00e7\u00e3o e como mencionado anteriormente , casamento de padr\u00f5es pode ser usado na defini\u00e7\u00e3o de fun\u00e7\u00f5es para simplificar testes via if-then-else e guardas nos par\u00e2metros da fun\u00e7\u00e3o. Neste caso, a fun\u00e7\u00e3o \u00e9 definida como uma sequ\u00eancia de equa\u00e7\u00f5es em que s\u00e3o feitas tentativas sucessivas de casamento de padr\u00f5es, na ordem das defini\u00e7\u00f5es. O resultado da invoca\u00e7\u00e3o da fun\u00e7\u00e3o \u00e9 dado pela primeira equa\u00e7\u00e3o em que houver um casamento bem sucedido e todas as guardas forem satisfeitas. Se ao final n\u00e3o houver casamento ou se as guardas n\u00e3o forem satisfeitas, ocorre um erro de execu\u00e7\u00e3o . Para come\u00e7ar, vejamos uma defini\u00e7\u00e3o sem guardas, revisitando a fun\u00e7\u00e3o nomeMes . Usando casamento de padr\u00f5es constantes, ela ficaria assim: nomeMes 1 = \"JAN\" nomeMes 2 = \"FEB\" nomeMes 3 = \"ABR\" nomeMes 4 = \"MAR\" nomeMes 5 = \"MAI\" nomeMes 6 = \"JUN\" nomeMes 7 = \"JUL\" nomeMes 8 = \"AGO\" nomeMes 9 = \"SET\" nomeMes 10 = \"OUT\" nomeMes 11 = \"NOV\" nomeMes 12 = \"DEZ\" Esta fun\u00e7\u00e3o funciona especificamente para valores na faixa [1,12] e retornar\u00e1 um erro para qualquer valor fora da mesma. * Main > nomeMes 13 \"*** Exception: scratch.hs:(112,1)-(123,18): Non-exhaustive patterns in function nomeMes \u00c9 poss\u00edvel usar uma defini\u00e7\u00e3o gen\u00e9rica catch-all para casar com valores n\u00e3o espec\u00edficos usando um padr\u00e3o vari\u00e1vel. Por exemplo, a defini\u00e7\u00e3o da fun\u00e7\u00e3o fatorial tem um tratamento especial para 0, via padr\u00e3o constante, e um caso gen\u00e9rico para qualquer outro n\u00famero, via padr\u00e3o vari\u00e1vel. fatorial 0 = 1 fatorial n = n * fatorial ( n - 1 ) Mas esta defini\u00e7\u00e3o de fatorial tem um problema, que aparece ao se tentar calcular o fatorial de n\u00fameros negativos, que s\u00e3o indefinidos. Neste caso, precisamos impedir que n\u00fameros negativos sejam aceitos pela fun\u00e7\u00e3o, lan\u00e7ando erros. fatorial 0 = 1 fatorial n | n > 0 = n * fatorial ( n - 1 ) | otherwise = error \"Indefinido\" fatorial' 0 = 1 fatorial' n | n > 0 = n * fat ( n - 1 ) fatorial' _ = error \"Indefinido\" Com o seguinte resultado * Main > fat ( - 1 ) *** Exception: Indefinido O exemplo seguinte mostra o uso de padr\u00f5es curinga, constantes e vari\u00e1veis, combinados com guardas e, um caso especial, gerando um erro. Voc\u00ea consegue determinar o que a fun\u00e7\u00e3o faz? pr\u00f3ximos3 :: Int -> Char -> ( Int , Int , Int ) pr\u00f3ximos3 0 _ = ( - 1 , 0 , 1 ) pr\u00f3ximos3 n 'd' | n > 0 = ( n - 1 , n - 2 , n - 3 ) | n < 0 = ( n + 1 , n + 2 , n + 3 ) pr\u00f3ximos3 n 'a' | n < 0 = ( n - 1 , n - 2 , n - 3 ) | n > 0 = ( n + 1 , n + 2 , n + 3 ) pr\u00f3ximos3 _ _ = error \"Use d ou a\" Vejamos outros exemplos, do m\u00f3dulo prelude do Haskell. Primeiro, a fun\u00e7\u00e3o not , que nega o valor passado. not :: Bool -> Bool not True = False not False = True Vejamos agora diferentes defini\u00e7\u00f5es do operador && . Observe que como o operador \u00e9 infixo, a defini\u00e7\u00e3o das equa\u00e7\u00f5es segue esta nota\u00e7\u00e3o, mesmo que a defini\u00e7\u00e3o do prot\u00f3tipo n\u00e3o siga. A primeira defini\u00e7\u00e3o usa somente constantes como padr\u00e3o. Esta defini\u00e7\u00e3o est\u00e1 correta, mas \u00e9 mais complexa do que o necess\u00e1rio, j\u00e1 que somente a primeira equa\u00e7\u00e3o resulta em True . ( && ) Bool -> Bool -> Bool True && True = True True && False = False False && True = False False && False = False Uma vers\u00e3o simplificada pelo uso de padr\u00f5es curinga, seria a seguinte. Observe como ela \u00e9 mais leg\u00edvel. ( && ) Bool -> Bool -> Bool True && True = True _ && _ = False Finalmente, uma terceira vers\u00e3o que usa um padr\u00e3o vari\u00e1vel e um curinga tamb\u00e9m poderia ser usada. ( && ) Bool -> Bool -> Bool True && b = b False && _ = False Como exemplo do casamento em padr\u00f5es em tuplas, relembre as defini\u00e7\u00f5es de fst e snd . fst ( x , _ ) = x snd ( _ , y ) = y Tamb\u00e9m podemos pensar no tipo Pessoa e fun\u00e7\u00f5es associadas, definidos anteriormente. Neste caso, como ficaria uma fun\u00e7\u00e3o que extra\u00edsse apenas o sobrenome de uma pessoa? type Nome = ( String , String , String ) type Telefone = ( String , String ) type CPF = String type Endere\u00e7o = ( String , String , String ) type Pessoa = ( Nome , Telefone , CPF , Endere\u00e7o ) fazPessoa :: Nome -> Telefone -> CPF -> Endere\u00e7o -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> Nome pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> Telefone pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone :: Pessoa -> Telefone -> Pessoa trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) Exerc\u00edcio Seguindo os moldes da defini\u00e7\u00e3o do operador && , defina o operador l\u00f3gico ou || de tr\u00eas formas diferentes. Seguindo os moldes da defini\u00e7\u00e3o do operador && , defina o operador l\u00f3gico ou || de tr\u00eas formas diferentes. Defina 3 fun\u00e7\u00f5es, usando if - then - else , guardas e casamento de padr\u00f5es, que calculem os n\u00fameros da s\u00e9rie de Fibonacci, a saber Fib(1) = 1 Fib(2) = 1 Fib(n) = Fib(n-1) + Fib(n-2) Resolu\u00e7\u00e3o ```hs Surprise! ```","title":"Defini\u00e7\u00e3o de Fun\u00e7\u00f5es"},{"location":"preface/","text":"Pref\u00e1cio O paradigma de funcional \u00e9 um dos muitos paradigmas de programa\u00e7\u00e3o dispon\u00edveis e, uma vez que voc\u00ea tenha sido \"contaminado\" pelos outros, certamente n\u00e3o \u00e9 o mais simples de se entender. Ainda assim, \u00e9 um paradigma que deve ser estudado pois seus pontos fortes tem sido incorporados cada vez mais frequentemente em frameworks e linguagens n\u00e3o necessariamente reconhecidos como funcionais. Por isso, neste curso estudaremos o paradigma funcional de uma forma pr\u00e1tica, tentando sempre que poss\u00edvel mostrar diversas aplica\u00e7\u00f5es das ideias apresentadas no mundo da programa\u00e7\u00e3o moderna. Tamb\u00e9m ser\u00e1 foco deste curso, destacar e demonstrar como o uso do paradigma funcional traz vantagens no desenvolvimento de sistemas paralelos e distribu\u00eddos. Agradecimentos Antes de come\u00e7armos nosso estudo, deixo aqui o meu agradecimento aos professores que forneceram o material sobre o qual estas notas de aula s\u00e3o baseadas, Profa. Gina Maira B. Oliveira, Profa. Maria Adriana Vidigal de Lima, e Prof. Henrique Fernandes, da Faculdade de Computa\u00e7\u00e3o da UFU. Conven\u00e7\u00f5es Neste documento, usamos diversos recursos visuais com diferentes prop\u00f3sitos. it\u00e1lico indica termos em outras l\u00ednguas, como framework ou middleware . Alguns termos, contudo, s\u00e3o t\u00e3o corriqueiramente usados que me escapam quando escrevendo e acabam n\u00e3o grafados corretamente. negrito indica a introdu\u00e7\u00e3o de termos e conceitos importantes, como escalabilidade e falha . Apontadores indicam um s\u00edtio relacionado ao termo, por exemplo, como criar um reposit\u00f3rio no Github , e cuja leitura \u00e9 sugerida ao final da aula. Notas de rodap\u00e9, indicam uma observa\u00e7\u00e3o importante sobre o que est\u00e1 sendo apresentado, cuja leitura \u00e9 sugerida ao final do par\u00e1grafo. 1 Estas notas incluem referenciais te\u00f3ricos importantes, com detalhes da publica\u00e7\u00e3o e apontadores para onde a publica\u00e7\u00e3o pode ser lida. Imagens n\u00e3o autorais s\u00e3o tamb\u00e9m apontadores para onde s\u00e3o encontradas e tem como texto alternativo as informa\u00e7\u00f5es da autoria. Caixas alinhadas \u00e0 esquerda s\u00e3o usadas para v\u00e1rias finalidades. Por exemplo, para apresentar exerc\u00edcios, destacar especifica\u00e7\u00f5es, apontar tarefas a serem executas por mim. Os diversos usos s\u00e3o indicados nos \u00edcones e cores das caixas. Exerc\u00edcio Isso \u00e9 um exerc\u00edcio! Resposta Esta \u00e9 a resposta do exerc\u00edcio. Resumo Elementos visuais Aviso! Este material est\u00e1 em constante evolu\u00e7\u00e3o. Caixas alinhadas \u00e0 direita podem ser vistas como um sum\u00e1rio executivo do que est\u00e1 sendo apresentado no texto adjacente. Exemplo de nota de rodap\u00e9. \u21a9","title":"Pref\u00e1cio"},{"location":"preface/#prefacio","text":"O paradigma de funcional \u00e9 um dos muitos paradigmas de programa\u00e7\u00e3o dispon\u00edveis e, uma vez que voc\u00ea tenha sido \"contaminado\" pelos outros, certamente n\u00e3o \u00e9 o mais simples de se entender. Ainda assim, \u00e9 um paradigma que deve ser estudado pois seus pontos fortes tem sido incorporados cada vez mais frequentemente em frameworks e linguagens n\u00e3o necessariamente reconhecidos como funcionais. Por isso, neste curso estudaremos o paradigma funcional de uma forma pr\u00e1tica, tentando sempre que poss\u00edvel mostrar diversas aplica\u00e7\u00f5es das ideias apresentadas no mundo da programa\u00e7\u00e3o moderna. Tamb\u00e9m ser\u00e1 foco deste curso, destacar e demonstrar como o uso do paradigma funcional traz vantagens no desenvolvimento de sistemas paralelos e distribu\u00eddos.","title":"Pref\u00e1cio"},{"location":"preface/#agradecimentos","text":"Antes de come\u00e7armos nosso estudo, deixo aqui o meu agradecimento aos professores que forneceram o material sobre o qual estas notas de aula s\u00e3o baseadas, Profa. Gina Maira B. Oliveira, Profa. Maria Adriana Vidigal de Lima, e Prof. Henrique Fernandes, da Faculdade de Computa\u00e7\u00e3o da UFU.","title":"Agradecimentos"},{"location":"preface/#convencoes","text":"Neste documento, usamos diversos recursos visuais com diferentes prop\u00f3sitos. it\u00e1lico indica termos em outras l\u00ednguas, como framework ou middleware . Alguns termos, contudo, s\u00e3o t\u00e3o corriqueiramente usados que me escapam quando escrevendo e acabam n\u00e3o grafados corretamente. negrito indica a introdu\u00e7\u00e3o de termos e conceitos importantes, como escalabilidade e falha . Apontadores indicam um s\u00edtio relacionado ao termo, por exemplo, como criar um reposit\u00f3rio no Github , e cuja leitura \u00e9 sugerida ao final da aula. Notas de rodap\u00e9, indicam uma observa\u00e7\u00e3o importante sobre o que est\u00e1 sendo apresentado, cuja leitura \u00e9 sugerida ao final do par\u00e1grafo. 1 Estas notas incluem referenciais te\u00f3ricos importantes, com detalhes da publica\u00e7\u00e3o e apontadores para onde a publica\u00e7\u00e3o pode ser lida. Imagens n\u00e3o autorais s\u00e3o tamb\u00e9m apontadores para onde s\u00e3o encontradas e tem como texto alternativo as informa\u00e7\u00f5es da autoria. Caixas alinhadas \u00e0 esquerda s\u00e3o usadas para v\u00e1rias finalidades. Por exemplo, para apresentar exerc\u00edcios, destacar especifica\u00e7\u00f5es, apontar tarefas a serem executas por mim. Os diversos usos s\u00e3o indicados nos \u00edcones e cores das caixas. Exerc\u00edcio Isso \u00e9 um exerc\u00edcio! Resposta Esta \u00e9 a resposta do exerc\u00edcio. Resumo Elementos visuais Aviso! Este material est\u00e1 em constante evolu\u00e7\u00e3o. Caixas alinhadas \u00e0 direita podem ser vistas como um sum\u00e1rio executivo do que est\u00e1 sendo apresentado no texto adjacente. Exemplo de nota de rodap\u00e9. \u21a9","title":"Conven\u00e7\u00f5es"},{"location":"project/","text":"Nada melhor que um bom projeto para fixar e colocar \u00e0 prova o que estamos aprendendo, e nada melhor que unir o \u00fatil ao agrad\u00e1vel na hora de escolher um projeto. Neste semestre, o projeto que desenvolver\u00e3o \u00e9 um clone de um cl\u00e1ssico dos jogos de computadores, Bomberman ! Bom, n\u00e3o exatamente um clone, mas os rudimentos de um clone. Ainda assim, o projeto n\u00e3o \u00e9 trivial e por isso vamos divid\u00ed-lo em etapas para gerenciar a complexidade. De forma geral, podemos dividir o projeto em duas etapas: Etapa 1 Estruturas de dados para representa\u00e7\u00e3o dos elementos do jogo usando listas Uso de tipos primitivos para representa\u00e7\u00e3o do estado e dos elementos do jogo. Uso de type Fun\u00e7\u00f5es de manipula\u00e7\u00e3o das estruturas Etapa 2 Uso de tipos definidos pelo usu\u00e1rio para representa\u00e7\u00e3o do estado e dos elementos do jogo. Uso de data Tipos alg\u00e9bricos Fun\u00e7\u00f5es de manipula\u00e7\u00e3o das estruturas Visualiza\u00e7\u00e3o do tabuleiro Movimenta\u00e7\u00e3o de (pelo menos) um bomberman pelo tabuleiro usando o teclado Etapa 1 O jogo bomberman acontece em um \"tabuleiro\" onde os v\u00e1rios jogadores, bombermen de diversas cores, tentam explodir os seus competidores at\u00e9 serem os \u00fanicos restantes no jogo. No processo, os competidores se movimentam pelo tabuleiro explodindo barreiras e coletando presentes que lhes conferem habilidades, como aumentar a quantidade de bombas que cada um pode colocar no tabuleiro concorrentemente, aumentar a velocidade de deslocamento, arremessar bombas em posi\u00e7\u00f5es adjacentes no mapa, ou aumentar o alcance das explos\u00f5es. Uma explos\u00e3o segue em linha reta nas quatro dire\u00e7\u00f5es (norte, sul, leste e oeste) at\u00e9 que encontre algum obst\u00e1culo, que pode ou n\u00e3o ser destru\u00eddo pela explos\u00e3o. Tabuleiro Um tabuleiro de pode ser visto como uma matriz em que cada c\u00e9lula \u00e9 uma pilha de elementos. Para representar a matriz do tabuleiro, usaremos uma tupla de tuplas. Assim, defina as seguintes estruturas de dados. Tabuleiro \u00e9 uma tupla com 8 Linha. Linha \u00e9 uma tupla com 8 C\u00e9lula. C\u00e9lula \u00e9 uma pilha com 4 Item C\u00e9lula e Items Cada posi\u00e7\u00e3o do tabuleiro \u00e9 uma c\u00e9lula e contem uma pilha de itens. Use uma lista para representar a pilha. Em nosso prot\u00f3tipo, os seguintes items podem estar presentes na c\u00e9lula: grama presente_patins presente_arremesso bomba jogador_X Algumas regras devem ser respeitadas pela pilha, onde \"sobre\" quer dizer imediatamente subsequente acima na pilha. uma pilha vazia \u00e9 um buraco no tabuleiro grama s\u00f3 pode estar na base da pilha presente s\u00f3 pode estar sobre grama parede s\u00f3 pode estar na base da pilha, sobre grama ou sobre presente pedra s\u00f3 pode estar na base da pilha bomba s\u00f3 pode estar sobre grama jogador s\u00f3 pode estar sobre grama Jogador Para cada jogador, voc\u00ea precisa manter algumas informa\u00e7\u00f5es extra como: identificador (o X que aparece no Item jogador_X) localiza\u00e7\u00e3o - \u00e9 uma tupla com coordenadas X e Y do tipo Int que representam a linha e coluna em o item jogador_X correspondente est\u00e1. dire\u00e7\u00e3o - \u00e9 um caractere que indica para onde on jogador est\u00e1 olhando. 'N', 'S', 'L' e 'O' capacidades - \u00e9 uma tupla com 3 elementos com um dos seguintes valores, onde a, b e c s\u00e3o Int (Patins,a) (Bomba,b) (Arremesso,c) Fun\u00e7\u00f5es O jogo s\u00f3 tem gra\u00e7a se tiver alguma coisa acontecendo nele. Nesta primeira etapa, voc\u00ea desenvolver\u00e1 as fun\u00e7\u00f5es que permitir\u00e3o criar e manipular os elementos do jogo, de acordo com algumas regras, para as seguintes funcionalidades: Cria\u00e7\u00e3o de um tabuleiro Fun\u00e7\u00e3o receba uma lista de listas de items e constr\u00f3i um tabuleiro v\u00e1lido. Movimenta\u00e7\u00e3o de um jogador em qualquer dos sentidos Fun\u00e7\u00e3o que receba um tabuleiro e uma instru\u00e7\u00e3o de movimenta\u00e7\u00e3o de um jogador e retorne um novo tabuleiro, com o jogador na nova posi\u00e7\u00e3o. Jogador s\u00f3 pode se deslocar para c\u00e9lula adjacente que n\u00e3o tenha pedra ou bomba Pode ser imposs\u00edvel ao jogador se deslocar Ao se deslocar para uma c\u00e9lula vazia, cai no buraco Ao se deslocar para uma c\u00e9lula com um presente, o coleta Coleta de presente Ao coletar um presente, incrementa a posi\u00e7\u00e3o correspondente ao presente nas suas capacidades Arremesso Se estiver adjacente, olhando para uma bomba, e tiver a capacidade \"arremesso\", o jogador arremessa a bomba uma dist\u00e2ncia proporcional \u00e0 capacidade. Teste de dire\u00e7\u00e3o Explos\u00e3o Dire\u00e7\u00e3o Capacidade Elimina\u00e7\u00e3o de presentes Elimina\u00e7\u00e3o de pedra Elimina\u00e7\u00e3o de jogador Detec\u00e7\u00e3o de fim de jogo Voc\u00eas s\u00e3o livres para preencher as lacunas da especifica\u00e7\u00e3o de forma razo\u00e1vel. Na d\u00favida, me pergunte.","title":"Projeto"},{"location":"project/#etapa-1","text":"O jogo bomberman acontece em um \"tabuleiro\" onde os v\u00e1rios jogadores, bombermen de diversas cores, tentam explodir os seus competidores at\u00e9 serem os \u00fanicos restantes no jogo. No processo, os competidores se movimentam pelo tabuleiro explodindo barreiras e coletando presentes que lhes conferem habilidades, como aumentar a quantidade de bombas que cada um pode colocar no tabuleiro concorrentemente, aumentar a velocidade de deslocamento, arremessar bombas em posi\u00e7\u00f5es adjacentes no mapa, ou aumentar o alcance das explos\u00f5es. Uma explos\u00e3o segue em linha reta nas quatro dire\u00e7\u00f5es (norte, sul, leste e oeste) at\u00e9 que encontre algum obst\u00e1culo, que pode ou n\u00e3o ser destru\u00eddo pela explos\u00e3o.","title":"Etapa 1"},{"location":"prova/","text":"Prova. https://haskell.mooc.fi/part1#a-word-about-type-inference-and-polymorphism -- given a sentence, decide whether it is a statement, question or exclamation sentenceType :: String -> String sentenceType sentence = case last sentence of '.' -> \"statement\" '?' -> \"question\" '!' -> \"exclamation\" _ -> \"not a sentence\" -- same function, helper function instead of case-of sentenceType sentence = classify (last sentence) where classify '.' = \"statement\" classify '?' = \"question\" classify '!' = \"exclamation\" classify _ = \"not a sentence\"","title":"Prova"},{"location":"quickcheck/","text":"Agora que nossas fun\u00e7\u00f5es est\u00e3o ficando mais complexas, precisamos gastar um pouco mais de esfor\u00e7o nos certificando de que est\u00e3o corretas. Uma ferramenta que nos ajuda a fazer isso \u00e9 a biblioteca QuickCheck . Para entender como usar a QuickCheck, considere as duas seguintes fun\u00e7\u00f5es. celsius2fahrenheit c = c * 9 / 5 + 32 fahrenheit2celsius f = ( f - 32 ) * 5 / 9 Elas s\u00e3o obviamente inversas uma da outra, o que quer dizer que se eu aplicar um valor qualquer \u00e0 primeira fun\u00e7\u00e3o e ent\u00e3o aplicar resultado na segunda, eu deveria recuperar o valor original. Por exemplo, se o valor qualquer \u00e9 100, 100 == fahrenheit2celsius ( celsius2fahrenheit 100 ) . Pois a QuickCheck nos permite escrever exatamente este tipo de afirma\u00e7\u00e3o e t\u00ea-la testada automaticamente para um conjunto de valores aleat\u00f3rios. Obviamente, mesmo se o c\u00f3digo passar nos testes gerados pelo QuickCheck, n\u00e3o quer dizer que outros valores n\u00e3o resultariam em erros. Contudo, nossa confian\u00e7a na corretude aumentaria. Para testar as fun\u00e7\u00f5es acima escrever\u00edamos ent\u00e3o a propriedade como uma fun\u00e7\u00e3o que retorna um booleano. A propriedade tem um nome iniciado em prop_ , mas isso \u00e9 apenas uma conven\u00e7\u00e3o. A defini\u00e7\u00e3o recebe como par\u00e2metro um valor c , converte para Celcius e de volta para Fahrenheit, e confere se o valor resultante \u00e9 igual ao valor de entrada. Observe que o resultado da fun\u00e7\u00e3o \u00e9 o resultado da compara\u00e7\u00e3o com o valor inicial, o que \u00e9 equivalente mas muito mais limpo do que fazer um teste do tipo if Condi\u00e7\u00e3o then True else False . prop_C2f2C c = fahrenheit2celsius ( celsius2fahrenheit c ) == c Para usar a biblioteca, precisamos import\u00e1-la, no in\u00edcio do arquivo, com um import Test.QuickCheck . Assim, o arquivo ficar\u00e1 assim. import Test.QuickCheck celsius2fahrenheit c = c * 9 / 5 + 32 fahrenheit2celsius f = ( f - 32 ) * 5 / 9 prop_C2f2C c = fahrenheit2celsius ( celsius2fahrenheit c ) == c Para testar o c\u00f3digo, execute o ghci carregando o QuickCheck. A forma mais simples de faz\u00ea-lo \u00e9 usando stack: stack ghci --package QuickCheck . Agora carregue seu programa, usando :l f2c2f no meu caso e execute o teste *Main> quickCheck prop_C2f2C *** Failed! Falsified (after 2 tests and 4 shrinks): -0.1 Ooops! O teste falhou para o valor -0.1. Mas por qu\u00ea? Vejamos cada fun\u00e7\u00e3o isoladamente. *Main> celsius2fahrenheit (-0.1) 31.82 *Main> fahrenheit2celsius 31.82 -9.999999999999984e-2 Os valores s\u00e3o pr\u00f3ximos, mas n\u00e3o s\u00e3o iguais, por causa de problemas de arredondamento causados pela imprecis\u00e3o dos tipos utilizados. O problema est\u00e1 no teste, pois \u00e9 imposs\u00edvel para o computador representar certos valores e estes erros de aproxima\u00e7\u00e3o ocorrer\u00e3o. Assim, uma estrat\u00e9gia melhor \u00e9 definir um operador quase igual , para comparar valores com pequenos erros. import Test.QuickCheck celsius2fahrenheit c = c * 9 / 5 + 32 fahrenheit2celsius f = ( f - 32 ) * 5 / 9 prop_C2f2C c = fahrenheit2celsius ( celsius2fahrenheit c ) ~== c l ~== r = abs ( l - r ) < \u03b5 where \u03b5 = 10e-10 Com esta nova defini\u00e7\u00e3o, nosso teste agora passa com sucesso. *Main> quickCheck prop_C2f2C +++ OK, passed 100 tests.","title":"Quick, Check!"},{"location":"recursion/","text":"Recursividade Uma fun\u00e7\u00e3o \u00e9 dita recursiva quando ela \u00e9 definida em termos de si mesma . Estas fun\u00e7\u00f5es s\u00e3o muito importantes tanto na matem\u00e1tica, onde s\u00e3o tamb\u00e9m conhecidas como recorr\u00eancias . Por exemplo, vejamos como \u00e9 definido um exemplo recorrentes de fun\u00e7\u00e3o na computa\u00e7\u00e3o ( pun intended ) de forma recursiva, o c\u00e1lculo do fatorial de um n\u00famero. Considere a seguinte defini\u00e7\u00e3o. \\[ n! = \\begin{cases} 1 & \\text{se } n = 0\\\\ n * (n-1)! & \\text{se } n > 0 \\end{cases} \\] Por esta defini\u00e7\u00e3o, podemos calcular o fatorial de 4, por exemplo, assim. \\[ \\begin{align} 4! &= 4 * (4-1)! \\\\ &= 4 * (3 * (3-1)!) \\\\ &= 4 * (3 * (2 * (2-1)!)) \\\\ &= 4 * (3 * (2 * (1 * (1-1)!))) \\\\ &= 4 * (3 * (2 * (1 * 0!))) \\\\ &= 4 * (3 * (2 * (1 * 1))) \\\\ &= 4 * (3 * (2 * 1)) \\\\ &= 4 * (3 * 2) \\\\ &= 4 * 6 \\\\ &= 24 \\end{align} \\] Na computa\u00e7\u00e3o, as fun\u00e7\u00f5es recursivas s\u00e3o importantes por serem uma estrat\u00e9gia de resolu\u00e7\u00e3o de problemas , pois possibilitam resolver problemas pouco a pouco, e especialmente importantes na programa\u00e7\u00e3o funcional, onde servem de alternativa \u00e0s instru\u00e7\u00f5es de itera\u00e7\u00e3o como for (;;) e while () , comuns nas linguagens imperativas. Em Haskell N\u00e3o h\u00e1 nada de especial em termos de sintaxe na declara\u00e7\u00e3o de fun\u00e7\u00f5es recursivas. O c\u00e1lculo do fatorial pode ser traduzido quase que diretamente para Haskell usando guardas. fatorialGuardas n | n == 0 = 1 | otherwise = n * fatorialGuardas ( n - 1 ) Observe que a defini\u00e7\u00e3o \u00e9 iniciada tratando o caso em que 0 \u00e9 passado como par\u00e2metro; este \u00e9 o que chamamos de caso base , que serve para limitar a recurs\u00e3o e impedir que execute para sempre. J\u00e1 o que torna a fun\u00e7\u00e3o recursiva acontece na \u00faltima linha: a invoca\u00e7\u00e3o da pr\u00f3pria fun\u00e7\u00e3o. Como esta invoca\u00e7\u00e3o ser\u00e1 feita para o valor passado como par\u00e2metro menos 1, temos a garantia de que, para qualquer n\u00famero positivo passado como par\u00e2metro, em algum momento haver\u00e1 uma invoca\u00e7\u00e3o da fun\u00e7\u00e3o com o par\u00e2metro igual a 0 , que ser\u00e1 respondida pelo caso base. \u00c9 importante ficar claro que para cada invoca\u00e7\u00e3o da fun\u00e7\u00e3o, \\(n\\) assume um valor diferente, o que pode fazer parecer que o valor de \\(n\\) est\u00e1 mudando, mas isso n\u00e3o poderia estar mais longe da verdade! Cada \\(n\\) s\u00f3 existe no escopo de uma invoca\u00e7\u00e3o da fun\u00e7\u00e3o. Pictograficamente, \\(n\\) s\u00f3 \u00e9 vis\u00edvel dentro da \"caixinha\" onde foi associada a um valor. Outra forma absolutamente equivalente de definir a fun\u00e7\u00e3o \u00e9 usando casamento de padr\u00f5es, como a seguir. fatorialPM 0 = 1 fatorialPM n = n * fatorialPM ( n - 1 ) Considerando as duas defini\u00e7\u00f5es da fun\u00e7\u00e3o, considere o que acontece se as mesmas forem invocadas com um n\u00famero negativo como par\u00e2metro. O que acontece? A recurs\u00e3o simplesmente \"nunca\" termina, continuando com \\(n\\) indo para o - infinito. Acontece que n\u00e3o \u00e9 definido o fatorial de n\u00fameros negativos e, por isso, precisamos que um erro seja lan\u00e7ado quando uma tentativa de invoca\u00e7\u00e3o deste tipo ocorrer. H\u00e1 diferentes formas de se lan\u00e7ar um erro, sendo a primeira simplesmente limitar os valores v\u00e1lidos para os par\u00e2metros. fatorialGuardas n | n == 0 = 1 | n > 0 = n * fatorialGuardas ( n - 1 ) A outra alternativa \u00e9 explicitamente causar um erro. fatorialGuardas' n | n == 0 = 1 | n > 0 = n * fatorialGuardas' ( n - 1 ) | otherwise = error \"N\u00e3o se pode calcular o fatorial de n\u00fameros negativos\" fatorialGuardas'' n | n == 0 = 1 | otherwise = if n > 0 then n * fatorialGuardas'' ( n - 1 ) else error \"N\u00e3o se pode calcular o fatorial de n\u00fameros negativos\" Fun\u00e7\u00f5es Recursivas Caso base - Limita recurs\u00e3o. Caso geral - Faz chamada recursiva para problema \" menor \" Note que em ambas as formas, temos algumas defini\u00e7\u00f5es simples, os casos base , que n\u00e3o fazem recurs\u00e3o, e os casos recursivos , envolvem recurs\u00e3o. Este padr\u00e3o se repetir\u00e1 praticamente sempre nas defini\u00e7\u00f5es recursivas, o que n\u00e3o quer dizer que a defini\u00e7\u00e3o ser\u00e1 \u00f3bvia. M\u00e1ximo Divisor Comum O m\u00e1ximo divisor comum de dois n\u00fameros \u00e9, bem, o maior dentre os divisores comuns. Por exemplo, considere os n\u00fameros 18 e 12: j\u00e1 que o 18 tem como divisores {18, 9, 6, 3, 2, 1} e o 12 tem {12, 6, 4, 3, 2, 1}, o maior dentre os divisores comuns \u00e9 6, isto \u00e9, o mdc(18,12) = 6. Logo, se quisermos implementar uma fun\u00e7\u00e3o que calcule o mdc, podemos come\u00e7ar por encontrar o conjunto de divisores, usando uma recurs\u00e3o, e ent\u00e3o iterar pelos conjuntos para identificar o maior comum, com outra recurs\u00e3o. Enquanto esta abordagem \u00e9 um bom exerc\u00edcio de manipula\u00e7\u00e3o de listas, se o objetivo \u00e9 calcular o mdc de forma recursiva, h\u00e1 uma abordagem melhor, conhecida como o algoritmo de Euclides . De forma direta, este algoritmo pode ser expresso como a seguinte fun\u00e7\u00e3o recursiva, onde \\(a >= b\\) \\[ mdc(a,b) = \\begin{cases} a & \\text{se } b = 0\\\\ \\text{mdc}(b, a \\text{ mod } b) & \\text{caso contr\u00e1rio } \\end{cases} \\] Em Haskell, a defini\u00e7\u00e3o fica assim. mdc :: Integer -> Integer -> Integer mdc a b | b == 0 = a | otherwise = mdc b ( a ` mod ` b ) Fibonacci Considere a fun\u00e7\u00e3o que retorna um termo da sequ\u00eancia de Fibonacci, em que os dois primeiros termos s\u00e3o 1 e todos os outros termos s\u00e3o iguais \u00e0 soma dos dois termos anteriores. \\[ F(n) = \\begin{cases} 1 & \\text{se } n = 1\\\\ 1 & \\text{se } n = 2\\\\ F(n-1) + F(n - 2) & \\text{se } n > 2 \\end{cases} \\] A mesma tradu\u00e7\u00e3o direta da defini\u00e7\u00e3o matem\u00e1tica para Haskell tamb\u00e9m pode ser feita aqui, sendo a \u00fanica diferen\u00e7a o fato de que duas invoca\u00e7\u00f5es recursivas s\u00e3o feitas a cada passo. H\u00e1, contudo, diversas possibilidades de tradu\u00e7\u00e3o. fibIf n = if n == 1 then 1 else if n == 2 then 1 else fibIf ( n - 1 ) + fibIf ( n - 2 ) fibGuard n | n == 1 = 1 | n == 2 = 1 | otherwise = fibGuard ( n - 1 ) + fibGuard ( n - 2 ) fibPattern 1 = 1 fibPattern 2 = 1 fibPattern n = fibPattern ( n - 1 ) + fibPattern ( n - 2 ) fibCase x = case x of 1 -> 0 2 -> 1 n -> fibCase ( n - 1 ) + fibCase ( n - 2 ) Conjectura de Collatz Considere a seguinte fun\u00e7\u00e3o para construir uma sequ\u00eancia de n\u00fameros usando \\(n\\) como base. \\[ F_n(i) = \\begin{cases} n & \\text{se } i = 1\\\\ F_n(i-1)/2 & \\text{se } F_n(i-1) \\text{ \u00e9 par}\\\\ F_n(i-1)* 3 + 1 & \\text{se } F_n(i-1) \\text{ \u00e9 \u00edmpar} \\end{cases} \\] Exerc\u00edcio Defina a fun\u00e7\u00e3o acima em Haskell. Segundo a conjectura de Collatz , para qualquer valor de \\(n\\) , em algum momento a sequ\u00eancia converge para o valor 1 e a partir da\u00ed repete infinitamente os termos 4, 2, 1. Por exemplo, para \\(n=7\\) , a sequ\u00eancia \u00e9 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1; para \\(n=12\\) , 12, 6, 3, 10, 5, 16, 8, 4, 2, 1; para \\(n=19\\) , 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1; e, para \\(n=27\\) , 27, 82, 41, 124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1 Esta \u00e9 uma conjectura pois n\u00e3o se sabe se a sequ\u00eancia realmente converge para 1 dado qualquer \\(n\\) . O que voc\u00ea acha de testar alguns valores para tentar identificar h\u00e1 ou n\u00e3o uma converg\u00eancia? Em C, poder\u00edamos fazer o seguinte: int collatz ( int n , int i ){ if ( i == 1 ) return n ; else { int f_n_i_menos_1 = collatz ( n , i -1 ); if ( f_n_i_menos_1 % 2 == 0 ) return f_n_i_menos_1 / 2 ; else f_n_i_menos_1 * 3 + 1 ; } bool converge ( int n ) { bool convergiu = false ; for ( int i = 0 ; ! convergiu ; i ++ ) convergiu = collatz ( n , i ) == 1 ; return convergiu ; } Por mais ineficiente que seja, este c\u00f3digo em C funciona e pode servir de base para uma vers\u00e3o em Haskell, mas como escrever a itera\u00e7\u00e3o? Como dito anteriormente, a itera\u00e7\u00e3o pode ser feita por meio de outra recurs\u00e3o! collatz :: Int -> Int -> Int collatz n i | i == 1 = n | even ( collatz n ( i - 1 )) = collatz n ( i - 1 ) ` div ` 2 | otherwise = collatz n ( i - 1 ) * 3 + 1 converge :: Int -> Bool converge n = convergeInterna n 1 convergeInterna :: Int -> Int -> Bool convergeInterna n passo | collatz n passo == 1 = True | otherwise = convergeInterna n ( passo + 1 ) Vejamos alguns exemplos. * Main > collatz 7 13 16 * Main > collatz 7 17 1 * Main > converge 7 True * Main > converge 12 True * Main > convergeInterna 7 15 True * Main > convergeInterna 7 1 True Tente executar a fun\u00e7\u00e3o para o n\u00famero 27, cuja sequ\u00eancia calculada acima tem 111 passos. Quando seu computador come\u00e7ar a se desesperar ou voc\u00ea cansar de esperar, aperte Ctrl + C . Mas por qu\u00ea esta fun\u00e7\u00e3o t\u00e3o simples ficou t\u00e3o pesada? Por qu\u00ea para calcular se a sequ\u00eancia converge, primeiro a fun\u00e7\u00e3o testou o primeiro termo, 27, e viu que n\u00e3o era igual 1; calculou ent\u00e3o o segundo termo, para isto calculando o primeiro termo novamente, e testando se igual a 1; calculou ent\u00e3o o terceiro termo, para isso calculando o segundo termo, para isso calculando o primeiro, e assim por diante. Al\u00e9m disso, no c\u00e1lculo de cada termo, h\u00e1 um teste para ver se o termo anterior \u00e9 \u00edmpar ou par, o que por si s\u00f3 calcula o termo anterior. Mais tarde veremos como tornar esta fun\u00e7\u00e3o muito mais eficiente, como na vers\u00e3o em C, em que o termo anterior s\u00f3 \u00e9 calculado uma vez, mas por enquanto pensemos em como podemos limitar o n\u00famero de passos nesta itera\u00e7\u00e3o. Exerc\u00edcio Modifique a defini\u00e7\u00e3o da fun\u00e7\u00e3o converge para impedir que execute ad eternum . Dica Use um contador para limitar o n\u00famero de recurs\u00f5es e, no caso do limite ser alcan\u00e7ado, emita um erro. Resolu\u00e7\u00e3o Use um contador para limitar o n\u00famero de recurs\u00f5es e, no caso do limite ser alcan\u00e7ado, emita um erro. collatz :: Int -> Int -> Int collatz n i | i == 1 = n | even ( collatz n ( i - 1 )) = collatz n ( i - 1 ) ` div ` 2 | otherwise = collatz n ( i - 1 ) * 3 + 1 converge :: Int -> Int -> Int -> Bool converge n passo limite | limite == 0 = error \"N\u00e3o alcan\u00e7ou uma resposta\" | collatz n passo == 1 = True | otherwise = converge n ( passo + 1 ) ( limite - 1 ) Binomial H\u00e1 v\u00e1rias maneiras de se calcular o n\u00famero de combina\u00e7\u00f5es que se pode obter com \\(k\\) elementos de um conjunto de \\(n\\) elementos. Uma destas formas \u00e9 via a seguinte recorr\u00eancia. \\[ \\binom{n}{k} = \\begin{cases} \\text{indefinido} & \\text{se} k > n\\\\ 1 & \\text{se } k = 0\\\\ 1 & \\text{se } k = n\\\\ \\binom{n-1}{k} + \\binom{n-1}{k-1} & \\text{caso contr\u00e1rio } \\end{cases} \\] Binomial Implemente uma fun\u00e7\u00e3o recursiva que calcule \\(\\binom{n}{k}\\) Resolu\u00e7\u00e3o A ser implementado Recurs\u00e3o e Listas Fun\u00e7\u00f5es recursivas s\u00e3o particularmente importantes na manipula\u00e7\u00e3o listas, como veremos adiante. Recurs\u00e3o de Cauda A recurs\u00e3o de cauda \u00e9 uma t\u00e9cnica important\u00edssima para melhorar o desempenho de fun\u00e7\u00f5es recursivas ao economizar os recursos do sistema, e ao permitir as recurs\u00f5es possam at\u00e9 ser infinitas, como em la\u00e7os infinitos usados em jogos, por exemplo. Esta t\u00e9cnica ser\u00e1 explorada no futuro, uma vez que j\u00e1 estejam confort\u00e1veis com recurs\u00f5es n\u00e3o otimizadas.","title":"Recurs\u00e3o"},{"location":"recursion/#recursividade","text":"Uma fun\u00e7\u00e3o \u00e9 dita recursiva quando ela \u00e9 definida em termos de si mesma . Estas fun\u00e7\u00f5es s\u00e3o muito importantes tanto na matem\u00e1tica, onde s\u00e3o tamb\u00e9m conhecidas como recorr\u00eancias . Por exemplo, vejamos como \u00e9 definido um exemplo recorrentes de fun\u00e7\u00e3o na computa\u00e7\u00e3o ( pun intended ) de forma recursiva, o c\u00e1lculo do fatorial de um n\u00famero. Considere a seguinte defini\u00e7\u00e3o. \\[ n! = \\begin{cases} 1 & \\text{se } n = 0\\\\ n * (n-1)! & \\text{se } n > 0 \\end{cases} \\] Por esta defini\u00e7\u00e3o, podemos calcular o fatorial de 4, por exemplo, assim. \\[ \\begin{align} 4! &= 4 * (4-1)! \\\\ &= 4 * (3 * (3-1)!) \\\\ &= 4 * (3 * (2 * (2-1)!)) \\\\ &= 4 * (3 * (2 * (1 * (1-1)!))) \\\\ &= 4 * (3 * (2 * (1 * 0!))) \\\\ &= 4 * (3 * (2 * (1 * 1))) \\\\ &= 4 * (3 * (2 * 1)) \\\\ &= 4 * (3 * 2) \\\\ &= 4 * 6 \\\\ &= 24 \\end{align} \\] Na computa\u00e7\u00e3o, as fun\u00e7\u00f5es recursivas s\u00e3o importantes por serem uma estrat\u00e9gia de resolu\u00e7\u00e3o de problemas , pois possibilitam resolver problemas pouco a pouco, e especialmente importantes na programa\u00e7\u00e3o funcional, onde servem de alternativa \u00e0s instru\u00e7\u00f5es de itera\u00e7\u00e3o como for (;;) e while () , comuns nas linguagens imperativas.","title":"Recursividade"},{"location":"recursion/#em-haskell","text":"N\u00e3o h\u00e1 nada de especial em termos de sintaxe na declara\u00e7\u00e3o de fun\u00e7\u00f5es recursivas. O c\u00e1lculo do fatorial pode ser traduzido quase que diretamente para Haskell usando guardas. fatorialGuardas n | n == 0 = 1 | otherwise = n * fatorialGuardas ( n - 1 ) Observe que a defini\u00e7\u00e3o \u00e9 iniciada tratando o caso em que 0 \u00e9 passado como par\u00e2metro; este \u00e9 o que chamamos de caso base , que serve para limitar a recurs\u00e3o e impedir que execute para sempre. J\u00e1 o que torna a fun\u00e7\u00e3o recursiva acontece na \u00faltima linha: a invoca\u00e7\u00e3o da pr\u00f3pria fun\u00e7\u00e3o. Como esta invoca\u00e7\u00e3o ser\u00e1 feita para o valor passado como par\u00e2metro menos 1, temos a garantia de que, para qualquer n\u00famero positivo passado como par\u00e2metro, em algum momento haver\u00e1 uma invoca\u00e7\u00e3o da fun\u00e7\u00e3o com o par\u00e2metro igual a 0 , que ser\u00e1 respondida pelo caso base. \u00c9 importante ficar claro que para cada invoca\u00e7\u00e3o da fun\u00e7\u00e3o, \\(n\\) assume um valor diferente, o que pode fazer parecer que o valor de \\(n\\) est\u00e1 mudando, mas isso n\u00e3o poderia estar mais longe da verdade! Cada \\(n\\) s\u00f3 existe no escopo de uma invoca\u00e7\u00e3o da fun\u00e7\u00e3o. Pictograficamente, \\(n\\) s\u00f3 \u00e9 vis\u00edvel dentro da \"caixinha\" onde foi associada a um valor. Outra forma absolutamente equivalente de definir a fun\u00e7\u00e3o \u00e9 usando casamento de padr\u00f5es, como a seguir. fatorialPM 0 = 1 fatorialPM n = n * fatorialPM ( n - 1 ) Considerando as duas defini\u00e7\u00f5es da fun\u00e7\u00e3o, considere o que acontece se as mesmas forem invocadas com um n\u00famero negativo como par\u00e2metro. O que acontece? A recurs\u00e3o simplesmente \"nunca\" termina, continuando com \\(n\\) indo para o - infinito. Acontece que n\u00e3o \u00e9 definido o fatorial de n\u00fameros negativos e, por isso, precisamos que um erro seja lan\u00e7ado quando uma tentativa de invoca\u00e7\u00e3o deste tipo ocorrer. H\u00e1 diferentes formas de se lan\u00e7ar um erro, sendo a primeira simplesmente limitar os valores v\u00e1lidos para os par\u00e2metros. fatorialGuardas n | n == 0 = 1 | n > 0 = n * fatorialGuardas ( n - 1 ) A outra alternativa \u00e9 explicitamente causar um erro. fatorialGuardas' n | n == 0 = 1 | n > 0 = n * fatorialGuardas' ( n - 1 ) | otherwise = error \"N\u00e3o se pode calcular o fatorial de n\u00fameros negativos\" fatorialGuardas'' n | n == 0 = 1 | otherwise = if n > 0 then n * fatorialGuardas'' ( n - 1 ) else error \"N\u00e3o se pode calcular o fatorial de n\u00fameros negativos\" Fun\u00e7\u00f5es Recursivas Caso base - Limita recurs\u00e3o. Caso geral - Faz chamada recursiva para problema \" menor \" Note que em ambas as formas, temos algumas defini\u00e7\u00f5es simples, os casos base , que n\u00e3o fazem recurs\u00e3o, e os casos recursivos , envolvem recurs\u00e3o. Este padr\u00e3o se repetir\u00e1 praticamente sempre nas defini\u00e7\u00f5es recursivas, o que n\u00e3o quer dizer que a defini\u00e7\u00e3o ser\u00e1 \u00f3bvia.","title":"Em Haskell"},{"location":"recursion/#recursao-e-listas","text":"Fun\u00e7\u00f5es recursivas s\u00e3o particularmente importantes na manipula\u00e7\u00e3o listas, como veremos adiante.","title":"Recurs\u00e3o e Listas"},{"location":"recursion/#recursao-de-cauda","text":"A recurs\u00e3o de cauda \u00e9 uma t\u00e9cnica important\u00edssima para melhorar o desempenho de fun\u00e7\u00f5es recursivas ao economizar os recursos do sistema, e ao permitir as recurs\u00f5es possam at\u00e9 ser infinitas, como em la\u00e7os infinitos usados em jogos, por exemplo. Esta t\u00e9cnica ser\u00e1 explorada no futuro, uma vez que j\u00e1 estejam confort\u00e1veis com recurs\u00f5es n\u00e3o otimizadas.","title":"Recurs\u00e3o de Cauda"},{"location":"refs/","text":"Tutorial completo de PF https://www.tutorialspoint.com/functional_programming/functional_programming_introduction.htm https://www.cse.chalmers.se/edu/year/2018/course/TDA555/lectures.html","title":"Refs"},{"location":"tail_recursion/","text":"Recurs\u00e3o de cauda Considere a seguinte fun\u00e7\u00e3o, que calcula o somat\u00f3rio dos elementos em uma lista. soma [] = 0 soma ( x : xs ) = x + soma xs N\u00e3o h\u00e1 nada de errado com esta defini\u00e7\u00e3o, n\u00e3o \u00e9 mesmo? Veja como funciona perfeitamente. > soma [ 1 .. 10 ] 55 > soma [ 1 .. 10000 ] 50005000 > Mas testemos com uma lista \"um pouco\" maior e teremos uma desagrad\u00e1vel surpresa. > soma [ 1 .. 100000000 ] *** Exception: stack overflow Para entender o que aconteceu aqui, precisamos entender como a invoca\u00e7\u00e3o \u00e9 tratada pelo computador. Por exemplo, no caso para resolver soma [ 1 , 2 , 3 , 4 , 5 ] , o seguinte acontece: para calcular soma [ 1 , 2 , 3 , 4 , 5 ] , primeiro \u00e9 necess\u00e1rio calcular soma [ 2 , 3 , 4 , 5 ] , ent\u00e3o a invoca\u00e7\u00e3o recursiva \u00e9 feita e somente ap\u00f3s levar a uma resposta, a pergunta original \u00e9 respondida; mas, para calcular soma [ 2 , 3 , 4 , 5 ] primeiro \u00e9 necess\u00e1rio calcular soma [ 3 , 4 , 5 ] , e a invoca\u00e7\u00e3o recursiva \u00e9 feita, e assim por diante; as informa\u00e7\u00f5es que permitem ao programa continuar a execu\u00e7\u00e3o de uma invoca\u00e7\u00e3o depois da chamada recursiva retornar, isto \u00e9, o valor da cabe\u00e7a da lista na invoca\u00e7\u00e3o atual, s\u00e3o \"empilhadas\" na mem\u00f3ria; Acontece que se a pilha ( stack ) cresce muito, como \u00e9 o caso quando fazemos uma invoca\u00e7\u00e3o soma [ 100000000 ] , ela extrapola a capacidade do processo de crescer a pilha e \"transborda\" ( overflow ) o espa\u00e7o reservado para a pilha, que \u00e9 o erro visto no exemplo anterior. Acontece que Haskell \u00e9 inteligente o suficiente para perceber se a fun\u00e7\u00e3o n\u00e3o tiver pend\u00eancias e, neste caso, n\u00e3o colocar na pilha. Para n\u00e3o deixar pend\u00eancias, a chamada recursiva deve receber toda a informa\u00e7\u00e3o que seja necess\u00e1ria para o c\u00e1lculo do resultado final da fun\u00e7\u00e3o. Esta t\u00e9cnica \u00e9 conhecida como recurs\u00e3o de cauda , pois a chamada recursiva \u00e9 a \u00faltima coisa feita na fun\u00e7\u00e3o e, por isso, n\u00e3o deixa pend\u00eancias. Em outras palavra o resultado da chamada recursiva \u00e9 o resultado da chamada . No exemplo da soma, podemos reescrever a fun\u00e7\u00e3o assim: soma 0 acc [] = acc soma acc ( x : xs ) = soma ( acc + x ) xs Como n\u00e3o h\u00e1 pilha, \u00e9 poss\u00edvel calcular somat\u00f3rios bem maiores, pois nada fica para tr\u00e1s, correto? A verdade \u00e9 que o Haskell \u00e9 muito pregui\u00e7oso, e n\u00e3o avalia o + enquanto n\u00e3o for necess\u00e1rio, ent\u00e3o a computa\u00e7\u00e3o fica na verdade assim. Haskell nos d\u00e1, contudo, a op\u00e7\u00e3o de for\u00e7ar o c\u00e1lculo do acumulador antes de pass\u00e1-lo como par\u00e2metro para a chamada recursiva usando a fun\u00e7\u00e3o seq . soma 0 acc [] = acc soma acc ( x : xs ) = seq acc soma ( acc + x ) xs O que a segunda linha do c\u00f3digo faz \u00e9 dizer ao Haskell que \"primeiro avalie acc e na sequ\u00eancia avalie soma ( acc + x ) xs . Outra forma, mais idiom\u00e1tica de escrever o mesmo c\u00f3digo \u00e9 usando seq de forma infixa. soma 0 acc [] = acc soma acc ( x : xs ) = acc ` seq ` soma ( acc + x ) xs Felizmente voc\u00ea quase nunca precisar\u00e1 usar seq manualmente quando estiver escrevendo c\u00f3digo que v\u00e1 entrar em produ\u00e7\u00e3o, isto \u00e9, que ser\u00e1 compilado, pois poder\u00e1 usar a flag -O para dizer ao compilador que tente encontrar onde o uso de seq seria apropriado, e o compilador faz um excelente trabalho neste sentido. A t\u00e9cnica de passar um acumulador ou acumuladores na invoca\u00e7\u00e3o recursiva \u00e9 muito comum e deve estar sempre em sua mente. E se voc\u00ea n\u00e3o quiser \"poluir\" a API com um par\u00e2metro que s\u00f3 faz sentido por causa da recurs\u00e3o, voc\u00ea pode usar fun\u00e7\u00f5es auxiliares, como a seguir. soma l = soma' 0 l where soma' 0 acc [] = acc soma' acc ( x : xs ) = soma' ( acc + x ) xs Vejamos um outro exemplo do uso de recurs\u00e3o de cauda, desta vez para calcular os n\u00fameros da sequ\u00eancia de Fibonacci \"de baixo para cima\". fibUp :: Integer -> Integer fibUp 0 = 0 fibUp 1 = 1 fibUp n = fibUpTo 0 1 1 n where fibUpTo prevPrev prev prevCount limit = if prevCount == limit then prev + prevPrev else fibUpTo prev ( prev + prevPrev ) ( prevCount + 1 ) limit foldl x foldr","title":"Recurs\u00e3o de Cauda"},{"location":"tail_recursion/#recursao-de-cauda","text":"Considere a seguinte fun\u00e7\u00e3o, que calcula o somat\u00f3rio dos elementos em uma lista. soma [] = 0 soma ( x : xs ) = x + soma xs N\u00e3o h\u00e1 nada de errado com esta defini\u00e7\u00e3o, n\u00e3o \u00e9 mesmo? Veja como funciona perfeitamente. > soma [ 1 .. 10 ] 55 > soma [ 1 .. 10000 ] 50005000 > Mas testemos com uma lista \"um pouco\" maior e teremos uma desagrad\u00e1vel surpresa. > soma [ 1 .. 100000000 ] *** Exception: stack overflow Para entender o que aconteceu aqui, precisamos entender como a invoca\u00e7\u00e3o \u00e9 tratada pelo computador. Por exemplo, no caso para resolver soma [ 1 , 2 , 3 , 4 , 5 ] , o seguinte acontece: para calcular soma [ 1 , 2 , 3 , 4 , 5 ] , primeiro \u00e9 necess\u00e1rio calcular soma [ 2 , 3 , 4 , 5 ] , ent\u00e3o a invoca\u00e7\u00e3o recursiva \u00e9 feita e somente ap\u00f3s levar a uma resposta, a pergunta original \u00e9 respondida; mas, para calcular soma [ 2 , 3 , 4 , 5 ] primeiro \u00e9 necess\u00e1rio calcular soma [ 3 , 4 , 5 ] , e a invoca\u00e7\u00e3o recursiva \u00e9 feita, e assim por diante; as informa\u00e7\u00f5es que permitem ao programa continuar a execu\u00e7\u00e3o de uma invoca\u00e7\u00e3o depois da chamada recursiva retornar, isto \u00e9, o valor da cabe\u00e7a da lista na invoca\u00e7\u00e3o atual, s\u00e3o \"empilhadas\" na mem\u00f3ria; Acontece que se a pilha ( stack ) cresce muito, como \u00e9 o caso quando fazemos uma invoca\u00e7\u00e3o soma [ 100000000 ] , ela extrapola a capacidade do processo de crescer a pilha e \"transborda\" ( overflow ) o espa\u00e7o reservado para a pilha, que \u00e9 o erro visto no exemplo anterior. Acontece que Haskell \u00e9 inteligente o suficiente para perceber se a fun\u00e7\u00e3o n\u00e3o tiver pend\u00eancias e, neste caso, n\u00e3o colocar na pilha. Para n\u00e3o deixar pend\u00eancias, a chamada recursiva deve receber toda a informa\u00e7\u00e3o que seja necess\u00e1ria para o c\u00e1lculo do resultado final da fun\u00e7\u00e3o. Esta t\u00e9cnica \u00e9 conhecida como recurs\u00e3o de cauda , pois a chamada recursiva \u00e9 a \u00faltima coisa feita na fun\u00e7\u00e3o e, por isso, n\u00e3o deixa pend\u00eancias. Em outras palavra o resultado da chamada recursiva \u00e9 o resultado da chamada . No exemplo da soma, podemos reescrever a fun\u00e7\u00e3o assim: soma 0 acc [] = acc soma acc ( x : xs ) = soma ( acc + x ) xs Como n\u00e3o h\u00e1 pilha, \u00e9 poss\u00edvel calcular somat\u00f3rios bem maiores, pois nada fica para tr\u00e1s, correto? A verdade \u00e9 que o Haskell \u00e9 muito pregui\u00e7oso, e n\u00e3o avalia o + enquanto n\u00e3o for necess\u00e1rio, ent\u00e3o a computa\u00e7\u00e3o fica na verdade assim. Haskell nos d\u00e1, contudo, a op\u00e7\u00e3o de for\u00e7ar o c\u00e1lculo do acumulador antes de pass\u00e1-lo como par\u00e2metro para a chamada recursiva usando a fun\u00e7\u00e3o seq . soma 0 acc [] = acc soma acc ( x : xs ) = seq acc soma ( acc + x ) xs O que a segunda linha do c\u00f3digo faz \u00e9 dizer ao Haskell que \"primeiro avalie acc e na sequ\u00eancia avalie soma ( acc + x ) xs . Outra forma, mais idiom\u00e1tica de escrever o mesmo c\u00f3digo \u00e9 usando seq de forma infixa. soma 0 acc [] = acc soma acc ( x : xs ) = acc ` seq ` soma ( acc + x ) xs Felizmente voc\u00ea quase nunca precisar\u00e1 usar seq manualmente quando estiver escrevendo c\u00f3digo que v\u00e1 entrar em produ\u00e7\u00e3o, isto \u00e9, que ser\u00e1 compilado, pois poder\u00e1 usar a flag -O para dizer ao compilador que tente encontrar onde o uso de seq seria apropriado, e o compilador faz um excelente trabalho neste sentido. A t\u00e9cnica de passar um acumulador ou acumuladores na invoca\u00e7\u00e3o recursiva \u00e9 muito comum e deve estar sempre em sua mente. E se voc\u00ea n\u00e3o quiser \"poluir\" a API com um par\u00e2metro que s\u00f3 faz sentido por causa da recurs\u00e3o, voc\u00ea pode usar fun\u00e7\u00f5es auxiliares, como a seguir. soma l = soma' 0 l where soma' 0 acc [] = acc soma' acc ( x : xs ) = soma' ( acc + x ) xs Vejamos um outro exemplo do uso de recurs\u00e3o de cauda, desta vez para calcular os n\u00fameros da sequ\u00eancia de Fibonacci \"de baixo para cima\". fibUp :: Integer -> Integer fibUp 0 = 0 fibUp 1 = 1 fibUp n = fibUpTo 0 1 1 n where fibUpTo prevPrev prev prevCount limit = if prevCount == limit then prev + prevPrev else fibUpTo prev ( prev + prevPrev ) ( prevCount + 1 ) limit","title":"Recurs\u00e3o de cauda"},{"location":"todo/","text":"TODO Ativar plugin bibtex ( https://en.wikibooks.org/wiki/Haskell ) Tipos Haskell \u00e9 Fortemente tipada: sem convers\u00e3o autom\u00e1tica \u00e9 Statically typed: em tempo de compila\u00e7\u00e3o. Exemplo python e tipos mutantes Prot\u00f3tipos Infer\u00eancia de tipos. Especifica\u00e7\u00e3o manual Type classes Comuns Eq Ord Enum Show Read Bounded: minBound maxBound [] ] Defini\u00e7\u00e3o class Eq a where ( == ) :: a -> a -> Bool ( /= ) :: a -> a -> Bool x == y = not ( x /= y ) x /= y = not ( x == y ) Tuplas Listas sao homog\u00eaneas range operator [1..10] : cons ++ append !! get at index Pattern matching Compreens\u00e3o de listas Listas infinitas ordena\u00e7\u00e3o selection-sort quick-sort Merge-sort Polimorfismo - fun\u00e7\u00f5es que se aplicam a v\u00e1rios tipos - generics () http://learnyouahaskell.com/types-and-typeclasses ) type variables - http://www.decom.ufop.br/romildo/2014-1/bcc222/practices/p06-polimorfismo.pdf head :: [a] -> a `swap :: (a,b) -> (b,a) Tipos especificados pelo usu\u00e1rio - [ ] apelidos - type - [x] n\u00e3o parametrizado - [ ] parametrizado ( http://learnyouahaskell.com/making-our-own-types-and-typeclasses#algebraic-data-types ) - [ ] Tipos alg\u00e9bricos - data * [x] Defini\u00e7\u00e3o ( https://mmhaskell.com/blog/2017/12/24/haskell-data-types-in-5-steps ) ( https://en.wikibooks.org/wiki/Haskell/GADT#Extending_the_language ) - [x] n\u00e3o parametrizado - [ ] parametrizado - [ ] produto x soma * [x] Casamento de padr\u00f5es * Exemplos * [ ] Maybe * https://www.youtube.com/watch?v=b9FagOVqxmI data Maybe a = Nothing | Just a deriving ( Eq , Ord , Read , Show ) data Either a b = Left a | Right b deriving ( Eq , Ord , Read , Show ) * [ ] Either * [ ] Tipos recursivos - [ ] Listas - [ ] \u00c1rvores Pattern matching case-of Declara\u00e7\u00e3o de fun\u00e7\u00f5es as pattern - @ Fun\u00e7\u00f5es Equa\u00e7\u00f5es simples Guarda where https://stackoverflow.com/questions/32562614/is-something-in-the-where-clause-in-haskell-only-calculated-once let in Recurs\u00e3o simples em listas de cauda Currying: Alta Ordem: There are a number of concepts which are the main corner stones of functional programming, such as first-class and higher-order functions, pure functions, recursion, strict versus non-strict evaluation, and type systems. Higher-order functions can take other functions as arguments or return them as results. An example of a higherorder functions is an integrator or differential operator as it returns a function. Pure functions have no side effects (memory or I/O). This means that pure functions are very useful to optimize code. For example, if the result of a pure expression is not used, it can be removed without affecting the other expressions. If there is no data dependency between two pure expressions, then their order can be reversed or they can be performed in parallel and not interfere with each other. This means pure expressions are thread safe. To allow compilers to optimize code more easily in other languages, there is usually keywords you can add to tell the compiler the function is pure. Recursion functions invoke themselves, performing an operation multiple times unit the base case is reached. Common patterns of recursion can be re-factored using higher order functions. Some recursions require maintaining a stack but tail recursions can be optimized into the same code used to implement iteration in imperative languages. Functional programming that is limited to well-founded recursion with a few other constraints is called total functional programming [24]. Strict versus non-strict evaluation is a concept that divides functional languages by whether they use strict (eager) or nonstrict (lazy) evaluation. Figure 8 presents an example. Under strict evaluation the entire term and function and evaluated, meaning if any term of the expression would fail, the whole expression would fail. Under non-strict evaluation, the length function will return the value 4 since evaluation it will not attempt to evaluate the terms making p the list. The usual implementation strategy for non-strict evaluation in functional languages is graph reduction [25]. fold filter map . $ Avalia\u00e7\u00e3o pregui\u00e7osa mostrar com listas infinitas a fun\u00e7\u00e3o cycle Where - let in https://takenobu-hs.github.io/downloads/haskell_lazy_evaluation.pdf Entrada e sa\u00edda: Show Read Monads Haskell em produ\u00e7\u00e3o Comunica\u00e7\u00e3o entre linguagens Paralelismo e Distribui\u00e7\u00e3o: actors C\u00e1lculo Lambda: https://crypto.stanford.edu/~blynn/lambda/ https://youtu.be/3VQ382QG-y4 transpar\u00eancia referencial - https://takenobu-hs.github.io/downloads/haskell_lazy_evaluation.pdf idempot\u00eancia Test HSpec quickcheck quickcheck + Hspec https://hspec.github.io/quickcheck.html Exerc\u00edcios/Provas Fontes https://www.cantab.net/users/antoni.diller/haskell/questions/quest07.pdf Exercism https://www.cse.chalmers.se/edu/year/2018/course/TDA555/exam.html https://www.cse.chalmers.se/edu/year/2018/course/TDA555/ex-week2.html https://haskell.mooc.fi/part1#sidenote-the-.-and-operators Tipos Pedra tesoura papel - usando strings Pedra tesoura papel - usando tipos definidos pelo usu\u00e1rio Tipos alg\u00e9bricos Pedra tesoura papel - usando tipos alg\u00e9bricos cartas teste se bateu em algum jogo ordene as cartas Exerc\u00edcios Defina uma fun\u00e7\u00e3o que dado uma String, verifique se ela \u00e9 um pal\u00edndromo. Resolu\u00e7\u00e3o \u00e9Pal\u00edndromo s = s == reverse s * Main > \u00e9Pal\u00edndromo \"aba\" True * Main > \u00e9Pal\u00edndromo \"abac\" False Um pangrama \u00e9 uma frase que contem todas as letras do alfabeto. Escreva uma fun\u00e7\u00e3o que, dado uma String, verifique se \u00e9 um pangrama. Resolu\u00e7\u00e3o module Pangram ( isPangram ) where import Data.Char ( toLower ) isPangram :: String -> Bool isPangram text = all (` elem ` ( map toLower text )) [ 'a' .. 'z' ]","title":"Todo"},{"location":"todo/#todo","text":"Ativar plugin bibtex ( https://en.wikibooks.org/wiki/Haskell ) Tipos Haskell \u00e9 Fortemente tipada: sem convers\u00e3o autom\u00e1tica \u00e9 Statically typed: em tempo de compila\u00e7\u00e3o. Exemplo python e tipos mutantes Prot\u00f3tipos Infer\u00eancia de tipos. Especifica\u00e7\u00e3o manual Type classes Comuns Eq Ord Enum Show Read Bounded: minBound maxBound [] ] Defini\u00e7\u00e3o class Eq a where ( == ) :: a -> a -> Bool ( /= ) :: a -> a -> Bool x == y = not ( x /= y ) x /= y = not ( x == y ) Tuplas Listas sao homog\u00eaneas range operator [1..10] : cons ++ append !! get at index Pattern matching Compreens\u00e3o de listas Listas infinitas ordena\u00e7\u00e3o selection-sort quick-sort Merge-sort Polimorfismo - fun\u00e7\u00f5es que se aplicam a v\u00e1rios tipos - generics () http://learnyouahaskell.com/types-and-typeclasses ) type variables - http://www.decom.ufop.br/romildo/2014-1/bcc222/practices/p06-polimorfismo.pdf head :: [a] -> a `swap :: (a,b) -> (b,a) Tipos especificados pelo usu\u00e1rio - [ ] apelidos - type - [x] n\u00e3o parametrizado - [ ] parametrizado ( http://learnyouahaskell.com/making-our-own-types-and-typeclasses#algebraic-data-types ) - [ ] Tipos alg\u00e9bricos - data * [x] Defini\u00e7\u00e3o ( https://mmhaskell.com/blog/2017/12/24/haskell-data-types-in-5-steps ) ( https://en.wikibooks.org/wiki/Haskell/GADT#Extending_the_language ) - [x] n\u00e3o parametrizado - [ ] parametrizado - [ ] produto x soma * [x] Casamento de padr\u00f5es * Exemplos * [ ] Maybe * https://www.youtube.com/watch?v=b9FagOVqxmI data Maybe a = Nothing | Just a deriving ( Eq , Ord , Read , Show ) data Either a b = Left a | Right b deriving ( Eq , Ord , Read , Show ) * [ ] Either * [ ] Tipos recursivos - [ ] Listas - [ ] \u00c1rvores Pattern matching case-of Declara\u00e7\u00e3o de fun\u00e7\u00f5es as pattern - @ Fun\u00e7\u00f5es Equa\u00e7\u00f5es simples Guarda where https://stackoverflow.com/questions/32562614/is-something-in-the-where-clause-in-haskell-only-calculated-once let in Recurs\u00e3o simples em listas de cauda Currying: Alta Ordem: There are a number of concepts which are the main corner stones of functional programming, such as first-class and higher-order functions, pure functions, recursion, strict versus non-strict evaluation, and type systems. Higher-order functions can take other functions as arguments or return them as results. An example of a higherorder functions is an integrator or differential operator as it returns a function. Pure functions have no side effects (memory or I/O). This means that pure functions are very useful to optimize code. For example, if the result of a pure expression is not used, it can be removed without affecting the other expressions. If there is no data dependency between two pure expressions, then their order can be reversed or they can be performed in parallel and not interfere with each other. This means pure expressions are thread safe. To allow compilers to optimize code more easily in other languages, there is usually keywords you can add to tell the compiler the function is pure. Recursion functions invoke themselves, performing an operation multiple times unit the base case is reached. Common patterns of recursion can be re-factored using higher order functions. Some recursions require maintaining a stack but tail recursions can be optimized into the same code used to implement iteration in imperative languages. Functional programming that is limited to well-founded recursion with a few other constraints is called total functional programming [24]. Strict versus non-strict evaluation is a concept that divides functional languages by whether they use strict (eager) or nonstrict (lazy) evaluation. Figure 8 presents an example. Under strict evaluation the entire term and function and evaluated, meaning if any term of the expression would fail, the whole expression would fail. Under non-strict evaluation, the length function will return the value 4 since evaluation it will not attempt to evaluate the terms making p the list. The usual implementation strategy for non-strict evaluation in functional languages is graph reduction [25]. fold filter map . $ Avalia\u00e7\u00e3o pregui\u00e7osa mostrar com listas infinitas a fun\u00e7\u00e3o cycle Where - let in https://takenobu-hs.github.io/downloads/haskell_lazy_evaluation.pdf Entrada e sa\u00edda: Show Read Monads Haskell em produ\u00e7\u00e3o Comunica\u00e7\u00e3o entre linguagens Paralelismo e Distribui\u00e7\u00e3o: actors C\u00e1lculo Lambda: https://crypto.stanford.edu/~blynn/lambda/ https://youtu.be/3VQ382QG-y4 transpar\u00eancia referencial - https://takenobu-hs.github.io/downloads/haskell_lazy_evaluation.pdf idempot\u00eancia Test HSpec quickcheck quickcheck + Hspec https://hspec.github.io/quickcheck.html Exerc\u00edcios/Provas Fontes https://www.cantab.net/users/antoni.diller/haskell/questions/quest07.pdf Exercism https://www.cse.chalmers.se/edu/year/2018/course/TDA555/exam.html https://www.cse.chalmers.se/edu/year/2018/course/TDA555/ex-week2.html https://haskell.mooc.fi/part1#sidenote-the-.-and-operators Tipos Pedra tesoura papel - usando strings Pedra tesoura papel - usando tipos definidos pelo usu\u00e1rio Tipos alg\u00e9bricos Pedra tesoura papel - usando tipos alg\u00e9bricos cartas teste se bateu em algum jogo ordene as cartas Exerc\u00edcios Defina uma fun\u00e7\u00e3o que dado uma String, verifique se ela \u00e9 um pal\u00edndromo. Resolu\u00e7\u00e3o \u00e9Pal\u00edndromo s = s == reverse s * Main > \u00e9Pal\u00edndromo \"aba\" True * Main > \u00e9Pal\u00edndromo \"abac\" False Um pangrama \u00e9 uma frase que contem todas as letras do alfabeto. Escreva uma fun\u00e7\u00e3o que, dado uma String, verifique se \u00e9 um pangrama. Resolu\u00e7\u00e3o module Pangram ( isPangram ) where import Data.Char ( toLower ) isPangram :: String -> Bool isPangram text = all (` elem ` ( map toLower text )) [ 'a' .. 'z' ]","title":"TODO"},{"location":"tuples/","text":"Tuplas Nas fun\u00e7\u00f5es vistas at\u00e9 agora, todos os par\u00e2metros eram de algum tipo simples. Por exemplo, vejamos a fun\u00e7\u00e3o soma2n que soma 2 n\u00fameros: soma2n :: Int -> Int -> Int soma2n a b = a + b Muitas vezes estes tipos simples precisam ser associados para significar algo de mais alto n\u00edvel. Por exemplo, seja a fun\u00e7\u00e3o soma2v que soma as coordenadas x e y de 2 pontos representando dois vetores. Como poder\u00edamos definir tal fun\u00e7\u00e3o, j\u00e1 que o resultado deve ter informa\u00e7\u00e3o tanto sobre a coordenada x quanto y do resultado? soma2v x1 y1 x2 y2 = ? A resposta est\u00e1 no uso de tipos estruturados que agreguem outros tipos. No caso, a solu\u00e7\u00e3o ideal par ordenado na forma de uma tupla de dois elementos. Tuplas s\u00e3o geralmente representadas usando a sintaxe (Elem1, Elem2, ... , ElemN) , tanto em Haskell como em diversas outras linguagens. Assim, a fun\u00e7\u00e3o soma2v pode ser definida, incluindo o prot\u00f3tipo, como a seguir. Observe que a fun\u00e7\u00e3o define claramente quantos elementos a tupla ter\u00e1 e qual a vari\u00e1vel associada a cada uma das coordenadas de cada ponto. soma2v :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) soma2v ( x1 , y1 ) ( x2 , y2 ) = ( x1 + x2 , y1 + y2 ) Para usar a fun\u00e7\u00e3o, podemos invoc\u00e1-la de duas formas, usando a nota\u00e7\u00e3o prefixa ou infixa, com o mesmo resultado. soma2v ( 3 , 4 ) ( 5 , 4 ) ( 3 , 4 ) ` soma2v ` ( 5 , 4 ) Outra forma de definir a mesma fun\u00e7\u00e3o, sem especificar o nome das vari\u00e1veis, seria usando as fun\u00e7\u00f5es fst e snd do Prelude , abrevia\u00e7\u00f5es para first e second e que retornam o primeiro e o segundo elemento de uma tupla de dois elementos, um par, respectivamente. Logo, > snd ( 1 , 2 ) 2 > fst ( 3 , 4 ) 3 > fst ( snd (( 1 , 2 , 3 ),( 4 , 5 ))) 4 > fst ( 1 , 2 , 3 ) <== Erro ! De forma simplificada, fst e snd poderiam ser definidos assim: fst ( x , y ) = x snd ( x , y ) = y Mas na pr\u00e1tica, ainda de forma simplificada, s\u00e3o definidos assim fst ( x , _ ) = x snd ( _ , y ) = y Observe que o _ \u00e9 usado em substitui\u00e7\u00e3o a um nome para vari\u00e1veis com as quais n\u00e3o nos importamos , isto que, que n\u00e3o ser\u00e3o usadas no dado escopo. O GHC consegue otimizar o c\u00f3digo para n\u00e3o gastar recursos com mesma. Assim, usando fst e snd , a defini\u00e7\u00e3o da soma dos vetores fica como se segue: soma2v' :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) soma2v' p1 p2 = (( fst p1 ) + ( fst p2 ), ( snd p1 ) + ( snd p2 )) Exerc\u00edcio Considerando uma tupla de 4 elementos, defina 4 fun\u00e7\u00f5es que, aos moldes de fst e snd , extraiam cada um dos 4 elementos da tupla. N\u00e3o defina um prot\u00f3tipo. Resolu\u00e7\u00e3o prim ( x , _ , _ , _ ) = x segu ( _ , y , _ , _ ) = y terc ( _ , _ , z , _ ) = z quar ( _ , _ , _ , w ) = w Exerc\u00edcio Escreva uma fun\u00e7\u00e3o que receba um inteiro como par\u00e2metro e retorne uma tupla como resultado onde o primeiro elemento \u00e9 um booleano que indica se o n\u00famero \u00e9 negativo, e o segundo elemento \u00e9 o valor absoluto do n\u00famero. Resolu\u00e7\u00e3o \u00e9Neg :: Int -> ( Bool , Int ) \u00e9Neg x = if x < 0 then ( True , abs x ) else ( False , abs x ) \u00e9Neg' :: Int -> ( Bool , Int ) \u00e9Neg' x = ( x < 0 , abs x ) Tuplas est\u00e3o para Haskell assim como estruturas est\u00e3o para outras linguagens. Por exemplo, imagine que se queira armazenar os dados nome, telefone, CPF e endere\u00e7o de uma pessoa. Poder\u00edamos convencionar que seria usado uma tupla em que cada posi\u00e7\u00e3o corresponderia a um dos dados. Neste caso, alguns exemplos de fun\u00e7\u00f5es \u00fateis s\u00e3o mostrados a seguir. fazPessoa :: String -> String -> String -> String -> ( String , String , String , String ) -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: ( String , String , String , String ) -> String pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: ( String , String , String , String ) -> String pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone :: ( String , String , String , String ) -> String -> ( String , String , String , String ) trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) > x = fazPessoa \"jose da silva\" \"12345\" \"0003003093\" \"Av das Couves, 14\" > x => ( \"jose da silva\" , \"12345\" , \"0003003093\" , \"Av das Couves, 14\" ) > pegaNome x => \"jose da silva\" > pegaTelefone x => \"12345\" > y = trocaTelefone x \"54321\" > y => ( \"jose da silva\" , \"54321\" , \"0003003093\" , \"Av das Couves, 14\" ) Uma observa\u00e7\u00e3o a ser feita \u00e9 que, na \u00faltima fun\u00e7\u00e3o, nomear a vari\u00e1vel como _t tem o mesmo efeito que simplesmente _ para o compilador, mas deixa o c\u00f3digo mais leg\u00edvel. Outra observa\u00e7\u00e3o \u00e9 que mesmo com o uso _t , o c\u00f3digo fica rapidamente dif\u00edcil de se ler, pois o desenvolvedor deve manter em mente qual posi\u00e7\u00e3o corresponde a qual dado de uma pessoa; imagine estruturas mais complexas, contendo outros dados de cada pessoa, e v\u00e1rias outras estruturas semelhantes, como ordens de servi\u00e7o, descri\u00e7\u00e3o de invent\u00e1rios, cadastro de vendedores, etc. Uma forma de simplificar o c\u00f3digo \u00e9 definir tipos associados a cada estrutura. Tuplas como tipos Como visto anteriormente, a palavra reservada type permite que definamos apelidos para tipos no Haskell. Pois tuplas tamb\u00e9m podem ser associadas a tipos, por exemplo, podemos definir que Pessoa \u00e9 o tipo definido na se\u00e7\u00e3o anterior, i.e., uma tupla dos campos nome, telefone, CPF e endere\u00e7o. type Pessoa = ( String , String , String , String ) fazPessoa :: String -> String -> String -> String -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> String pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> String pegaTelefone ( _ , telefone , _ , _ ) = telefone pegaCPF :: Pessoa -> String pegaCPF ( _ , _ , c , _ ) = c pegaEndere\u00e7o :: Pessoa -> String pegaEndere\u00e7o ( _ , _ , _ , e ) = e trocaTelefone :: Pessoa -> String -> Pessoa trocaTelefone p novoTelefone = fazPessoa ( pegaNome p ) novoTelefone ( pegaCPF p ) ( pegaEndere\u00e7o p ) Se perguntarmos ao Haskell qual o tipo da tupla gerada pela fun\u00e7\u00e3o fazPessoa , ele responder\u00e1 Pessoa . > : t fazPessoa fazPessoa :: String -> String -> String -> String -> Pessoa > p = fazPessoa \"Jose\" \"Tel\" \"CPF\" \"End\" > : t p p :: Pessoa Podemos ir al\u00e9m e definir tipos usando outros tipos estruturados. Por exemplo: type Nome = ( String , String , String ) type Telefone = ( String , String ) type CPF = String type Endere\u00e7o = ( String , String , String ) type Pessoa = ( Nome , Telefone , CPF , Endere\u00e7o ) fazPessoa :: Nome -> Telefone -> CPF -> Endere\u00e7o -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> Nome pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> Telefone pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone :: Pessoa -> Telefone -> Pessoa trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) Neste caso > p = fazPessoa ( \"Jos\u00e9\" , \"da\" , \"Silva\" ) ( \"ddd\" , \"numero\" ) \"CPF\" ( \"Rua da Couves\" , \"143\" , \"Brasil\" ) > p (( \"Jos \\233 \" , \"da\" , \"Silva\" ),( \"ddd\" , \"numero\" ), \"CPF\" ,( \"Rua da Couves\" , \"143\" , \"Brasil\" )) > : t p p :: Pessoa > n = pegaNome p > n ( \"Jos \\233 \" , \"da\" , \"Silva\" ) > : t n n :: Nome Vejamos outro exemplo; sejam datas, tuplas de 3 inteiros: dia, m\u00eas e ano. Assim, 25 de dezembro de 1999 \u00e9 ( 25 , 12 , 1999 ) . Dado duas datas v\u00e1lidas, uma opera\u00e7\u00e3o interessante \u00e9 testar se uma data \u00e9 menor que outra. type Data = ( Int , Int , Int ) dataEhMenor :: ( Int , Int , Int ) -> ( Int , Int , Int ) -> Bool dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) dataEhMenor' :: Data -> Data -> Bool dataEhMenor' ( de , me , ae ) ( dd , md , ad ) = if ae < ad then True else if me < md then True else if de < dd then True else False Mas esta fun\u00e7\u00e3o pode ser descartada com a escolha da defini\u00e7\u00e3o de data, pois tuplas s\u00e3o naturalmente orden\u00e1veis. Data V\u00e1lida Defina um tipo para representar datas como tuplas. Defina uma fun\u00e7\u00e3o dataValida que receba uma data e retorne True se a data for v\u00e1lida e False se for inv\u00e1lida. Por exemplo, 38 de onzembro de 2021 \u00e9 uma data inv\u00e1lida, assim como 29 de fevereiro de 2017, mas dia primeiro de Janeiro de 2000 \u00e9 v\u00e1lida. Isto \u00e9, dataValida ( 38 , 13 , 2021 ) == False dataValida ( 29 , 02 , 2017 ) == False dataValida ( 1 , 1 , 2000 ) == True Resolu\u00e7\u00e3o type Data = ( Int , Int , Int ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) {- >>> bissexto 3 False >>> bissexto 20 True >>> bissexto 100 False >>> bissexto 2000 True -} bissexto :: Integral a => a -> Bool bissexto x | mod x 400 == 0 = True | mod x 100 == 0 = False | otherwise = mod x 4 == 0 {- >>> dataValida (1,1,2001) True >>> dataValida (1,13,2001) False >>> dataValida (29,2,2000) True >>> dataValida (29,2,1999) -} dataValida :: ( Int , Int , Int ) -> Bool dataValida ( d , m , a ) = anoValido a && mesValido m && diaValido d m ( bissexto a ) {- >>> diaValido 2 1 False True >>> diaValido 2 1 True True >>> diaValido 29 2 False False >>> diaValido 29 2 True True -} diaValido :: Int -> Int -> Bool -> Bool diaValido d m bi = d > 0 && d <= numDias m bi {- >>> numDias 3 False 31 >>> numDias 2 True 29 >>> numDias 2 False 28 -} numDias :: Int -> Bool -> Int numDias m bi | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = if bi then 29 else 28 | otherwise = 30 {- >>> mesValido 4 True >>> mesValido 13 False -} mesValido :: Int -> Bool mesValido m = m > 0 && m < 13 {- >>> anoValido 3000 True -} anoValido :: Int -> Bool anoValido a = a > 0 Ordem entre tuplas Dado duas tuplas com mesmo tipo e, obviamente, de mesmo tamanho , elas podem se comparadas lexicogr\u00e1ficamente. Isto quer dizer que uma tupla \\(t_1\\) \u00e9 menor que uma tupla \\(t_2\\) se, considerando posi\u00e7\u00f5es da direita para a esquerda: dado uma posi\u00e7\u00e3o \\(i\\) , se \\(t_1\\) na posi\u00e7\u00e3o \\(i\\) \u00e9 menor que \\(t_2\\) na posi\u00e7\u00e3o \\(i\\) e se \\(\\forall j < i\\) , \\(t_1\\) na posi\u00e7\u00e3o \\(j\\) \u00e9 igual a \\(t_2\\) na posi\u00e7\u00e3o \\(j\\) . > ( 1 , 2 ) < ( 1 , 3 ) True > ( 'a' , 2 ) < ( 'b' , 3 ) True > ( 'a' , 2 ) == ( 'b' , 3 ) False > ( 'a' , 2 ) > ( 'b' , 3 ) False > ( 1 , 2 ) < ( 1 , 3 , 4 ) <== Erro ! > ( 1 , 1 , 1 ) < ( 1 , 1 , 1 ) False > ( 1 , 1 , 1 ) < ( 1 , 1 , 2 ) True > ( 1 , 1 , 1 ) < ( 1 , 2 , 1 ) True > ( 1 , 1 , 1 ) < ( 2 , 1 , 1 ) True > ( 1 , 1 , 1 ) < ( 0 , 2 , 2 ) False Assim, se usarmos como data uma tupla com ano, m\u00eas e dia, nesta ordem , ent\u00e3o duas datas podem ser comparadas diretamente como compara\u00e7\u00e3o de tuplas. type Data = ( Int , Int , Int ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor :: Data -> Data -> Bool dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor' :: Data -> Data -> Bool dataEhMenor' ( de , me , ae ) ( dd , md , ad ) = ( ae , me , de ) < ( ad , md , dd ) A tupla vazia Por completude, \u00e9 preciso mencionar que tuplas podem ter qualquer aridade, inclusive zero. Isto \u00e9, () \u00e9 uma tupla v\u00e1lida e a \u00fanica inst\u00e2ncia de tuplas de aridade zero.","title":"Tuplas"},{"location":"tuples/#tuplas","text":"Nas fun\u00e7\u00f5es vistas at\u00e9 agora, todos os par\u00e2metros eram de algum tipo simples. Por exemplo, vejamos a fun\u00e7\u00e3o soma2n que soma 2 n\u00fameros: soma2n :: Int -> Int -> Int soma2n a b = a + b Muitas vezes estes tipos simples precisam ser associados para significar algo de mais alto n\u00edvel. Por exemplo, seja a fun\u00e7\u00e3o soma2v que soma as coordenadas x e y de 2 pontos representando dois vetores. Como poder\u00edamos definir tal fun\u00e7\u00e3o, j\u00e1 que o resultado deve ter informa\u00e7\u00e3o tanto sobre a coordenada x quanto y do resultado? soma2v x1 y1 x2 y2 = ? A resposta est\u00e1 no uso de tipos estruturados que agreguem outros tipos. No caso, a solu\u00e7\u00e3o ideal par ordenado na forma de uma tupla de dois elementos. Tuplas s\u00e3o geralmente representadas usando a sintaxe (Elem1, Elem2, ... , ElemN) , tanto em Haskell como em diversas outras linguagens. Assim, a fun\u00e7\u00e3o soma2v pode ser definida, incluindo o prot\u00f3tipo, como a seguir. Observe que a fun\u00e7\u00e3o define claramente quantos elementos a tupla ter\u00e1 e qual a vari\u00e1vel associada a cada uma das coordenadas de cada ponto. soma2v :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) soma2v ( x1 , y1 ) ( x2 , y2 ) = ( x1 + x2 , y1 + y2 ) Para usar a fun\u00e7\u00e3o, podemos invoc\u00e1-la de duas formas, usando a nota\u00e7\u00e3o prefixa ou infixa, com o mesmo resultado. soma2v ( 3 , 4 ) ( 5 , 4 ) ( 3 , 4 ) ` soma2v ` ( 5 , 4 ) Outra forma de definir a mesma fun\u00e7\u00e3o, sem especificar o nome das vari\u00e1veis, seria usando as fun\u00e7\u00f5es fst e snd do Prelude , abrevia\u00e7\u00f5es para first e second e que retornam o primeiro e o segundo elemento de uma tupla de dois elementos, um par, respectivamente. Logo, > snd ( 1 , 2 ) 2 > fst ( 3 , 4 ) 3 > fst ( snd (( 1 , 2 , 3 ),( 4 , 5 ))) 4 > fst ( 1 , 2 , 3 ) <== Erro ! De forma simplificada, fst e snd poderiam ser definidos assim: fst ( x , y ) = x snd ( x , y ) = y Mas na pr\u00e1tica, ainda de forma simplificada, s\u00e3o definidos assim fst ( x , _ ) = x snd ( _ , y ) = y Observe que o _ \u00e9 usado em substitui\u00e7\u00e3o a um nome para vari\u00e1veis com as quais n\u00e3o nos importamos , isto que, que n\u00e3o ser\u00e3o usadas no dado escopo. O GHC consegue otimizar o c\u00f3digo para n\u00e3o gastar recursos com mesma. Assim, usando fst e snd , a defini\u00e7\u00e3o da soma dos vetores fica como se segue: soma2v' :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) soma2v' p1 p2 = (( fst p1 ) + ( fst p2 ), ( snd p1 ) + ( snd p2 )) Exerc\u00edcio Considerando uma tupla de 4 elementos, defina 4 fun\u00e7\u00f5es que, aos moldes de fst e snd , extraiam cada um dos 4 elementos da tupla. N\u00e3o defina um prot\u00f3tipo. Resolu\u00e7\u00e3o prim ( x , _ , _ , _ ) = x segu ( _ , y , _ , _ ) = y terc ( _ , _ , z , _ ) = z quar ( _ , _ , _ , w ) = w Exerc\u00edcio Escreva uma fun\u00e7\u00e3o que receba um inteiro como par\u00e2metro e retorne uma tupla como resultado onde o primeiro elemento \u00e9 um booleano que indica se o n\u00famero \u00e9 negativo, e o segundo elemento \u00e9 o valor absoluto do n\u00famero. Resolu\u00e7\u00e3o \u00e9Neg :: Int -> ( Bool , Int ) \u00e9Neg x = if x < 0 then ( True , abs x ) else ( False , abs x ) \u00e9Neg' :: Int -> ( Bool , Int ) \u00e9Neg' x = ( x < 0 , abs x ) Tuplas est\u00e3o para Haskell assim como estruturas est\u00e3o para outras linguagens. Por exemplo, imagine que se queira armazenar os dados nome, telefone, CPF e endere\u00e7o de uma pessoa. Poder\u00edamos convencionar que seria usado uma tupla em que cada posi\u00e7\u00e3o corresponderia a um dos dados. Neste caso, alguns exemplos de fun\u00e7\u00f5es \u00fateis s\u00e3o mostrados a seguir. fazPessoa :: String -> String -> String -> String -> ( String , String , String , String ) -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: ( String , String , String , String ) -> String pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: ( String , String , String , String ) -> String pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone :: ( String , String , String , String ) -> String -> ( String , String , String , String ) trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) > x = fazPessoa \"jose da silva\" \"12345\" \"0003003093\" \"Av das Couves, 14\" > x => ( \"jose da silva\" , \"12345\" , \"0003003093\" , \"Av das Couves, 14\" ) > pegaNome x => \"jose da silva\" > pegaTelefone x => \"12345\" > y = trocaTelefone x \"54321\" > y => ( \"jose da silva\" , \"54321\" , \"0003003093\" , \"Av das Couves, 14\" ) Uma observa\u00e7\u00e3o a ser feita \u00e9 que, na \u00faltima fun\u00e7\u00e3o, nomear a vari\u00e1vel como _t tem o mesmo efeito que simplesmente _ para o compilador, mas deixa o c\u00f3digo mais leg\u00edvel. Outra observa\u00e7\u00e3o \u00e9 que mesmo com o uso _t , o c\u00f3digo fica rapidamente dif\u00edcil de se ler, pois o desenvolvedor deve manter em mente qual posi\u00e7\u00e3o corresponde a qual dado de uma pessoa; imagine estruturas mais complexas, contendo outros dados de cada pessoa, e v\u00e1rias outras estruturas semelhantes, como ordens de servi\u00e7o, descri\u00e7\u00e3o de invent\u00e1rios, cadastro de vendedores, etc. Uma forma de simplificar o c\u00f3digo \u00e9 definir tipos associados a cada estrutura.","title":"Tuplas"},{"location":"tuples/#tuplas-como-tipos","text":"Como visto anteriormente, a palavra reservada type permite que definamos apelidos para tipos no Haskell. Pois tuplas tamb\u00e9m podem ser associadas a tipos, por exemplo, podemos definir que Pessoa \u00e9 o tipo definido na se\u00e7\u00e3o anterior, i.e., uma tupla dos campos nome, telefone, CPF e endere\u00e7o. type Pessoa = ( String , String , String , String ) fazPessoa :: String -> String -> String -> String -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> String pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> String pegaTelefone ( _ , telefone , _ , _ ) = telefone pegaCPF :: Pessoa -> String pegaCPF ( _ , _ , c , _ ) = c pegaEndere\u00e7o :: Pessoa -> String pegaEndere\u00e7o ( _ , _ , _ , e ) = e trocaTelefone :: Pessoa -> String -> Pessoa trocaTelefone p novoTelefone = fazPessoa ( pegaNome p ) novoTelefone ( pegaCPF p ) ( pegaEndere\u00e7o p ) Se perguntarmos ao Haskell qual o tipo da tupla gerada pela fun\u00e7\u00e3o fazPessoa , ele responder\u00e1 Pessoa . > : t fazPessoa fazPessoa :: String -> String -> String -> String -> Pessoa > p = fazPessoa \"Jose\" \"Tel\" \"CPF\" \"End\" > : t p p :: Pessoa Podemos ir al\u00e9m e definir tipos usando outros tipos estruturados. Por exemplo: type Nome = ( String , String , String ) type Telefone = ( String , String ) type CPF = String type Endere\u00e7o = ( String , String , String ) type Pessoa = ( Nome , Telefone , CPF , Endere\u00e7o ) fazPessoa :: Nome -> Telefone -> CPF -> Endere\u00e7o -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> Nome pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> Telefone pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone :: Pessoa -> Telefone -> Pessoa trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) Neste caso > p = fazPessoa ( \"Jos\u00e9\" , \"da\" , \"Silva\" ) ( \"ddd\" , \"numero\" ) \"CPF\" ( \"Rua da Couves\" , \"143\" , \"Brasil\" ) > p (( \"Jos \\233 \" , \"da\" , \"Silva\" ),( \"ddd\" , \"numero\" ), \"CPF\" ,( \"Rua da Couves\" , \"143\" , \"Brasil\" )) > : t p p :: Pessoa > n = pegaNome p > n ( \"Jos \\233 \" , \"da\" , \"Silva\" ) > : t n n :: Nome Vejamos outro exemplo; sejam datas, tuplas de 3 inteiros: dia, m\u00eas e ano. Assim, 25 de dezembro de 1999 \u00e9 ( 25 , 12 , 1999 ) . Dado duas datas v\u00e1lidas, uma opera\u00e7\u00e3o interessante \u00e9 testar se uma data \u00e9 menor que outra. type Data = ( Int , Int , Int ) dataEhMenor :: ( Int , Int , Int ) -> ( Int , Int , Int ) -> Bool dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) dataEhMenor' :: Data -> Data -> Bool dataEhMenor' ( de , me , ae ) ( dd , md , ad ) = if ae < ad then True else if me < md then True else if de < dd then True else False Mas esta fun\u00e7\u00e3o pode ser descartada com a escolha da defini\u00e7\u00e3o de data, pois tuplas s\u00e3o naturalmente orden\u00e1veis. Data V\u00e1lida Defina um tipo para representar datas como tuplas. Defina uma fun\u00e7\u00e3o dataValida que receba uma data e retorne True se a data for v\u00e1lida e False se for inv\u00e1lida. Por exemplo, 38 de onzembro de 2021 \u00e9 uma data inv\u00e1lida, assim como 29 de fevereiro de 2017, mas dia primeiro de Janeiro de 2000 \u00e9 v\u00e1lida. Isto \u00e9, dataValida ( 38 , 13 , 2021 ) == False dataValida ( 29 , 02 , 2017 ) == False dataValida ( 1 , 1 , 2000 ) == True Resolu\u00e7\u00e3o type Data = ( Int , Int , Int ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) {- >>> bissexto 3 False >>> bissexto 20 True >>> bissexto 100 False >>> bissexto 2000 True -} bissexto :: Integral a => a -> Bool bissexto x | mod x 400 == 0 = True | mod x 100 == 0 = False | otherwise = mod x 4 == 0 {- >>> dataValida (1,1,2001) True >>> dataValida (1,13,2001) False >>> dataValida (29,2,2000) True >>> dataValida (29,2,1999) -} dataValida :: ( Int , Int , Int ) -> Bool dataValida ( d , m , a ) = anoValido a && mesValido m && diaValido d m ( bissexto a ) {- >>> diaValido 2 1 False True >>> diaValido 2 1 True True >>> diaValido 29 2 False False >>> diaValido 29 2 True True -} diaValido :: Int -> Int -> Bool -> Bool diaValido d m bi = d > 0 && d <= numDias m bi {- >>> numDias 3 False 31 >>> numDias 2 True 29 >>> numDias 2 False 28 -} numDias :: Int -> Bool -> Int numDias m bi | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = if bi then 29 else 28 | otherwise = 30 {- >>> mesValido 4 True >>> mesValido 13 False -} mesValido :: Int -> Bool mesValido m = m > 0 && m < 13 {- >>> anoValido 3000 True -} anoValido :: Int -> Bool anoValido a = a > 0","title":"Tuplas como tipos"},{"location":"tuples/#ordem-entre-tuplas","text":"Dado duas tuplas com mesmo tipo e, obviamente, de mesmo tamanho , elas podem se comparadas lexicogr\u00e1ficamente. Isto quer dizer que uma tupla \\(t_1\\) \u00e9 menor que uma tupla \\(t_2\\) se, considerando posi\u00e7\u00f5es da direita para a esquerda: dado uma posi\u00e7\u00e3o \\(i\\) , se \\(t_1\\) na posi\u00e7\u00e3o \\(i\\) \u00e9 menor que \\(t_2\\) na posi\u00e7\u00e3o \\(i\\) e se \\(\\forall j < i\\) , \\(t_1\\) na posi\u00e7\u00e3o \\(j\\) \u00e9 igual a \\(t_2\\) na posi\u00e7\u00e3o \\(j\\) . > ( 1 , 2 ) < ( 1 , 3 ) True > ( 'a' , 2 ) < ( 'b' , 3 ) True > ( 'a' , 2 ) == ( 'b' , 3 ) False > ( 'a' , 2 ) > ( 'b' , 3 ) False > ( 1 , 2 ) < ( 1 , 3 , 4 ) <== Erro ! > ( 1 , 1 , 1 ) < ( 1 , 1 , 1 ) False > ( 1 , 1 , 1 ) < ( 1 , 1 , 2 ) True > ( 1 , 1 , 1 ) < ( 1 , 2 , 1 ) True > ( 1 , 1 , 1 ) < ( 2 , 1 , 1 ) True > ( 1 , 1 , 1 ) < ( 0 , 2 , 2 ) False Assim, se usarmos como data uma tupla com ano, m\u00eas e dia, nesta ordem , ent\u00e3o duas datas podem ser comparadas diretamente como compara\u00e7\u00e3o de tuplas. type Data = ( Int , Int , Int ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor :: Data -> Data -> Bool dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor' :: Data -> Data -> Bool dataEhMenor' ( de , me , ae ) ( dd , md , ad ) = ( ae , me , de ) < ( ad , md , dd )","title":"Ordem entre tuplas"},{"location":"tuples/#a-tupla-vazia","text":"Por completude, \u00e9 preciso mencionar que tuplas podem ter qualquer aridade, inclusive zero. Isto \u00e9, () \u00e9 uma tupla v\u00e1lida e a \u00fanica inst\u00e2ncia de tuplas de aridade zero.","title":"A tupla vazia"},{"location":"type_variables/","text":"Polimorfismo Observe o funcionamento da fun\u00e7\u00e3o head nos seguintes exemplos. > head [( 1 , 2 ),( 3 , 4 ),( 5 , 6 )] ( 1 , 2 ) > head [ 1 , 2 , 3 , 4 ] 1 > head \"abcd\" 'a' Independentemente do tipo dos elementos da lista e, portanto, da lista, head consistentemente retorna o primeiro elemento da lista passada como par\u00e2metro. Isso acontece porqu\u00ea a fun\u00e7\u00e3o head \u00e9 o que chamamos de polim\u00f3rfica , literalmente, com muitos formas, e pode atuar sobre listas de diversos tipos. Fun\u00e7\u00f5es polim\u00f3rficas s\u00e3o declaradas usando vari\u00e1veis de tipo em vez de tipos espec\u00edficos para os par\u00e2metros, como fizemos at\u00e9 agora. A fun\u00e7\u00e3o head , por exemplo, tem declara\u00e7\u00e3o de tipo head :: [ a ] -> a , 1 onde a \u00e9 a vari\u00e1vel de tipo. Esta declara\u00e7\u00e3o implica que a fun\u00e7\u00e3o recebe como par\u00e2metro uma lista de elementos de um tipo qualquer a e que retorna um elemento do mesmo tipo a . V\u00e1rias vari\u00e1veis de tipos podem aparecer em uma mesma declara\u00e7\u00e3o, como em snd :: ( a , b ) -> b , que define que o resultado da fun\u00e7\u00e3o \u00e9 do mesmo tipo do segundo elemento da dupla passada como par\u00e2metros, ou zip :: [ a ] -> [ b ] -> [( a , b )] , que combina o tipo dos par\u00e2metros de entrada em uma tupla dos mesmos tipos no resultado da fun\u00e7\u00e3o. Observe que vari\u00e1veis de tipo devem come\u00e7ar com uma letra min\u00fascula e, geralmente, s\u00e3o recebem nomes a , b , c ... , mas fora isso, podem ter qualquer nome, o que literalmente permite que fun\u00e7\u00f5es tenham uma infinitude de nomes. Declara\u00e7\u00f5es tamb\u00e9m podem misturar vari\u00e1veis de tipo com tipos normais, como em length :: [ a ] -> Int , que define que o comprimento de uma lista de qualquer tipo ser\u00e1 sempre do tipo Int , e take :: Int -> [ a ] -> [ a ] . Enquanto algumas fun\u00e7\u00f5es tem vari\u00e1veis de tipo completamente livres, isto \u00e9, podem ser instanciadas com qualquer tipo, outras imp\u00f5em certas restri\u00e7\u00f5es nos tipos na forma de classes de tipo . Por exemplo, a fun\u00e7\u00e3o sort recebe uma lista de dados e retorna uma lista com os mesmos dados, ordenados. Para implementar a ordena\u00e7\u00e3o, \u00e9 preciso que os elementos da lista possam ser comparados uns com os outros, o que \u00e9 determinado pela pertin\u00eancia do tipo \u00e0 classe de tipos Ord . A declara\u00e7\u00e3o da fun\u00e7\u00e3o fica ent\u00e3o assim: sort :: Ord a => [ a ] -> [ a ] . 2 Uma mesma vari\u00e1vel de tipo pode pertencer a m\u00faltiplas classes e diferentes vari\u00e1veis podem pertencer a classes diferentes, como nas seguintes declara\u00e7\u00f5es: quickSort :: Ord a => [ a ] -> [ a ] quickSort [] = [] quickSort ( x : xs ) = quickSort ( filter ( <= x ) xs ) ++ [ x ] ++ quickSort ( filter ( > x ) xs ) sortAndPrint :: ( Show a , Ord a ) => [ a ] -> [ String ] sortAndPrint l = map show ( quickSort l ) > quickSort [ 10 , 9 .. 1 ] [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] > sortAndPrint [ 10 , 9 .. 1 ] [ \"1\" , \"2\" , \"3\" , \"4\" , \"5\" , \"6\" , \"7\" , \"8\" , \"9\" , \"10\" ] Este tipo de polimorfismo, em que o tipo n\u00e3o tem qualquer restri\u00e7\u00e3o, \u00e9 denominado param\u00e9trico . \u21a9 Este tipo de polimorfismo \u00e9 denominado ad-hoc . \u21a9","title":"Polimorfismo"},{"location":"type_variables/#polimorfismo","text":"Observe o funcionamento da fun\u00e7\u00e3o head nos seguintes exemplos. > head [( 1 , 2 ),( 3 , 4 ),( 5 , 6 )] ( 1 , 2 ) > head [ 1 , 2 , 3 , 4 ] 1 > head \"abcd\" 'a' Independentemente do tipo dos elementos da lista e, portanto, da lista, head consistentemente retorna o primeiro elemento da lista passada como par\u00e2metro. Isso acontece porqu\u00ea a fun\u00e7\u00e3o head \u00e9 o que chamamos de polim\u00f3rfica , literalmente, com muitos formas, e pode atuar sobre listas de diversos tipos. Fun\u00e7\u00f5es polim\u00f3rficas s\u00e3o declaradas usando vari\u00e1veis de tipo em vez de tipos espec\u00edficos para os par\u00e2metros, como fizemos at\u00e9 agora. A fun\u00e7\u00e3o head , por exemplo, tem declara\u00e7\u00e3o de tipo head :: [ a ] -> a , 1 onde a \u00e9 a vari\u00e1vel de tipo. Esta declara\u00e7\u00e3o implica que a fun\u00e7\u00e3o recebe como par\u00e2metro uma lista de elementos de um tipo qualquer a e que retorna um elemento do mesmo tipo a . V\u00e1rias vari\u00e1veis de tipos podem aparecer em uma mesma declara\u00e7\u00e3o, como em snd :: ( a , b ) -> b , que define que o resultado da fun\u00e7\u00e3o \u00e9 do mesmo tipo do segundo elemento da dupla passada como par\u00e2metros, ou zip :: [ a ] -> [ b ] -> [( a , b )] , que combina o tipo dos par\u00e2metros de entrada em uma tupla dos mesmos tipos no resultado da fun\u00e7\u00e3o. Observe que vari\u00e1veis de tipo devem come\u00e7ar com uma letra min\u00fascula e, geralmente, s\u00e3o recebem nomes a , b , c ... , mas fora isso, podem ter qualquer nome, o que literalmente permite que fun\u00e7\u00f5es tenham uma infinitude de nomes. Declara\u00e7\u00f5es tamb\u00e9m podem misturar vari\u00e1veis de tipo com tipos normais, como em length :: [ a ] -> Int , que define que o comprimento de uma lista de qualquer tipo ser\u00e1 sempre do tipo Int , e take :: Int -> [ a ] -> [ a ] . Enquanto algumas fun\u00e7\u00f5es tem vari\u00e1veis de tipo completamente livres, isto \u00e9, podem ser instanciadas com qualquer tipo, outras imp\u00f5em certas restri\u00e7\u00f5es nos tipos na forma de classes de tipo . Por exemplo, a fun\u00e7\u00e3o sort recebe uma lista de dados e retorna uma lista com os mesmos dados, ordenados. Para implementar a ordena\u00e7\u00e3o, \u00e9 preciso que os elementos da lista possam ser comparados uns com os outros, o que \u00e9 determinado pela pertin\u00eancia do tipo \u00e0 classe de tipos Ord . A declara\u00e7\u00e3o da fun\u00e7\u00e3o fica ent\u00e3o assim: sort :: Ord a => [ a ] -> [ a ] . 2 Uma mesma vari\u00e1vel de tipo pode pertencer a m\u00faltiplas classes e diferentes vari\u00e1veis podem pertencer a classes diferentes, como nas seguintes declara\u00e7\u00f5es: quickSort :: Ord a => [ a ] -> [ a ] quickSort [] = [] quickSort ( x : xs ) = quickSort ( filter ( <= x ) xs ) ++ [ x ] ++ quickSort ( filter ( > x ) xs ) sortAndPrint :: ( Show a , Ord a ) => [ a ] -> [ String ] sortAndPrint l = map show ( quickSort l ) > quickSort [ 10 , 9 .. 1 ] [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] > sortAndPrint [ 10 , 9 .. 1 ] [ \"1\" , \"2\" , \"3\" , \"4\" , \"5\" , \"6\" , \"7\" , \"8\" , \"9\" , \"10\" ] Este tipo de polimorfismo, em que o tipo n\u00e3o tem qualquer restri\u00e7\u00e3o, \u00e9 denominado param\u00e9trico . \u21a9 Este tipo de polimorfismo \u00e9 denominado ad-hoc . \u21a9","title":"Polimorfismo"},{"location":"types/","text":"Tipos Seja a fun\u00e7\u00e3o diasMes a fun\u00e7\u00e3o que calcula a quantidade de dias em um m\u00eas, dado o n\u00famero do m\u00eas, definida assim: diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 O que acontece se voc\u00ea passar 7.2 para a fun\u00e7\u00e3o? O resultado est\u00e1 correto? Isso nos leva a perguntar como definir que uma fun\u00e7\u00e3o s\u00f3 \u00e9 aplic\u00e1vel a n\u00fameros inteiros, do tipo inteiro. Em linguagens de programa\u00e7\u00e3o, um tipo \u00e9 um nome dado a uma cole\u00e7\u00e3o de valores que tem um mesmo comportamento na linguagem. Na linguagem C, por exemplo, temos os tipos int e short , ambos associados a valores inteiros mas com n\u00famero de bits diferentes usados para represent\u00e1-los. Algumas linguagens s\u00e3o denominadas fracamente tipadas , o que quer dizer que o uso de tipos \u00e9 relaxado e pode at\u00e9 ser alterado em tempo de execu\u00e7\u00e3o. Por exemplo, no seguinte c\u00f3digo em Python a vari\u00e1vel x assume tr\u00eas tipos diferentes em momentos diferentes da execu\u00e7\u00e3o. x = \"lala\" print ( type ( x )) x = 10 print ( type ( x )) x = 10.0 print ( type ( x )) <class 'str' > <class 'int' > <class 'float' > J\u00e1 a linguagem Haskell \u00e9 o que chamamos de fortemente tipada , o que quer dizer que toda vari\u00e1vel, constante ou fun\u00e7\u00e3o tem apenas um tipo e este sempre pode ser determinado. Al\u00e9m disso, Haskell \u00e9 estaticamente tipada , ou seja, os tipos s\u00e3o determinados em tempo de compila\u00e7\u00e3o, em oposi\u00e7\u00e3o a linguagens que determinam o tipo durante a execu\u00e7\u00e3o do programa, denominadas dinamicamente tipadas. Assim como type em Python, Haskell tem a fun\u00e7\u00e3o : type para verificar o tipo de uma vari\u00e1vel. Por exemplo: > : type 1 1 :: Num p => p > : type 1.0 1.0 :: Fractional p => p > : type \"Bom dia\" \"Bom dia\" :: [ Char ] Tipos em Haskell Forte Est\u00e1ticos Por Infer\u00eancia Finalmente, se olharmos novamente para os exemplos de fun\u00e7\u00f5es anteriores, veremos que n\u00e3o foram definidos tipos em suas declara\u00e7\u00f5es; isto \u00e9 poss\u00edvel porqu\u00ea Haskell consegue inferir os tipos dos dados de forma muito eficiente. Quando voc\u00ea explicita tipos, o faz apenas para facilitar a leitura do c\u00f3digo e para indicar sua inten\u00e7\u00e3o ao compilador que, pode-se dizer, far\u00e1 a infer\u00eancia e testar\u00e1 se voc\u00ea est\u00e1 certo. Haskell tem um n\u00famero imenso de tipos pre-definidos, organizados hierarquicamente, e que podem ser usados para definir novos tipos pelo programador. Mas por enquanto, nos foquemos nos tipos mais simples. Tipos Primitivos e Operadores Tipos num\u00e9ricos Como toda linguagem de programa\u00e7\u00e3o, Haskell tem v\u00e1rios tipos pr\u00e9-definidos para representar n\u00fameros, como mostra a seguinte tabela. Tipo Descri\u00e7\u00e3o Valores Int Inteiro de precis\u00e3o finita 4, -14, 2147483647 Integer Inteiro de precis\u00e3o arbitr\u00e1ria 30414093201713378043612608166064768844377641568960512000000000000 Float Ponto flutuante de precis\u00e3o simples 25.132742 Double Ponto flutuante de precis\u00e3o dupla 25.132741228718345 Dados os tipos num\u00e9ricos prim\u00e1rios, o pr\u00f3ximo passo \u00e9 ver alguns dos operadores que os manipulam. Operador Opera\u00e7\u00e3o + Adi\u00e7\u00e3o - Subtra\u00e7\u00e3o * Multiplica\u00e7\u00e3o / Divis\u00e3o ^ Exponencia\u00e7\u00e3o, e.g, 2^4 == 16 - Invers\u00e3o de sinal, e.g, - (-10) == 10 2 negate Invers\u00e3o de sinal, e.g, negate (-10) == 10 2 quot Divis\u00e3o inteira, truncado pro 0, i.e., quot a b \u00e9 igual a \\(\\lfloor\\frac{a}{b}\\rfloor\\) se \\(a>0\\) e \\(\\lceil\\frac{a}{b}\\rceil\\) se \\(a<0\\) , e.g, div 8 3 == 2 e div (-8) 3 == -2 rem Resto da divis\u00e3o inteira, tal que (x `quot` y)*y + (x `rem` y) == x div Resto da divis\u00e3o, truncado para baixo, i.e., div a b \u00e9 igual a \\(\\lfloor\\frac{a}{b}\\rfloor\\) , e.g, div 8 3 == 2 e div (-8) 3 == -3 mod M\u00f3dulo do inteiro, tal que ( x ` div ` y ) * y + ( x ` mod ` y ) == x Observe que alguns destes operadores s\u00e3o naturalmente infixos, e.g., + , e outros, prefixos, e.g., rem . 1 Contudo, ambos podem ser usados da outra forma, como mostrado nos seguintes exemplos. 10 + 20 ( + ) 10 20 quot 10 3 10 ` quot ` 3 Caso voc\u00ea queira ou precise especificar um tipo para um n\u00famero, pode sufix\u00e1-lo com o tipo, por exemplo, 20 :: Int ou 20 :: Double . Exerc\u00edcios Usar todos os operadores Evidenciar diferen\u00e7as entrem quot/rem e div/mod. Booleanos Finalmente, para representa\u00e7\u00e3o de valores l\u00f3gicos, Haskell define o tipo bool . Tipo Descri\u00e7\u00e3o Valores Bool Booleano True ou False Para este tipo, temos os seguintes operadores. Operador Opera\u00e7\u00e3o && E l\u00f3gico || OU l\u00f3gico not Nega\u00e7\u00e3o == Igualdade /= Diferen\u00e7a Caracteres Para a representa\u00e7\u00e3o de caracteres individuais, Haskell usa o tipo Char , e para sequ\u00eancias de caracteres, usa o tipo String , que \u00e9 um \"apelido\" para lista de Char . 3 Como lista n\u00e3o \u00e9 um tipo primitivo, ou melhor, mesmo que em Haskell listas sejam fundamentais, n\u00e3o as estudaremos agora. Ainda assim, usaremos String em alguns exemplos, mas sem entrar em detalhes da manipula\u00e7\u00e3o de listas. Exemplos dos dois tipos s\u00e3o apresentados na tabela a seguir. Tipo Descri\u00e7\u00e3o Valores Char Caractere '1'; 'a'; 'B' String Sequ\u00eancia de caracteres \"Eu\"; \"Hello\"; \"Zabumba\" Algumas fun\u00e7\u00f5es \u00fateis na manipula\u00e7\u00e3o de caracteres e strings s\u00e3o apresentadas na tabela. Operador Opera\u00e7\u00e3o Exemplo ++ Concatena\u00e7\u00e3o \"foo\" ++ \"bar\" -> \"foobar\" !! Caractere no \u00edndice \"foo bar\" !! 2 -> 'o' take Substring iniciando em 0 take 3 \"foo bar\" -> \"foo\" drop Substring come\u00e7ando em um \u00edndice drop 3 \"foo bar\" -> \" bar\" reverse String ao contr\u00e1rio reverse \"foo bar\" -> \"rab oof\" length Comprimento da string length \"foo bar\" -> 7 N\u00f3s voltaremos a falar sobre Strings uma vez que estudarmos listas. Exerc\u00edcios Defina fun\u00e7\u00e3o que retorne substring de t elementos come\u00e7ando na posi\u00e7\u00e3o i minhaFuncao \"entrada1\" 2 2 retorna \"tr\" Defina fun\u00e7\u00e3o que retorne substring com os \u00faltimos u elementos minhaFuncao \"entrada1\" 2 retorna \"a1\" Defina fun\u00e7\u00e3o que receba duas strings e retorne a resultado da concatena\u00e7\u00e3o das substrings de t elementos come\u00e7ando na posi\u00e7\u00e3o i minhaFuncao \"entrada1\" \"entrada2\" 2 2 retorna \"trtr\" Prot\u00f3tipo de fun\u00e7\u00f5es Agora que j\u00e1 conhecemos alguns tipos, podemos ver como us\u00e1-los na defini\u00e7\u00e3o de fun\u00e7\u00f5es. Para faz\u00ea-lo, devemos usar a seguinte sintaxe: nomeFuncao :: tipo_arg1 -> ... -> tipo_argN -> tipo_saida nomeFuncao arg1 ... argN = < definicao > Por exemplo, o prot\u00f3tipo da fun\u00e7\u00e3o diaMes , isto \u00e9, a defini\u00e7\u00e3o dos tipos de entrada e sa\u00edda da fun\u00e7\u00e3o, fica assim: diasMes :: Int -> Int diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 Exerc\u00edcios Defina o prot\u00f3tipo da fun\u00e7\u00e3o de convers\u00e3o de Fahrenheit para Celsius f2c x = ( x - 32 ) / 1.8 Descubra a quanto 100f corresponde em C\u00e9lsius Resolu\u00e7\u00e3o f2c :: Float -> Float ` f2c x = ( x - 32 ) / 1.8 Defina o prot\u00f3tipo da fun\u00e7\u00e3o de media de dois n\u00fameros reais m2n a b = ( a + b ) / 2 Resolu\u00e7\u00e3o m2n :: Float -> Float -> Float m2n a b = ( a + b ) / 2 Defina o prot\u00f3tipo da soma de dois n\u00fameros inteiros soma2int a b = a + b Aplique a fun\u00e7\u00e3o aos valores 2 e 3. Aplique a fun\u00e7\u00e3o aos valores 2.0 e 3.0. Resolu\u00e7\u00e3o soma2int :: Int -> Int -> Int soma2int a b = a + b Defina o prot\u00f3tipo da soma de dois n\u00fameros reais soma2reais a b = a + b Aplique a fun\u00e7\u00e3o aos valores 2.0 e 3.0. Aplique a fun\u00e7\u00e3o aos valores 2 e 3. Resolu\u00e7\u00e3o soma2reais :: Float -> Float -> Float Explique a diferen\u00e7a de comportamento das duas \u00faltimas fun\u00e7\u00f5es. Resolu\u00e7\u00e3o As fun\u00e7\u00f5es se comportam diferentemente, sendo que a primeira mostra um erro quando aplicada a dois n\u00fameros reais, porqu\u00ea \\(Z \\subset R\\) mas \\(R \\not\\subset Z\\) . Defini\u00e7\u00e3o de novos tipos A palavra reservada type permite que definamos apelidos para tipos no Haskell, tornando o c\u00f3digo mais leg\u00edvel. Por exemplo, podemos definir um tipo Inteiro similar ao tipo Int e fun\u00e7\u00f5es associadas ao tipo. type Inteiro = Int somaInteiros :: Inteiro -> Inteiro -> Inteiro somaInteiros a b = a + b O uso da fun\u00e7\u00e3o \u00e9 como esperado. * Main > somaInteiros 1 2 3 * Main > somaInteiros ( 1 :: Inteiro ) ( 2 :: Inteiro ) 3 :type e :info O GHC \u00e9 uma ferramenta poderosa no aprendizado da linguagem Haskell por possuir uma s\u00e9rie de comandos que permitem extrair informa\u00e7\u00f5es sobre tipos e fun\u00e7\u00f5es definidas. Usando o comando : info (ou simplesmente : i ), por exemplo, podemos perguntar ao ghci o que ele sabe sobre o tipo Inteiro , ao que ser\u00e1 respondido que \u00e9 o tipo inteiro \u00e9 um apelido para Int , definido no arquivo scratch.hs, no meu caso. * Main > : i Inteiro type Inteiro :: * type Inteiro = Int -- Defined at scratch.hs:82:1 J\u00e1 o comando : type (ou : t ) pode ser usado para identificar o tipo de fun\u00e7\u00f5es, por exemplo: * Main > somaInteiros 1 2 3 * Main > : i somaInteiros somaInteiros :: Inteiro -> Inteiro -> Inteiro * Main > : t 1 :: Inteiro 1 :: Inteiro :: Inteiro Estes comandos podem ser aplicados a quaisquer defini\u00e7\u00f5es, n\u00e3o somente \u00e0s suas. Por exemplo, podemos solicitar informa\u00e7\u00f5es sobre o tipo Num , com seguinte resultado. * Main > : i Num type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ( - ) :: a -> a -> a ( * ) :: a -> a -> a negate :: a -> a abs :: a -> a signum :: a -> a fromInteger :: Integer -> a {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-} -- Defined in \u2018GHC.Num\u2019 instance Num Word -- Defined in \u2018GHC.Num\u2019 instance Num Integer -- Defined in \u2018GHC.Num\u2019 instance Num Int -- Defined in \u2018GHC.Num\u2019 instance Num Float -- Defined in \u2018GHC.Float\u2019 instance Num Double -- Defined in \u2018GHC.Float\u2019 Algumas das informa\u00e7\u00f5es apresentadas podem ainda n\u00e3o fazer sentido para voc\u00ea, mas de forma geral podemos resum\u00ed-las como implicando que algumas opera\u00e7\u00f5es, como + , - e abs se aplicam ao tipo Num , e que outros tipos, como Float e Integer s\u00e3o inst\u00e2ncias de Num . Se aplicarmos o mesmo comando ao operador + , descobriremos que ele \u00e9 uma fun\u00e7\u00e3o infixa por padr\u00e3o ( INFIXl ), associativo \u00e0 esquerda ( infixL ), e com prioridade 6. * Main > : i ( + ) type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ... -- Defined in \u2018GHC.Num\u2019 infixl 6 + Tamb\u00e9m vemos que o estas defini\u00e7\u00f5es s\u00e3o parde do GHC.Num, mas o que \u00e9 o GHC.Num? M\u00f3dulos Como em diversas outras linguagens, Haskell usa m\u00f3dulos para organizar a defini\u00e7\u00e3o de tipos e fun\u00e7\u00f5es, colocando aquelas relacionadas no mesmo m\u00f3dulo. Por padr\u00e3o, o m\u00f3dulo prelude 5 \u00e9 carregado toda vez que executa o ghci ou compila um programa, a n\u00e3o ser que seja explicitamente indicado em contr\u00e1rio. Este m\u00f3dulo cont\u00e9m a defini\u00e7\u00e3o dos tipos e operadores b\u00e1sicos vistos anteriormente, al\u00e9m de muitos outros, e o GHC.Num \u00e9 parte do Prelude. Uma pequena mas interessante amostra de outros tipos inclu\u00eddos: Nome Defini\u00e7\u00e3o min Menor de 2 elementos orden\u00e1veis max Maior de 2 elementos orden\u00e1veis Semigroup Uma classe em que vale a associatividade Monoid Mon\u00f3ide em que h\u00e1 um elemento identidade putChar Escreve um caractere na saida padr\u00e3o putString Escreve uma string na saida padr\u00e3o getChar L\u00ea um caractere da entrada padr\u00e3o getString L\u00ea uma string da entrada padr\u00e3o Estes exemplos servem para mostrar como o m\u00f3dulo mais b\u00e1sico do Haskell \u00e9 diverso e como a sua biblioteca \u00e9 mais diversa ainda. Al\u00e9m do Prelude, centenas de outros m\u00f3dulos est\u00e3o dispon\u00edveis na Web, de compiladores a geradores de gr\u00e1ficos 3D, de transformadas r\u00e1pidas de Fourier a message brokers , em reposit\u00f3rios como o Hackage. 4 Contudo, \u00e9 preciso ter cuidado com os m\u00f3dulos que baixa. Caso voc\u00ea encontre um m\u00f3dulo que queira usar, de nome X , bastar baix\u00e1-lo e usar o import . Por exemplo, para trabalhar com n\u00fameros complexos, voce pode usar o m\u00f3dulo Data . Complex assim: Prelude > import Data.Complex Prelude Data . Complex > let x = 1.0 :+ 0.0 Prelude Data . Complex > x 1.0 :+ 0.0 Com esta visita r\u00e1pida ao Prelude, encerramos esta introdu\u00e7\u00e3o ao Haskell e rumamos para t\u00f3picos mais universais. Isto \u00e9, mesmo que os t\u00f3picos vistos at\u00e9 agora sejam obviamente associados \u00e0 programa\u00e7\u00e3o funcional, os mesmos est\u00e3o fortemente relacionados \u00e0 sintaxe do Haskell. J\u00e1 nas pr\u00f3ximas se\u00e7\u00f5es, veremos t\u00f3picos mais independentes, i.e., mesmo que as fun\u00e7\u00f5es, tipos e construtos usados ainda sejam implementadas em Haskell, os conceitos por tr\u00e1s s\u00e3o mais universais. Operadores s\u00e3o fun\u00e7\u00f5es cujos nomes s\u00f3 contem caracteres especiais. Eles s\u00e3o naturalmente infixos. \u21a9 Observe que o o -10 est\u00e1 entre par\u00eanteses n\u00e3o porque o operador demanda, mas para deixar claro que o - faz parte do n\u00famero. \u21a9 \u21a9 Haskell define tamb\u00e9m o tipo Text, uma forma mais moderna de manipular texto, mas n\u00e3o discutiremos Text aqui. \u21a9 https://hackage.haskell.org/packages/browse \u21a9 Prelude: https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html [^typeconversion] https://andrew.gibiansky.com/blog/haskell/haskell-typeclasses/#_read \u21a9","title":"Tipos"},{"location":"types/#tipos","text":"Seja a fun\u00e7\u00e3o diasMes a fun\u00e7\u00e3o que calcula a quantidade de dias em um m\u00eas, dado o n\u00famero do m\u00eas, definida assim: diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 O que acontece se voc\u00ea passar 7.2 para a fun\u00e7\u00e3o? O resultado est\u00e1 correto? Isso nos leva a perguntar como definir que uma fun\u00e7\u00e3o s\u00f3 \u00e9 aplic\u00e1vel a n\u00fameros inteiros, do tipo inteiro. Em linguagens de programa\u00e7\u00e3o, um tipo \u00e9 um nome dado a uma cole\u00e7\u00e3o de valores que tem um mesmo comportamento na linguagem. Na linguagem C, por exemplo, temos os tipos int e short , ambos associados a valores inteiros mas com n\u00famero de bits diferentes usados para represent\u00e1-los. Algumas linguagens s\u00e3o denominadas fracamente tipadas , o que quer dizer que o uso de tipos \u00e9 relaxado e pode at\u00e9 ser alterado em tempo de execu\u00e7\u00e3o. Por exemplo, no seguinte c\u00f3digo em Python a vari\u00e1vel x assume tr\u00eas tipos diferentes em momentos diferentes da execu\u00e7\u00e3o. x = \"lala\" print ( type ( x )) x = 10 print ( type ( x )) x = 10.0 print ( type ( x )) <class 'str' > <class 'int' > <class 'float' > J\u00e1 a linguagem Haskell \u00e9 o que chamamos de fortemente tipada , o que quer dizer que toda vari\u00e1vel, constante ou fun\u00e7\u00e3o tem apenas um tipo e este sempre pode ser determinado. Al\u00e9m disso, Haskell \u00e9 estaticamente tipada , ou seja, os tipos s\u00e3o determinados em tempo de compila\u00e7\u00e3o, em oposi\u00e7\u00e3o a linguagens que determinam o tipo durante a execu\u00e7\u00e3o do programa, denominadas dinamicamente tipadas. Assim como type em Python, Haskell tem a fun\u00e7\u00e3o : type para verificar o tipo de uma vari\u00e1vel. Por exemplo: > : type 1 1 :: Num p => p > : type 1.0 1.0 :: Fractional p => p > : type \"Bom dia\" \"Bom dia\" :: [ Char ] Tipos em Haskell Forte Est\u00e1ticos Por Infer\u00eancia Finalmente, se olharmos novamente para os exemplos de fun\u00e7\u00f5es anteriores, veremos que n\u00e3o foram definidos tipos em suas declara\u00e7\u00f5es; isto \u00e9 poss\u00edvel porqu\u00ea Haskell consegue inferir os tipos dos dados de forma muito eficiente. Quando voc\u00ea explicita tipos, o faz apenas para facilitar a leitura do c\u00f3digo e para indicar sua inten\u00e7\u00e3o ao compilador que, pode-se dizer, far\u00e1 a infer\u00eancia e testar\u00e1 se voc\u00ea est\u00e1 certo. Haskell tem um n\u00famero imenso de tipos pre-definidos, organizados hierarquicamente, e que podem ser usados para definir novos tipos pelo programador. Mas por enquanto, nos foquemos nos tipos mais simples.","title":"Tipos"},{"location":"types/#tipos-primitivos-e-operadores","text":"","title":"Tipos Primitivos e Operadores"},{"location":"types/#prototipo-de-funcoes","text":"Agora que j\u00e1 conhecemos alguns tipos, podemos ver como us\u00e1-los na defini\u00e7\u00e3o de fun\u00e7\u00f5es. Para faz\u00ea-lo, devemos usar a seguinte sintaxe: nomeFuncao :: tipo_arg1 -> ... -> tipo_argN -> tipo_saida nomeFuncao arg1 ... argN = < definicao > Por exemplo, o prot\u00f3tipo da fun\u00e7\u00e3o diaMes , isto \u00e9, a defini\u00e7\u00e3o dos tipos de entrada e sa\u00edda da fun\u00e7\u00e3o, fica assim: diasMes :: Int -> Int diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 Exerc\u00edcios Defina o prot\u00f3tipo da fun\u00e7\u00e3o de convers\u00e3o de Fahrenheit para Celsius f2c x = ( x - 32 ) / 1.8 Descubra a quanto 100f corresponde em C\u00e9lsius Resolu\u00e7\u00e3o f2c :: Float -> Float ` f2c x = ( x - 32 ) / 1.8 Defina o prot\u00f3tipo da fun\u00e7\u00e3o de media de dois n\u00fameros reais m2n a b = ( a + b ) / 2 Resolu\u00e7\u00e3o m2n :: Float -> Float -> Float m2n a b = ( a + b ) / 2 Defina o prot\u00f3tipo da soma de dois n\u00fameros inteiros soma2int a b = a + b Aplique a fun\u00e7\u00e3o aos valores 2 e 3. Aplique a fun\u00e7\u00e3o aos valores 2.0 e 3.0. Resolu\u00e7\u00e3o soma2int :: Int -> Int -> Int soma2int a b = a + b Defina o prot\u00f3tipo da soma de dois n\u00fameros reais soma2reais a b = a + b Aplique a fun\u00e7\u00e3o aos valores 2.0 e 3.0. Aplique a fun\u00e7\u00e3o aos valores 2 e 3. Resolu\u00e7\u00e3o soma2reais :: Float -> Float -> Float Explique a diferen\u00e7a de comportamento das duas \u00faltimas fun\u00e7\u00f5es. Resolu\u00e7\u00e3o As fun\u00e7\u00f5es se comportam diferentemente, sendo que a primeira mostra um erro quando aplicada a dois n\u00fameros reais, porqu\u00ea \\(Z \\subset R\\) mas \\(R \\not\\subset Z\\) .","title":"Prot\u00f3tipo de fun\u00e7\u00f5es"},{"location":"types/#definicao-de-novos-tipos","text":"A palavra reservada type permite que definamos apelidos para tipos no Haskell, tornando o c\u00f3digo mais leg\u00edvel. Por exemplo, podemos definir um tipo Inteiro similar ao tipo Int e fun\u00e7\u00f5es associadas ao tipo. type Inteiro = Int somaInteiros :: Inteiro -> Inteiro -> Inteiro somaInteiros a b = a + b O uso da fun\u00e7\u00e3o \u00e9 como esperado. * Main > somaInteiros 1 2 3 * Main > somaInteiros ( 1 :: Inteiro ) ( 2 :: Inteiro ) 3","title":"Defini\u00e7\u00e3o de novos tipos"},{"location":"types/#type-e-info","text":"O GHC \u00e9 uma ferramenta poderosa no aprendizado da linguagem Haskell por possuir uma s\u00e9rie de comandos que permitem extrair informa\u00e7\u00f5es sobre tipos e fun\u00e7\u00f5es definidas. Usando o comando : info (ou simplesmente : i ), por exemplo, podemos perguntar ao ghci o que ele sabe sobre o tipo Inteiro , ao que ser\u00e1 respondido que \u00e9 o tipo inteiro \u00e9 um apelido para Int , definido no arquivo scratch.hs, no meu caso. * Main > : i Inteiro type Inteiro :: * type Inteiro = Int -- Defined at scratch.hs:82:1 J\u00e1 o comando : type (ou : t ) pode ser usado para identificar o tipo de fun\u00e7\u00f5es, por exemplo: * Main > somaInteiros 1 2 3 * Main > : i somaInteiros somaInteiros :: Inteiro -> Inteiro -> Inteiro * Main > : t 1 :: Inteiro 1 :: Inteiro :: Inteiro Estes comandos podem ser aplicados a quaisquer defini\u00e7\u00f5es, n\u00e3o somente \u00e0s suas. Por exemplo, podemos solicitar informa\u00e7\u00f5es sobre o tipo Num , com seguinte resultado. * Main > : i Num type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ( - ) :: a -> a -> a ( * ) :: a -> a -> a negate :: a -> a abs :: a -> a signum :: a -> a fromInteger :: Integer -> a {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-} -- Defined in \u2018GHC.Num\u2019 instance Num Word -- Defined in \u2018GHC.Num\u2019 instance Num Integer -- Defined in \u2018GHC.Num\u2019 instance Num Int -- Defined in \u2018GHC.Num\u2019 instance Num Float -- Defined in \u2018GHC.Float\u2019 instance Num Double -- Defined in \u2018GHC.Float\u2019 Algumas das informa\u00e7\u00f5es apresentadas podem ainda n\u00e3o fazer sentido para voc\u00ea, mas de forma geral podemos resum\u00ed-las como implicando que algumas opera\u00e7\u00f5es, como + , - e abs se aplicam ao tipo Num , e que outros tipos, como Float e Integer s\u00e3o inst\u00e2ncias de Num . Se aplicarmos o mesmo comando ao operador + , descobriremos que ele \u00e9 uma fun\u00e7\u00e3o infixa por padr\u00e3o ( INFIXl ), associativo \u00e0 esquerda ( infixL ), e com prioridade 6. * Main > : i ( + ) type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ... -- Defined in \u2018GHC.Num\u2019 infixl 6 + Tamb\u00e9m vemos que o estas defini\u00e7\u00f5es s\u00e3o parde do GHC.Num, mas o que \u00e9 o GHC.Num?","title":":type e :info"},{"location":"types/#modulos","text":"Como em diversas outras linguagens, Haskell usa m\u00f3dulos para organizar a defini\u00e7\u00e3o de tipos e fun\u00e7\u00f5es, colocando aquelas relacionadas no mesmo m\u00f3dulo. Por padr\u00e3o, o m\u00f3dulo prelude 5 \u00e9 carregado toda vez que executa o ghci ou compila um programa, a n\u00e3o ser que seja explicitamente indicado em contr\u00e1rio. Este m\u00f3dulo cont\u00e9m a defini\u00e7\u00e3o dos tipos e operadores b\u00e1sicos vistos anteriormente, al\u00e9m de muitos outros, e o GHC.Num \u00e9 parte do Prelude. Uma pequena mas interessante amostra de outros tipos inclu\u00eddos: Nome Defini\u00e7\u00e3o min Menor de 2 elementos orden\u00e1veis max Maior de 2 elementos orden\u00e1veis Semigroup Uma classe em que vale a associatividade Monoid Mon\u00f3ide em que h\u00e1 um elemento identidade putChar Escreve um caractere na saida padr\u00e3o putString Escreve uma string na saida padr\u00e3o getChar L\u00ea um caractere da entrada padr\u00e3o getString L\u00ea uma string da entrada padr\u00e3o Estes exemplos servem para mostrar como o m\u00f3dulo mais b\u00e1sico do Haskell \u00e9 diverso e como a sua biblioteca \u00e9 mais diversa ainda. Al\u00e9m do Prelude, centenas de outros m\u00f3dulos est\u00e3o dispon\u00edveis na Web, de compiladores a geradores de gr\u00e1ficos 3D, de transformadas r\u00e1pidas de Fourier a message brokers , em reposit\u00f3rios como o Hackage. 4 Contudo, \u00e9 preciso ter cuidado com os m\u00f3dulos que baixa. Caso voc\u00ea encontre um m\u00f3dulo que queira usar, de nome X , bastar baix\u00e1-lo e usar o import . Por exemplo, para trabalhar com n\u00fameros complexos, voce pode usar o m\u00f3dulo Data . Complex assim: Prelude > import Data.Complex Prelude Data . Complex > let x = 1.0 :+ 0.0 Prelude Data . Complex > x 1.0 :+ 0.0 Com esta visita r\u00e1pida ao Prelude, encerramos esta introdu\u00e7\u00e3o ao Haskell e rumamos para t\u00f3picos mais universais. Isto \u00e9, mesmo que os t\u00f3picos vistos at\u00e9 agora sejam obviamente associados \u00e0 programa\u00e7\u00e3o funcional, os mesmos est\u00e3o fortemente relacionados \u00e0 sintaxe do Haskell. J\u00e1 nas pr\u00f3ximas se\u00e7\u00f5es, veremos t\u00f3picos mais independentes, i.e., mesmo que as fun\u00e7\u00f5es, tipos e construtos usados ainda sejam implementadas em Haskell, os conceitos por tr\u00e1s s\u00e3o mais universais. Operadores s\u00e3o fun\u00e7\u00f5es cujos nomes s\u00f3 contem caracteres especiais. Eles s\u00e3o naturalmente infixos. \u21a9 Observe que o o -10 est\u00e1 entre par\u00eanteses n\u00e3o porque o operador demanda, mas para deixar claro que o - faz parte do n\u00famero. \u21a9 \u21a9 Haskell define tamb\u00e9m o tipo Text, uma forma mais moderna de manipular texto, mas n\u00e3o discutiremos Text aqui. \u21a9 https://hackage.haskell.org/packages/browse \u21a9 Prelude: https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html [^typeconversion] https://andrew.gibiansky.com/blog/haskell/haskell-typeclasses/#_read \u21a9","title":"M\u00f3dulos"},{"location":"where_let_in/","text":"Frequentemente em nossas fun\u00e7\u00f5es, precisamos usar mais de uma vez um valor calculado por outra fun\u00e7\u00e3o. No c\u00e1lculo do \u00edndice de massa corporal a seguir, por exemplo, o valor do \u00edndice \u00e9 recalculado a cada guarda, ou seja, pode ser calculado at\u00e9 3 vezes. imc p a | p / a ^ 2 <= 18.5 = \"Baixo\" | p / a ^ 2 <= 25.0 = \"Normal\" | p / a ^ 2 <= 30.0 = \"Alto\" Para estes casos, Haskell nos d\u00e1 o construto where , que permite fazer defini\u00e7\u00f5es \"locais\" \u00e0 fun\u00e7\u00e3o. Where imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" where imc' = p / a ^ 2 O c\u00f3digo fica muito mais leg\u00edvel desta forma. O where pode ser at\u00e9 usado m\u00faltiplas vezes, bastando que todas as defini\u00e7\u00f5es estejam perfeitamente indentadas. No exemplo a seguir, fica f\u00e1cil localizar e modificar as defini\u00e7\u00f5es dos v\u00e1rios n\u00edveis de IMC. Ponto para a manutenabilidade! imc p a | imc' <= baixo = \"Baixo\" | imc' <= normal = \"Normal\" | imc' <= alto = \"Alto\" where imc' = p / a ^ 2 baixo = 18.5 normal = 25.0 alto = 30.0 where \u00e9 especialmente \u00fatil na defini\u00e7\u00e3o de fun\u00e7\u00f5es recursivas, pois permite nomear as invoca\u00e7\u00f5es, como por exemplo na defini\u00e7\u00e3o da fun\u00e7\u00e3o que calcula os termos da sequ\u00eancia de Fibonacci, com e sem o uso do construto. Sem Where fib 0 = 0 fib 1 = 1 fib n = fib ( n - 1 ) + fib ( n - 2 ) Com Where fib 0 = 0 fib 1 = 1 fib n = prev + prevPrev where prev = fib ( n - 1 ) prevPrev = fib ( n - 2 ) Neste caso pode-se argumentar que n\u00e3o houve ganhos com o mudan\u00e7a, dado que a fun\u00e7\u00e3o \u00e9 muito simples. Em fun\u00e7\u00f5es mais complexas, contudo, os benef\u00edcios em termos de legibilidade aumentam, como na fun\u00e7\u00e3o a seguir. collatz :: Int -> Int -> Int collatz n i | i == 1 = n | even anterior = anterior ` div ` 2 | otherwise = anterior * 3 + 1 where anterior = collatz n ( i - 1 ) converge :: Int -> Int -> Bool converge n passo | termo == 1 = True | otherwise = converge n ( passo + 1 ) where termo = collatz n passo let-in Um outro construto interessante e com funcionalidade parecida \u00e9 o let in , em que se pode fazer algumas defini\u00e7\u00f5es no let e que ser\u00e3o vis\u00edveis no in . Por exemplo, nas seguintes defini\u00e7\u00f5es. fib 0 = 0 fib 1 = 1 fib n = let prev = fib ( n - 1 ) prevPrev = fib ( n - 2 ) in prev + prevPrev areaCilindro r a = let areaLateral = 2 * pi * r * a areaTopo = pi * r ^ 2 in areaLateral + 2 * areaTopo Nestes exemplos, parece que where e let in s\u00e3o apenas sintaxes diferentes para o mesmo fim, criar defini\u00e7\u00f5es locais. Isso \u00e9 verdade, mas h\u00e1 algumas diferen\u00e7as fundamentais. Primeiro, enquanto o as defini\u00e7\u00f5es feitas no where s\u00e3o amarradas ao contexto da fun\u00e7\u00e3o em que est\u00e3o colocadas, podendo ser vistas em quaisquer outras partes da fun\u00e7\u00e3o, por exemplo guardas, as defini\u00e7\u00f5es feitas no let s\u00e3o muito mais localizadas, v\u00e1lidas apenas dentro do in correspondente. Segundo, let in s\u00e3o express\u00f5es e podem aparecer em qualquer lugar onde uma express\u00e3o \u00e9 esperada. Por exemplo, eles podem ser usados para definir constantes ou fun\u00e7\u00f5es * Main > 1 * ( let um = 1 in um + 1 ) + 1 3 * Main > let quadrado x = x * x in quadrado 3 9 Em alguns contextos em que o escopo \u00e9 muito claro, podemos omitir o in da defini\u00e7\u00e3o. No GHCI, por exemplo, o fizermos, ent\u00e3o a defini\u00e7\u00e3o feita ser\u00e1 v\u00e1lida por toda a execu\u00e7\u00e3o do REPL, ou at\u00e9 que seja sobrescrita. * Main > let quadrado x = x * x in quadrado 3 9 * Main > quadrado 3 < interactive >: 25 : 1 : error : Variable not in scope : quadrado :: t0 -> t * Main > let quadrado x = x * x * Main > quadrado 3 9","title":"Where e Let-In"}]}