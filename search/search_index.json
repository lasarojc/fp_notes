{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Notas de Aula em Programa\u00e7\u00e3o Funcional","title":"Notas de Aula em <br> Programa\u00e7\u00e3o Funcional"},{"location":"#notas-de-aula-em-programacao-funcional","text":"","title":"Notas de Aula em  Programa\u00e7\u00e3o Funcional"},{"location":"functions/","text":"Fun\u00e7\u00f5es Agora que j\u00e1 vimos exemplos extremamente simples, vejamos alguns um pouco mais interessantes, como uma fun\u00e7\u00e3o que soma os n\u00fameros de x a y , inclusive. A t\u00edtulo de compara\u00e7\u00e3o, vejamos primeiro a fun\u00e7\u00e3o em linguagem C. 1 2 3 4 5 6 7 8 int soma ( int x , int y ) { int total = 0 ; for ( int i = x ; i <= y ; i ++ ) total = total + i ; return total ; } soma ( 1 , 10 ); Em Haskell, temos diversas op\u00e7\u00f5es para obter o mesmo resultado, por exemplo, usando uma fun\u00e7\u00e3o recursiva... 1 2 3 4 5 somaDeAte x y = if x < y then x + somaDeAte ( x + 1 ) y else x somaDeAte 1 10 ... ou a fun\u00e7\u00e3o j\u00e1 existente sum , que recebe uma lista de n\u00fameros, neste caso criada pelo operador .. 1 sum [ 1 .. 10 ] Observe que a sintaxe do uso das fun\u00e7\u00f5es, contudo, \u00e9 diferente; em Haskell, usa-se o nome da fun\u00e7\u00e3o, seguido dos par\u00e2metros, com espa\u00e7o os separando. J\u00e1 a defini\u00e7\u00e3o de fun\u00e7\u00f5es segue algumas estruturas b\u00e1sicas, sendo a mais simples a defini\u00e7\u00e3o via equa\u00e7\u00e3o . Equa\u00e7\u00f5es Por exemplo, consideremos uma fun\u00e7\u00e3o que soma dois n\u00fameros. Em Haskell, ela \u00e9 definida simplesmente como soma x y = x + y e usada como soma 3 5 . Exerc\u00edcio: Soma Defina a fun\u00e7\u00e3o soma e a use, de acordo com a imagem. 1 Como outro exemplo, definamos uma fun\u00e7\u00e3o que retorna o sucessor de um inteiro como sucessor x = x + 1 . Com estas duas fun\u00e7\u00f5es, podemos inclusive compor fun\u00e7\u00f5es, no melhor estilo \\(g(f(x))\\) , por exemplo: sucessor ( soma 3 4 ) ou sucessor ( sucessor ( sucessor 4 )) . Exerc\u00edcio: Composi\u00e7\u00e3o Defina uma fun\u00e7\u00e3o que multiplique 3 n\u00fameros, isto \u00e9, dados \\(x\\) , \\(y\\) e \\(z\\) , calcule \\(x*y*z\\) . Calcule \\((1 + (3 * 2 * 3)) + (5 * 3 * 2)\\) usando as fun\u00e7\u00f5es de soma e multiplica\u00e7\u00e3o definidas. Resolu\u00e7\u00e3o Defina as fun\u00e7\u00f5es 1 2 3 soma x y = x + y mult3 x y z = x * y * z Invoque soma ( soma 1 ( mult3 3 2 3 )) ( mult3 5 3 2 ) . Observe que os par\u00eanteses s\u00e3o necess\u00e1rios para delimitar os par\u00e2metros de cada uma das invoca\u00e7\u00f5es. Exerc\u00edcio: m\u00e9dia de 3 n\u00fameros Defina uma fun\u00e7\u00e3o que calcule a m\u00e9dia de 3 n\u00fameros Resolu\u00e7\u00e3o media x y z = ( x + y + z ) / 3 Exerc\u00edcio: \u00e1rea das figuras Defina uma fun\u00e7\u00e3o o c\u00e1lculo da \u00e1rea de cada figura geom\u00e9trica. Resolu\u00e7\u00e3o 1 2 3 4 5 areaQuad a = a * a areaRet a b = a * b areaCirc r = pi * r * r areaTri a h = ( a * h ) / 2 areaTra a b h = ( a + b ) / 2 * h Se voc\u00ea se logar no Repl.it, poder\u00e1 salvar seus arquivos online e edit\u00e1-los de qualquer lugar, como no exemplo dado no exerc\u00edcio. \u21a9","title":"Primeiras fun\u00e7\u00f5es"},{"location":"functions/#funcoes","text":"Agora que j\u00e1 vimos exemplos extremamente simples, vejamos alguns um pouco mais interessantes, como uma fun\u00e7\u00e3o que soma os n\u00fameros de x a y , inclusive. A t\u00edtulo de compara\u00e7\u00e3o, vejamos primeiro a fun\u00e7\u00e3o em linguagem C. 1 2 3 4 5 6 7 8 int soma ( int x , int y ) { int total = 0 ; for ( int i = x ; i <= y ; i ++ ) total = total + i ; return total ; } soma ( 1 , 10 ); Em Haskell, temos diversas op\u00e7\u00f5es para obter o mesmo resultado, por exemplo, usando uma fun\u00e7\u00e3o recursiva... 1 2 3 4 5 somaDeAte x y = if x < y then x + somaDeAte ( x + 1 ) y else x somaDeAte 1 10 ... ou a fun\u00e7\u00e3o j\u00e1 existente sum , que recebe uma lista de n\u00fameros, neste caso criada pelo operador .. 1 sum [ 1 .. 10 ] Observe que a sintaxe do uso das fun\u00e7\u00f5es, contudo, \u00e9 diferente; em Haskell, usa-se o nome da fun\u00e7\u00e3o, seguido dos par\u00e2metros, com espa\u00e7o os separando. J\u00e1 a defini\u00e7\u00e3o de fun\u00e7\u00f5es segue algumas estruturas b\u00e1sicas, sendo a mais simples a defini\u00e7\u00e3o via equa\u00e7\u00e3o .","title":"Fun\u00e7\u00f5es"},{"location":"functions/#equacoes","text":"Por exemplo, consideremos uma fun\u00e7\u00e3o que soma dois n\u00fameros. Em Haskell, ela \u00e9 definida simplesmente como soma x y = x + y e usada como soma 3 5 . Exerc\u00edcio: Soma Defina a fun\u00e7\u00e3o soma e a use, de acordo com a imagem. 1 Como outro exemplo, definamos uma fun\u00e7\u00e3o que retorna o sucessor de um inteiro como sucessor x = x + 1 . Com estas duas fun\u00e7\u00f5es, podemos inclusive compor fun\u00e7\u00f5es, no melhor estilo \\(g(f(x))\\) , por exemplo: sucessor ( soma 3 4 ) ou sucessor ( sucessor ( sucessor 4 )) . Exerc\u00edcio: Composi\u00e7\u00e3o Defina uma fun\u00e7\u00e3o que multiplique 3 n\u00fameros, isto \u00e9, dados \\(x\\) , \\(y\\) e \\(z\\) , calcule \\(x*y*z\\) . Calcule \\((1 + (3 * 2 * 3)) + (5 * 3 * 2)\\) usando as fun\u00e7\u00f5es de soma e multiplica\u00e7\u00e3o definidas. Resolu\u00e7\u00e3o Defina as fun\u00e7\u00f5es 1 2 3 soma x y = x + y mult3 x y z = x * y * z Invoque soma ( soma 1 ( mult3 3 2 3 )) ( mult3 5 3 2 ) . Observe que os par\u00eanteses s\u00e3o necess\u00e1rios para delimitar os par\u00e2metros de cada uma das invoca\u00e7\u00f5es. Exerc\u00edcio: m\u00e9dia de 3 n\u00fameros Defina uma fun\u00e7\u00e3o que calcule a m\u00e9dia de 3 n\u00fameros Resolu\u00e7\u00e3o media x y z = ( x + y + z ) / 3 Exerc\u00edcio: \u00e1rea das figuras Defina uma fun\u00e7\u00e3o o c\u00e1lculo da \u00e1rea de cada figura geom\u00e9trica. Resolu\u00e7\u00e3o 1 2 3 4 5 areaQuad a = a * a areaRet a b = a * b areaCirc r = pi * r * r areaTri a h = ( a * h ) / 2 areaTra a b h = ( a + b ) / 2 * h Se voc\u00ea se logar no Repl.it, poder\u00e1 salvar seus arquivos online e edit\u00e1-los de qualquer lugar, como no exemplo dado no exerc\u00edcio. \u21a9","title":"Equa\u00e7\u00f5es"},{"location":"guards/","text":"Vamos definir uma fun\u00e7\u00e3o que retorne o nome do m\u00eas, dado o seu n\u00famero. Seria poss\u00edvel escreve esta fun\u00e7\u00e3o com if aninhados, assim. 1 2 3 4 5 6 nomeMes m = if m == 1 then \"JAN\" else if m == 2 then \"FEB\" else if m == 3 then \"MAR\" ... else if m == 11 then \"NOV\" else \"DEZ\" Esta estrutura, contudo, pode ser simplificada com o uso guardas , uma op\u00e7\u00e3o que faz sentido quando os par\u00e2metros de uma fun\u00e7\u00e3o podem ser classificados em grupos. Guardas tem a seguinte sintaxe, onde o otherwise \u00e9 opcional e serve para cobrir todos os outros casos . 1 2 3 4 5 6 nomeFuncao arg1 ... argN | < condicao1 > = < definicao1 > | < condicao2 > = < definicao2 > ... | < condicaoM > = < definicaoM > | [ otherwise ] = < definicaoO > Especificamente, o exemplo do c\u00e1lculo do nome dos meses ficaria assim: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 nomeMes m | m == 1 = \"JAN\" | m == 2 = \"FEV\" | m == 3 = \"MAR\" | m == 4 = \"ABR\" | m == 5 = \"MAI\" | m == 6 = \"JUN\" | m == 7 = \"JUL\" | m == 8 = \"AGO\" | m == 9 = \"SET\" | m == 10 = \"OUT\" | m == 11 = \"NOV\" | m == 12 = \"DEZ\" | m == 13 = \"ONZ\" Outras observa\u00e7\u00f5es tamb\u00e9m s\u00e3o importantes. Primeiro, as condi\u00e7\u00f5es podem ser mais complexas que um simples teste, podendo incluir m\u00faltiplos testes e computa\u00e7\u00f5es; a \u00fanica condi\u00e7\u00e3o \u00e9 que retorne um booleano. Vejamos uma fun\u00e7\u00e3o que calcula o maior entre tr\u00eas n\u00fameros. 1 2 3 4 maiorDeTres a b c | a >= b && a >= c = a | b >= c = b | otherwise = c Segundo, as condi\u00e7\u00f5es s\u00e3o testadas de cima para baixo e isso \u00e9 importante porqu\u00ea alguns par\u00e2metros podem satisfazer mais de uma condi\u00e7\u00e3o. Vejamos novamente o caso do c\u00e1lculo de anos bissextos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 {- >>>bissexto 5 False >>>bissexto 200 False >>>bissexto 2000 True >>>bissexto 1996 True >>>bissexto 1900 False -} bissexto x | mod x 4 /= 0 = False -- N\u00e3o divis\u00edveis por 4 | mod x 400 == 0 = True -- Divis\u00edveis por 4 e por 400 | mod x 100 == 0 = False -- Divis\u00edveis por 4, n\u00e3o por 400, e por 100 | otherwise = True -- Divis\u00edveis por 4, e n\u00e3o por 100 Observe que se a terceira e segunda guardas fossem invertidas, o ano 1900 seria considerado bissexto, quando na verdade ele n\u00e3o \u00e9. Exerc\u00edcio Escreva uma fun\u00e7\u00e3o que receba um n\u00famero representando um m\u00eas, um n\u00famero de 1 a 12, e retorne a quantidade de dias no m\u00eas. Assuma que fevereiro sempre tem 28 dias. Resolu\u00e7\u00e3o 1 2 3 4 diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 \u00cdndice de massa corporal O \u00edndice de massa corporal, IMC, \u00e9 calculado como o peso dividido pelo quadrado da altura. Um IMC abaixo de 18,5, inclusive, \u00e9 considerado baixo e acima de 30 \u00e9 considerado alto; aqueles no intervalo s\u00e3o considerados normais. Defina uma fun\u00e7\u00e3o que, dados peso e altura, decida se o IMC correspondente \u00e9 Baixo, Normal ou Alto. Resolu\u00e7\u00e3o 1 2 3 4 5 imc p a | p / a ^ 2 <= 18.5 = \"Baixo\" | p / a ^ 2 <= 25.0 = \"Normal\" | p / a ^ 2 <= 30.0 = \"Alto\" | otherwise = error \"N\u00e3o sei o que dizer\" otherwise \u00e9 verdade Uma curiosidade sobre o uso de guardas \u00e9 que o caso final, que pega todas as outras op\u00e7\u00f5es, poderia ser definido como um guarda em que a condi\u00e7\u00e3o \u00e9 sempre verdadeira, como no seguinte exemplo: 1 2 3 4 maiorDeTres a b c | a >= b && a >= c = a | b >= c = b | True = c De fato, se usarmos o ghci para obtermos mais informa\u00e7\u00f5es sobre otherwise , veremos que \u00e9 uma constante, cujo valor \u00e9 True . Isso serve para ilustrar o poder da linguagem, que tem um conjunto reduzido de palavras chave que \u00e9 estendida usando suas funcionalidades b\u00e1sicas. 1 2 3 4 Prelude> :i otherwise otherwise :: Bool -- Defined in \u2018GHC.Base\u2019 Prelude> otherwise True Ainda sobre guardas, quando a condi\u00e7\u00e3o testada \u00e9 de igualdade dos par\u00e2metros com algum valor, temos uma terceira forma de definir fun\u00e7\u00f5es que precisam testar v\u00e1rios casos, al\u00e9m de usar if - then - else e guardas: Casamento de padr\u00f5es .","title":"Guardas!"},{"location":"haskell101/","text":"A primeira vers\u00e3o da linguagem Haskell, cujo nome \u00e9 uma homenagem ao matem\u00e1tico e l\u00f3gico Haskell B. Curry , apareceu em 1987 do esfor\u00e7o para se consolidar v\u00e1rios avan\u00e7os propostos no paradigma funcional, sendo famosa por ser uma linguagem funcional pura , de prop\u00f3sito geral e por ter caracter\u00edsticas marcantes como avalia\u00e7\u00e3o pregui\u00e7osa , e tipagem est\u00e1tica , forte e por infer\u00eancia , como discutiremos mais adiante. Mais do que uma linguagem, Haskell era uma especifica\u00e7\u00e3o, ou s\u00e9rie de especifica\u00e7\u00f5es, tendo tido v\u00e1rias implementa\u00e7\u00f5es distintas. A vers\u00e3o de 98 foi um marco da linguagem, sendo uma vers\u00e3o considerada est\u00e1vel. Nesta \u00e9poca surgiu o Glasgow Haskell Compiler (GHC), que se tornou o compilador Haskell \"padr\u00e3o\". A vers\u00e3o seguinte da linguagem come\u00e7ou a ser especificada em 2006 e anunciada em 2009, a Haskell 2010. Dentre os principais avan\u00e7os desta vers\u00e3o est\u00e1 a possibilidade de interagir com c\u00f3digo escrito em outras linguagens, via a foreign function interface (FFI). Mas chega de hist\u00f3ria e vamos colocar a m\u00e3o na massa vendo alguns exemplos extremamente simples da linguagem. Exemplos simples Para exemplos mais complexos, voc\u00ea dever\u00e1 instalar o compilador Haskell na sua m\u00e1quina, seguindo as instru\u00e7\u00f5es espec\u00edficas, 2 mas para pequenos experimentos e exerc\u00edcios, podemos usar o Repl.It 1 . Do lado direito do s\u00edtio, na \u00e1rea marcada em vermelho, digite ghci seguido de Enter . Agora digite as express\u00f5es a seguir. 1 2 3 4 5 6 7 8 9 10 11 1 + 1 True && True 100 / 10 ( 10 + 4 ) * 50 3 * ( - 2 ) 2 * - 1 Estas express\u00f5es fazem uso de operadores comuns e se comportam exatamente como voc\u00ea esperaria, depois de ter aprendido a programar em qualquer linguagem, em qualquer paradigma. Operadores s\u00e3o a\u00e7\u00facar sint\u00e1tico para fun\u00e7\u00f5es, a alma da programa\u00e7\u00e3o funcional. REPL \u00e9 o acr\u00f4nimo para Read, Evaluate, Print, Loop. \u21a9 Instru\u00e7\u00f5es de como instalar o GHC s\u00e3o espec\u00edficas para cada sistema operacional. Por isso, consulte o s\u00edtio https://www.haskell.org/platform/ para instalar o Haskell na sua m\u00e1quina. \u21a9","title":"1+1"},{"location":"highorder/","text":"discard :: (a -> Bool) -> [a] -> [a] discard p xs = [x | x <- xs, not(p x)] keep :: (a -> Bool) -> [a] -> [a] keep p xs = [x | x <- xs, p x]","title":"Fun\u00e7\u00f5es de alta ordem"},{"location":"ifthenelse/","text":"Voc\u00ea como saberia calcular o maior de dois n\u00fameros \\(a\\) e \\(b\\) sem usar um teste do tipo se ent\u00e3o sen\u00e3o ? \u00c9 bem interessante; assuma \\(M\\) maior e \\(m\\) menor entre \\(a\\) e \\(b\\) . \\[\\begin{eqnarray} M &=& (M + M)/2 \\nonumber \\\\ &=& (M + m + M - m)/2 \\nonumber \\\\ &=& (M + m + (M-m))/2 \\nonumber \\\\ &=& (M + n + \\|M-m\\|)/2 \\nonumber \\\\ &=& (a + b + \\|a - b\\|)/2 \\nonumber \\end{eqnarray}\\] Em outras palavras, o maior entre dois n\u00fameros \\(a\\) e \\(b\\) \u00e9 igual \u00e0 m\u00e9dia dos n\u00fameros \\(a\\) e \\(b\\) , mais a metade da diferen\u00e7a entre \\(a\\) e \\(b\\) . Logo, em Haskell, temos 1 maior x y = ( x + y + ( abs ( x - y ))) / 2 Estou certo de que voc\u00ea concordar\u00e1 que calcular o maior entre dois n\u00fameros deveria ser muito mais simples que isso, especialmente porqu\u00ea naquele abs provavelmente h\u00e1 um if escondido. \\[ f(a,b)= \\begin{cases} a,& \\text{if } a\\geq b\\\\ b, & \\text{otherwise} \\end{cases} \\] Mas como faz\u00ea-lo em Haskell, isto \u00e9, como testar uma condi\u00e7\u00e3o sobre os valores para decidir a forma correta de computar o resultado? Usando uma express\u00e3o de sele\u00e7\u00e3o, isto \u00e9, if ... then ... else ... Veja o exemplo da escolha do maior n\u00famero. 1 2 maior x y = if x > y then x else y Observe que, diferentemente de outras linguagens em que se pode usar o if para decidir entre fazer ou n\u00e3o uma computa\u00e7\u00e3o, o if do Haskell serve para decidir entre duas computa\u00e7\u00f5es. Isto \u00e9, o if deve sempre ser seguido do then e do else . Observe tamb\u00e9m que o if pode estar em qualquer parte da express\u00e3o, porqu\u00ea este construto \u00e9 tamb\u00e9m uma express\u00e3o. Por exemplo, imagine que queira somar um n\u00famero inteiro com o valor absoluto de outro n\u00famero, sem usar o abs . 1 somaEstranha x y = x + ( if y < 0 then - y else y ) Com esta defini\u00e7\u00e3o, tanto somaEstranha 1 2 quanto somaEstranha 1 (-2) resultam em 3. Mas este exemplo \u00e9 muito estranho, ent\u00e3o pensemos em um mais \u00fatil. Exerc\u00edcio Implemente uma fun\u00e7\u00e3o que calcule se um ano \u00e9 bissexto sabendo que: Se o n\u00e3o \u00e9 m\u00faltiplo de 4, n\u00e3o \u00e9 bissexto. Se \u00e9 m\u00faltiplo de 4 e n\u00e3o \u00e9 m\u00faltiplo de 100, ent\u00e3o \u00e9 bissexto. Se \u00e9 m\u00faltiplo de 100 e n\u00e3o \u00e9 m\u00faltiplo de 400, ent\u00e3o n\u00e3o \u00e9 bissexto. Se \u00e9 m\u00faltiplo de 400, ent\u00e3o \u00e9 bissexto. Resolu\u00e7\u00e3o 1 2 3 4 bissexto x = if mod x 4 /= 0 then False else if mod x 100 /= 0 then True else if mod x 400 == 0 then True else False Aninhar if assim pode funcionar, mas leva a estruturas estranhas e dif\u00edceis de serem lidas. H\u00e1 formas melhores de se lidar com m\u00faltiplas possibilidades de computa\u00e7\u00e3o.","title":"Se ent\u00e3o, sen\u00e3o"},{"location":"intro/","text":"Introdu\u00e7\u00e3o Embora este curso assuma que voc\u00ea j\u00e1 saiba programar em alguma linguagem, ou exatamente por isso, \u00e9 importante que fa\u00e7amos uma revis\u00e3o de algumas ideias b\u00e1sicas de programa\u00e7\u00e3o antes de mergulharmos no paradigma funcional, para que possamos melhor posicionar este paradigma com em rela\u00e7\u00e3o aos demais. Paradigmas de Programa\u00e7\u00e3o Programar um computador consiste em comunicar ao computador instru\u00e7\u00f5es para que ele resolva problemas. E a comunica\u00e7\u00e3o entre duas entidades s\u00f3 \u00e9 poss\u00edvel se usarem uma linguagem em comum, isto \u00e9, dominada pelas duas partes. Comunica\u00e7\u00e3o A\u00e7\u00e3o ou efeito de comunicar, de transmitir ou de receber ideias, conhecimento, mensagens etc., buscando compartilhar informa\u00e7\u00f5es. 1 Comunica\u00e7\u00e3o Linguagens naturais Linguagens de programa\u00e7\u00e3o Quando humanos se comunicam, usam uma linguagens naturais , como o portugu\u00eas, libras, ou canton\u00eas. Linguagens naturais s\u00e3o altamente expressivas, cheias de nuances e depend\u00eancias do contexto, o que lhes confere grande poder, mas tamb\u00e9m a grande fraqueza de permitirem a constru\u00e7\u00e3o de mensagens amb\u00edguas. A comunica\u00e7\u00e3o entre computadores ou computares e humanos, contudo, precisa ser feita de forma precisa, e por isso linguagens naturais n\u00e3o s\u00e3o boas neste contexto, apesar do grande esfor\u00e7o dispendido e da evolu\u00e7\u00e3o do processamento de linguagens naturais, como as \"alexas\" e \"siris\" do mundo podem provar. A comunica\u00e7\u00e3o entre computadores \u00e9 feita por um protocolo de comunica\u00e7\u00e3o, assunto para outro curso. J\u00e1 a comunica\u00e7\u00e3o entre humanos e computadores, na programa\u00e7\u00e3o do computador, \u00e9 feita por meio de linguagens de programa\u00e7\u00e3o , que s\u00e3o muito mais restritas que as linguagens naturais e, por isso, n\u00e3o amb\u00edguas. Linguagem de Programa\u00e7\u00e3o A linguagem de programa\u00e7\u00e3o \u00e9 um m\u00e9todo padronizado, formado por um conjunto de regras sint\u00e1ticas e sem\u00e2nticas, de implementa\u00e7\u00e3o de um c\u00f3digo fonte - que pode ser compilado e transformado em um programa de computador, ou usado como script interpretado - que informar\u00e1 instru\u00e7\u00f5es de processamento ao computador. 2 A n\u00e3o ambiguidade das linguagens de programa\u00e7\u00e3o do fato de terem uma sintaxe e sem\u00e2nticas precisas, descritas por uma gram\u00e1tica tamb\u00e9m precisa. Sintaxe A sintaxe de uma linguagem descreve o que constitui um programa estruturalmente correto e \u00e9 definida por uma gram\u00e1tica. Sem\u00e2ntica O significado de um programa \u00e9 definido por sua sem\u00e2ntica, ou seja, por regras que definem como as instru\u00e7\u00f5es especificado devem ser interpretadas. Serem precisas n\u00e3o quer dizer que as linguagens sejam simples, como demonstra claramente a seguinte imagem, que \u00e9 um programa \u00e9 um \"hello world\" na linguagem Piet . Tamb\u00e9m n\u00e3o quer dizer que sejam limitadas. De fato, h\u00e1 milhares linguagens de programa\u00e7\u00e3o por a\u00ed, e contando, com diferentes caracter\u00edsticas que as tornam mais mais ou menos apropriadas para resolver diferentes problemas. Mas mesmo apesar de t\u00e3o grande n\u00famero, as linguagens podem ser classificadas em grandes fam\u00edlias ou paradigmas. Imperativo x Descritivo Imperativo x Descritivo Imperativo: como Descritivo: o qu\u00ea Os primeiros \"computadores\" eram m\u00e1quinas que computavam mecanicamente seus resultados. Uma segunda gera\u00e7\u00e3o, da qual destacamos o ENIAC (circa 1955), eram computadores sem parte mec\u00e2nicas, programados por conex\u00f5es el\u00e9tricas de suas diversas partes. O pr\u00f3ximo passo, foram computadores que interpretavam c\u00f3digo escrito em uma linguagem de programa\u00e7\u00e3o. Estas primeiras linguagens eram todas imperativas , no sentido de que ditavam ao computador uma sequ\u00eancia de instru\u00e7\u00f5es a serem seguidas para se chegar a um resultado. Isto \u00e9, estas linguagens permitiam ao programador dizer como realizar uma computa\u00e7\u00e3o. Imperativo leia a linha 1 do arquivo separe a linha por espa\u00e7os pegue a segunda parte da linha converta a parte para n\u00famero se o n\u00famero for maior que 15, escreva na tela leia a pr\u00f3xima linha do arquivo volte para o passo 2 Este paradigma tem suas ra\u00edzes no modelo computacional cl\u00e1ssico de von Neumann e na m\u00e1quina de Turing Em contrapartida a este modelo, surgiram mais tarde linguagens declarativas , em que o programado diz o qu\u00ea deve ser computado e o computador se encarrega de achar um \"como\". Descritivo selecione todas as linhas em que a segunda parte \u00e9 maior que 15 Com uma an\u00e1lise r\u00e1pida das linguagens mais conhecidas, voce deve reconhecer a maior parte como imperativas, por exemplo, C, Java, e Python. J\u00e1 dentre as linguagens declarativas, se destacam SQL, LINQ, e Prolog. Ortogonalmente ao foco em no \"como x o qu\u00ea\", podemos nos focar em como as estas instru\u00e7\u00f5es s\u00e3o organizadas mais em um n\u00edvel mais alto, de onde se destacam quatro paradigmas principais: procedimental , orientado a objetos , l\u00f3gico e funcional . 3 Procedimental Linguagens que usam o paradigma procedimental organizam instru\u00e7\u00f5es em blocos, denominados procedimentos, de onde vem o nome, ou fun\u00e7\u00f5es. A ideia \u00e9 que o c\u00f3digo seja modularizado para separar funcionalidades e tornar o c\u00f3digo mais compreens\u00edvel e manuten\u00edvel. Cada fun\u00e7\u00e3o deve executar uma opera\u00e7\u00e3o bem espec\u00edfica, fun\u00e7\u00f5es associadas s\u00e3o colocadas em um mesmo arquivo, e arquivos associados s\u00e3o colocados em um mesmo namespace . O c\u00f3digo seguinte, em C, mostra a fun\u00e7\u00e3o main , ponto de entrada do programa e de onde a fun\u00e7\u00e3o printf , importada de stdio.h , \u00e9 invocada. 1 2 3 4 5 #include <stdio.h> int main () { printf ( \"Hello, World!\" ); return 0 ; } Al\u00e9m da linguagem C, outros exemplos \u00f3bvios deste paradigma s\u00e3o as linguagens Pascal, Fortran e Python. Contudo, mesmo linguagens como Java e C++ podem ser consideradas procedurais, uma vez que organizam a computa\u00e7\u00e3o em m\u00e9todos, que s\u00e3o nada mais que fun\u00e7\u00f5es. Mas como m\u00e9todos est\u00e3o fortemente associados a classes e suas inst\u00e2ncias, os objetos, estas linguagens s\u00e3o melhor classificadas como orientadas a objetos. Orientado a Objetos Na orienta\u00e7\u00e3o a objetos, o foco est\u00e1 n\u00e3o na execu\u00e7\u00e3o passo a passo de fun\u00e7\u00f5es, mas na organiza\u00e7\u00e3o de dados e fun\u00e7\u00f5es associadas em objetos. Embora esta organiza\u00e7\u00e3o possa ser feita em qualquer qualquer linguagem estruturada, a sintaxe das linguagens orientadas a objeto facilita e tornam mais natural este trabalho. Dois conceitos b\u00e1sicos na orienta\u00e7\u00e3o a objetos s\u00e3o as classes e os objetos . Classes s\u00e3o abstra\u00e7\u00f5es de tipos de coisas encontrados no mundo real, ou seja, receitas de estruturas de dados e definem quais os dados devem ser considerados em conjunto para representar um objeto e quais as a\u00e7\u00f5es associadas a este objeto. Por exemplo, se no mundo real cachorros tem uma data de nascimento e um nome, e s\u00e3o capazes de latir, uma classe que represente cachorros pode ser definida assim em Java. 1 2 3 4 5 6 7 8 9 10 11 class Cachorro { int diaNascimento ; int mesNascimento ; int anoNascimento ; String nome ; void latir ( int quantidade ) { for ( int i = 0 ; i < quantidade ; i ++ ) System . out . println ( nome + \": Au!\" ); } } J\u00e1 um objeto \u00e9 uma inst\u00e2ncia de uma classe, uma representa\u00e7\u00e3o de um tipo mas de uma coisa em si. Um c\u00e3o qualquer poderia ser representado assim 1 2 Cachorro cachorro1 = new Cachorro ( 25 , 12 , 2020 , \"Napole\u00e3o\" ); cachorro1 . latir ( 3 ); e a execu\u00e7\u00e3o deste c\u00f3digo resultaria em 1 2 3 Napole\u00e3o: Au! Napole\u00e3o: Au! Napole\u00e3o: Au! Observe que o \".\" em cachorro1.latir(3) quer dizer \"executar a fun\u00e7\u00e3o latir no objeto cachorro1 \", o que leva \u00e0 string Napole\u00e3o a aparecer antes de cada latido. Duas coisas poder ser ditas sobre este \".\". Primeiro, que ele n\u00e3o \u00e9 necess\u00e1rio, o objeto em si poderia ser passado como par\u00e2metro para uma fun\u00e7\u00e3o latir que recebesse o objeto al\u00e9m da quantidade de latidos; de fato, em Python, a classe seria definida como a seguir 1 2 3 4 5 6 7 8 9 class Cachorro : diaNascimento mesNascimento anoNascimento nome def latir ( self , quantidade ): for i in range ( 0 , quantidade ): print ( self . nome + \": Au!\" ) o que implica que o \".\" \u00e9 o s\u00f3 a\u00e7\u00facar sint\u00e1tico para a execu\u00e7\u00e3o de uma fun\u00e7\u00e3o, o que nos leva ao segundo ponto. Na orienta\u00e7\u00e3o a objetos conceitual, n\u00e3o se fala em invoca\u00e7\u00e3o de fun\u00e7\u00f5es mas de sinais sendo transmitidos entre objetos: envie mensagem para o 2 \"somar-se com 3\", ao que o objeto 2 responderia com uma mensagem \"refer\u00eancia ao objeto 4\". Em Smalltalk, esta intera\u00e7\u00e3o seria escrita assim: 1 x := 2 + 3 . Grande parte do poder da orienta\u00e7\u00e3o objetos est\u00e1 no encapsulamento do como opera\u00e7\u00f5es s\u00e3o executadas, nos m\u00e9todos. Uma outra ordem de encapsulamento, de outro tipo, \u00e9 encontrada no paradigma l\u00f3gico. L\u00f3gico No paradigma l\u00f3gico, voc\u00ea declara-se fatos b\u00e1sicos e regras sobre como os fatos se relacionam e pergunta ao programa se certos fatos s\u00e3o ou n\u00e3o s\u00e3o verdade. Por exemplo, como fatos, podemos declarar 1 2 3 4 5 eh_maior_que ( gato , rato ). eh_maior_que ( leao , gato ). eh_maior_que ( elefante , leao ). eh_maior_que ( elefante , moto ). eh_maior_que ( legal , cachorro ). que vale a transitividade 1 2 3 eh_maior_que ( A , B ) :- eh_maior_que ( A , C ), eh_maior_que ( C , B ). e, finalmente, perguntar se elefante \u00e9 maior rato 1 eh_maior_que ( elefante , rato ). ao que seremos respondidos com um \"sim\". Voc\u00ea consegue imaginar quantas linhas de c\u00f3digo voc\u00ea precisaria para expressar a mesma l\u00f3gica acima em uma linguagem como C ou Java? Apesar do claro poder deste paradigma, o mesmo tem poucos representantes, como Prolog e Mercury, e mesmo que exista v\u00e1rios compiladores do primeiro, o uso comercial do paradigma \u00e9 bem limitado. Funcional A programa\u00e7\u00e3o, como indicado pelo nome, \u00e9 focada na organiza\u00e7\u00e3o do processamento em termos de fun\u00e7\u00f5es, mas de uma forma diferente da programa\u00e7\u00e3o procedimental. De forma geral, fun\u00e7\u00f5es s\u00e3o blocos de c\u00f3digo criadas essencialmente para se obter reusabilidade : uma vez definidas, as fun\u00e7\u00f5es podem ser invocadas repetidas vezes para executar a mesma tarefa sobre diferentes par\u00e2metros , sempre retornando um resultado. 4 Mas enquanto na programa\u00e7\u00e3o procedimental a invoca\u00e7\u00e3o de uma fun\u00e7\u00e3o pode retornar diferentes resultados mesmo quando os par\u00e2metros s\u00e3o os mesmos, na programa\u00e7\u00e3o funcional, fun\u00e7\u00f5es s\u00e3o como na matem\u00e1tica, isto \u00e9, mapeiam uma entrada para exatamente uma sa\u00edda, sempre. Isto \u00e9, fun\u00e7\u00f5es resolvem o problema sem se basear em nada al\u00e9m dos par\u00e2metros passados e sem efeitos colaterais. Mas e as fun\u00e7\u00f5es que tem efeitos colaterais? Estas n\u00e3o s\u00e3o fun\u00e7\u00f5es \"de verdade\" e n\u00e3o \u00e9 a toa que outro nome usado para os blocos de c\u00f3digo \u00e9 procedimento e que para discernir entre fun\u00e7\u00f5es que tem efeitos colaterais e que n\u00e3o n\u00e3o, chamamos de puras as do segundo tipo. Vejamos alguns exemplos. As fun\u00e7\u00f5es seguintes, definidas em Erlang, calculam A+B , A*C e (A+B)*(A+B) e, independentemente de quantas vezes voc\u00ea o fizer, add(2,3) sempre retornar\u00e1 5 . 1 2 3 4 5 6 7 8 add ( A , B ) -> A + B . mult ( A , B ) -> A * B . mult_add ( A , B ) -> mult ( add ( A , B ), add ( A , B )). Agora observe a fun\u00e7\u00e3o seguinte, escritas em Python; a cada invoca\u00e7\u00e3o, a vari\u00e1vel acc tem seu valor alterado e mesmo que invocada com a mesma entrada, o resultado da fun\u00e7\u00e3o \u00e9 sempre diferente. Os efeitos externos \u00e0 fun\u00e7\u00e3o, e.g., a altera\u00e7\u00e3o da vari\u00e1vel acc , \u00e9 conhecido efeito colateral . Programa\u00e7\u00e3o funcional n\u00e3o tem tem efeitos colaterais por que trata vari\u00e1veis n\u00e3o como \u00e1reas de mem\u00f3ria alter\u00e1veis, mas como inc\u00f3gnitas, como na matem\u00e1tica. Pelo menos esta \u00e9 a ideia de programa\u00e7\u00e3o funcional pura, que \u00e9 essencialmente a escrita de longu\u00edssimas equa\u00e7\u00f5es. Acontece que devido \u00e0 complexidade inerente do uso de programa\u00e7\u00e3o funcional pura, sem efeitos colaterais, i.e., sem muta\u00e7\u00e3o de estados, muitas linguagens n\u00e3o s\u00e3o puramente funcionais. A raz\u00e3o mais comum para efeitos colaterais \u00e9 a realiza\u00e7\u00e3o de Entrada/Sa\u00edda. Por exemplo, ao invocar print no Python, o terminal tem seu estado alterado, e cada nova invoca\u00e7\u00e3o altera mais o estado. Assim, podemos dividir as linguagens e funcionais puras, funcionais n\u00e3o puras e n\u00e3o funcionais, mas mesmo dentro das n\u00e3o funcionais, h\u00e1 aquelas com elementos de programa\u00e7\u00e3o funcional. \"Funcionalidades\" Muitas linguagens modernas, como Python e JavaScript, embora n\u00e3o estritamente funcionais, tem diversos elementos de programa\u00e7\u00e3o funcional, eu diretamente na linguagem ou via frameworks . Python, por exemplo, v\u00e1rias funcionalidades caracter\u00edsticas do paradigma funcional, embora seja poss\u00edvel ignor\u00e1-las por completo. Por exemplo, imagine que voc\u00ea queira criar uma lista com o quadrado de todos os n\u00fameros de 1 a x . Voc\u00ea pode optar por um for cl\u00e1ssico ... 1 2 3 4 5 def quads ( x ): lista = [] for i in range ( 1 , x ): lista . append ( i * i ) return lista ... ou uma compreens\u00e3o de listas , como nos exemplos a seguir. 1 2 def quads2 ( x ): return [ e ** 2 for e in range ( 1 , x )] Al\u00e9m disso, h\u00e1 linguagens funcionais que tamb\u00e9m se enquadram em outros paradigmas e que podem ser consideradas h\u00edbridas, ou multi-paradigma. Multi-paradigmas Muitas linguagens modernas podem ser classificadas ao mesmo tempo em muitos paradigmas, por exemplo, a linguagem Scala \u00e9 ao mesmo tempo funcional e orientada a objetos, sendo muito dif\u00edcil us\u00e1-la sem fazer uso desta caracter\u00edstica. 1 2 3 4 5 object HelloWorld { def main ( args : Array [ String ]) : Unit = { println ( \"Hello, world!\" ) } } Para cada servi\u00e7o, uma ferramenta! Em cada paradigma, encontramos vantagens e desvantagens. Como desenvolvedores de tecnologia, nada mais justo que voc\u00eas conhe\u00e7am todos os paradigmas e que possam, assim, escolher aquele paradigma e, dentro dele, aquela linguagem que permite resolver o seu problema da forma mais eficiente, isto \u00e9, rapidamente, com menor custo e com melhor qualidade. Mas quanto ao paradigma funciona, em especial, \u00e9 importante compreend\u00ea-lo pois muitas de suas funcionalidades tem sido incorporadas a outras linguagens, como compreens\u00e3o de listas em Python, fun\u00e7\u00f5es lambda em Java e C++, e processamento ass\u00edncrono pode ser visto como uma forma de avalia\u00e7\u00e3o pregui\u00e7osa em diversas linguagens. Vejamos estes outras pontos importantes do paradigma: Sem efeitos colaterais: executando um programa, de repente voc\u00ea percebe que uma certa vari\u00e1vel tem um valor estranho e fica se perguntando quem foi que atribuiu tal valor; efeitos colaterais s\u00e3o a origem de boa parte dos bugs e elimin\u00e1-los, ou ao menos reduz\u00ed-los, permite que voc\u00ea identifique rapidamente onde altera\u00e7\u00f5es poderiam ter acontecido. Camadas de abstra\u00e7\u00e3o: fun\u00e7\u00f5es podem ser compostas levando a programas verdadeiramente complexos, permitindo que abstra\u00e7\u00f5es sejam definidas em diversas camadas. Al\u00e9m disso, \u00e9 poss\u00edvel, em teoria, ser provar a corretude de fun\u00e7\u00f5es e, mesmo que na pr\u00e1tica isso n\u00e3o se realize, h\u00e1 ferramentas que conseguem usar esta ideia para lhe ajudar a encontrar bugs. Processamento paralelo eficiente: a aus\u00eancia de efeitos colaterais tamb\u00e9m implica que fun\u00e7\u00f5es sem depend\u00eancias podem ser executadas em paralelo, sem se preocupar com qualquer sincroniza\u00e7\u00e3o, isto \u00e9, sem mutexes e vari\u00e1veis de condi\u00e7\u00e3o, etc. Avalia\u00e7\u00e3o pregui\u00e7osa: fun\u00e7\u00f5es s\u00f3 precisam realmente ser executadas se seus resultados s\u00e3o necess\u00e1rios e o compilador consegue atrasar a execu\u00e7\u00e3o de fun\u00e7\u00f5es enquanto poss\u00edvel. Recurs\u00e3o de calda: alguns problemas podem ser descritos muito facilmente como uma recurs\u00e3o que com uma itera\u00e7\u00e3o, mas linguagens tradicionais tem um limite no tamanho das pilhas de fun\u00e7\u00e3o; linguagens funcionais conseguem, em certas condi\u00e7\u00f5es, usar recurs\u00e3o infinita, contornando esta limita\u00e7\u00e3o. Fun\u00e7\u00f5es de alta ordem: fun\u00e7\u00f5es podem receber outras fun\u00e7\u00f5es como par\u00e2metro e com isso podemos compor fun\u00e7\u00f5es, por exemplo para implementar orienta\u00e7\u00e3o a objetos. Escolha o seu veneno Como j\u00e1 ficou \u00f3bvio, h\u00e1 muitas, muitas linguagens de programa\u00e7\u00e3o por a\u00ed e \u00e9 poss\u00edvel escrever c\u00f3digo bom em cada um delas, assim como \u00e9 poss\u00edvel escrever c\u00f3digo ruim em cada uma delas. Tamb\u00e9m \u00e9 poss\u00edvel escrever usando orienta\u00e7\u00e3o a objetos ou funcionalmente em cada uma delas, mas embora seja poss\u00edvel , h\u00e1 aquelas linguagens que suportam melhor cada um dos paradigmas. Dentre estas, h\u00e1 diversas op\u00e7\u00f5es de linguagens que podemos usar para estudar o paradigma funcional, por exemplo: Scheme Lisp ML F# Erlang Elixir Haskell Clojure Neste curso, veremos princ\u00edpios gerais e que, em teoria, poderiam ser aplicados em qualquer destas linguagens. Contudo, como a sintaxe pode variar muito de uma linguagem para outra, precisaremos nos focar em uma \u00fanica linguagem, mesmo que, frequentemente, apresente exemplos em outras. Assim, nosso foco aqui ser\u00e1 em Haskell, uma linguagem funcional madura e est\u00e1vel. Recomenda\u00e7\u00f5es Sobre a hist\u00f3ria das linguagens de programa\u00e7\u00e3o Sobre porqu\u00ea PF n\u00e3o \u00e9 mais comum Comunica\u00e7\u00e3o \u21a9 Linguagem de Programa\u00e7\u00e3o \u21a9 Programming Language Families \u21a9 void \u00e9 simplesmente um resultado que diz que o resultado n\u00e3o importa. \u21a9","title":"Introdu\u00e7\u00e3o"},{"location":"intro/#introducao","text":"Embora este curso assuma que voc\u00ea j\u00e1 saiba programar em alguma linguagem, ou exatamente por isso, \u00e9 importante que fa\u00e7amos uma revis\u00e3o de algumas ideias b\u00e1sicas de programa\u00e7\u00e3o antes de mergulharmos no paradigma funcional, para que possamos melhor posicionar este paradigma com em rela\u00e7\u00e3o aos demais.","title":"Introdu\u00e7\u00e3o"},{"location":"intro/#paradigmas-de-programacao","text":"Programar um computador consiste em comunicar ao computador instru\u00e7\u00f5es para que ele resolva problemas. E a comunica\u00e7\u00e3o entre duas entidades s\u00f3 \u00e9 poss\u00edvel se usarem uma linguagem em comum, isto \u00e9, dominada pelas duas partes. Comunica\u00e7\u00e3o A\u00e7\u00e3o ou efeito de comunicar, de transmitir ou de receber ideias, conhecimento, mensagens etc., buscando compartilhar informa\u00e7\u00f5es. 1 Comunica\u00e7\u00e3o Linguagens naturais Linguagens de programa\u00e7\u00e3o Quando humanos se comunicam, usam uma linguagens naturais , como o portugu\u00eas, libras, ou canton\u00eas. Linguagens naturais s\u00e3o altamente expressivas, cheias de nuances e depend\u00eancias do contexto, o que lhes confere grande poder, mas tamb\u00e9m a grande fraqueza de permitirem a constru\u00e7\u00e3o de mensagens amb\u00edguas. A comunica\u00e7\u00e3o entre computadores ou computares e humanos, contudo, precisa ser feita de forma precisa, e por isso linguagens naturais n\u00e3o s\u00e3o boas neste contexto, apesar do grande esfor\u00e7o dispendido e da evolu\u00e7\u00e3o do processamento de linguagens naturais, como as \"alexas\" e \"siris\" do mundo podem provar. A comunica\u00e7\u00e3o entre computadores \u00e9 feita por um protocolo de comunica\u00e7\u00e3o, assunto para outro curso. J\u00e1 a comunica\u00e7\u00e3o entre humanos e computadores, na programa\u00e7\u00e3o do computador, \u00e9 feita por meio de linguagens de programa\u00e7\u00e3o , que s\u00e3o muito mais restritas que as linguagens naturais e, por isso, n\u00e3o amb\u00edguas. Linguagem de Programa\u00e7\u00e3o A linguagem de programa\u00e7\u00e3o \u00e9 um m\u00e9todo padronizado, formado por um conjunto de regras sint\u00e1ticas e sem\u00e2nticas, de implementa\u00e7\u00e3o de um c\u00f3digo fonte - que pode ser compilado e transformado em um programa de computador, ou usado como script interpretado - que informar\u00e1 instru\u00e7\u00f5es de processamento ao computador. 2 A n\u00e3o ambiguidade das linguagens de programa\u00e7\u00e3o do fato de terem uma sintaxe e sem\u00e2nticas precisas, descritas por uma gram\u00e1tica tamb\u00e9m precisa. Sintaxe A sintaxe de uma linguagem descreve o que constitui um programa estruturalmente correto e \u00e9 definida por uma gram\u00e1tica. Sem\u00e2ntica O significado de um programa \u00e9 definido por sua sem\u00e2ntica, ou seja, por regras que definem como as instru\u00e7\u00f5es especificado devem ser interpretadas. Serem precisas n\u00e3o quer dizer que as linguagens sejam simples, como demonstra claramente a seguinte imagem, que \u00e9 um programa \u00e9 um \"hello world\" na linguagem Piet . Tamb\u00e9m n\u00e3o quer dizer que sejam limitadas. De fato, h\u00e1 milhares linguagens de programa\u00e7\u00e3o por a\u00ed, e contando, com diferentes caracter\u00edsticas que as tornam mais mais ou menos apropriadas para resolver diferentes problemas. Mas mesmo apesar de t\u00e3o grande n\u00famero, as linguagens podem ser classificadas em grandes fam\u00edlias ou paradigmas.","title":"Paradigmas de Programa\u00e7\u00e3o"},{"location":"intro/#imperativo-x-descritivo","text":"Imperativo x Descritivo Imperativo: como Descritivo: o qu\u00ea Os primeiros \"computadores\" eram m\u00e1quinas que computavam mecanicamente seus resultados. Uma segunda gera\u00e7\u00e3o, da qual destacamos o ENIAC (circa 1955), eram computadores sem parte mec\u00e2nicas, programados por conex\u00f5es el\u00e9tricas de suas diversas partes. O pr\u00f3ximo passo, foram computadores que interpretavam c\u00f3digo escrito em uma linguagem de programa\u00e7\u00e3o. Estas primeiras linguagens eram todas imperativas , no sentido de que ditavam ao computador uma sequ\u00eancia de instru\u00e7\u00f5es a serem seguidas para se chegar a um resultado. Isto \u00e9, estas linguagens permitiam ao programador dizer como realizar uma computa\u00e7\u00e3o. Imperativo leia a linha 1 do arquivo separe a linha por espa\u00e7os pegue a segunda parte da linha converta a parte para n\u00famero se o n\u00famero for maior que 15, escreva na tela leia a pr\u00f3xima linha do arquivo volte para o passo 2 Este paradigma tem suas ra\u00edzes no modelo computacional cl\u00e1ssico de von Neumann e na m\u00e1quina de Turing Em contrapartida a este modelo, surgiram mais tarde linguagens declarativas , em que o programado diz o qu\u00ea deve ser computado e o computador se encarrega de achar um \"como\". Descritivo selecione todas as linhas em que a segunda parte \u00e9 maior que 15 Com uma an\u00e1lise r\u00e1pida das linguagens mais conhecidas, voce deve reconhecer a maior parte como imperativas, por exemplo, C, Java, e Python. J\u00e1 dentre as linguagens declarativas, se destacam SQL, LINQ, e Prolog. Ortogonalmente ao foco em no \"como x o qu\u00ea\", podemos nos focar em como as estas instru\u00e7\u00f5es s\u00e3o organizadas mais em um n\u00edvel mais alto, de onde se destacam quatro paradigmas principais: procedimental , orientado a objetos , l\u00f3gico e funcional . 3","title":"Imperativo x Descritivo"},{"location":"intro/#procedimental","text":"Linguagens que usam o paradigma procedimental organizam instru\u00e7\u00f5es em blocos, denominados procedimentos, de onde vem o nome, ou fun\u00e7\u00f5es. A ideia \u00e9 que o c\u00f3digo seja modularizado para separar funcionalidades e tornar o c\u00f3digo mais compreens\u00edvel e manuten\u00edvel. Cada fun\u00e7\u00e3o deve executar uma opera\u00e7\u00e3o bem espec\u00edfica, fun\u00e7\u00f5es associadas s\u00e3o colocadas em um mesmo arquivo, e arquivos associados s\u00e3o colocados em um mesmo namespace . O c\u00f3digo seguinte, em C, mostra a fun\u00e7\u00e3o main , ponto de entrada do programa e de onde a fun\u00e7\u00e3o printf , importada de stdio.h , \u00e9 invocada. 1 2 3 4 5 #include <stdio.h> int main () { printf ( \"Hello, World!\" ); return 0 ; } Al\u00e9m da linguagem C, outros exemplos \u00f3bvios deste paradigma s\u00e3o as linguagens Pascal, Fortran e Python. Contudo, mesmo linguagens como Java e C++ podem ser consideradas procedurais, uma vez que organizam a computa\u00e7\u00e3o em m\u00e9todos, que s\u00e3o nada mais que fun\u00e7\u00f5es. Mas como m\u00e9todos est\u00e3o fortemente associados a classes e suas inst\u00e2ncias, os objetos, estas linguagens s\u00e3o melhor classificadas como orientadas a objetos.","title":"Procedimental"},{"location":"intro/#orientado-a-objetos","text":"Na orienta\u00e7\u00e3o a objetos, o foco est\u00e1 n\u00e3o na execu\u00e7\u00e3o passo a passo de fun\u00e7\u00f5es, mas na organiza\u00e7\u00e3o de dados e fun\u00e7\u00f5es associadas em objetos. Embora esta organiza\u00e7\u00e3o possa ser feita em qualquer qualquer linguagem estruturada, a sintaxe das linguagens orientadas a objeto facilita e tornam mais natural este trabalho. Dois conceitos b\u00e1sicos na orienta\u00e7\u00e3o a objetos s\u00e3o as classes e os objetos . Classes s\u00e3o abstra\u00e7\u00f5es de tipos de coisas encontrados no mundo real, ou seja, receitas de estruturas de dados e definem quais os dados devem ser considerados em conjunto para representar um objeto e quais as a\u00e7\u00f5es associadas a este objeto. Por exemplo, se no mundo real cachorros tem uma data de nascimento e um nome, e s\u00e3o capazes de latir, uma classe que represente cachorros pode ser definida assim em Java. 1 2 3 4 5 6 7 8 9 10 11 class Cachorro { int diaNascimento ; int mesNascimento ; int anoNascimento ; String nome ; void latir ( int quantidade ) { for ( int i = 0 ; i < quantidade ; i ++ ) System . out . println ( nome + \": Au!\" ); } } J\u00e1 um objeto \u00e9 uma inst\u00e2ncia de uma classe, uma representa\u00e7\u00e3o de um tipo mas de uma coisa em si. Um c\u00e3o qualquer poderia ser representado assim 1 2 Cachorro cachorro1 = new Cachorro ( 25 , 12 , 2020 , \"Napole\u00e3o\" ); cachorro1 . latir ( 3 ); e a execu\u00e7\u00e3o deste c\u00f3digo resultaria em 1 2 3 Napole\u00e3o: Au! Napole\u00e3o: Au! Napole\u00e3o: Au! Observe que o \".\" em cachorro1.latir(3) quer dizer \"executar a fun\u00e7\u00e3o latir no objeto cachorro1 \", o que leva \u00e0 string Napole\u00e3o a aparecer antes de cada latido. Duas coisas poder ser ditas sobre este \".\". Primeiro, que ele n\u00e3o \u00e9 necess\u00e1rio, o objeto em si poderia ser passado como par\u00e2metro para uma fun\u00e7\u00e3o latir que recebesse o objeto al\u00e9m da quantidade de latidos; de fato, em Python, a classe seria definida como a seguir 1 2 3 4 5 6 7 8 9 class Cachorro : diaNascimento mesNascimento anoNascimento nome def latir ( self , quantidade ): for i in range ( 0 , quantidade ): print ( self . nome + \": Au!\" ) o que implica que o \".\" \u00e9 o s\u00f3 a\u00e7\u00facar sint\u00e1tico para a execu\u00e7\u00e3o de uma fun\u00e7\u00e3o, o que nos leva ao segundo ponto. Na orienta\u00e7\u00e3o a objetos conceitual, n\u00e3o se fala em invoca\u00e7\u00e3o de fun\u00e7\u00f5es mas de sinais sendo transmitidos entre objetos: envie mensagem para o 2 \"somar-se com 3\", ao que o objeto 2 responderia com uma mensagem \"refer\u00eancia ao objeto 4\". Em Smalltalk, esta intera\u00e7\u00e3o seria escrita assim: 1 x := 2 + 3 . Grande parte do poder da orienta\u00e7\u00e3o objetos est\u00e1 no encapsulamento do como opera\u00e7\u00f5es s\u00e3o executadas, nos m\u00e9todos. Uma outra ordem de encapsulamento, de outro tipo, \u00e9 encontrada no paradigma l\u00f3gico.","title":"Orientado a Objetos"},{"location":"intro/#logico","text":"No paradigma l\u00f3gico, voc\u00ea declara-se fatos b\u00e1sicos e regras sobre como os fatos se relacionam e pergunta ao programa se certos fatos s\u00e3o ou n\u00e3o s\u00e3o verdade. Por exemplo, como fatos, podemos declarar 1 2 3 4 5 eh_maior_que ( gato , rato ). eh_maior_que ( leao , gato ). eh_maior_que ( elefante , leao ). eh_maior_que ( elefante , moto ). eh_maior_que ( legal , cachorro ). que vale a transitividade 1 2 3 eh_maior_que ( A , B ) :- eh_maior_que ( A , C ), eh_maior_que ( C , B ). e, finalmente, perguntar se elefante \u00e9 maior rato 1 eh_maior_que ( elefante , rato ). ao que seremos respondidos com um \"sim\". Voc\u00ea consegue imaginar quantas linhas de c\u00f3digo voc\u00ea precisaria para expressar a mesma l\u00f3gica acima em uma linguagem como C ou Java? Apesar do claro poder deste paradigma, o mesmo tem poucos representantes, como Prolog e Mercury, e mesmo que exista v\u00e1rios compiladores do primeiro, o uso comercial do paradigma \u00e9 bem limitado.","title":"L\u00f3gico"},{"location":"intro/#funcional","text":"A programa\u00e7\u00e3o, como indicado pelo nome, \u00e9 focada na organiza\u00e7\u00e3o do processamento em termos de fun\u00e7\u00f5es, mas de uma forma diferente da programa\u00e7\u00e3o procedimental. De forma geral, fun\u00e7\u00f5es s\u00e3o blocos de c\u00f3digo criadas essencialmente para se obter reusabilidade : uma vez definidas, as fun\u00e7\u00f5es podem ser invocadas repetidas vezes para executar a mesma tarefa sobre diferentes par\u00e2metros , sempre retornando um resultado. 4 Mas enquanto na programa\u00e7\u00e3o procedimental a invoca\u00e7\u00e3o de uma fun\u00e7\u00e3o pode retornar diferentes resultados mesmo quando os par\u00e2metros s\u00e3o os mesmos, na programa\u00e7\u00e3o funcional, fun\u00e7\u00f5es s\u00e3o como na matem\u00e1tica, isto \u00e9, mapeiam uma entrada para exatamente uma sa\u00edda, sempre. Isto \u00e9, fun\u00e7\u00f5es resolvem o problema sem se basear em nada al\u00e9m dos par\u00e2metros passados e sem efeitos colaterais. Mas e as fun\u00e7\u00f5es que tem efeitos colaterais? Estas n\u00e3o s\u00e3o fun\u00e7\u00f5es \"de verdade\" e n\u00e3o \u00e9 a toa que outro nome usado para os blocos de c\u00f3digo \u00e9 procedimento e que para discernir entre fun\u00e7\u00f5es que tem efeitos colaterais e que n\u00e3o n\u00e3o, chamamos de puras as do segundo tipo. Vejamos alguns exemplos. As fun\u00e7\u00f5es seguintes, definidas em Erlang, calculam A+B , A*C e (A+B)*(A+B) e, independentemente de quantas vezes voc\u00ea o fizer, add(2,3) sempre retornar\u00e1 5 . 1 2 3 4 5 6 7 8 add ( A , B ) -> A + B . mult ( A , B ) -> A * B . mult_add ( A , B ) -> mult ( add ( A , B ), add ( A , B )). Agora observe a fun\u00e7\u00e3o seguinte, escritas em Python; a cada invoca\u00e7\u00e3o, a vari\u00e1vel acc tem seu valor alterado e mesmo que invocada com a mesma entrada, o resultado da fun\u00e7\u00e3o \u00e9 sempre diferente. Os efeitos externos \u00e0 fun\u00e7\u00e3o, e.g., a altera\u00e7\u00e3o da vari\u00e1vel acc , \u00e9 conhecido efeito colateral . Programa\u00e7\u00e3o funcional n\u00e3o tem tem efeitos colaterais por que trata vari\u00e1veis n\u00e3o como \u00e1reas de mem\u00f3ria alter\u00e1veis, mas como inc\u00f3gnitas, como na matem\u00e1tica. Pelo menos esta \u00e9 a ideia de programa\u00e7\u00e3o funcional pura, que \u00e9 essencialmente a escrita de longu\u00edssimas equa\u00e7\u00f5es. Acontece que devido \u00e0 complexidade inerente do uso de programa\u00e7\u00e3o funcional pura, sem efeitos colaterais, i.e., sem muta\u00e7\u00e3o de estados, muitas linguagens n\u00e3o s\u00e3o puramente funcionais. A raz\u00e3o mais comum para efeitos colaterais \u00e9 a realiza\u00e7\u00e3o de Entrada/Sa\u00edda. Por exemplo, ao invocar print no Python, o terminal tem seu estado alterado, e cada nova invoca\u00e7\u00e3o altera mais o estado. Assim, podemos dividir as linguagens e funcionais puras, funcionais n\u00e3o puras e n\u00e3o funcionais, mas mesmo dentro das n\u00e3o funcionais, h\u00e1 aquelas com elementos de programa\u00e7\u00e3o funcional.","title":"Funcional"},{"location":"intro/#multi-paradigmas","text":"Muitas linguagens modernas podem ser classificadas ao mesmo tempo em muitos paradigmas, por exemplo, a linguagem Scala \u00e9 ao mesmo tempo funcional e orientada a objetos, sendo muito dif\u00edcil us\u00e1-la sem fazer uso desta caracter\u00edstica. 1 2 3 4 5 object HelloWorld { def main ( args : Array [ String ]) : Unit = { println ( \"Hello, world!\" ) } }","title":"Multi-paradigmas"},{"location":"intro/#para-cada-servico-uma-ferramenta","text":"Em cada paradigma, encontramos vantagens e desvantagens. Como desenvolvedores de tecnologia, nada mais justo que voc\u00eas conhe\u00e7am todos os paradigmas e que possam, assim, escolher aquele paradigma e, dentro dele, aquela linguagem que permite resolver o seu problema da forma mais eficiente, isto \u00e9, rapidamente, com menor custo e com melhor qualidade. Mas quanto ao paradigma funciona, em especial, \u00e9 importante compreend\u00ea-lo pois muitas de suas funcionalidades tem sido incorporadas a outras linguagens, como compreens\u00e3o de listas em Python, fun\u00e7\u00f5es lambda em Java e C++, e processamento ass\u00edncrono pode ser visto como uma forma de avalia\u00e7\u00e3o pregui\u00e7osa em diversas linguagens. Vejamos estes outras pontos importantes do paradigma: Sem efeitos colaterais: executando um programa, de repente voc\u00ea percebe que uma certa vari\u00e1vel tem um valor estranho e fica se perguntando quem foi que atribuiu tal valor; efeitos colaterais s\u00e3o a origem de boa parte dos bugs e elimin\u00e1-los, ou ao menos reduz\u00ed-los, permite que voc\u00ea identifique rapidamente onde altera\u00e7\u00f5es poderiam ter acontecido. Camadas de abstra\u00e7\u00e3o: fun\u00e7\u00f5es podem ser compostas levando a programas verdadeiramente complexos, permitindo que abstra\u00e7\u00f5es sejam definidas em diversas camadas. Al\u00e9m disso, \u00e9 poss\u00edvel, em teoria, ser provar a corretude de fun\u00e7\u00f5es e, mesmo que na pr\u00e1tica isso n\u00e3o se realize, h\u00e1 ferramentas que conseguem usar esta ideia para lhe ajudar a encontrar bugs. Processamento paralelo eficiente: a aus\u00eancia de efeitos colaterais tamb\u00e9m implica que fun\u00e7\u00f5es sem depend\u00eancias podem ser executadas em paralelo, sem se preocupar com qualquer sincroniza\u00e7\u00e3o, isto \u00e9, sem mutexes e vari\u00e1veis de condi\u00e7\u00e3o, etc. Avalia\u00e7\u00e3o pregui\u00e7osa: fun\u00e7\u00f5es s\u00f3 precisam realmente ser executadas se seus resultados s\u00e3o necess\u00e1rios e o compilador consegue atrasar a execu\u00e7\u00e3o de fun\u00e7\u00f5es enquanto poss\u00edvel. Recurs\u00e3o de calda: alguns problemas podem ser descritos muito facilmente como uma recurs\u00e3o que com uma itera\u00e7\u00e3o, mas linguagens tradicionais tem um limite no tamanho das pilhas de fun\u00e7\u00e3o; linguagens funcionais conseguem, em certas condi\u00e7\u00f5es, usar recurs\u00e3o infinita, contornando esta limita\u00e7\u00e3o. Fun\u00e7\u00f5es de alta ordem: fun\u00e7\u00f5es podem receber outras fun\u00e7\u00f5es como par\u00e2metro e com isso podemos compor fun\u00e7\u00f5es, por exemplo para implementar orienta\u00e7\u00e3o a objetos.","title":"Para cada servi\u00e7o, uma ferramenta!"},{"location":"intro/#escolha-o-seu-veneno","text":"Como j\u00e1 ficou \u00f3bvio, h\u00e1 muitas, muitas linguagens de programa\u00e7\u00e3o por a\u00ed e \u00e9 poss\u00edvel escrever c\u00f3digo bom em cada um delas, assim como \u00e9 poss\u00edvel escrever c\u00f3digo ruim em cada uma delas. Tamb\u00e9m \u00e9 poss\u00edvel escrever usando orienta\u00e7\u00e3o a objetos ou funcionalmente em cada uma delas, mas embora seja poss\u00edvel , h\u00e1 aquelas linguagens que suportam melhor cada um dos paradigmas. Dentre estas, h\u00e1 diversas op\u00e7\u00f5es de linguagens que podemos usar para estudar o paradigma funcional, por exemplo: Scheme Lisp ML F# Erlang Elixir Haskell Clojure Neste curso, veremos princ\u00edpios gerais e que, em teoria, poderiam ser aplicados em qualquer destas linguagens. Contudo, como a sintaxe pode variar muito de uma linguagem para outra, precisaremos nos focar em uma \u00fanica linguagem, mesmo que, frequentemente, apresente exemplos em outras. Assim, nosso foco aqui ser\u00e1 em Haskell, uma linguagem funcional madura e est\u00e1vel.","title":"Escolha o seu veneno"},{"location":"intro/#recomendacoes","text":"Sobre a hist\u00f3ria das linguagens de programa\u00e7\u00e3o Sobre porqu\u00ea PF n\u00e3o \u00e9 mais comum Comunica\u00e7\u00e3o \u21a9 Linguagem de Programa\u00e7\u00e3o \u21a9 Programming Language Families \u21a9 void \u00e9 simplesmente um resultado que diz que o resultado n\u00e3o importa. \u21a9","title":"Recomenda\u00e7\u00f5es"},{"location":"io/","text":"Entrada e Sa\u00edda Hello, world!","title":"Entrada e Sa\u00edda"},{"location":"io/#entrada-e-saida","text":"Hello, world!","title":"Entrada e Sa\u00edda"},{"location":"lazy/","text":"Avalia\u00e7\u00e3o Pregui\u00e7osa Considere o seguinte c\u00f3digo novamente. 1 2 3 4 5 imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" where imc' = p / a ^ 2 O uso de where na defini\u00e7\u00e3o, al\u00e9m de melhorar a legibilidade do c\u00f3digo, d\u00e1 ao compilador Haskell a oportunidade de usar uma de suas mais importantes funcionalidades, a avalia\u00e7\u00e3o pregui\u00e7osa . Quando a fun\u00e7\u00e3o imc \u00e9 invocada, imc' n\u00e3o \u00e9 calculada at\u00e9 que a primeira guarda seja testada. Isso acontece porqu\u00ea pela avalia\u00e7\u00e3o pregui\u00e7osa do Haskell, a avalia\u00e7\u00e3o acontece apenas quando necess\u00e1ria . Para demonstrar esta funcionalidade, vamos usar a fun\u00e7\u00e3o trace , que imprime uma mensagem na tela a cada computa\u00e7\u00e3o de imc' 1 2 3 4 5 6 7 8 9 import Debug.Trace ( trace ) imc :: Double -> Double -> String imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" | otherwise = \"Muito, muito alto\" where imc' = trace \"hmmm... \" ( p / a ^ 2 ) Agora atribu\u00edmos uma invoca\u00e7\u00e3o da fun\u00e7\u00e3o a y e verificamos que somente quando tentamos ver o valor de de y \u00e9 que o c\u00e1lculo \u00e9 realmente feito. 1 2 3 4 * Main > y = imc 90 1.8 * Main > y \"hmmm... Alto\" Al\u00e9m disso, a avalia\u00e7\u00e3o acontece no m\u00e1ximo uma vez , o que quer dizer que se a primeira guarda falha e a segunda deve ser testada, imc' n\u00e3o \u00e9 recomputada, pois o Haskell se lembra do valor j\u00e1 calculado para os mesmos par\u00e2metros. 1 2 3 4 5 6 7 8 9 import Debug.Trace ( trace ) imc :: Double -> Double -> String imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" | otherwise = \"Muito, muito alto\" where imc' = trace \"hmmm... \" ( p / a ^ 2 ) Na pr\u00f3xima execu\u00e7\u00e3o, mesmo o resultado tendo sido gerado pela terceira guarda, veja que imc' s\u00f3 foi executado uma vez. 1 2 3 * Main > imc 90 1.8 \"hmmm... Alto\" Outro princ\u00edpio da avalia\u00e7\u00e3o pregui\u00e7osa \u00e9 que se deve avaliar somente o necess\u00e1rio . Observe a pr\u00f3xima defini\u00e7\u00e3o, onde m\u00faltiplos where s\u00e3o usados (onde todas as defini\u00e7\u00f5es est\u00e3o perfeitamente indentadas.) 1 2 3 4 5 6 7 8 imc p a | imc' <= baixo = \"Baixo\" | imc' <= normal = \"Normal\" | imc' <= alto = \"Alto\" where imc' = trace \"hmmm... \" ( p / a ^ 2 ) baixo = trace \"b\" ( 18.5 ) normal = trace \"n\" ( 25.0 ) alto = trace \"a\" ( 30.0 ) Dependendo da chamada, os valores de normal e alto nunca ser\u00e3o avaliados. 1 2 3 4 5 6 7 8 9 10 11 * Main > imc 90 1.8 \"hmmm... b n a Alto\" * Main > imc 70 1.8 \"hmmm... b n Normal\" Pr\u00f3s A avalia\u00e7\u00e3o pregui\u00e7osa \u00e9 imprescind\u00edvel para algumas funcionalidades do Haskell, como a capacidade de expressar uma lista infinita no pr\u00f3ximo trecho de c\u00f3digo. Se a lista tivesse que ser constru\u00edda antes de se poder acessar seu in\u00edcio, as chamadas nunca terminariam. 1 2 3 4 5 6 7 * Main > x = [ 1 , 3 .. ] * Main > take 2 x [ 1 , 3 ] * Main > take 4 x [ 1 , 3 , 5 , 7 ] * Main > take 20 x [ 1 , 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 , 19 , 21 , 23 , 25 , 27 , 29 , 31 , 33 , 35 , 37 , 39 ] Mesmo quando as chamadas terminal, pode ser que o tempo de execu\u00e7\u00e3o seja alto demais. Por exemplo, considere a lista dos elementos da s\u00e9rie de Fibonacci geradas por uma defini\u00e7\u00e3o recursiva. 1 2 3 4 5 fibWhere 0 = 0 fibWhere 1 = 1 fibWhere n = prev + prevPrev where prev = fibWhere ( n - 1 ) prevPrev = fibWhere ( n - 2 ) Se voc\u00ea invocar esta fun\u00e7\u00e3o para calcular fib 5 , ter\u00e1 uma resposta rapidamente. Se tentar com 20 ou 30, ter\u00e1 que esperar um pouco. Mas se tentar com fib 300 , ter\u00e1 que esperar por muito tempo at\u00e9 que veja algum progresso. Ainda assim, a seguinte chamada termina quase que imediatamente! 1 2 3 4 5 6 7 8 * Main > length [ fib n | n <- [ 1 .. 300 ]] 300 * Main > x = [ fib n | n <- [ 1 .. 300 ]] * Main > take 1 x [ 1 ] * Main > take 3 x [ 1 , 1 , 2 ] Isso acontece pois para se saber o comprimento da lista n\u00e3o \u00e9 necess\u00e1rio conhecer o valor dos elementos, apenas como s\u00e3o definidos. O Haskell ent\u00e3o gera uma lista de \"invoca\u00e7\u00f5es\" da fun\u00e7\u00e3o fib , mas n\u00e3o chega a executar as invoca\u00e7\u00f5es enquanto precisar. Contras Como uma moeda sempre tem duas faces, vejamos o lado ruim da avalia\u00e7\u00e3o pregui\u00e7osa. Em vez de uma fun\u00e7\u00e3o custosa como a Fibonacci recursiva, se construirmos uma lista de somat\u00f3rios de \\(2i + 2*+1, 0\\leq 1 \\leq 100\\) , ou seja, 0+1, 2+3, 4+5,... 1 2 3 4 5 6 7 8 9 * Main > x = [ 2 * i + 2 * i + 1 | i <- [ 0 .. 100 ]] * Main > take 3 x [ 1 , 5 , 9 ] * Main > take 5 x [ 1 , 5 , 9 , 13 , 17 ] * Main > last x 401 * Main > length x 101 Sem a avalia\u00e7\u00e3o pregui\u00e7osa, ter\u00edamos uma lista de 100 inteiros, sendo o maior 401, que cabe facilmente em um array de bytes. Contudo, com a avalia\u00e7\u00e3o pregui\u00e7osa, temos uma lista de express\u00f5es que indicam duas multiplica\u00e7\u00f5es e duas somas, certamente mais espa\u00e7osas que a alternativa anterior. A principal consequ\u00eancia disto \u00e9 que, embora leve \u00e0 economia de computa\u00e7\u00e3o, \u00e0s vezes a avalia\u00e7\u00e3o pregui\u00e7osa leva ao uso exagerado de espa\u00e7o. Al\u00e9m disso, computa\u00e7\u00f5es pesadas invocadas em um per\u00edodo de pouca atividade no sistema podem ser executadas mais tarde, quando o sistema est\u00e1 sobrecarregado, aumentando a variabilidade do tempo de execu\u00e7\u00e3o e dificultando a previs\u00e3o de t\u00e9rmino da computa\u00e7\u00e3o. Como funciona A computa\u00e7\u00e3o de uma fun\u00e7\u00e3o em Haskell pode ser entendida em termos da reescrita de express\u00f5es, da ordem de reescrita e do compartilhamento de resultados pr\u00e9vios. \u00c9 tamb\u00e9m baseado nestes mecanismos que a avalia\u00e7\u00e3o pregui\u00e7osa se torna poss\u00edvel. Reescrita H\u00e1 diferentes tipos de reescrita em Haskell. O tipo mais simples \u00e9 a redu\u00e7\u00e3o em que uma express\u00e3o \u00e9 substitu\u00edda por outra, equivalente, mas mais simples. Por exemplo, a express\u00e3o 2 + 2 pode ser reescrita como #hs 4 . Outra forma de reescrita \u00e9 o desdobramento ( unfolding ), em que o lado esquerdo de uma equa\u00e7\u00e3o \u00e9 substitu\u00eddo pelo lado direito. Por exemplo, quando invocamos 1 + head [ 1 , 2 , 3 ] , Haskell tenta achar uma defini\u00e7\u00e3o da fun\u00e7\u00e3o head que case com a invoca\u00e7\u00e3o. Suponha que exista uma defini\u00e7\u00e3o head ( x : _ ) = x ; neste caso, head ( x : _ ) = x \u00e9 reescrito como 1 e head [ 1 , 2 , 3 ] \u00e9 reescrito como 1, levando a express\u00e3o inicial a ser reduzida a 1 + 1 , onde uma redu\u00e7\u00e3o \u00e9 aplicada, levando a 2 . Ordem de reescrita Uma vez entendido que express\u00f5es podem ser reescritas, surge a d\u00favida do que substituir primeiro, quando houver m\u00faltiplas op\u00e7\u00f5es. Por exemplo, se temos a seguinte invoca\u00e7\u00e3o head (( 1 + 1 ) : ( 2 + 2 ) :[] ) ent\u00e3o podemos reduzir 1 + 1 para 1, ou 2 + 2 para 4, ou head (( 1 + 1 ) : ( 2 + 2 ) :[] ) para ( 1 + 1 ) . Haskell escolhe sempre a redu\u00e7\u00e3o mais \"externa\" ( outermost reduction ou avalia\u00e7\u00e3o call-by-name ), no caso, a terceira op\u00e7\u00e3o acima. Isso faz com que 2 + 2 nunca seja reduzido, economizando recursos. Esta abordagem n\u00e3o \u00e9 muito comum, nem mesmo entre outras linguagens funcionais, que usam uma avalia\u00e7\u00e3o gulosa ( call-by-value ou eager ). Compartilhamento Outro aspecto importante no processo de redu\u00e7\u00e3o \u00e9 o fato de que Haskell identifica express\u00f5es repetidas e compartilha o resultado da avalia\u00e7\u00e3o de uma inst\u00e2ncia com as outras. Por exemplo, a seguinte express\u00e3o aparece no seu c\u00f3digo, ( head x ) : ( head y ) : ( head x ) : [] , ent\u00e3o Haskell sabe que as duas apari\u00e7\u00f5es de head x levar\u00e3o ao mesmo valor, gra\u00e7as \u00e0 aus\u00eancia de efeitos colaterais. As express\u00f5es s\u00e3o substitu\u00eddas por uma refer\u00eancia para a express\u00e3o, que uma vez resolvida, \u00e9 substitu\u00edda na express\u00e3o original. A avalia\u00e7\u00e3o pregui\u00e7osa pode ser entendida como a combina\u00e7\u00e3o da reescrita do tipo call-by-name com o compartilhamento, sendo tamb\u00e9m conhecida como call-by-need .","title":"Que pregui\u00e7a"},{"location":"lazy/#avaliacao-preguicosa","text":"Considere o seguinte c\u00f3digo novamente. 1 2 3 4 5 imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" where imc' = p / a ^ 2 O uso de where na defini\u00e7\u00e3o, al\u00e9m de melhorar a legibilidade do c\u00f3digo, d\u00e1 ao compilador Haskell a oportunidade de usar uma de suas mais importantes funcionalidades, a avalia\u00e7\u00e3o pregui\u00e7osa . Quando a fun\u00e7\u00e3o imc \u00e9 invocada, imc' n\u00e3o \u00e9 calculada at\u00e9 que a primeira guarda seja testada. Isso acontece porqu\u00ea pela avalia\u00e7\u00e3o pregui\u00e7osa do Haskell, a avalia\u00e7\u00e3o acontece apenas quando necess\u00e1ria . Para demonstrar esta funcionalidade, vamos usar a fun\u00e7\u00e3o trace , que imprime uma mensagem na tela a cada computa\u00e7\u00e3o de imc' 1 2 3 4 5 6 7 8 9 import Debug.Trace ( trace ) imc :: Double -> Double -> String imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" | otherwise = \"Muito, muito alto\" where imc' = trace \"hmmm... \" ( p / a ^ 2 ) Agora atribu\u00edmos uma invoca\u00e7\u00e3o da fun\u00e7\u00e3o a y e verificamos que somente quando tentamos ver o valor de de y \u00e9 que o c\u00e1lculo \u00e9 realmente feito. 1 2 3 4 * Main > y = imc 90 1.8 * Main > y \"hmmm... Alto\" Al\u00e9m disso, a avalia\u00e7\u00e3o acontece no m\u00e1ximo uma vez , o que quer dizer que se a primeira guarda falha e a segunda deve ser testada, imc' n\u00e3o \u00e9 recomputada, pois o Haskell se lembra do valor j\u00e1 calculado para os mesmos par\u00e2metros. 1 2 3 4 5 6 7 8 9 import Debug.Trace ( trace ) imc :: Double -> Double -> String imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" | otherwise = \"Muito, muito alto\" where imc' = trace \"hmmm... \" ( p / a ^ 2 ) Na pr\u00f3xima execu\u00e7\u00e3o, mesmo o resultado tendo sido gerado pela terceira guarda, veja que imc' s\u00f3 foi executado uma vez. 1 2 3 * Main > imc 90 1.8 \"hmmm... Alto\" Outro princ\u00edpio da avalia\u00e7\u00e3o pregui\u00e7osa \u00e9 que se deve avaliar somente o necess\u00e1rio . Observe a pr\u00f3xima defini\u00e7\u00e3o, onde m\u00faltiplos where s\u00e3o usados (onde todas as defini\u00e7\u00f5es est\u00e3o perfeitamente indentadas.) 1 2 3 4 5 6 7 8 imc p a | imc' <= baixo = \"Baixo\" | imc' <= normal = \"Normal\" | imc' <= alto = \"Alto\" where imc' = trace \"hmmm... \" ( p / a ^ 2 ) baixo = trace \"b\" ( 18.5 ) normal = trace \"n\" ( 25.0 ) alto = trace \"a\" ( 30.0 ) Dependendo da chamada, os valores de normal e alto nunca ser\u00e3o avaliados. 1 2 3 4 5 6 7 8 9 10 11 * Main > imc 90 1.8 \"hmmm... b n a Alto\" * Main > imc 70 1.8 \"hmmm... b n Normal\"","title":"Avalia\u00e7\u00e3o Pregui\u00e7osa"},{"location":"lazy/#como-funciona","text":"A computa\u00e7\u00e3o de uma fun\u00e7\u00e3o em Haskell pode ser entendida em termos da reescrita de express\u00f5es, da ordem de reescrita e do compartilhamento de resultados pr\u00e9vios. \u00c9 tamb\u00e9m baseado nestes mecanismos que a avalia\u00e7\u00e3o pregui\u00e7osa se torna poss\u00edvel.","title":"Como funciona"},{"location":"lazy/#reescrita","text":"H\u00e1 diferentes tipos de reescrita em Haskell. O tipo mais simples \u00e9 a redu\u00e7\u00e3o em que uma express\u00e3o \u00e9 substitu\u00edda por outra, equivalente, mas mais simples. Por exemplo, a express\u00e3o 2 + 2 pode ser reescrita como #hs 4 . Outra forma de reescrita \u00e9 o desdobramento ( unfolding ), em que o lado esquerdo de uma equa\u00e7\u00e3o \u00e9 substitu\u00eddo pelo lado direito. Por exemplo, quando invocamos 1 + head [ 1 , 2 , 3 ] , Haskell tenta achar uma defini\u00e7\u00e3o da fun\u00e7\u00e3o head que case com a invoca\u00e7\u00e3o. Suponha que exista uma defini\u00e7\u00e3o head ( x : _ ) = x ; neste caso, head ( x : _ ) = x \u00e9 reescrito como 1 e head [ 1 , 2 , 3 ] \u00e9 reescrito como 1, levando a express\u00e3o inicial a ser reduzida a 1 + 1 , onde uma redu\u00e7\u00e3o \u00e9 aplicada, levando a 2 .","title":"Reescrita"},{"location":"lazy/#ordem-de-reescrita","text":"Uma vez entendido que express\u00f5es podem ser reescritas, surge a d\u00favida do que substituir primeiro, quando houver m\u00faltiplas op\u00e7\u00f5es. Por exemplo, se temos a seguinte invoca\u00e7\u00e3o head (( 1 + 1 ) : ( 2 + 2 ) :[] ) ent\u00e3o podemos reduzir 1 + 1 para 1, ou 2 + 2 para 4, ou head (( 1 + 1 ) : ( 2 + 2 ) :[] ) para ( 1 + 1 ) . Haskell escolhe sempre a redu\u00e7\u00e3o mais \"externa\" ( outermost reduction ou avalia\u00e7\u00e3o call-by-name ), no caso, a terceira op\u00e7\u00e3o acima. Isso faz com que 2 + 2 nunca seja reduzido, economizando recursos. Esta abordagem n\u00e3o \u00e9 muito comum, nem mesmo entre outras linguagens funcionais, que usam uma avalia\u00e7\u00e3o gulosa ( call-by-value ou eager ).","title":"Ordem de reescrita"},{"location":"lazy/#compartilhamento","text":"Outro aspecto importante no processo de redu\u00e7\u00e3o \u00e9 o fato de que Haskell identifica express\u00f5es repetidas e compartilha o resultado da avalia\u00e7\u00e3o de uma inst\u00e2ncia com as outras. Por exemplo, a seguinte express\u00e3o aparece no seu c\u00f3digo, ( head x ) : ( head y ) : ( head x ) : [] , ent\u00e3o Haskell sabe que as duas apari\u00e7\u00f5es de head x levar\u00e3o ao mesmo valor, gra\u00e7as \u00e0 aus\u00eancia de efeitos colaterais. As express\u00f5es s\u00e3o substitu\u00eddas por uma refer\u00eancia para a express\u00e3o, que uma vez resolvida, \u00e9 substitu\u00edda na express\u00e3o original. A avalia\u00e7\u00e3o pregui\u00e7osa pode ser entendida como a combina\u00e7\u00e3o da reescrita do tipo call-by-name com o compartilhamento, sendo tamb\u00e9m conhecida como call-by-need .","title":"Compartilhamento"},{"location":"lists/","text":"Listas Vamos agora estudar listas, pe\u00e7as fundamentais no desenvolvimento de programas usando o paradigma funcional, por serem estruturas de dados que permitem agregar v\u00e1rias informa\u00e7\u00f5es na forma de uma cole\u00e7\u00e3o ordenada de elementos. Por exemplo, [ \"Eu\" , \"amo\" , \"programa\u00e7\u00e3o\" , \"funcional\" ] \u00e9 a cole\u00e7\u00e3o de quatro strings em que o primeiro elemento \u00e9 \"Eu\" , o segundo \"amo\" , o terceiro \"programa\u00e7\u00e3o\" e o quarto e \u00faltimo \"funcional\" . J\u00e1 [ 1 :: Int , 2 :: Int , 3 :: Int ] \u00e9 uma lista de 3 elementos do tipo Int , onde o primeiro elemento \u00e9 1, o segundo 2, e o terceiro 3. \"Mas e as tuplas?\", voc\u00ea pergunta, \"N\u00e3o s\u00e3o exatamente isto?\" Listas x Tuplas Listas tem duas particularidades que as diferenciam de tuplas. Primeiro, enquanto as tuplas ( 1 :: Int , 2 :: Int , 3 :: Int ) e ( 1 :: Int , 2 :: Int , 3 :: Int , 4 :: Int ) tem tipos diferentes, isto \u00e9, uma \u00e9 uma tupla de tr\u00eas inteiros e a outra uma tupla de quatro inteiros, as listas [ 1 :: Int , 2 :: Int , 3 :: Int ] e [ 1 :: Int , 2 :: Int , 3 :: Int , 4 :: Int ] tem exatamente o mesmo tipo, lista de inteiros, ou mais especificamente, [ Int ] . Ou seja, listas com cardinalidades diferentes, mas com elementos do mesmo tipo, s\u00e3o do mesmo tipo. Ali\u00e1s, outra forma de escrever estas listas, enquanto especificando seus tipos, \u00e9 [ 1 , 2 , 3 ] :: [ Int ] e [ 1 , 2 , 3 , 4 ] :: [ Int ] . Segundo, enquanto uma tupla pode ter elementos de tipos diferentes, todos os elementos de uma lista devem ser do mesmo tipo. Ou seja, enquanto \u00e9 poss\u00edvel definir x = ( \"Joao\" , 14 , True ) , n\u00e3o \u00e9 poss\u00edvel definir x = [ \"Joao\" , 14 , True ] . \u00c9 preciso observar contudo que \u00e9 poss\u00edvel construir uma lista [ 1 , 2 , 3 , 4 , 17 , 4.2 ] , mas mas isto s\u00f3 \u00e9 poss\u00edvel porqu\u00ea existe um tipo do qual todos os elementos da lista s\u00e3o derivados, no caso, Fractional . De fato, quando defino este lista, Haskell automaticamente faz o boxing dos cinco primeiros valores para ponto flutuante. 1 2 3 4 5 * Main > z = [ 1 , 2 , 3 , 4 , 17 , 4.2 ] * Main > z [ 1.0 , 2.0 , 3.0 , 4.0 , 17.0 , 4.2 ] * Main > : t z z :: Fractional a => [ a ] J\u00e1 a tupla ( 1 , 2 , 3 , 4 , 17 , 4.2 ) tem elementos com tipos diferentes. 1 1 2 Prelude > : t t t :: ( Num , Num , Num , Num , Num , Fractional ) Uma vez diferenciadas das tuplas, estamos livres para explorar outros aspectos das listas, iniciando por como s\u00e3o constru\u00eddas. Estrutura Dado uma lista qualquer, de qualquer tipo, ela pode ser ou vazia ou n\u00e3o vazia, sendo que a lista vazia \u00e9 representada em Haskell por [] . Listas n\u00e3o vazias s\u00e3o representadas como a concatena\u00e7\u00e3o do primeiro elemento da lista com uma lista com os demais elementos, usando o operador de concatena\u00e7\u00e3o : , ou cons . Por exemplo, a lista dos n\u00fameros 1, 2 e 3 nesta ordem \u00e9 constru\u00edda como 1 : 2 : 3 :[] ; observe que como o 3 \u00e9 o \u00faltimo elemento da lista, a lista que vem depois do cons, com os demais elementos, \u00e9 a lista vazia. 1 2 3 Prelude > x = 1 : 2 : 3 :[] Prelude > x [ 1 , 2 , 3 ] Cabe\u00e7a e Cauda Esta divis\u00e3o de uma lista entre primeiro elemento e restante \u00e9 o que chamamos de cabe\u00e7a ( head ) e cauda ( tail ) da lista. No exemplo anterior, 1 : 2 : 3 :[] , 1 \u00e9 a cabe\u00e7a e 2 : 3 :[] a cauda. Haskell inclusive define fun\u00e7\u00f5es para recuperar estas partes de uma lista qualquer. 1 2 3 4 Prelude > head x 1 Prelude > tail x [ 2 , 3 ] A cabe\u00e7a de uma lista de elementos de um tipo \\(a\\) qualquer \u00e9 um elemento do tipo \\(a\\) . J\u00e1 a cauda desta lista \u00e9 tamb\u00e9m uma lista de elementos do tipo \\(a\\) . Logo, podemos subdivid\u00ed-la tamb\u00e9m em uma cabe\u00e7a e uma cauda, no exemplo, 2 e 3 :[] . 1 2 3 4 Prelude > head ( tail x ) 2 Prelude > tail ( tail x ) [ 3 ] Podemos aplicar head e tail mais uma vez na lista, obtendo 3 e [] como resultado. 1 2 3 4 Prelude > head ( tail ( tail x )) 3 Prelude > tail ( tail ( tail x )) [] Mas e se formos al\u00e9m? Neste caso estar\u00edamos tentando identificar o primeiro elemento da lista, mas sendo a lista vazia, isto n\u00e3o \u00e9 poss\u00edvel. Tampouco podemos extrair a lista ap\u00f3s a cabe\u00e7a. 1 2 3 4 Prelude > head [] *** Exception: Prelude . head : empty list Prelude > tail [] *** Exception: Prelude . tail : empty list Logo, qualquer itera\u00e7\u00e3o nos elementos de uma lista, geralmente especificada por uma recurs\u00e3o que extrai a cabe\u00e7a da lista a cada passo, precisa tomar cuidado para n\u00e3o tentar extrair a cabe\u00e7a da lista vazia, como veremos na sess\u00e3o sobre recurs\u00e3o aplicada a listas. Um pouco de a\u00e7\u00facar sint\u00e1tico A especifica\u00e7\u00e3o manual de uma lista usando o operador cons n\u00e3o \u00e9 muito utilizada na pr\u00e1tica, sendo a especifica\u00e7\u00e3o usando colchetes e v\u00edrgulas mais comum, como feito nos primeiros exemplos deste cap\u00edtulo, e \u00e9 inclusive como o pr\u00f3prio Haskell exibe as listas. O efeito final \u00e9 o mesmo, ficando para voc\u00ea a decis\u00e3o qual constru\u00e7\u00e3o usar. 1 :[] \u00e9 igual a [ 1 ] 2 : 1 :[] \u00e9 igual a [ 2 , 1 ] As duas nota\u00e7\u00f5es podem at\u00e9 ser misturadas, como em 1 : 2 : [ 3 , 4 , 5 ] , que \u00e9 equivalente [ 1 , 2 , 3 , 4 , 5 ] . Strings Se o a\u00e7\u00facar sint\u00e1tico dos colchetes n\u00e3o representa economia em termos de digita\u00e7\u00e3o de listas em geral, quando falamos em listas de caracteres a economia \u00e9 clara e o resultado muito mais agrad\u00e1vel. Isto por que para listas de caracteres, como [ 'a' , 'b' , 'c' ] , podemos escrever simplesmente \"abc\" , com exatamente o mesmo efeito, e at\u00e9 misturar com o uso de cons. 1 2 3 4 5 6 7 8 Prelude > \"abc\" \"abc\" Prelude > [ 'a' , 'b' , 'c' ] \"abc\" Prelude > 'a' : [ 'b' , 'c' ] \"abc\" Prelude > 'a' : \"bc\" \"abc\" [qualquer coisa] Uma lista pode conter elementos de qualquer tipo, desde que todos os elementos sejam do mesmo tipo. Logo, uma lista pode conter tipos primitivos, mas tamb\u00e9m tipos complexos, como tuplas e outras listas. Vejamos alguns exemplos: [ 1 , 2 , 3 ] :: [ Int ] - Lista de inteiros. [[ 1 , 2 , 3 ]] :: [[ Int ]] - Lista de listas de inteiros de inteiros. [[ 1 , 2 , 3 ], [] ,[ 3 , 4 , 5 , 6 , 7 , 8 , 9 ]] :: [[ Int ]] - Lista de listas de inteiros de inteiros. [( 1 , 2 , 3 ),( 3 , 4 , 5 )] :: [( Int , Int , Int )] - Lista de triplas de inteiros. ( \"lala\" ,[ 'l' , 'a' ], 'l' : '\u00e3' : 'o' :[] ) - Tripla de listas de Char. [ \"lala\" ,[ 'l' , 'a' ], 'l' : '\u00e3' : 'o' :[] ] - Lista de listas de Char. [ True , False , True ] :: [ Bool ] - Lista de booleanos. [( 4 , Ouro ),( 5 , Paus )] :: [ Carta ] - Lista de cartas. [( 1 , 2 , 3 ),( 3 )] - Um bug Enumera\u00e7\u00e3o Para facilitar a vida dos desenvolvedores, Haskell permite a constru\u00e7\u00e3o de listas por enumera\u00e7\u00e3o, bastando para isso o especificar o primeiro elemento da lista, opcionalmente o segundo, e o \u00faltimo elemento. Por exemplo 1 2 3 4 5 Prelude > [ 11 , 13 .. 23 ] [ 11 , 13 , 15 , 17 , 19 , 21 , 23 ] Prelude > [ - 15 , - 13 .. 14 ] [ - 15 , - 13 , - 11 , - 9 , - 7 , - 5 , - 3 , - 1 , 1 , 3 , 5 , 7 , 9 , 11 , 13 ] Observe que Haskell determinou um passo de incremento igual a \\(13-11 = 2\\) no primeiro exemplo e \\(-15 - -13 = 2\\) no segundo exemplo, e usou estes passos para gerar as lista. Tamb\u00e9m \u00e9 poss\u00edvel definir um passo negativo, como no pr\u00f3ximo exemplo. 1 2 Prelude > [ 11 , 9 .. 0 ] [ 11 , 9 , 7 , 5 , 3 , 1 ] Como mencionado, o segundo elemento \u00e9 opcional na enumera\u00e7\u00e3o e caso n\u00e3o especificado, Haskell assume que seja \\(1\\) , como no exemplo a seguir. 1 2 3 4 Prelude > [ 11 .. 23 ] [ 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 ] Prelude > [ 3.5 .. 10 ] [ 3.5 , 4.5 , 5.5 , 6.5 , 7.5 , 8.5 , 9.5 , 10.5 ] Contudo, n\u00e3o \u00e9 poss\u00edvel omitir o segundo elemento se a inten\u00e7\u00e3o for gerar uma lista com valores decrescentes. 1 2 Prelude > [ 11 .. 0 ] [] A enumera\u00e7\u00e3o pode ser feita para outros tipos que n\u00e3o sejam num\u00e9ricos, bastando que exista uma rela\u00e7\u00e3o de ordem entre os elementos para que Haskell consiga \"incrementar\" a cada passo. Isso existe, por exemplo, entre os caracteres, mas tamb\u00e9m para tipos definidos pelo desenvolvedor. 2 1 2 3 4 5 6 Prelude > [ 'a' .. 'm' ] \"abcdefghijklm\" Prelude > data Naipe = Copas | Espada | Ouro | Paus deriving ( Ord , Eq , Enum , Show ) Prelude > [ Copas .. Ouro ] [ Copas , Espada , Ouro ] Exerc\u00edcio Defina uma fun\u00e7\u00e3o que dado um n\u00famero inteiro x, gere uma lista de 1 a x e de volta a 1. Resolu\u00e7\u00e3o 1 2 vaiEVolta n = lista ++ drop 1 ( reverse lista ) where lista = [ 1 .. n ] 1 2 * Main > vaiEVolta 3 [ 1 , 2 , 3 , 2 , 1 ] Defina uma fun\u00e7\u00e3o que dado uma String, verifique se ela \u00e9 um pal\u00edndromo. Resolu\u00e7\u00e3o 1 \u00e9Pal\u00edndromo s = s == reverse s 1 2 3 4 * Main > \u00e9Pal\u00edndromo \"aba\" True * Main > \u00e9Pal\u00edndromo \"abac\" False Defina uma fun\u00e7\u00e3o que calcule o fatorial e um n\u00famero n, usando product e listas por enumera\u00e7\u00e3o. Resolu\u00e7\u00e3o 1 fatorial n = product [ 1 .. n ] Um pangrama \u00e9 uma frase que contem todas as letras do alfabeto. Escreva uma fun\u00e7\u00e3o que, dado uma String, verifique se \u00e9 um pangrama. Resolu\u00e7\u00e3o 1 2 3 4 5 6 module Pangram ( isPangram ) where import Data.Char ( toLower ) isPangram :: String -> Bool isPangram text = all (` elem ` ( map toLower text )) [ 'a' .. 'z' ] Compreens\u00e3o de Listas A compreens\u00e3o de listas \u00e9 uma forma de construir listas pela defini\u00e7\u00e3o de uma regra de constru\u00e7\u00e3o, e \u00e9 muito comum nas linguagens funcionais, incluindo Haskell. Defini\u00e7\u00e3o em fun\u00e7\u00e3o de outra lista Suponha que tenha uma lista de n\u00fameros e que gostaria de gerar uma nova lista em que cada valor da lista original \u00e9 acrescido de 30%. Com compreens\u00e3o de listas, isto pode ser feito muito facilmente usando a compreens\u00e3o de listas [ e * 1.3 | e <- lista ] . Esta compreens\u00e3o diz que ser\u00e1 constru\u00edda uma lista cujos elementos ser\u00e3o da forma e * 1.3 , onde e s\u00e3o os elementos da lista original. Veja o exemplo de execu\u00e7\u00e3o. 1 2 3 > lista = Prelude > lista = [ 10 , 20 , 30 , 40 , 100 ] > [ e * 1.3 | e <- lista ] [ 13.0 , 26.0 , 39.0 , 52.0 , 130.0 ] Sintaxe A compreens\u00e3o de listas \u00e9 baseada na compreens\u00e3o de conjuntos, da teoria de conjuntos da matem\u00e1tica. A seguinte compreens\u00e3o de conjuntos pode ser lida como o conjunto \\(A\\) formado pela aplica\u00e7\u00e3o da fun\u00e7\u00e3o \\(f\\) a todos os valores \\(x\\) tal que \\(x\\) pertence ao conjunto \\(C\\) e para os quais valem os predicados \\(P_i, 1\\leq i \\leq n\\) . \\(A = \\{ f(x) | x \\in C \\land P_1(x) \\land \\ldots \\land P_n(x)\\}\\) A compreens\u00e3o de listas \u00e9 similar a = [ f x | x <- c , p1 x , ... , pn x ] Uma diferen\u00e7a importante \u00e9 que enquanto n\u00e3o h\u00e1 ordem nos conjuntos, h\u00e1 ordem nas listas e a constru\u00e7\u00e3o \u00e9 feita na ordem da lista original. Listas infinitas Assim como \u00e9 poss\u00edvel expressar um conjunto infinito usando compreens\u00e3o de conjuntos, por exemplo o conjunto dos quadrados de todos os n\u00fameros naturais \\(S = \\{e^2 | e \\in \\mathcal{N} \\}\\) , podemos expressar listas infinitas usando enumera\u00e7\u00e3o e compreens\u00e3o de listas como lq = [ e ** 2 | e <- [ 1 .. ]] . \"Mas como \u00e9 poss\u00edvel?\", voc\u00ea me pergunta, afinal, a mem\u00f3ria do computador \u00e9 finita e portanto n\u00e3o poderia armazenar uma lista infinita. Esta \u00e9 uma das m\u00e1gicas de Haskell, conhecida como avalia\u00e7\u00e3o pregui\u00e7osa, e ser\u00e1 vista em detalhes mais adiante. Por enquanto, basta acreditar que, desde que voc\u00ea n\u00e3o tente enumerar todos os elementos, uma lista infinita pode se representada em Haskell. Podemos, inclusive, consultar alguns elementos da lista infinita constru\u00edda acima para, por exemplo, verificar se um certo n\u00famero \u00e9 um quadrado perfeito! 1 2 3 4 5 > lq = [ e ** 2 | e <- [ 1 .. ]] > elem 4 lq True > elem 16 lq True Observe, contudo, que se um elemento n\u00e3o estiver na lista, a fun\u00e7\u00e3o nunca retornar\u00e1! 1 2 > elem 3 lq ^ CInterrupted . Exerc\u00edcio Modifique o exemplo acima para limitar a quantidade de elementos que ser\u00e3o buscados na lista de quadrados. Resolu\u00e7\u00e3o 1 2 3 4 5 6 Prelude > elem 16 ( take 100 lq ) True Prelude > elem 20 ( take 100 lq ) False Prelude > elem 64 ( take 5 lq ) False Compreens\u00e3o como uma itera\u00e7\u00e3o Sabendo que a fun\u00e7\u00e3o ord do m\u00f3dulo Data.Char converte um caractere para seu valor na tabela ASCII, imagine que voc\u00ea queira converter uma String para uma lista dos valores ASCII correspondentes. Isso pode ser feito trivialmente com compreens\u00e3o de listas. 1 2 3 Prelude > import Data.Char ( ord ) Prelude Data . Char > [ ord e | e <- \"abcd,'dasdfa;lkqwoiur\" ] [ 97 , 98 , 99 , 100 , 44 , 39 , 100 , 97 , 115 , 100 , 102 , 97 , 59 , 108 , 107 , 113 , 119 , 111 , 105 , 117 , 114 ] Isto demonstra que a constru\u00e7\u00e3o da lista pode ser usada aplicar uma fun\u00e7\u00e3o a todos os elementos de um \"conjunto\". No pr\u00f3ximo exemplo, usamos esta habilidade para capitalizar de uma String. 1 2 3 Prelude Data . Char > import Data.Char ( toUpper ) Prelude Data . Char > [ toUpper e | e <- \"abcd,'dasdfa;lkqwoiur\" ] \"ABCD,'DASDFA;LKQWOIUR\" A lista resultante pode tem tipos complexos como elementos, como no exemplo seguinte, em que compreens\u00e3o gera uma com tuplas com as vers\u00f5es min\u00fascula e em mai\u00fascula de cada letra encontrada na entrada. 1 2 Prelude Data . Char > [ ( toUpper e , toLower e ) | e <- \"abCD\" ] [( 'A' , 'a' ),( 'B' , 'b' ),( 'C' , 'c' ),( 'D' , 'd' )] Exerc\u00edcio Explique [ ( e , chr (( ord e - ord 'a' + 10 ) mod 26 + (ord 'a'))) | e <- ['a'..'z']] Resolu\u00e7\u00e3o Retorna uma lista de tuplas em que os primeiros elementos s\u00e3o letras e seus pares s\u00e3o letras 10 posi\u00e7\u00f5es adiante no alfabeto, m\u00f3dulo 26. Predicados Imagine agora que voc\u00ea queira construir uma lista com os quadrados dos n\u00fameros naturais m\u00faltiplos de 3 e menores que 100. Neste caso, podemos adicionar um teste aos elementos sendo aplicados na constru\u00e7\u00e3o da lista 1 2 > [ e ^ 2 | e <- [ 1 .. 100 ], e ` mod ` 3 == 0 ] [ 9 , 36 , 81 , 144 , 225 , 324 , 441 , 576 , 729 , 900 , 1089 , 1296 , 1521 , 1764 , 2025 , 2304 , 2601 , 2916 , 3249 , 3600 , 3969 , 4356 , 4761 , 5184 , 5625 , 6084 , 6561 , 7056 , 7569 , 8100 , 8649 , 9216 , 9801 ] Observe que os predicados em si podem ser t\u00e3o complexos quanto se queira. 1 2 Prelude Data . Char > [ e ^ 2 | e <- [ 1 .. 100 ], e ` mod ` 3 == 0 , e ^ 2 ` mod ` 4 == 0 ] [ 36 , 144 , 324 , 576 , 900 , 1296 , 1764 , 2304 , 2916 , 3600 , 4356 , 5184 , 6084 , 7056 , 8100 , 9216 ] Exerc\u00edcio Usando compreens\u00e3o de listas, defina uma fun\u00e7\u00e3o que gera a lista dos divisores de um n\u00famero. Resolu\u00e7\u00e3o 1 2 3 > divisores x = [ e | e <- [ 1 .. x ], x ` mod ` e == 0 ] > divisores 10 [ 1 , 2 , 5 , 10 ] Usando a fun\u00e7\u00e3o definida acima, defina uma fun\u00e7\u00e3o que teste se um n\u00famero \u00e9 primo. Resolu\u00e7\u00e3o 1 2 3 4 5 6 > divisores x = [ e | e <- [ 1 .. x ], x ` mod ` e == 0 ] > primo x = divisores x == [ 1 , x ] > primo 7 True > primo 45 False M\u00faltiplos geradores Uma compreens\u00e3o de listas pode ter mais de um gerador ( <- ), o que faz com que todas as combina\u00e7\u00f5es dos elementos gerados sejam aplicadas \u00e0 fun\u00e7\u00e3o. Por exemplo, a seguinte compreens\u00e3o combina todos os n\u00fameros de 1 a 4 com todos os n\u00fameros de 1 a 4 na constru\u00e7\u00e3o de uma tupla de dois inteiros. 1 2 > [( x , y ) | x <- [ 1 .. 4 ], y <- [ 1 .. 4 ]] [( 1 , 1 ),( 1 , 2 ),( 1 , 3 ),( 1 , 4 ),( 2 , 1 ),( 2 , 2 ),( 2 , 3 ),( 2 , 4 ),( 3 , 1 ),( 3 , 2 ),( 3 , 3 ),( 3 , 4 ),( 4 , 1 ),( 4 , 2 ),( 4 , 3 ),( 4 , 4 )] Veja que predicados podem ser normalmente aplicados a m\u00faltiplos geradores, como no seguinte exemplo, em que somente as combina\u00e7\u00f5es onde \\(x,y\\) s\u00e3o usadas. 1 2 > [( x , y ) | x <- [ 1 .. 4 ], y <- [ 1 .. 4 ], x < y ] [( 1 , 2 ),( 1 , 3 ),( 1 , 4 ),( 2 , 3 ),( 2 , 4 ),( 3 , 4 )] \u00c9 importante observar que a ordem dos geradores altera a ordem dos elementos da lista gerada, pois para cada elemento gerado pelo primeiro gerador, ser\u00e1 combinado a cada elemento gerado pelo segundo. 1 2 3 4 > [ ( x , y ) | x <- [ 1 .. 4 ], y <- [ 'a' .. 'd' ]] [( 1 , 'a' ),( 1 , 'b' ),( 1 , 'c' ),( 1 , 'd' ),( 2 , 'a' ),( 2 , 'b' ),( 2 , 'c' ),( 2 , 'd' ),( 3 , 'a' ),( 3 , 'b' ),( 3 , 'c' ),( 3 , 'd' ),( 4 , 'a' ),( 4 , 'b' ),( 4 , 'c' ),( 4 , 'd' )] > [ ( x , y ) | y <- [ 'a' .. 'd' ], x <- [ 1 .. 4 ]] [( 1 , 'a' ),( 2 , 'a' ),( 3 , 'a' ),( 4 , 'a' ),( 1 , 'b' ),( 2 , 'b' ),( 3 , 'b' ),( 4 , 'b' ),( 1 , 'c' ),( 2 , 'c' ),( 3 , 'c' ),( 4 , 'c' ),( 1 , 'd' ),( 2 , 'd' ),( 3 , 'd' ),( 4 , 'd' )] Al\u00e9m disso, \u00e9 poss\u00edvel definir um gerador em termos dos geradores anteriores. Por exemplo 1 2 > [ ( x , y ) | x <- [ 1 .. 4 ], y <- [ 1 .. x ]] [( 1 , 1 ),( 2 , 1 ),( 2 , 2 ),( 3 , 1 ),( 3 , 2 ),( 3 , 3 ),( 4 , 1 ),( 4 , 2 ),( 4 , 3 ),( 4 , 4 )] Este construto \u00e9 deveras poderoso, pois geradores podem ser aplicados eles pr\u00f3prios a compreens\u00e3o de listas. Outra possibilidade \u00e9 a aplica\u00e7\u00e3o recursiva, como no seguinte c\u00f3digo. 1 2 partitions [] = [ [] ] partitions ( x : xs ) = [ x : e | e <- partitions xs ] ++ partitions xs Exerc\u00edcio Explique o que a fun\u00e7\u00e3o acima faz, com um exemplo. Casamento de padr\u00f5es Toda lista \u00e9 ou uma lista vazia ou ou um elemento cabe\u00e7a seguido por uma lista cauda. Assim, se cobrir estes dois casos em uma defini\u00e7\u00e3o por casamento de padr\u00f5es, ter\u00e1 coberto \"todos\" os casos! Mas como? Vejamos um exemplo. 1 2 3 oQueH\u00e1NaCabe\u00e7a :: ( Show a ) => [ a ] -> String oQueH\u00e1NaCabe\u00e7a [] = \"Nada\" oQueH\u00e1NaCabe\u00e7a ( x : xs ) = \"H\u00e1 \" ++ x Linha 1: n\u00e3o se preocupe esta linha; ela apenas implica que a lista deve ser de valores convert\u00edveis a String Linha 2: esta linha usa um padr\u00e3o constante para testar se a lista \u00e9 vazia, isto \u00e9, [] e, neste caso, retornar a string \"Nada\" como resultado. Linha 3: este \u00e9 o caso mais interessante, pois usa um padr\u00e3o que define uma lista em que x \u00e9 a cabe\u00e7a, concatenada por : a uma cauda xs , e retorna \"H\u00e1 \" seguido do valor casado com x . Observe que foram usados par\u00eanteses na linha 3 para especificar o padr\u00e3o, e n\u00e3o apenas x : xs como seria de se esperar. A verdade \u00e9 que o padr\u00e3o \u00e9 x : xs e os par\u00eantesis s\u00e3o usados apenas para impedir que Haskell primeiro avalie oQueH\u00e1NaCabe\u00e7a x antes de avaliar o operador : e o seu segundo operando. Esta \u00e9 uma das idiossincrasias de Haskell com a qual voc\u00ea simplesmente ter\u00e1 que aprender a conviver para dividir listas entre cabe\u00e7a e cauda em um casamento de padr\u00f5es. Embora estes dois padr\u00f5es, isto \u00e9, lista vazia e cabe\u00e7a seguida de cauda, cubram todas as possibilidades de listas, n\u00e3o quer dizer que n\u00e3o haja melhores op\u00e7\u00f5es, dependendo do que precise extrair da lista. Por exemplo, na pr\u00f3xima fun\u00e7\u00e3o h\u00e1 4 casos de casamento de padr\u00f5es distintos: 1 2 3 4 5 oQueH\u00e1NaLista :: ( Show a ) => [ a ] -> String oQueH\u00e1NaLista [] = \"Nada\" oQueH\u00e1NaLista [ x ] = \"S\u00f3 \" ++ ( show x ) oQueH\u00e1NaLista [ x1 , x2 ] = \"H\u00e1 \" ++ ( show x1 ) ++ \" e \" ++ ( show x2 ) oQueH\u00e1NaLista ( x : xs ) = \"H\u00e1 \" ++ ( show x ) ++ \" e mais um monte de coisas\" Linha 2: lista vazia; Linha 3: lista com exatamente um elemento, casado com x . Linha 4: lista com exatamente 2 elementos, casados com x1 e x2 . Linha 5: lista com mais de 2 elementos, em que a cabe\u00e7a \u00e9 casada com x e a cauda com xs . Outra forma de obter exatamente o mesmo resultado, usando mais o operador cons , seria a seguinte. 1 2 3 4 5 oQueH\u00e1NaLista :: ( Show a ) => [ a ] -> String oQueH\u00e1NaLista [] = \"Nada\" oQueH\u00e1NaLista ( x :[] ) = \"S\u00f3 \" ++ ( show x ) oQueH\u00e1NaLista ( x1 : x2 :[] ) = \"H\u00e1 \" ++ ( show x1 ) ++ \" e \" ++ ( show x2 ) oQueH\u00e1NaLista ( x : xs ) = \"H\u00e1 \" ++ ( show x ) ++ \" e mais um monte de coisas\" Dado que strings s\u00e3o apenas listas de Char, estas tamb\u00e9m podem ser decompostas por casamentos de padr\u00f5es. 1 2 3 4 5 resumo :: [ a ] -> \"String\" resumo [] -> \"Nada\" resumo [ _ ] -> \"Um\" resumo [ _ , _ ] -> \"Dois\" resumo _ -> \"Muitos\" Assim como listas podem ter elementos mais complexos que tipos primitivos, por exemplo tuplas e listas, tamb\u00e9m os casamentos de padr\u00f5es aplicados a estas listas ser\u00e3o mais complexos. Por exemplo, considere uma lista de tr\u00eas ou mais String, isto \u00e9, uma lista de lista de Char; \u00e9 poss\u00edvel, por exemplo, selecionar a primeira letra de cada uma das tr\u00eas primeiras strings com a seguinte fun\u00e7\u00e3o. 1 2 3 4 5 iniciais :: [ String ] -> [ Char ] iniciais [] = [] iniciais [( x : _ )] = [ x ] iniciais [( x : _ ),( y : _ )] = [ x , y ] iniciais (( x : _ ) : ( y : _ ) : ( z : _ ) : _ ) = [ x , y , z ] Fun\u00e7\u00f5es \u00fateis Em uma se\u00e7\u00e3o anterior, apresentamos algumas fun\u00e7\u00f5es como \u00fateis na manipula\u00e7\u00e3o de String. Na verdade, todas aquelas fun\u00e7\u00f5es s\u00e3o definidas em termos de listas, e por isso as revisitaremos aqui, juntamente com mais algumas. Operador Opera\u00e7\u00e3o Exemplo ++ Concatena\u00e7\u00e3o de listas > \"foo\" ++ \"bar\" \"foobar\" !! Elemento no \u00edndice > [ 1 , 2 , 3 , 4 ] !! 2 3 reverse Lista ao contr\u00e1rio > reverse [ 1 , 2 , 3 , 4 ] [4,3,2,1] length Comprimento da string > length \"foo bar\" 7 last \u00daltimo elemento da lista > last \"foo bar\" r concat Retorna a concatena\u00e7\u00e3o das listas dentro de uma lista > concat [[ 1 , 2 , 3 , 4 ],[ 5 , 6 , 7 , 8 ]] [1,2,3,4,5,6,7,8] > concat [[[ 1 , 2 , 3 ]],[[ 4 , 5 , 6 ]]] [[ 1 , 2 , 3 ],[ 4 , 5 , 6 ]] elem Verifica se o par\u00e2metro \u00e9 um elemento da lista > elem 'o' \"foo bar\" True null Verifica se a lista \u00e9 vazia > null \"\" True > null [] True > null [ 1 , 2 ] False replicate Constr\u00f3i uma lista pela replica\u00e7\u00e3o de um elemento > replicate 4 ( 1 , 2 ) [( 1 , 2 ),( 1 , 2 ),( 1 , 2 ),( 1 , 2 )] take Sublista iniciando em 0 > take 3 1 : 2 : 3 : 4 : 5 :[] [ 1 , 2 , 3 ] drop Sublista come\u00e7ando em um \u00edndice > drop 3 [ 'f' , 'o' , 'o' , ' ' , 'b' , 'a' , 'r' ] \" bar\" takeWhile Sublista iniciando em 0 e at\u00e9 o primeiro elemento que n\u00e3o satisfaz ao crit\u00e9rio, exclusive > takeWhile ( < 4 ) [ 1 , 2 , 3 , 4 , 5 , 6 ] [ 1 , 2 , 3 ] dropWhile Sublista come\u00e7ando no primeiro elemento que n\u00e3o satisfaz ao crit\u00e9rio, inclusive > dropWhile ( < 4 ) [ 1 , 2 , 3 , 4 , 5 , 6 ] 4 , 5 , 6 splitAt Dupla das sublistas geradas pela divis\u00e3o no \u00edndice especificado > splitAt 3 [ 1 , 2 , 3 , 4 , 5 , 6 ] ([ 1 , 2 , 3 ],[ 4 , 5 , 6 ]) zip Lista de pares com os elementos das duas listas passadas como par\u00e2metro > zip [ 1 , 2 , 3 ] [ 4 , 5 , 6 ] [( 1 , 4 ),( 2 , 5 ),( 3 , 6 )] sum Somat\u00f3rio dos elementos da lista > sum [ 1 , 2 , 3 , 4 , 5 , 6 ] 16 product Produt\u00f3rio dos elementos da lista > product [ 1 , 2 , 3 , 4 , 5 , 6 ] 720 maximum Maior dos elemento lista > maximum [ 1 , 2 , 3 , 4 , 5 , 6 ] 6 minimum Menor dos elementos da lista > minimum [ 1 , 2 , 3 , 4 , 5 , 6 ] 1 Recurs\u00e3o A recurs\u00e3o \u00e9 essencial no processamento de listas e, de fato, muitas das fun\u00e7\u00f5es listadas na se\u00e7\u00e3o anterior podem e s\u00e3o definidas recursivamente, como a fun\u00e7\u00e3o maximum : \\(maximum~[1,2,3] = max~1 \\left( maximum~[2,3] = max~2 \\left( maximum~[3] = 3 \\right) \\right)\\) Vejamos algumas defini\u00e7\u00f5es. 3 maximum 1 2 3 maximum' [] = error \"lista vazia\" maximum' [ h ] = h maximum' ( h : t ) = max h ( maximum' t ) length 1 2 3 length' :: [ a ] -> Int length' [] = 0 length' ( x : xs ) = 1 + length' xs last 1 2 3 4 last' :: [ a ] -> a last' [] = error \"List is empty\" last' [ x ] = x last' ( _ : xs ) = last' xs reverse 1 2 3 reverse' :: [ a ] -> [ a ] reverse' [] = [] reverse' ( x : xs ) = reverse' xs ++ [ x ] replicate 1 2 replicate' 0 e = [] replicate' x e = e : replicate' ( x - 1 ) e zip 1 2 3 zip' [] _ = [] zip' _ [] = [] zip' ( x : xs ) ( y : ys ) = ( x , y ) : zip' xs ys elem 1 2 elem' _ [] = False elem' e ( x : xs ) = e == x || elem' e xs Foi feita uma pequena edi\u00e7\u00e3o na sa\u00edda do comando : t para claridade, pois o resultado real envolvia supertipos, a serem vistos mais adiante. \u21a9 No exemplo, observe o espa\u00e7o entre Copas e .. . \u21a9 Todas as fun\u00e7\u00f5es definidas a seguir tem nome terminado em ``` para evitar colis\u00e3o com as fun\u00e7\u00f5es padr\u00e3o. \u21a9","title":"Listas"},{"location":"lists/#listas","text":"Vamos agora estudar listas, pe\u00e7as fundamentais no desenvolvimento de programas usando o paradigma funcional, por serem estruturas de dados que permitem agregar v\u00e1rias informa\u00e7\u00f5es na forma de uma cole\u00e7\u00e3o ordenada de elementos. Por exemplo, [ \"Eu\" , \"amo\" , \"programa\u00e7\u00e3o\" , \"funcional\" ] \u00e9 a cole\u00e7\u00e3o de quatro strings em que o primeiro elemento \u00e9 \"Eu\" , o segundo \"amo\" , o terceiro \"programa\u00e7\u00e3o\" e o quarto e \u00faltimo \"funcional\" . J\u00e1 [ 1 :: Int , 2 :: Int , 3 :: Int ] \u00e9 uma lista de 3 elementos do tipo Int , onde o primeiro elemento \u00e9 1, o segundo 2, e o terceiro 3. \"Mas e as tuplas?\", voc\u00ea pergunta, \"N\u00e3o s\u00e3o exatamente isto?\"","title":"Listas"},{"location":"lists/#estrutura","text":"Dado uma lista qualquer, de qualquer tipo, ela pode ser ou vazia ou n\u00e3o vazia, sendo que a lista vazia \u00e9 representada em Haskell por [] . Listas n\u00e3o vazias s\u00e3o representadas como a concatena\u00e7\u00e3o do primeiro elemento da lista com uma lista com os demais elementos, usando o operador de concatena\u00e7\u00e3o : , ou cons . Por exemplo, a lista dos n\u00fameros 1, 2 e 3 nesta ordem \u00e9 constru\u00edda como 1 : 2 : 3 :[] ; observe que como o 3 \u00e9 o \u00faltimo elemento da lista, a lista que vem depois do cons, com os demais elementos, \u00e9 a lista vazia. 1 2 3 Prelude > x = 1 : 2 : 3 :[] Prelude > x [ 1 , 2 , 3 ]","title":"Estrutura"},{"location":"lists/#enumeracao","text":"Para facilitar a vida dos desenvolvedores, Haskell permite a constru\u00e7\u00e3o de listas por enumera\u00e7\u00e3o, bastando para isso o especificar o primeiro elemento da lista, opcionalmente o segundo, e o \u00faltimo elemento. Por exemplo 1 2 3 4 5 Prelude > [ 11 , 13 .. 23 ] [ 11 , 13 , 15 , 17 , 19 , 21 , 23 ] Prelude > [ - 15 , - 13 .. 14 ] [ - 15 , - 13 , - 11 , - 9 , - 7 , - 5 , - 3 , - 1 , 1 , 3 , 5 , 7 , 9 , 11 , 13 ] Observe que Haskell determinou um passo de incremento igual a \\(13-11 = 2\\) no primeiro exemplo e \\(-15 - -13 = 2\\) no segundo exemplo, e usou estes passos para gerar as lista. Tamb\u00e9m \u00e9 poss\u00edvel definir um passo negativo, como no pr\u00f3ximo exemplo. 1 2 Prelude > [ 11 , 9 .. 0 ] [ 11 , 9 , 7 , 5 , 3 , 1 ] Como mencionado, o segundo elemento \u00e9 opcional na enumera\u00e7\u00e3o e caso n\u00e3o especificado, Haskell assume que seja \\(1\\) , como no exemplo a seguir. 1 2 3 4 Prelude > [ 11 .. 23 ] [ 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 ] Prelude > [ 3.5 .. 10 ] [ 3.5 , 4.5 , 5.5 , 6.5 , 7.5 , 8.5 , 9.5 , 10.5 ] Contudo, n\u00e3o \u00e9 poss\u00edvel omitir o segundo elemento se a inten\u00e7\u00e3o for gerar uma lista com valores decrescentes. 1 2 Prelude > [ 11 .. 0 ] [] A enumera\u00e7\u00e3o pode ser feita para outros tipos que n\u00e3o sejam num\u00e9ricos, bastando que exista uma rela\u00e7\u00e3o de ordem entre os elementos para que Haskell consiga \"incrementar\" a cada passo. Isso existe, por exemplo, entre os caracteres, mas tamb\u00e9m para tipos definidos pelo desenvolvedor. 2 1 2 3 4 5 6 Prelude > [ 'a' .. 'm' ] \"abcdefghijklm\" Prelude > data Naipe = Copas | Espada | Ouro | Paus deriving ( Ord , Eq , Enum , Show ) Prelude > [ Copas .. Ouro ] [ Copas , Espada , Ouro ] Exerc\u00edcio Defina uma fun\u00e7\u00e3o que dado um n\u00famero inteiro x, gere uma lista de 1 a x e de volta a 1. Resolu\u00e7\u00e3o 1 2 vaiEVolta n = lista ++ drop 1 ( reverse lista ) where lista = [ 1 .. n ] 1 2 * Main > vaiEVolta 3 [ 1 , 2 , 3 , 2 , 1 ] Defina uma fun\u00e7\u00e3o que dado uma String, verifique se ela \u00e9 um pal\u00edndromo. Resolu\u00e7\u00e3o 1 \u00e9Pal\u00edndromo s = s == reverse s 1 2 3 4 * Main > \u00e9Pal\u00edndromo \"aba\" True * Main > \u00e9Pal\u00edndromo \"abac\" False Defina uma fun\u00e7\u00e3o que calcule o fatorial e um n\u00famero n, usando product e listas por enumera\u00e7\u00e3o. Resolu\u00e7\u00e3o 1 fatorial n = product [ 1 .. n ] Um pangrama \u00e9 uma frase que contem todas as letras do alfabeto. Escreva uma fun\u00e7\u00e3o que, dado uma String, verifique se \u00e9 um pangrama. Resolu\u00e7\u00e3o 1 2 3 4 5 6 module Pangram ( isPangram ) where import Data.Char ( toLower ) isPangram :: String -> Bool isPangram text = all (` elem ` ( map toLower text )) [ 'a' .. 'z' ]","title":"Enumera\u00e7\u00e3o"},{"location":"lists/#compreensao-de-listas","text":"A compreens\u00e3o de listas \u00e9 uma forma de construir listas pela defini\u00e7\u00e3o de uma regra de constru\u00e7\u00e3o, e \u00e9 muito comum nas linguagens funcionais, incluindo Haskell.","title":"Compreens\u00e3o de Listas"},{"location":"lists/#casamento-de-padroes","text":"Toda lista \u00e9 ou uma lista vazia ou ou um elemento cabe\u00e7a seguido por uma lista cauda. Assim, se cobrir estes dois casos em uma defini\u00e7\u00e3o por casamento de padr\u00f5es, ter\u00e1 coberto \"todos\" os casos! Mas como? Vejamos um exemplo. 1 2 3 oQueH\u00e1NaCabe\u00e7a :: ( Show a ) => [ a ] -> String oQueH\u00e1NaCabe\u00e7a [] = \"Nada\" oQueH\u00e1NaCabe\u00e7a ( x : xs ) = \"H\u00e1 \" ++ x Linha 1: n\u00e3o se preocupe esta linha; ela apenas implica que a lista deve ser de valores convert\u00edveis a String Linha 2: esta linha usa um padr\u00e3o constante para testar se a lista \u00e9 vazia, isto \u00e9, [] e, neste caso, retornar a string \"Nada\" como resultado. Linha 3: este \u00e9 o caso mais interessante, pois usa um padr\u00e3o que define uma lista em que x \u00e9 a cabe\u00e7a, concatenada por : a uma cauda xs , e retorna \"H\u00e1 \" seguido do valor casado com x . Observe que foram usados par\u00eanteses na linha 3 para especificar o padr\u00e3o, e n\u00e3o apenas x : xs como seria de se esperar. A verdade \u00e9 que o padr\u00e3o \u00e9 x : xs e os par\u00eantesis s\u00e3o usados apenas para impedir que Haskell primeiro avalie oQueH\u00e1NaCabe\u00e7a x antes de avaliar o operador : e o seu segundo operando. Esta \u00e9 uma das idiossincrasias de Haskell com a qual voc\u00ea simplesmente ter\u00e1 que aprender a conviver para dividir listas entre cabe\u00e7a e cauda em um casamento de padr\u00f5es. Embora estes dois padr\u00f5es, isto \u00e9, lista vazia e cabe\u00e7a seguida de cauda, cubram todas as possibilidades de listas, n\u00e3o quer dizer que n\u00e3o haja melhores op\u00e7\u00f5es, dependendo do que precise extrair da lista. Por exemplo, na pr\u00f3xima fun\u00e7\u00e3o h\u00e1 4 casos de casamento de padr\u00f5es distintos: 1 2 3 4 5 oQueH\u00e1NaLista :: ( Show a ) => [ a ] -> String oQueH\u00e1NaLista [] = \"Nada\" oQueH\u00e1NaLista [ x ] = \"S\u00f3 \" ++ ( show x ) oQueH\u00e1NaLista [ x1 , x2 ] = \"H\u00e1 \" ++ ( show x1 ) ++ \" e \" ++ ( show x2 ) oQueH\u00e1NaLista ( x : xs ) = \"H\u00e1 \" ++ ( show x ) ++ \" e mais um monte de coisas\" Linha 2: lista vazia; Linha 3: lista com exatamente um elemento, casado com x . Linha 4: lista com exatamente 2 elementos, casados com x1 e x2 . Linha 5: lista com mais de 2 elementos, em que a cabe\u00e7a \u00e9 casada com x e a cauda com xs . Outra forma de obter exatamente o mesmo resultado, usando mais o operador cons , seria a seguinte. 1 2 3 4 5 oQueH\u00e1NaLista :: ( Show a ) => [ a ] -> String oQueH\u00e1NaLista [] = \"Nada\" oQueH\u00e1NaLista ( x :[] ) = \"S\u00f3 \" ++ ( show x ) oQueH\u00e1NaLista ( x1 : x2 :[] ) = \"H\u00e1 \" ++ ( show x1 ) ++ \" e \" ++ ( show x2 ) oQueH\u00e1NaLista ( x : xs ) = \"H\u00e1 \" ++ ( show x ) ++ \" e mais um monte de coisas\" Dado que strings s\u00e3o apenas listas de Char, estas tamb\u00e9m podem ser decompostas por casamentos de padr\u00f5es. 1 2 3 4 5 resumo :: [ a ] -> \"String\" resumo [] -> \"Nada\" resumo [ _ ] -> \"Um\" resumo [ _ , _ ] -> \"Dois\" resumo _ -> \"Muitos\" Assim como listas podem ter elementos mais complexos que tipos primitivos, por exemplo tuplas e listas, tamb\u00e9m os casamentos de padr\u00f5es aplicados a estas listas ser\u00e3o mais complexos. Por exemplo, considere uma lista de tr\u00eas ou mais String, isto \u00e9, uma lista de lista de Char; \u00e9 poss\u00edvel, por exemplo, selecionar a primeira letra de cada uma das tr\u00eas primeiras strings com a seguinte fun\u00e7\u00e3o. 1 2 3 4 5 iniciais :: [ String ] -> [ Char ] iniciais [] = [] iniciais [( x : _ )] = [ x ] iniciais [( x : _ ),( y : _ )] = [ x , y ] iniciais (( x : _ ) : ( y : _ ) : ( z : _ ) : _ ) = [ x , y , z ]","title":"Casamento de padr\u00f5es"},{"location":"lists/#funcoes-uteis","text":"Em uma se\u00e7\u00e3o anterior, apresentamos algumas fun\u00e7\u00f5es como \u00fateis na manipula\u00e7\u00e3o de String. Na verdade, todas aquelas fun\u00e7\u00f5es s\u00e3o definidas em termos de listas, e por isso as revisitaremos aqui, juntamente com mais algumas. Operador Opera\u00e7\u00e3o Exemplo ++ Concatena\u00e7\u00e3o de listas > \"foo\" ++ \"bar\" \"foobar\" !! Elemento no \u00edndice > [ 1 , 2 , 3 , 4 ] !! 2 3 reverse Lista ao contr\u00e1rio > reverse [ 1 , 2 , 3 , 4 ] [4,3,2,1] length Comprimento da string > length \"foo bar\" 7 last \u00daltimo elemento da lista > last \"foo bar\" r concat Retorna a concatena\u00e7\u00e3o das listas dentro de uma lista > concat [[ 1 , 2 , 3 , 4 ],[ 5 , 6 , 7 , 8 ]] [1,2,3,4,5,6,7,8] > concat [[[ 1 , 2 , 3 ]],[[ 4 , 5 , 6 ]]] [[ 1 , 2 , 3 ],[ 4 , 5 , 6 ]] elem Verifica se o par\u00e2metro \u00e9 um elemento da lista > elem 'o' \"foo bar\" True null Verifica se a lista \u00e9 vazia > null \"\" True > null [] True > null [ 1 , 2 ] False replicate Constr\u00f3i uma lista pela replica\u00e7\u00e3o de um elemento > replicate 4 ( 1 , 2 ) [( 1 , 2 ),( 1 , 2 ),( 1 , 2 ),( 1 , 2 )] take Sublista iniciando em 0 > take 3 1 : 2 : 3 : 4 : 5 :[] [ 1 , 2 , 3 ] drop Sublista come\u00e7ando em um \u00edndice > drop 3 [ 'f' , 'o' , 'o' , ' ' , 'b' , 'a' , 'r' ] \" bar\" takeWhile Sublista iniciando em 0 e at\u00e9 o primeiro elemento que n\u00e3o satisfaz ao crit\u00e9rio, exclusive > takeWhile ( < 4 ) [ 1 , 2 , 3 , 4 , 5 , 6 ] [ 1 , 2 , 3 ] dropWhile Sublista come\u00e7ando no primeiro elemento que n\u00e3o satisfaz ao crit\u00e9rio, inclusive > dropWhile ( < 4 ) [ 1 , 2 , 3 , 4 , 5 , 6 ] 4 , 5 , 6 splitAt Dupla das sublistas geradas pela divis\u00e3o no \u00edndice especificado > splitAt 3 [ 1 , 2 , 3 , 4 , 5 , 6 ] ([ 1 , 2 , 3 ],[ 4 , 5 , 6 ]) zip Lista de pares com os elementos das duas listas passadas como par\u00e2metro > zip [ 1 , 2 , 3 ] [ 4 , 5 , 6 ] [( 1 , 4 ),( 2 , 5 ),( 3 , 6 )] sum Somat\u00f3rio dos elementos da lista > sum [ 1 , 2 , 3 , 4 , 5 , 6 ] 16 product Produt\u00f3rio dos elementos da lista > product [ 1 , 2 , 3 , 4 , 5 , 6 ] 720 maximum Maior dos elemento lista > maximum [ 1 , 2 , 3 , 4 , 5 , 6 ] 6 minimum Menor dos elementos da lista > minimum [ 1 , 2 , 3 , 4 , 5 , 6 ] 1","title":"Fun\u00e7\u00f5es \u00fateis"},{"location":"lists/#recursao","text":"A recurs\u00e3o \u00e9 essencial no processamento de listas e, de fato, muitas das fun\u00e7\u00f5es listadas na se\u00e7\u00e3o anterior podem e s\u00e3o definidas recursivamente, como a fun\u00e7\u00e3o maximum : \\(maximum~[1,2,3] = max~1 \\left( maximum~[2,3] = max~2 \\left( maximum~[3] = 3 \\right) \\right)\\) Vejamos algumas defini\u00e7\u00f5es. 3 maximum 1 2 3 maximum' [] = error \"lista vazia\" maximum' [ h ] = h maximum' ( h : t ) = max h ( maximum' t ) length 1 2 3 length' :: [ a ] -> Int length' [] = 0 length' ( x : xs ) = 1 + length' xs last 1 2 3 4 last' :: [ a ] -> a last' [] = error \"List is empty\" last' [ x ] = x last' ( _ : xs ) = last' xs reverse 1 2 3 reverse' :: [ a ] -> [ a ] reverse' [] = [] reverse' ( x : xs ) = reverse' xs ++ [ x ] replicate 1 2 replicate' 0 e = [] replicate' x e = e : replicate' ( x - 1 ) e zip 1 2 3 zip' [] _ = [] zip' _ [] = [] zip' ( x : xs ) ( y : ys ) = ( x , y ) : zip' xs ys elem 1 2 elem' _ [] = False elem' e ( x : xs ) = e == x || elem' e xs Foi feita uma pequena edi\u00e7\u00e3o na sa\u00edda do comando : t para claridade, pois o resultado real envolvia supertipos, a serem vistos mais adiante. \u21a9 No exemplo, observe o espa\u00e7o entre Copas e .. . \u21a9 Todas as fun\u00e7\u00f5es definidas a seguir tem nome terminado em ``` para evitar colis\u00e3o com as fun\u00e7\u00f5es padr\u00e3o. \u21a9","title":"Recurs\u00e3o"},{"location":"observations/","text":"Observa\u00e7\u00f5es Cheat sheet https://hackage.haskell.org/package/CheatSheet-1.7/src/CheatSheet.pdf Exerc\u00edcios da Semana 2 Par\u00eanteses desnecess\u00e1rios Todo if em um then e um else Diferentemente de outras linguagens, onde o if \u00e9 usado para determinar se uma computa\u00e7\u00e3o deve acontecer e o else \u00e9 um atalho para quando h\u00e1 duas op\u00e7\u00f5es, e portanto o else n\u00e3o \u00e9 necess\u00e1rio, em Haskell o if \u00e9 usado para determinar qual computa\u00e7\u00e3o deve acontecer, ou seja, sempre h\u00e1 duas op\u00e7\u00f5es . C 1 2 if ( x > 3 ) //If sem else: compila. y = \"maior\" ; //Se x <= 3, y continua com o valor anterior, seja qual for. Haskell 1 2 let y = if x > 3 then \"maior\" -- If sem else: n\u00e3o compila! Qual o valor de `y` se `x <= 3`? Por isso o if do Haskell deve ser comparado ao operador tern\u00e1rio do C, n\u00e3o com o if . C 1 y = x > 3 ? \"maior\" : \"menor\" ; Haskell 1 let y = if x > 3 then \"maior\" else \"menor\" ((b1+b2)/2) * h -> (b1+b2)/2 * h n\u00e3o h\u00e1 d\u00favida para o compilador que a divis\u00e3o deve ocorrer primeiro, pois os operadores tem a mesma preced\u00eancia e ambos s\u00e3o associativos \u00e0 esquerda. sqrt ((b*b)+ (c*c)) -> sqrt (b*b + c*c) n\u00e3o h\u00e1 d\u00favida para o compilador que a divis\u00e3o deve ocorrer primeiro, pois os operadores tem preced\u00eancias diferentes. Informa\u00e7\u00e3o sobre preced\u00eancia e associatividade pode ser derivadas via : info . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Prelude > : info * type Num :: * -> Constraint class Num a where ... ( * ) :: a -> a -> a ... infixl 7 * -- Infixo com associatividade a esquerda (l) e Preced\u00eancia 7. Prelude > : info / type Fractional :: * -> Constraint class Num a => Fractional a where ( / ) :: a -> a -> a ... infixl 7 / -- Infixo com associatividade a esquerda (l) e Preced\u00eancia 7. Prelude > : info + type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ... infixl 6 + -- Infixo com associatividade a esquerda (l) e Preced\u00eancia 6. maiorDeTres a b c = if a > b && a > c then a else if b > a && b > c then b else c Dif\u00edcil leitura. Quebrar linhas. estaoOrdenados a b c = if ( a > b && b > c ) then True else False if < cond > then True else False -> < cond > estaoOrdenados a b c = a > b && b > c sqrt (( a ^ 2 ) + ( b ^ 2 )) Par\u00eanteses s\u00f3 s\u00e3o necess\u00e1rios para deixar expl\u00edcito o que \u00e9 par\u00e2metro. sqrt (( a ^ 2 ) + ( b ^ 2 )) Fun\u00e7\u00f5es e par\u00e2metros s\u00e3o separados por espa\u00e7o. sqrt (( a ^ 2 ) + ( b ^ 2 )) sqrt (( a ^ 2 ) + ( b ^ 2 )) Operadores tem preced\u00eancias; pot\u00eancia tem preced\u00eancia maior que adi\u00e7\u00e3o sqrt ( a ^ 2 + b ^ 2 ) sqrt a ^ 2 + b ^ 2 Fun\u00e7\u00f5es tem preced\u00eancia sobre operadores. sqrt a ^ 2 + b ^ 2 == ( sqrt a ^ 2 ) + b ^ 2 Exerc\u00edcios da semana 3 Erros Para indicar uma condi\u00e7\u00e3o de erro, use \"error\". Por exemplo, em uma solu\u00e7\u00e3o eu encontrei o seguinte | otherwise = ( 99 , \"error\" ) mas o ideal seria | otherwise = error \"mensagem de erro\" . Prova 1 M\u00e1ximo Toda recurs\u00e3o deve ter um caso base, sen\u00e3o a recurs\u00e3o n\u00e3o para. No seguinte trecho, s\u00f3 temos dois casos. Um if-then-else me parece mais leg\u00edvel. ```#!hs m\u00e1ximo (x:xs) | (x > m\u00e1ximo xs) = x | otherwise = m\u00e1ximo xs 1 2 3 4 5 6 7 ### Ra\u00edzes * ```#!hs Prelude> 4/2*2 4.0 Prelude> 4/(2*2) 1.0 ValorFinal A idade precisa levar m\u00eas e dia em considera\u00e7\u00e3o.","title":"Observa\u00e7\u00f5es"},{"location":"observations/#observacoes","text":"","title":"Observa\u00e7\u00f5es"},{"location":"observations/#cheat-sheet","text":"https://hackage.haskell.org/package/CheatSheet-1.7/src/CheatSheet.pdf","title":"Cheat sheet"},{"location":"observations/#exercicios-da-semana-2","text":"","title":"Exerc\u00edcios da Semana 2"},{"location":"observations/#exercicios-da-semana-3","text":"","title":"Exerc\u00edcios da semana 3"},{"location":"observations/#erros","text":"Para indicar uma condi\u00e7\u00e3o de erro, use \"error\". Por exemplo, em uma solu\u00e7\u00e3o eu encontrei o seguinte | otherwise = ( 99 , \"error\" ) mas o ideal seria | otherwise = error \"mensagem de erro\" .","title":"Erros"},{"location":"observations/#prova-1","text":"","title":"Prova 1"},{"location":"observations/#maximo","text":"Toda recurs\u00e3o deve ter um caso base, sen\u00e3o a recurs\u00e3o n\u00e3o para. No seguinte trecho, s\u00f3 temos dois casos. Um if-then-else me parece mais leg\u00edvel. ```#!hs m\u00e1ximo (x:xs) | (x > m\u00e1ximo xs) = x | otherwise = m\u00e1ximo xs 1 2 3 4 5 6 7 ### Ra\u00edzes * ```#!hs Prelude> 4/2*2 4.0 Prelude> 4/(2*2) 1.0","title":"M\u00e1ximo"},{"location":"observations/#valorfinal","text":"A idade precisa levar m\u00eas e dia em considera\u00e7\u00e3o.","title":"ValorFinal"},{"location":"pattern_matching/","text":"Casamento de Padr\u00f5es Quando especificamos a lista de par\u00e2metros formais que uma fun\u00e7\u00e3o recebe, estamos dizendo ao compilador que os par\u00e2metros passados na invoca\u00e7\u00e3o da fun\u00e7\u00e3o devem ser associados aos par\u00e2metros formais. Por exemplo, considere a seguinte defini\u00e7\u00e3o de uma fun\u00e7\u00e3o que soma dois pontos 1 soma2n x y = x + y e sua invoca\u00e7\u00e3o. 1 2 > soma2n 3 4 7 Quando a invoca\u00e7\u00e3o acontece, o valor 3 \u00e9 associado a x e 4 a y . O mesmo acontece para qualquer tipo de par\u00e2metro passado, mesmo tuplas e, como veremos depois, listas. Por exemplo, considere a soma de dois pontos em um espa\u00e7o bidimensional, em que pontos s\u00e3o especificados como tuplas de aridade 2. 1 2 3 4 type Ponto = ( Integer , Integer ) soma2v :: Ponto -> Ponto -> Ponto soma2v ponto1 ponto2 = ( fst ponto1 + fst ponto2 , snd ponto1 + snd ponto2 ) Um dos problemas deste c\u00f3digo \u00e9 a necessidade de usar fst e snd para extrair os componentes das tuplas. Mas como vimos na se\u00e7\u00e3o sobre tuplas , \u00e9 poss\u00edvel associar as componentes das tuplas diretamente a vari\u00e1veis. Por exemplo, considere a defini\u00e7\u00e3o alternativa para soma2v . 1 2 3 4 type Ponto = ( Integer , Integer ) soma2v :: Ponto -> Ponto -> Ponto soma2v ( x1 , y1 ) ( x2 , y2 ) = ( x1 + x2 , y1 + y2 ) Observe que, na linha 4, as coordenadas dos pontos passados s\u00e3o associados \u00e0s vari\u00e1veis x1, y1, x2 e y2 . O termo correto para o que est\u00e1 acontecendo ali \u00e9 casamento de padr\u00f5es . Tipos de Padr\u00e3o O casamento de padr\u00f5es \u00e9 o processo pelo qual os valores em uma express\u00e3o s\u00e3o decompostos e associados aos elementos de um padr\u00e3o . Em outras palavras, dada uma express\u00e3o e um padr\u00e3o, \u00e9 feita uma tentativa de decomposi\u00e7\u00e3o da express\u00e3o de acordo com o especificado pelo padr\u00e3o. Se a decomposi\u00e7\u00e3o \u00e9 bem sucedida, isto \u00e9, se a express\u00e3o e o padr\u00e3o tem exatamente o mesmo tipo e se constantes especificadas no padr\u00e3o tem o mesmo valor na mesma posi\u00e7\u00e3o da express\u00e3o, ent\u00e3o o casamento \u00e9 bem sucedido ; caso contr\u00e1rio, o casamento fracassa . \u00c9 mais f\u00e1cil entender a descri\u00e7\u00e3o de casamento de padr\u00f5es acima usando exemplos. Para isso, vamos dividir os padr\u00f5es em alguns tipos e analisar exemplos de cada um destes tipos. Constante Considere a seguinte tabela, com suas colunas padr\u00e3o , cujas entradas s\u00e3o constantes , valor , cujas cujas entradas queremos tentar casar com o padr\u00e3o, e resultado , que informa o resultado do casamento. Padr\u00e3o Valor Resultado 10 10 Sucesso 10 20 Fracasso 10 'C' Erro True False Fracasso False False Sucesso Para cada linha, imagine uma fun\u00e7\u00e3o definida como a seguir, mas onde o s\u00edmbolo \u2588 \u00e9 substitu\u00eddo pelo padr\u00e3o 1 minhaFun\u00e7\u00e3o \u2588 = \"Sucesso!\" e que voc\u00ea esteja invocando a fun\u00e7\u00e3o no ghci assim como a seguir, mas onde o s\u00edmbolo \u2593 \u00e9 substitu\u00eddo pelo valor. 1 Prelude > minhaFun\u00e7\u00e3o \u2593 Por exemplo, para a primeira linha, a fun\u00e7\u00e3o fica assim 1 minhaFun\u00e7\u00e3o 10 = \"Sucesso!\" e a invoca\u00e7\u00e3o fica assim. 1 Prelude > minhaFun\u00e7\u00e3o 10 Quando a invoca\u00e7\u00e3o \u00e9 feita, o ghci pega o valor passado, 10, e tenta cas\u00e1-lo com o padr\u00e3o especificado na defini\u00e7\u00e3o de minhaFun\u00e7\u00e3o, 10. Neste caso, h\u00e1 um casamento entre o valor e o padr\u00e3o. 1 2 * Main > minhaFuncao 10 \"Deu certo\" J\u00e1 para a segunda linha, n\u00e3o h\u00e1 um casamento, pois o valor 10 n\u00e3o pode ser decomposto como a constante 20, e o ghci reclama com um erro que n\u00e3o vem ao caso agora. 1 2 * Main > minhaFuncao 20 \"*** Exception: scratch.hs:87:1-28: Non-exhaustive patterns in function minhaFuncao Vari\u00e1vel Se em vez de constantes a coluna padr\u00e3o tivesse como elementos uma vari\u00e1vel, ent\u00e3o o casamento sempre seria bem sucedido. Neste caso, a coluna associa\u00e7\u00f5es 1 mostra quais os valores associados \u00e0 cada vari\u00e1vel do padr\u00e3o. Padr\u00e3o Valor Resultado Associa\u00e7\u00e3o x 10 Sucesso x = 10 x 20 Sucesso x = 20 x 'C' Sucesso x = 'C' x False Sucesso x = False x (1,2,3) Sucesso x = (1,2,3) Curinga Como j\u00e1 mencionado antes, _ na defini\u00e7\u00e3o de uma fun\u00e7\u00e3o funciona como uma vari\u00e1vel, mas cujo valor \u00e9 descartado, isto \u00e9, n\u00e3o \u00e9 associado a uma vari\u00e1vel. Isto \u00e9 na verdade um casamento em que o padr\u00e3o \u00e9 um curinga , que \u00e9 sempre bem sucedido mas que n\u00e3o gera uma associa\u00e7\u00e3o. Padr\u00e3o Valor Resultado _ 10 Sucesso _ 20 Sucesso _ 'C' Sucesso _ False Sucesso _ (1,2,3) Sucesso Tupla Como demonstrado no exemplo da fun\u00e7\u00e3o soma2v , tuplas podem ser usados como padr\u00e3o, permitindo decompor uma tupla usada como valor. O casamento de tuplas no valor e no padr\u00e3o pode levar aos seguintes resultados, observando que o casamento de padr\u00f5es \u00e9 aplicado recursivamente em cada elemento da tupla. Sucesso se a tupla padr\u00e3o tiver a mesma aridade que a tupla valores e cada elemento da tupla padr\u00e3o casa com o elemento correspondente da tupla valor. Fracasso se a tupla padr\u00e3o tiver a mesma aridade que a tupla valore e algum elemento da tupla padr\u00e3o n\u00e3o casa com o elemento correspondente da tupla valor. Resulta em um erro de tipo se a tupla de padr\u00f5es n\u00e3o tiver a mesma aridade que a tupla de valores ou algum elemento da tupla de padr\u00f5es resultar um erro de tipo no casamento com o elemento correspondente da tupla de valores. Padr\u00e3o Valor Resultado Associa\u00e7\u00e3o (x,y) (1,2) Sucesso x = 1 e y = 2 (1,y) (1,2) Sucesso y = 2 (1,y) (2,2) Fracasso (_,y) (1,2) Sucesso y = 2 (_,y) (10,2) Sucesso y = 2 ('X',y) ('X',2) Sucesso y = 2 (x,y) (1,(2,3)) Sucesso x = 1; y = (2,3) (_, (_,y)) (1,(2,3)) Sucesso y = 3 (x,y) (1,(2,3),3) Erro de tipo (1,y) ('x',(2,3)) Erro de tipo x (1,2) Sucesso x = (1,2) (x,y) 1 Erro de tipo Listas Por completude, precisamos mencionar que o casamento funciona tamb\u00e9m para listas, mas deixaremos para mais tarde esta discuss\u00e3o, quando nos focarmos em listas. Mais de um padr\u00e3o Nos exemplos vistos nas tabelas, temos sempre um valor e um padr\u00e3o, mas fun\u00e7\u00f5es podem ter diversos par\u00e2metros. Neste caso, o casamento de padr\u00f5es acontece para cada um dos par\u00e2metros passados na invoca\u00e7\u00e3o da fun\u00e7\u00e3o, da esquerda para a direita. Por exemplo, considerando a seguinte defini\u00e7\u00e3o 1 minhaFun\u00e7\u00e3o'' ( a , b ) (( c , d ), _ , f ) g = a + b + c + d + f + fst g + snd g invoca\u00e7\u00e3o 1 2 * Main > minhaFun\u00e7\u00e3o'' ( 1 , 2 ) (( 3 , 4 ), 5 , 6 ) ( 7 , 8 ) 31 Isto \u00e9, temos as seguintes associa\u00e7\u00f5es a = 1, b = 2, c = 3, d = 4, f = 6, g = (7,8) . Defini\u00e7\u00e3o de Fun\u00e7\u00f5es Al\u00e9m de decompor os par\u00e2metros passados para um fun\u00e7\u00e3o e como mencionado anteriormente , casamento de padr\u00f5es pode ser usado na defini\u00e7\u00e3o de fun\u00e7\u00f5es para simplificar testes via if-then-else e guardas nos par\u00e2metros da fun\u00e7\u00e3o. Neste caso, a fun\u00e7\u00e3o \u00e9 definida como uma sequ\u00eancia de equa\u00e7\u00f5es em que s\u00e3o feitas tentativas sucessivas de casamento de padr\u00f5es, na ordem das defini\u00e7\u00f5es. O resultado da invoca\u00e7\u00e3o da fun\u00e7\u00e3o \u00e9 dado pela primeira equa\u00e7\u00e3o em que houver um casamento bem sucedido e todas as guardas forem satisfeitas. Se ao final n\u00e3o houver casamento ou se as guardas n\u00e3o forem satisfeitas, ocorre um erro de execu\u00e7\u00e3o . Para come\u00e7ar, vejamos uma defini\u00e7\u00e3o sem guardas, revisitando a fun\u00e7\u00e3o nomeMes . Usando casamento de padr\u00f5es constantes, ela ficaria assim: 1 2 3 4 5 6 7 8 9 10 11 12 nomeMes 1 = \"JAN\" nomeMes 2 = \"FEB\" nomeMes 3 = \"ABR\" nomeMes 4 = \"MAR\" nomeMes 5 = \"MAI\" nomeMes 6 = \"JUN\" nomeMes 7 = \"JUL\" nomeMes 8 = \"AGO\" nomeMes 9 = \"SET\" nomeMes 10 = \"OUT\" nomeMes 11 = \"NOV\" nomeMes 12 = \"DEZ\" Esta fun\u00e7\u00e3o funciona especificamente para valores na faixa [1,12] e retornar\u00e1 um erro para qualquer valor fora da mesma. 1 2 * Main > nomeMes 13 \"*** Exception: scratch.hs:(112,1)-(123,18): Non-exhaustive patterns in function nomeMes \u00c9 poss\u00edvel usar uma defini\u00e7\u00e3o gen\u00e9rica catch-all para casar com valores n\u00e3o espec\u00edficos usando um padr\u00e3o vari\u00e1vel. Por exemplo, a defini\u00e7\u00e3o da fun\u00e7\u00e3o fatorial tem um tratamento especial para 0, via padr\u00e3o constante, e um caso gen\u00e9rico para qualquer outro n\u00famero, via padr\u00e3o vari\u00e1vel. 1 2 fatorial 0 = 1 fatorial n = n * fatorial ( n - 1 ) Mas esta defini\u00e7\u00e3o de fatorial tem um problema, que aparece ao se tentar calcular o fatorial de n\u00fameros negativos, que s\u00e3o indefinidos. Neste caso, precisamos impedir que n\u00fameros negativos sejam aceitos pela fun\u00e7\u00e3o, lan\u00e7ando erros. 1 2 3 4 5 6 7 8 9 fatorial 0 = 1 fatorial n | n > 0 = n * fatorial ( n - 1 ) | otherwise = error \"Indefinido\" fatorial' 0 = 1 fatorial' n | n > 0 = n * fat ( n - 1 ) fatorial' _ = error \"Indefinido\" Com o seguinte resultado 1 2 * Main > fat ( - 1 ) *** Exception: Indefinido O exemplo seguinte mostra o uso de padr\u00f5es curinga, constantes e vari\u00e1veis, combinados com guardas e, um caso especial, gerando um erro. Voc\u00ea consegue determinar o que a fun\u00e7\u00e3o faz? 1 2 3 4 5 6 7 8 9 10 11 pr\u00f3ximos3 :: Int -> Char -> ( Int , Int , Int ) pr\u00f3ximos3 0 _ = ( - 1 , 0 , 1 ) pr\u00f3ximos3 n 'd' | n > 0 = ( n - 1 , n - 2 , n - 3 ) | n < 0 = ( n + 1 , n + 2 , n + 3 ) pr\u00f3ximos3 n 'a' | n < 0 = ( n - 1 , n - 2 , n - 3 ) | n > 0 = ( n + 1 , n + 2 , n + 3 ) pr\u00f3ximos3 _ _ = error \"Use d ou a\" Vejamos outros exemplos, do m\u00f3dulo prelude do Haskell. Primeiro, a fun\u00e7\u00e3o not , que nega o valor passado. 1 2 3 not :: Bool -> Bool not True = False not False = True Vejamos agora diferentes defini\u00e7\u00f5es do operador && . Observe que como o operador \u00e9 infixo, a defini\u00e7\u00e3o das equa\u00e7\u00f5es segue esta nota\u00e7\u00e3o, mesmo que a defini\u00e7\u00e3o do prot\u00f3tipo n\u00e3o siga. A primeira defini\u00e7\u00e3o usa somente constantes como padr\u00e3o. Esta defini\u00e7\u00e3o est\u00e1 correta, mas \u00e9 mais complexa do que o necess\u00e1rio, j\u00e1 que somente a primeira equa\u00e7\u00e3o resulta em True . 1 2 3 4 5 ( && ) Bool -> Bool -> Bool True && True = True True && False = False False && True = False False && False = False Uma vers\u00e3o simplificada pelo uso de padr\u00f5es curinga, seria a seguinte. Observe como ela \u00e9 mais leg\u00edvel. 1 2 3 ( && ) Bool -> Bool -> Bool True && True = True _ && _ = False Finalmente, uma terceira vers\u00e3o que usa um padr\u00e3o vari\u00e1vel e um curinga tamb\u00e9m poderia ser usada. 1 2 3 ( && ) Bool -> Bool -> Bool True && b = b False && _ = False Como exemplo do casamento em padr\u00f5es em tuplas, relembre as defini\u00e7\u00f5es de fst e snd . 1 2 3 fst ( x , _ ) = x snd ( _ , y ) = y Tamb\u00e9m podemos pensar no tipo Pessoa e fun\u00e7\u00f5es associadas, definidos anteriormente. Neste caso, como ficaria uma fun\u00e7\u00e3o que extra\u00edsse apenas o sobrenome de uma pessoa? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Nome = ( String , String , String ) type Telefone = ( String , String ) type CPF = String type Endere\u00e7o = ( String , String , String ) type Pessoa = ( Nome , Telefone , CPF , Endere\u00e7o ) fazPessoa :: Nome -> Telefone -> CPF -> Endere\u00e7o -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> Nome pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> Telefone pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone :: Pessoa -> Telefone -> Pessoa trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) Exerc\u00edcio Seguindo os moldes da defini\u00e7\u00e3o do operador && , defina o operador l\u00f3gico ou || de tr\u00eas formas diferentes. Seguindo os moldes da defini\u00e7\u00e3o do operador && , defina o operador l\u00f3gico ou || de tr\u00eas formas diferentes. Defina 3 fun\u00e7\u00f5es, usando if - then - else , guardas e casamento de padr\u00f5es, que calculem os n\u00fameros da s\u00e9rie de Fibonacci, a saber Fib(1) = 1 Fib(2) = 1 Fib(n) = Fib(n-1) + Fib(n-2) Resolu\u00e7\u00e3o 1 2 3 ```hs Surprise! ``` case - of Esta estrutura se assemelha ao switch de linguagens como C e Java, e tem a seguinte sintaxe, onde os padr\u00f5es devem estar perfeitamente alinhados. 1 2 3 case expression of pattern -> result pattern -> result pattern -> result Por exemplo, vamos definir uma fun\u00e7\u00e3o que retorne o nome do m\u00eas, dado o seu n\u00famero. Seria poss\u00edvel escreve esta fun\u00e7\u00e3o com if aninhados, assim. 1 2 3 4 5 6 nome_mes m = if m == 1 then \"JAN\" else if m == 2 then \"FEB\" else if m == 3 then \"MAR\" ... else if m == 11 then \"NOV\" else \"DEZ\" Usando guardas, ficaria assim: 1 2 3 4 5 6 7 nome_mes m | m == 1 = \"JAN\" | m == 2 = \"FEB\" | m == 3 = \"MAR\" ... | m == 11 = \"NOV\" | otherwise \"DEZ\" Usando case - of , a 1 2 3 4 5 6 nomeMes m = case m of 1 -> \"JAN\" m of 2 -> \"FEB\" m of 3 -> \"MAR\" ... m of 11 -> \"NOV\" m of 12 -> \"DEZ\" \u00c9 importante notar que \u00e9 poss\u00edvel aninhar case-of . A fun\u00e7\u00e3o pr\u00f3ximos3 poderia ser reescrita assim. Observe o alinhamento dentro do segundo case. 1 2 3 4 5 pr\u00f3ximos3''' :: Int -> Char -> ( Int , Int , Int ) pr\u00f3ximos3''' n dir = case n of 0 -> ( - 1 , 0 , 1 ) _ -> case dir of 'd' -> if n > 0 then ( n - 1 , n - 2 , n - 3 ) else ( n + 1 , n + 2 , n + 3 ) 'a' -> if n < 0 then ( n - 1 , n - 2 , n - 3 ) else ( n + 1 , n + 2 , n + 3 ) _ -> error \"Use d ou a\" O termo em ingl\u00eas \u00e9 bind . \u21a9","title":"Padr\u00f5es"},{"location":"pattern_matching/#casamento-de-padroes","text":"Quando especificamos a lista de par\u00e2metros formais que uma fun\u00e7\u00e3o recebe, estamos dizendo ao compilador que os par\u00e2metros passados na invoca\u00e7\u00e3o da fun\u00e7\u00e3o devem ser associados aos par\u00e2metros formais. Por exemplo, considere a seguinte defini\u00e7\u00e3o de uma fun\u00e7\u00e3o que soma dois pontos 1 soma2n x y = x + y e sua invoca\u00e7\u00e3o. 1 2 > soma2n 3 4 7 Quando a invoca\u00e7\u00e3o acontece, o valor 3 \u00e9 associado a x e 4 a y . O mesmo acontece para qualquer tipo de par\u00e2metro passado, mesmo tuplas e, como veremos depois, listas. Por exemplo, considere a soma de dois pontos em um espa\u00e7o bidimensional, em que pontos s\u00e3o especificados como tuplas de aridade 2. 1 2 3 4 type Ponto = ( Integer , Integer ) soma2v :: Ponto -> Ponto -> Ponto soma2v ponto1 ponto2 = ( fst ponto1 + fst ponto2 , snd ponto1 + snd ponto2 ) Um dos problemas deste c\u00f3digo \u00e9 a necessidade de usar fst e snd para extrair os componentes das tuplas. Mas como vimos na se\u00e7\u00e3o sobre tuplas , \u00e9 poss\u00edvel associar as componentes das tuplas diretamente a vari\u00e1veis. Por exemplo, considere a defini\u00e7\u00e3o alternativa para soma2v . 1 2 3 4 type Ponto = ( Integer , Integer ) soma2v :: Ponto -> Ponto -> Ponto soma2v ( x1 , y1 ) ( x2 , y2 ) = ( x1 + x2 , y1 + y2 ) Observe que, na linha 4, as coordenadas dos pontos passados s\u00e3o associados \u00e0s vari\u00e1veis x1, y1, x2 e y2 . O termo correto para o que est\u00e1 acontecendo ali \u00e9 casamento de padr\u00f5es .","title":"Casamento de Padr\u00f5es"},{"location":"pattern_matching/#tipos-de-padrao","text":"O casamento de padr\u00f5es \u00e9 o processo pelo qual os valores em uma express\u00e3o s\u00e3o decompostos e associados aos elementos de um padr\u00e3o . Em outras palavras, dada uma express\u00e3o e um padr\u00e3o, \u00e9 feita uma tentativa de decomposi\u00e7\u00e3o da express\u00e3o de acordo com o especificado pelo padr\u00e3o. Se a decomposi\u00e7\u00e3o \u00e9 bem sucedida, isto \u00e9, se a express\u00e3o e o padr\u00e3o tem exatamente o mesmo tipo e se constantes especificadas no padr\u00e3o tem o mesmo valor na mesma posi\u00e7\u00e3o da express\u00e3o, ent\u00e3o o casamento \u00e9 bem sucedido ; caso contr\u00e1rio, o casamento fracassa . \u00c9 mais f\u00e1cil entender a descri\u00e7\u00e3o de casamento de padr\u00f5es acima usando exemplos. Para isso, vamos dividir os padr\u00f5es em alguns tipos e analisar exemplos de cada um destes tipos.","title":"Tipos de Padr\u00e3o"},{"location":"pattern_matching/#definicao-de-funcoes","text":"Al\u00e9m de decompor os par\u00e2metros passados para um fun\u00e7\u00e3o e como mencionado anteriormente , casamento de padr\u00f5es pode ser usado na defini\u00e7\u00e3o de fun\u00e7\u00f5es para simplificar testes via if-then-else e guardas nos par\u00e2metros da fun\u00e7\u00e3o. Neste caso, a fun\u00e7\u00e3o \u00e9 definida como uma sequ\u00eancia de equa\u00e7\u00f5es em que s\u00e3o feitas tentativas sucessivas de casamento de padr\u00f5es, na ordem das defini\u00e7\u00f5es. O resultado da invoca\u00e7\u00e3o da fun\u00e7\u00e3o \u00e9 dado pela primeira equa\u00e7\u00e3o em que houver um casamento bem sucedido e todas as guardas forem satisfeitas. Se ao final n\u00e3o houver casamento ou se as guardas n\u00e3o forem satisfeitas, ocorre um erro de execu\u00e7\u00e3o . Para come\u00e7ar, vejamos uma defini\u00e7\u00e3o sem guardas, revisitando a fun\u00e7\u00e3o nomeMes . Usando casamento de padr\u00f5es constantes, ela ficaria assim: 1 2 3 4 5 6 7 8 9 10 11 12 nomeMes 1 = \"JAN\" nomeMes 2 = \"FEB\" nomeMes 3 = \"ABR\" nomeMes 4 = \"MAR\" nomeMes 5 = \"MAI\" nomeMes 6 = \"JUN\" nomeMes 7 = \"JUL\" nomeMes 8 = \"AGO\" nomeMes 9 = \"SET\" nomeMes 10 = \"OUT\" nomeMes 11 = \"NOV\" nomeMes 12 = \"DEZ\" Esta fun\u00e7\u00e3o funciona especificamente para valores na faixa [1,12] e retornar\u00e1 um erro para qualquer valor fora da mesma. 1 2 * Main > nomeMes 13 \"*** Exception: scratch.hs:(112,1)-(123,18): Non-exhaustive patterns in function nomeMes \u00c9 poss\u00edvel usar uma defini\u00e7\u00e3o gen\u00e9rica catch-all para casar com valores n\u00e3o espec\u00edficos usando um padr\u00e3o vari\u00e1vel. Por exemplo, a defini\u00e7\u00e3o da fun\u00e7\u00e3o fatorial tem um tratamento especial para 0, via padr\u00e3o constante, e um caso gen\u00e9rico para qualquer outro n\u00famero, via padr\u00e3o vari\u00e1vel. 1 2 fatorial 0 = 1 fatorial n = n * fatorial ( n - 1 ) Mas esta defini\u00e7\u00e3o de fatorial tem um problema, que aparece ao se tentar calcular o fatorial de n\u00fameros negativos, que s\u00e3o indefinidos. Neste caso, precisamos impedir que n\u00fameros negativos sejam aceitos pela fun\u00e7\u00e3o, lan\u00e7ando erros. 1 2 3 4 5 6 7 8 9 fatorial 0 = 1 fatorial n | n > 0 = n * fatorial ( n - 1 ) | otherwise = error \"Indefinido\" fatorial' 0 = 1 fatorial' n | n > 0 = n * fat ( n - 1 ) fatorial' _ = error \"Indefinido\" Com o seguinte resultado 1 2 * Main > fat ( - 1 ) *** Exception: Indefinido O exemplo seguinte mostra o uso de padr\u00f5es curinga, constantes e vari\u00e1veis, combinados com guardas e, um caso especial, gerando um erro. Voc\u00ea consegue determinar o que a fun\u00e7\u00e3o faz? 1 2 3 4 5 6 7 8 9 10 11 pr\u00f3ximos3 :: Int -> Char -> ( Int , Int , Int ) pr\u00f3ximos3 0 _ = ( - 1 , 0 , 1 ) pr\u00f3ximos3 n 'd' | n > 0 = ( n - 1 , n - 2 , n - 3 ) | n < 0 = ( n + 1 , n + 2 , n + 3 ) pr\u00f3ximos3 n 'a' | n < 0 = ( n - 1 , n - 2 , n - 3 ) | n > 0 = ( n + 1 , n + 2 , n + 3 ) pr\u00f3ximos3 _ _ = error \"Use d ou a\" Vejamos outros exemplos, do m\u00f3dulo prelude do Haskell. Primeiro, a fun\u00e7\u00e3o not , que nega o valor passado. 1 2 3 not :: Bool -> Bool not True = False not False = True Vejamos agora diferentes defini\u00e7\u00f5es do operador && . Observe que como o operador \u00e9 infixo, a defini\u00e7\u00e3o das equa\u00e7\u00f5es segue esta nota\u00e7\u00e3o, mesmo que a defini\u00e7\u00e3o do prot\u00f3tipo n\u00e3o siga. A primeira defini\u00e7\u00e3o usa somente constantes como padr\u00e3o. Esta defini\u00e7\u00e3o est\u00e1 correta, mas \u00e9 mais complexa do que o necess\u00e1rio, j\u00e1 que somente a primeira equa\u00e7\u00e3o resulta em True . 1 2 3 4 5 ( && ) Bool -> Bool -> Bool True && True = True True && False = False False && True = False False && False = False Uma vers\u00e3o simplificada pelo uso de padr\u00f5es curinga, seria a seguinte. Observe como ela \u00e9 mais leg\u00edvel. 1 2 3 ( && ) Bool -> Bool -> Bool True && True = True _ && _ = False Finalmente, uma terceira vers\u00e3o que usa um padr\u00e3o vari\u00e1vel e um curinga tamb\u00e9m poderia ser usada. 1 2 3 ( && ) Bool -> Bool -> Bool True && b = b False && _ = False Como exemplo do casamento em padr\u00f5es em tuplas, relembre as defini\u00e7\u00f5es de fst e snd . 1 2 3 fst ( x , _ ) = x snd ( _ , y ) = y Tamb\u00e9m podemos pensar no tipo Pessoa e fun\u00e7\u00f5es associadas, definidos anteriormente. Neste caso, como ficaria uma fun\u00e7\u00e3o que extra\u00edsse apenas o sobrenome de uma pessoa? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Nome = ( String , String , String ) type Telefone = ( String , String ) type CPF = String type Endere\u00e7o = ( String , String , String ) type Pessoa = ( Nome , Telefone , CPF , Endere\u00e7o ) fazPessoa :: Nome -> Telefone -> CPF -> Endere\u00e7o -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> Nome pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> Telefone pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone :: Pessoa -> Telefone -> Pessoa trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) Exerc\u00edcio Seguindo os moldes da defini\u00e7\u00e3o do operador && , defina o operador l\u00f3gico ou || de tr\u00eas formas diferentes. Seguindo os moldes da defini\u00e7\u00e3o do operador && , defina o operador l\u00f3gico ou || de tr\u00eas formas diferentes. Defina 3 fun\u00e7\u00f5es, usando if - then - else , guardas e casamento de padr\u00f5es, que calculem os n\u00fameros da s\u00e9rie de Fibonacci, a saber Fib(1) = 1 Fib(2) = 1 Fib(n) = Fib(n-1) + Fib(n-2) Resolu\u00e7\u00e3o 1 2 3 ```hs Surprise! ```","title":"Defini\u00e7\u00e3o de Fun\u00e7\u00f5es"},{"location":"preface/","text":"Pref\u00e1cio O paradigma de funcional \u00e9 um dos muitos paradigmas de programa\u00e7\u00e3o dispon\u00edveis e, uma vez que voc\u00ea tenha sido \"contaminado\" pelos outros, certamente n\u00e3o \u00e9 o mais simples de se entender. Ainda assim, \u00e9 um paradigma que deve ser estudado pois seus pontos fortes tem sido incorporados cada vez mais frequentemente em frameworks e linguagens n\u00e3o necessariamente reconhecidos como funcionais. Por isso, neste curso estudaremos o paradigma funcional de uma forma pr\u00e1tica, tentando sempre que poss\u00edvel mostrar diversas aplica\u00e7\u00f5es das ideias apresentadas no mundo da programa\u00e7\u00e3o moderna. Tamb\u00e9m ser\u00e1 foco deste curso, destacar e demonstrar como o uso do paradigma funcional traz vantagens no desenvolvimento de sistemas paralelos e distribu\u00eddos. Agradecimentos Antes de come\u00e7armos nosso estudo, deixo aqui o meu agradecimento aos professores que forneceram o material sobre o qual estas notas de aula s\u00e3o baseadas, Profa. Gina Maira B. Oliveira, Profa. Maria Adriana Vidigal de Lima, e Prof. Henrique Fernandes, da Faculdade de Computa\u00e7\u00e3o da UFU. Conven\u00e7\u00f5es Neste documento, usamos diversos recursos visuais com diferentes prop\u00f3sitos. it\u00e1lico indica termos em outras l\u00ednguas, como framework ou middleware . Alguns termos, contudo, s\u00e3o t\u00e3o corriqueiramente usados que me escapam quando escrevendo e acabam n\u00e3o grafados corretamente. negrito indica a introdu\u00e7\u00e3o de termos e conceitos importantes, como escalabilidade e falha . Apontadores indicam um s\u00edtio relacionado ao termo, por exemplo, como criar um reposit\u00f3rio no Github , e cuja leitura \u00e9 sugerida ao final da aula. Notas de rodap\u00e9, indicam uma observa\u00e7\u00e3o importante sobre o que est\u00e1 sendo apresentado, cuja leitura \u00e9 sugerida ao final do par\u00e1grafo. 1 Estas notas incluem referenciais te\u00f3ricos importantes, com detalhes da publica\u00e7\u00e3o e apontadores para onde a publica\u00e7\u00e3o pode ser lida. Imagens n\u00e3o autorais s\u00e3o tamb\u00e9m apontadores para onde s\u00e3o encontradas e tem como texto alternativo as informa\u00e7\u00f5es da autoria. Caixas alinhadas \u00e0 esquerda s\u00e3o usadas para v\u00e1rias finalidades. Por exemplo, para apresentar exerc\u00edcios, destacar especifica\u00e7\u00f5es, apontar tarefas a serem executas por mim. Os diversos usos s\u00e3o indicados nos \u00edcones e cores das caixas. Exerc\u00edcio Isso \u00e9 um exerc\u00edcio! Resposta Esta \u00e9 a resposta do exerc\u00edcio. Resumo Elementos visuais Aviso! Este material est\u00e1 em constante evolu\u00e7\u00e3o. Caixas alinhadas \u00e0 direita podem ser vistas como um sum\u00e1rio executivo do que est\u00e1 sendo apresentado no texto adjacente. Exemplo de nota de rodap\u00e9. \u21a9","title":"Pref\u00e1cio"},{"location":"preface/#prefacio","text":"O paradigma de funcional \u00e9 um dos muitos paradigmas de programa\u00e7\u00e3o dispon\u00edveis e, uma vez que voc\u00ea tenha sido \"contaminado\" pelos outros, certamente n\u00e3o \u00e9 o mais simples de se entender. Ainda assim, \u00e9 um paradigma que deve ser estudado pois seus pontos fortes tem sido incorporados cada vez mais frequentemente em frameworks e linguagens n\u00e3o necessariamente reconhecidos como funcionais. Por isso, neste curso estudaremos o paradigma funcional de uma forma pr\u00e1tica, tentando sempre que poss\u00edvel mostrar diversas aplica\u00e7\u00f5es das ideias apresentadas no mundo da programa\u00e7\u00e3o moderna. Tamb\u00e9m ser\u00e1 foco deste curso, destacar e demonstrar como o uso do paradigma funcional traz vantagens no desenvolvimento de sistemas paralelos e distribu\u00eddos.","title":"Pref\u00e1cio"},{"location":"preface/#agradecimentos","text":"Antes de come\u00e7armos nosso estudo, deixo aqui o meu agradecimento aos professores que forneceram o material sobre o qual estas notas de aula s\u00e3o baseadas, Profa. Gina Maira B. Oliveira, Profa. Maria Adriana Vidigal de Lima, e Prof. Henrique Fernandes, da Faculdade de Computa\u00e7\u00e3o da UFU.","title":"Agradecimentos"},{"location":"preface/#convencoes","text":"Neste documento, usamos diversos recursos visuais com diferentes prop\u00f3sitos. it\u00e1lico indica termos em outras l\u00ednguas, como framework ou middleware . Alguns termos, contudo, s\u00e3o t\u00e3o corriqueiramente usados que me escapam quando escrevendo e acabam n\u00e3o grafados corretamente. negrito indica a introdu\u00e7\u00e3o de termos e conceitos importantes, como escalabilidade e falha . Apontadores indicam um s\u00edtio relacionado ao termo, por exemplo, como criar um reposit\u00f3rio no Github , e cuja leitura \u00e9 sugerida ao final da aula. Notas de rodap\u00e9, indicam uma observa\u00e7\u00e3o importante sobre o que est\u00e1 sendo apresentado, cuja leitura \u00e9 sugerida ao final do par\u00e1grafo. 1 Estas notas incluem referenciais te\u00f3ricos importantes, com detalhes da publica\u00e7\u00e3o e apontadores para onde a publica\u00e7\u00e3o pode ser lida. Imagens n\u00e3o autorais s\u00e3o tamb\u00e9m apontadores para onde s\u00e3o encontradas e tem como texto alternativo as informa\u00e7\u00f5es da autoria. Caixas alinhadas \u00e0 esquerda s\u00e3o usadas para v\u00e1rias finalidades. Por exemplo, para apresentar exerc\u00edcios, destacar especifica\u00e7\u00f5es, apontar tarefas a serem executas por mim. Os diversos usos s\u00e3o indicados nos \u00edcones e cores das caixas. Exerc\u00edcio Isso \u00e9 um exerc\u00edcio! Resposta Esta \u00e9 a resposta do exerc\u00edcio. Resumo Elementos visuais Aviso! Este material est\u00e1 em constante evolu\u00e7\u00e3o. Caixas alinhadas \u00e0 direita podem ser vistas como um sum\u00e1rio executivo do que est\u00e1 sendo apresentado no texto adjacente. Exemplo de nota de rodap\u00e9. \u21a9","title":"Conven\u00e7\u00f5es"},{"location":"project/","text":"Nada melhor que um bom projeto para fixar e colocar \u00e0 prova o que estamos aprendendo, e nada melhor que unir o \u00fatil ao agrad\u00e1vel na hora de escolher um projeto. Neste semestre, o projeto que desenvolver\u00e3o \u00e9 um clone de um cl\u00e1ssico dos jogos de computadores, Bomberman! Bom, n\u00e3o exatamente um clone, mas os rudimentos de um clone. Ainda assim, o projeto n\u00e3o \u00e9 trivial e por isso vamos divid\u00ed-lo em etapas para gerenciar a complexidade. De forma geral, podemos dividir o projeto em duas etapas: Etapa 1 Estruturas de dados para representa\u00e7\u00e3o dos elementos do jogo usando listas Uso de tipos primitivos para representa\u00e7\u00e3o do estado e dos elementos do jogo. Uso de type Fun\u00e7\u00f5es de manipula\u00e7\u00e3o das estruturas Etapa 2 Uso de tipos definidos pelo usu\u00e1rio para representa\u00e7\u00e3o do estado e dos elementos do jogo. Uso de data Tipos alg\u00e9bricos Fun\u00e7\u00f5es de manipula\u00e7\u00e3o das estruturas Visualiza\u00e7\u00e3o do tabuleiro Movimenta\u00e7\u00e3o de (pelo menos) um bomberman pelo tabuleiro usando o teclado Etapa 1 Um tabuleiro de bomberman pode ser visto como uma matriz em que cada c\u00e9lula \u00e9 uma pilha de elementos. Em nosso prot\u00f3tipo, os seguintes elementos podem estar presentes na c\u00e9lula: grama presente_patins presente_arremesso bomba jogador_X Algumas regras devem ser respeitadas pela pilha, onde \"sobre\" quer dizer imediatamente subsequente acima na pilha. uma pilha vazia \u00e9 um buraco no tabuleiro grama s\u00f3 pode estar na base da pilha presente s\u00f3 pode estar sobre grama pedra s\u00f3 pode estar na base da pilha, sobre grama ou sobre presente bomba s\u00f3 pode estar sobre grama jogador s\u00f3 pode estar sobre grama Para representar a matriz do tabuleiro, usaremos uma tupla de tuplas. Assim, defina as seguintes estruturas de dados. Tabuleiro \u00e9 uma tupla com 8 Linha. Linha \u00e9 uma tupla com 8 C\u00e9lula. C\u00e9lula \u00e9 uma pilha com 4 Item Use uma lista para representar a pilha Para cada jogador, voc\u00ea precisa manter algumas informa\u00e7\u00f5es extra como identificador (o X que aparece no Item jogador_X) localiza\u00e7\u00e3o - \u00e9 uma tupla com coordenadas X e Y do tipo Int que representam a linha e coluna em o item jogador_X correspondente est\u00e1. dire\u00e7\u00e3o - \u00e9 um caractere que indica para onde on jogador est\u00e1 olhando. 'N', 'S', 'L' e 'O' capacidades - \u00e9 uma tupla com 3 elementos com um dos seguintes valores, onde a, b e c s\u00e3o Int (Patins,a) (Bomba,b) (Arremesso,c) O jogo s\u00f3 tem gra\u00e7a se tiver alguma coisa acontecendo nele. Nesta primeira etapa, voc\u00ea desenvolver\u00e1 as fun\u00e7\u00f5es que permitir\u00e3o criar e manipular os elementos do jogo, de acordo com algumas regras. Cria\u00e7\u00e3o de um tabuleiro Movimenta\u00e7\u00e3o de um jogador em qualquer dos sentidos Deslocamento Jogador s\u00f3 pode se deslocar para c\u00e9lula adjacente que n\u00e3o tenha pedra ou bomba Pode ser imposs\u00edvel ao jogador se delocar Ao se deslocar para uma c\u00e9lula vazia, cai no buraco Ao se deslocar para uma c\u00e9lula com um presente, o coleta Coleta de presente Ao coletar um presente, incrementa a posi\u00e7\u00e3o correspondente ao presente nas suas capacidades Arremesso Teste de capacidade Se estiver adjacente, olhando para uma bomba, e tiver a capacidade \"arremesso\", o jogador arremessa a bomba uma dist\u00e2ncia proporcional \u00e0 capacidade. Teste de dire\u00e7\u00e3o Explos\u00e3o Dire\u00e7\u00e3o Capacidade Elimina\u00e7\u00e3o de presentes Elimina\u00e7\u00e3o de pedra Elimina\u00e7\u00e3o de jogador Detec\u00e7\u00e3o de fim de jogo","title":"Projeto"},{"location":"project/#etapa-1","text":"Um tabuleiro de bomberman pode ser visto como uma matriz em que cada c\u00e9lula \u00e9 uma pilha de elementos. Em nosso prot\u00f3tipo, os seguintes elementos podem estar presentes na c\u00e9lula: grama presente_patins presente_arremesso bomba jogador_X Algumas regras devem ser respeitadas pela pilha, onde \"sobre\" quer dizer imediatamente subsequente acima na pilha. uma pilha vazia \u00e9 um buraco no tabuleiro grama s\u00f3 pode estar na base da pilha presente s\u00f3 pode estar sobre grama pedra s\u00f3 pode estar na base da pilha, sobre grama ou sobre presente bomba s\u00f3 pode estar sobre grama jogador s\u00f3 pode estar sobre grama Para representar a matriz do tabuleiro, usaremos uma tupla de tuplas. Assim, defina as seguintes estruturas de dados. Tabuleiro \u00e9 uma tupla com 8 Linha. Linha \u00e9 uma tupla com 8 C\u00e9lula. C\u00e9lula \u00e9 uma pilha com 4 Item Use uma lista para representar a pilha Para cada jogador, voc\u00ea precisa manter algumas informa\u00e7\u00f5es extra como identificador (o X que aparece no Item jogador_X) localiza\u00e7\u00e3o - \u00e9 uma tupla com coordenadas X e Y do tipo Int que representam a linha e coluna em o item jogador_X correspondente est\u00e1. dire\u00e7\u00e3o - \u00e9 um caractere que indica para onde on jogador est\u00e1 olhando. 'N', 'S', 'L' e 'O' capacidades - \u00e9 uma tupla com 3 elementos com um dos seguintes valores, onde a, b e c s\u00e3o Int (Patins,a) (Bomba,b) (Arremesso,c) O jogo s\u00f3 tem gra\u00e7a se tiver alguma coisa acontecendo nele. Nesta primeira etapa, voc\u00ea desenvolver\u00e1 as fun\u00e7\u00f5es que permitir\u00e3o criar e manipular os elementos do jogo, de acordo com algumas regras. Cria\u00e7\u00e3o de um tabuleiro Movimenta\u00e7\u00e3o de um jogador em qualquer dos sentidos Deslocamento Jogador s\u00f3 pode se deslocar para c\u00e9lula adjacente que n\u00e3o tenha pedra ou bomba Pode ser imposs\u00edvel ao jogador se delocar Ao se deslocar para uma c\u00e9lula vazia, cai no buraco Ao se deslocar para uma c\u00e9lula com um presente, o coleta Coleta de presente Ao coletar um presente, incrementa a posi\u00e7\u00e3o correspondente ao presente nas suas capacidades Arremesso Teste de capacidade Se estiver adjacente, olhando para uma bomba, e tiver a capacidade \"arremesso\", o jogador arremessa a bomba uma dist\u00e2ncia proporcional \u00e0 capacidade. Teste de dire\u00e7\u00e3o Explos\u00e3o Dire\u00e7\u00e3o Capacidade Elimina\u00e7\u00e3o de presentes Elimina\u00e7\u00e3o de pedra Elimina\u00e7\u00e3o de jogador Detec\u00e7\u00e3o de fim de jogo","title":"Etapa 1"},{"location":"prova/","text":"Prova. https://haskell.mooc.fi/part1#a-word-about-type-inference-and-polymorphism -- given a sentence, decide whether it is a statement, question or exclamation sentenceType :: String -> String sentenceType sentence = case last sentence of '.' -> \"statement\" '?' -> \"question\" '!' -> \"exclamation\" _ -> \"not a sentence\" -- same function, helper function instead of case-of sentenceType sentence = classify (last sentence) where classify '.' = \"statement\" classify '?' = \"question\" classify '!' = \"exclamation\" classify _ = \"not a sentence\"","title":"Prova"},{"location":"quickcheck/","text":"Agora que nossas fun\u00e7\u00f5es est\u00e3o ficando mais complexas, precisamos gastar um pouco mais de esfor\u00e7o nos certificando de que est\u00e3o corretas. Uma ferramenta que nos ajuda a fazer isso \u00e9 a biblioteca QuickCheck . Para entender como usar a QuickCheck, considere as duas seguintes fun\u00e7\u00f5es. 1 2 3 celsius2fahrenheit c = c * 9 / 5 + 32 fahrenheit2celsius f = ( f - 32 ) * 5 / 9 Elas s\u00e3o obviamente inversas uma da outra, o que quer dizer que se eu aplicar um valor qualquer \u00e0 primeira fun\u00e7\u00e3o e ent\u00e3o aplicar resultado na segunda, eu deveria recuperar o valor original. Por exemplo, se o valor qualquer \u00e9 100, 100 == fahrenheit2celsius ( celsius2fahrenheit 100 ) . Pois a QuickCheck nos permite escrever exatamente este tipo de afirma\u00e7\u00e3o e t\u00ea-la testada automaticamente para um conjunto de valores aleat\u00f3rios. Obviamente, mesmo se o c\u00f3digo passar nos testes gerados pelo QuickCheck, n\u00e3o quer dizer que outros valores n\u00e3o resultariam em erros. Contudo, nossa confian\u00e7a na corretude aumentaria. Para testar as fun\u00e7\u00f5es acima escrever\u00edamos ent\u00e3o a propriedade como uma fun\u00e7\u00e3o que retorna um booleano. A propriedade tem um nome iniciado em prop_ , mas isso \u00e9 apenas uma conven\u00e7\u00e3o. A defini\u00e7\u00e3o recebe como par\u00e2metro um valor c , converte para Celcius e de volta para Fahrenheit, e confere se o valor resultante \u00e9 igual ao valor de entrada. Observe que o resultado da fun\u00e7\u00e3o \u00e9 o resultado da compara\u00e7\u00e3o com o valor inicial, o que \u00e9 equivalente mas muito mais limpo do que fazer um teste do tipo if Condi\u00e7\u00e3o then True else False . 1 prop_C2f2C c = fahrenheit2celsius ( celsius2fahrenheit c ) == c Para usar a biblioteca, precisamos import\u00e1-la, no in\u00edcio do arquivo, com um import Test.QuickCheck . Assim, o arquivo ficar\u00e1 assim. 1 2 3 4 5 6 7 import Test.QuickCheck celsius2fahrenheit c = c * 9 / 5 + 32 fahrenheit2celsius f = ( f - 32 ) * 5 / 9 prop_C2f2C c = fahrenheit2celsius ( celsius2fahrenheit c ) == c Para testar o c\u00f3digo, execute o ghci carregando o QuickCheck. A forma mais simples de faz\u00ea-lo \u00e9 usando stack: stack ghci --package QuickCheck . Agora carregue seu programa, usando :l f2c2f no meu caso e execute o teste 1 2 3 *Main> quickCheck prop_C2f2C *** Failed! Falsified (after 2 tests and 4 shrinks): -0.1 Ooops! O teste falhou para o valor -0.1. Mas por qu\u00ea? Vejamos cada fun\u00e7\u00e3o isoladamente. 1 2 3 4 *Main> celsius2fahrenheit (-0.1) 31.82 *Main> fahrenheit2celsius 31.82 -9.999999999999984e-2 Os valores s\u00e3o pr\u00f3ximos, mas n\u00e3o s\u00e3o iguais, por causa de problemas de arredondamento causados pela imprecis\u00e3o dos tipos utilizados. O problema est\u00e1 no teste, pois \u00e9 imposs\u00edvel para o computador representar certos valores e estes erros de aproxima\u00e7\u00e3o ocorrer\u00e3o. Assim, uma estrat\u00e9gia melhor \u00e9 definir um operador quase igual , para comparar valores com pequenos erros. 1 2 3 4 5 6 7 8 9 10 import Test.QuickCheck celsius2fahrenheit c = c * 9 / 5 + 32 fahrenheit2celsius f = ( f - 32 ) * 5 / 9 prop_C2f2C c = fahrenheit2celsius ( celsius2fahrenheit c ) ~== c l ~== r = abs ( l - r ) < \u03b5 where \u03b5 = 10e-10 Com esta nova defini\u00e7\u00e3o, nosso teste agora passa com sucesso. 1 2 *Main> quickCheck prop_C2f2C +++ OK, passed 100 tests.","title":"Quick, Check!"},{"location":"recursion/","text":"Recursividade Uma fun\u00e7\u00e3o \u00e9 dita recursiva quando ela \u00e9 definida em termos de si mesma . Estas fun\u00e7\u00f5es s\u00e3o muito importantes tanto na matem\u00e1tica, onde s\u00e3o tamb\u00e9m conhecidas como recorr\u00eancias . Por exemplo, vejamos como \u00e9 definido um exemplo recorrentes de fun\u00e7\u00e3o na computa\u00e7\u00e3o ( pun intended ) de forma recursiva, o c\u00e1lculo do fatorial de um n\u00famero. Considere a seguinte defini\u00e7\u00e3o. \\[ n! = \\begin{cases} 1 & \\text{se } n = 0\\\\ n * (n-1)! & \\text{se } n > 0 \\end{cases} \\] Por esta defini\u00e7\u00e3o, podemos calcular o fatorial de 4, por exemplo, assim. \\[ \\begin{align} 4! &= 4 * (4-1)! \\\\ &= 4 * (3 * (3-1)!) \\\\ &= 4 * (3 * (2 * (2-1)!)) \\\\ &= 4 * (3 * (2 * (1 * (1-1)!))) \\\\ &= 4 * (3 * (2 * (1 * 0!))) \\\\ &= 4 * (3 * (2 * (1 * 1))) \\\\ &= 4 * (3 * (2 * 1)) \\\\ &= 4 * (3 * 2) \\\\ &= 4 * 6 \\\\ &= 24 \\end{align} \\] Na computa\u00e7\u00e3o, as fun\u00e7\u00f5es recursivas s\u00e3o importantes por serem uma estrat\u00e9gia de resolu\u00e7\u00e3o de problemas , pois possibilitam resolver problemas pouco a pouco, e especialmente importantes na programa\u00e7\u00e3o funcional, onde servem de alternativa \u00e0s instru\u00e7\u00f5es de itera\u00e7\u00e3o como for (;;) e while () , comuns nas linguagens imperativas. Em Haskell N\u00e3o h\u00e1 nada de especial em termos de sintaxe na declara\u00e7\u00e3o de fun\u00e7\u00f5es recursivas. O c\u00e1lculo do fatorial pode ser traduzido quase que diretamente para Haskell usando guardas. 1 2 3 fatorialGuardas n | n == 0 = 1 | otherwise = n * fatorialGuardas ( n - 1 ) Observe que a defini\u00e7\u00e3o \u00e9 iniciada tratando o caso em que 0 \u00e9 passado como par\u00e2metro; este \u00e9 o que chamamos de caso base , que serve para limitar a recurs\u00e3o e impedir que execute para sempre. J\u00e1 o que torna a fun\u00e7\u00e3o recursiva acontece na \u00faltima linha: a invoca\u00e7\u00e3o da pr\u00f3pria fun\u00e7\u00e3o. Como esta invoca\u00e7\u00e3o ser\u00e1 feita para o valor passado como par\u00e2metro menos 1, temos a garantia de que, para qualquer n\u00famero positivo passado como par\u00e2metro, em algum momento haver\u00e1 uma invoca\u00e7\u00e3o da fun\u00e7\u00e3o com o par\u00e2metro igual a 0 , que ser\u00e1 respondida pelo caso base. \u00c9 importante ficar claro que para cada invoca\u00e7\u00e3o da fun\u00e7\u00e3o, \\(n\\) assume um valor diferente, o que pode fazer parecer que o valor de \\(n\\) est\u00e1 mudando, mas isso n\u00e3o poderia estar mais longe da verdade! Cada \\(n\\) s\u00f3 existe no escopo de uma invoca\u00e7\u00e3o da fun\u00e7\u00e3o. Pictograficamente, \\(n\\) s\u00f3 \u00e9 vis\u00edvel dentro da \"caixinha\" onde foi associada a um valor. Outra forma absolutamente equivalente de definir a fun\u00e7\u00e3o \u00e9 usando casamento de padr\u00f5es, como a seguir. 1 2 fatorialPM 0 = 1 fatorialPM n = n * fatorialPM ( n - 1 ) Considerando as duas defini\u00e7\u00f5es da fun\u00e7\u00e3o, considere o que acontece se as mesmas forem invocadas com um n\u00famero negativo como par\u00e2metro. O que acontece? A recurs\u00e3o simplesmente \"nunca\" termina, continuando com \\(n\\) indo para o - infinito. Acontece que n\u00e3o \u00e9 definido o fatorial de n\u00fameros negativos e, por isso, precisamos que um erro seja lan\u00e7ado quando uma tentativa de invoca\u00e7\u00e3o deste tipo ocorrer. H\u00e1 diferentes formas de se lan\u00e7ar um erro, sendo a primeira simplesmente limitar os valores v\u00e1lidos para os par\u00e2metros. 1 2 3 fatorialGuardas n | n == 0 = 1 | n > 0 = n * fatorialGuardas ( n - 1 ) A outra alternativa \u00e9 explicitamente causar um erro. 1 2 3 4 5 6 7 8 9 fatorialGuardas' n | n == 0 = 1 | n > 0 = n * fatorialGuardas' ( n - 1 ) | otherwise = error \"N\u00e3o se pode calcular o fatorial de n\u00fameros negativos\" fatorialGuardas'' n | n == 0 = 1 | otherwise = if n > 0 then n * fatorialGuardas'' ( n - 1 ) else error \"N\u00e3o se pode calcular o fatorial de n\u00fameros negativos\" Fun\u00e7\u00f5es Recursivas Caso base - Limita recurs\u00e3o. Caso geral - Faz chamada recursiva para problema \" menor \" Note que em ambas as formas, temos algumas defini\u00e7\u00f5es simples, os casos base , que n\u00e3o fazem recurs\u00e3o, e os casos recursivos , envolvem recurs\u00e3o. Este padr\u00e3o se repetir\u00e1 praticamente sempre nas defini\u00e7\u00f5es recursivas, o que n\u00e3o quer dizer que a defini\u00e7\u00e3o ser\u00e1 \u00f3bvia. M\u00e1ximo Divisor Comum O m\u00e1ximo divisor comum de dois n\u00fameros \u00e9, bem, o maior dentre os divisores comuns. Por exemplo, considere os n\u00fameros 18 e 12: j\u00e1 que o 18 tem como divisores {18, 9, 6, 3, 2, 1} e o 12 tem {12, 6, 4, 3, 2, 1}, o maior dentre os divisores comuns \u00e9 6, isto \u00e9, o mdc(18,12) = 6. Logo, se quisermos implementar uma fun\u00e7\u00e3o que calcule o mdc, podemos come\u00e7ar por encontrar o conjunto de divisores, usando uma recurs\u00e3o, e ent\u00e3o iterar pelos conjuntos para identificar o maior comum, com outra recurs\u00e3o. Enquanto esta abordagem \u00e9 um bom exerc\u00edcio de manipula\u00e7\u00e3o de listas, se o objetivo \u00e9 calcular o mdc de forma recursiva, h\u00e1 uma abordagem melhor, conhecida como o algoritmo de Euclides . De forma direta, este algoritmo pode ser expresso como a seguinte fun\u00e7\u00e3o recursiva, onde \\(a >= b\\) \\[ mdc(a,b) = \\begin{cases} a & \\text{se } b = 0\\\\ \\text{mdc}(b, a \\text{ mod } b) & \\text{caso contr\u00e1rio } \\end{cases} \\] Em Haskell, a defini\u00e7\u00e3o fica assim. 1 2 3 4 mdc :: Integer -> Integer -> Integer mdc a b | b == 0 = a | otherwise = mdc b ( a ` mod ` b ) Fibonacci Considere a fun\u00e7\u00e3o que retorna um termo da sequ\u00eancia de Fibonacci, em que os dois primeiros termos s\u00e3o 1 e todos os outros termos s\u00e3o iguais \u00e0 soma dos dois termos anteriores. \\[ F(n) = \\begin{cases} 1 & \\text{se } n = 1\\\\ 1 & \\text{se } n = 2\\\\ F(n-1) + F(n - 2) & \\text{se } n > 2 \\end{cases} \\] A mesma tradu\u00e7\u00e3o direta da defini\u00e7\u00e3o matem\u00e1tica para Haskell tamb\u00e9m pode ser feita aqui, sendo a \u00fanica diferen\u00e7a o fato de que duas invoca\u00e7\u00f5es recursivas s\u00e3o feitas a cada passo. H\u00e1, contudo, diversas possibilidades de tradu\u00e7\u00e3o. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 fibIf n = if n == 1 then 1 else if n == 2 then 1 else fibIf ( n - 1 ) + fibIf ( n - 2 ) fibGuard n | n == 1 = 1 | n == 2 = 1 | otherwise = fibGuard ( n - 1 ) + fibGuard ( n - 2 ) fibPattern 1 = 1 fibPattern 2 = 1 fibPattern n = fibPattern ( n - 1 ) + fibPattern ( n - 2 ) fibCase x = case x of 1 -> 0 2 -> 1 n -> fibCase ( n - 1 ) + fibCase ( n - 2 ) Conjectura de Collatz Considere a seguinte fun\u00e7\u00e3o para construir uma sequ\u00eancia de n\u00fameros usando \\(n\\) como base. \\[ F_n(i) = \\begin{cases} n & \\text{se } i = 1\\\\ F_n(i-1)/2 & \\text{se } F_n(i-1) \\text{ \u00e9 par}\\\\ F_n(i-1)* 3 + 1 & \\text{se } F_n(i-1) \\text{ \u00e9 \u00edmpar} \\end{cases} \\] Exerc\u00edcio Defina a fun\u00e7\u00e3o acima em Haskell. Segundo a conjectura de Collatz , para qualquer valor de \\(n\\) , em algum momento a sequ\u00eancia converge para o valor 1 e a partir da\u00ed repete infinitamente os termos 4, 2, 1. Por exemplo, para \\(n=7\\) , a sequ\u00eancia \u00e9 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1; para \\(n=12\\) , 12, 6, 3, 10, 5, 16, 8, 4, 2, 1; para \\(n=19\\) , 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1; e, para \\(n=27\\) , 27, 82, 41, 124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1 Esta \u00e9 uma conjectura pois n\u00e3o se sabe se a sequ\u00eancia realmente converge para 1 dado qualquer \\(n\\) . O que voc\u00ea acha de testar alguns valores para tentar identificar h\u00e1 ou n\u00e3o uma converg\u00eancia? Em C, poder\u00edamos fazer o seguinte: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int collatz ( int n , int i ){ if ( i == 1 ) return n ; else { int f_n_i_menos_1 = collatz ( n , i -1 ); if ( f_n_i_menos_1 % 2 == 0 ) return f_n_i_menos_1 / 2 ; else f_n_i_menos_1 * 3 + 1 ; } bool converge ( int n ) { bool convergiu = false ; for ( int i = 0 ; ! convergiu ; i ++ ) convergiu = collatz ( n , i ) == 1 ; return convergiu ; } Por mais ineficiente que seja, este c\u00f3digo em C funciona e pode servir de base para uma vers\u00e3o em Haskell, mas como escrever a itera\u00e7\u00e3o? Como dito anteriormente, a itera\u00e7\u00e3o pode ser feita por meio de outra recurs\u00e3o! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 collatz :: Int -> Int -> Int collatz n i | i == 1 = n | even ( collatz n ( i - 1 )) = collatz n ( i - 1 ) ` div ` 2 | otherwise = collatz n ( i - 1 ) * 3 + 1 converge :: Int -> Bool converge n = convergeInterna n 1 convergeInterna :: Int -> Int -> Bool convergeInterna n passo | collatz n passo == 1 = True | otherwise = convergeInterna n ( passo + 1 ) Vejamos alguns exemplos. 1 2 3 4 5 6 7 8 9 10 11 12 * Main > collatz 7 13 16 * Main > collatz 7 17 1 * Main > converge 7 True * Main > converge 12 True * Main > convergeInterna 7 15 True * Main > convergeInterna 7 1 True Tente executar a fun\u00e7\u00e3o para o n\u00famero 27, cuja sequ\u00eancia calculada acima tem 111 passos. Quando seu computador come\u00e7ar a se desesperar ou voc\u00ea cansar de esperar, aperte Ctrl + C . Mas por qu\u00ea esta fun\u00e7\u00e3o t\u00e3o simples ficou t\u00e3o pesada? Por qu\u00ea para calcular se a sequ\u00eancia converge, primeiro a fun\u00e7\u00e3o testou o primeiro termo, 27, e viu que n\u00e3o era igual 1; calculou ent\u00e3o o segundo termo, para isto calculando o primeiro termo novamente, e testando se igual a 1; calculou ent\u00e3o o terceiro termo, para isso calculando o segundo termo, para isso calculando o primeiro, e assim por diante. Al\u00e9m disso, no c\u00e1lculo de cada termo, h\u00e1 um teste para ver se o termo anterior \u00e9 \u00edmpar ou par, o que por si s\u00f3 calcula o termo anterior. Mais tarde veremos como tornar esta fun\u00e7\u00e3o muito mais eficiente, como na vers\u00e3o em C, em que o termo anterior s\u00f3 \u00e9 calculado uma vez, mas por enquanto pensemos em como podemos limitar o n\u00famero de passos nesta itera\u00e7\u00e3o. Exerc\u00edcio Modifique a defini\u00e7\u00e3o da fun\u00e7\u00e3o converge para impedir que execute ad eternum . Dica Use um contador para limitar o n\u00famero de recurs\u00f5es e, no caso do limite ser alcan\u00e7ado, emita um erro. Resolu\u00e7\u00e3o Use um contador para limitar o n\u00famero de recurs\u00f5es e, no caso do limite ser alcan\u00e7ado, emita um erro. 1 2 3 4 5 6 7 8 9 10 11 collatz :: Int -> Int -> Int collatz n i | i == 1 = n | even ( collatz n ( i - 1 )) = collatz n ( i - 1 ) ` div ` 2 | otherwise = collatz n ( i - 1 ) * 3 + 1 converge :: Int -> Int -> Int -> Bool converge n passo limite | limite == 0 = error \"N\u00e3o alcan\u00e7ou uma resposta\" | collatz n passo == 1 = True | otherwise = converge n ( passo + 1 ) ( limite - 1 ) Binomial H\u00e1 v\u00e1rias maneiras de se calcular o n\u00famero de combina\u00e7\u00f5es que se pode obter com \\(k\\) elementos de um conjunto de \\(n\\) elementos. Uma destas formas \u00e9 via a seguinte recorr\u00eancia. \\[ \\binom{n}{k} = \\begin{cases} \\text{indefinido} & \\text{se} k > n\\\\ 1 & \\text{se } k = 0\\\\ 1 & \\text{se } k = n\\\\ \\binom{n-1}{k} + \\binom{n-1}{k-1} & \\text{caso contr\u00e1rio } \\end{cases} \\] Binomial Implemente uma fun\u00e7\u00e3o recursiva que calcule \\(\\binom{n}{k}\\) Resolu\u00e7\u00e3o A ser implementado Recurs\u00e3o e Listas Fun\u00e7\u00f5es recursivas s\u00e3o particularmente importantes na manipula\u00e7\u00e3o listas, como veremos adiante. Recurs\u00e3o de Cauda A recurs\u00e3o de cauda \u00e9 uma t\u00e9cnica important\u00edssima para melhorar o desempenho de fun\u00e7\u00f5es recursivas ao economizar os recursos do sistema, e ao permitir as recurs\u00f5es possam at\u00e9 ser infinitas, como em la\u00e7os infinitos usados em jogos, por exemplo. Esta t\u00e9cnica ser\u00e1 explorada no futuro, uma vez que j\u00e1 estejam confort\u00e1veis com recurs\u00f5es n\u00e3o otimizadas.","title":"Recurs\u00e3o"},{"location":"recursion/#recursividade","text":"Uma fun\u00e7\u00e3o \u00e9 dita recursiva quando ela \u00e9 definida em termos de si mesma . Estas fun\u00e7\u00f5es s\u00e3o muito importantes tanto na matem\u00e1tica, onde s\u00e3o tamb\u00e9m conhecidas como recorr\u00eancias . Por exemplo, vejamos como \u00e9 definido um exemplo recorrentes de fun\u00e7\u00e3o na computa\u00e7\u00e3o ( pun intended ) de forma recursiva, o c\u00e1lculo do fatorial de um n\u00famero. Considere a seguinte defini\u00e7\u00e3o. \\[ n! = \\begin{cases} 1 & \\text{se } n = 0\\\\ n * (n-1)! & \\text{se } n > 0 \\end{cases} \\] Por esta defini\u00e7\u00e3o, podemos calcular o fatorial de 4, por exemplo, assim. \\[ \\begin{align} 4! &= 4 * (4-1)! \\\\ &= 4 * (3 * (3-1)!) \\\\ &= 4 * (3 * (2 * (2-1)!)) \\\\ &= 4 * (3 * (2 * (1 * (1-1)!))) \\\\ &= 4 * (3 * (2 * (1 * 0!))) \\\\ &= 4 * (3 * (2 * (1 * 1))) \\\\ &= 4 * (3 * (2 * 1)) \\\\ &= 4 * (3 * 2) \\\\ &= 4 * 6 \\\\ &= 24 \\end{align} \\] Na computa\u00e7\u00e3o, as fun\u00e7\u00f5es recursivas s\u00e3o importantes por serem uma estrat\u00e9gia de resolu\u00e7\u00e3o de problemas , pois possibilitam resolver problemas pouco a pouco, e especialmente importantes na programa\u00e7\u00e3o funcional, onde servem de alternativa \u00e0s instru\u00e7\u00f5es de itera\u00e7\u00e3o como for (;;) e while () , comuns nas linguagens imperativas.","title":"Recursividade"},{"location":"recursion/#em-haskell","text":"N\u00e3o h\u00e1 nada de especial em termos de sintaxe na declara\u00e7\u00e3o de fun\u00e7\u00f5es recursivas. O c\u00e1lculo do fatorial pode ser traduzido quase que diretamente para Haskell usando guardas. 1 2 3 fatorialGuardas n | n == 0 = 1 | otherwise = n * fatorialGuardas ( n - 1 ) Observe que a defini\u00e7\u00e3o \u00e9 iniciada tratando o caso em que 0 \u00e9 passado como par\u00e2metro; este \u00e9 o que chamamos de caso base , que serve para limitar a recurs\u00e3o e impedir que execute para sempre. J\u00e1 o que torna a fun\u00e7\u00e3o recursiva acontece na \u00faltima linha: a invoca\u00e7\u00e3o da pr\u00f3pria fun\u00e7\u00e3o. Como esta invoca\u00e7\u00e3o ser\u00e1 feita para o valor passado como par\u00e2metro menos 1, temos a garantia de que, para qualquer n\u00famero positivo passado como par\u00e2metro, em algum momento haver\u00e1 uma invoca\u00e7\u00e3o da fun\u00e7\u00e3o com o par\u00e2metro igual a 0 , que ser\u00e1 respondida pelo caso base. \u00c9 importante ficar claro que para cada invoca\u00e7\u00e3o da fun\u00e7\u00e3o, \\(n\\) assume um valor diferente, o que pode fazer parecer que o valor de \\(n\\) est\u00e1 mudando, mas isso n\u00e3o poderia estar mais longe da verdade! Cada \\(n\\) s\u00f3 existe no escopo de uma invoca\u00e7\u00e3o da fun\u00e7\u00e3o. Pictograficamente, \\(n\\) s\u00f3 \u00e9 vis\u00edvel dentro da \"caixinha\" onde foi associada a um valor. Outra forma absolutamente equivalente de definir a fun\u00e7\u00e3o \u00e9 usando casamento de padr\u00f5es, como a seguir. 1 2 fatorialPM 0 = 1 fatorialPM n = n * fatorialPM ( n - 1 ) Considerando as duas defini\u00e7\u00f5es da fun\u00e7\u00e3o, considere o que acontece se as mesmas forem invocadas com um n\u00famero negativo como par\u00e2metro. O que acontece? A recurs\u00e3o simplesmente \"nunca\" termina, continuando com \\(n\\) indo para o - infinito. Acontece que n\u00e3o \u00e9 definido o fatorial de n\u00fameros negativos e, por isso, precisamos que um erro seja lan\u00e7ado quando uma tentativa de invoca\u00e7\u00e3o deste tipo ocorrer. H\u00e1 diferentes formas de se lan\u00e7ar um erro, sendo a primeira simplesmente limitar os valores v\u00e1lidos para os par\u00e2metros. 1 2 3 fatorialGuardas n | n == 0 = 1 | n > 0 = n * fatorialGuardas ( n - 1 ) A outra alternativa \u00e9 explicitamente causar um erro. 1 2 3 4 5 6 7 8 9 fatorialGuardas' n | n == 0 = 1 | n > 0 = n * fatorialGuardas' ( n - 1 ) | otherwise = error \"N\u00e3o se pode calcular o fatorial de n\u00fameros negativos\" fatorialGuardas'' n | n == 0 = 1 | otherwise = if n > 0 then n * fatorialGuardas'' ( n - 1 ) else error \"N\u00e3o se pode calcular o fatorial de n\u00fameros negativos\" Fun\u00e7\u00f5es Recursivas Caso base - Limita recurs\u00e3o. Caso geral - Faz chamada recursiva para problema \" menor \" Note que em ambas as formas, temos algumas defini\u00e7\u00f5es simples, os casos base , que n\u00e3o fazem recurs\u00e3o, e os casos recursivos , envolvem recurs\u00e3o. Este padr\u00e3o se repetir\u00e1 praticamente sempre nas defini\u00e7\u00f5es recursivas, o que n\u00e3o quer dizer que a defini\u00e7\u00e3o ser\u00e1 \u00f3bvia.","title":"Em Haskell"},{"location":"recursion/#recursao-e-listas","text":"Fun\u00e7\u00f5es recursivas s\u00e3o particularmente importantes na manipula\u00e7\u00e3o listas, como veremos adiante.","title":"Recurs\u00e3o e Listas"},{"location":"recursion/#recursao-de-cauda","text":"A recurs\u00e3o de cauda \u00e9 uma t\u00e9cnica important\u00edssima para melhorar o desempenho de fun\u00e7\u00f5es recursivas ao economizar os recursos do sistema, e ao permitir as recurs\u00f5es possam at\u00e9 ser infinitas, como em la\u00e7os infinitos usados em jogos, por exemplo. Esta t\u00e9cnica ser\u00e1 explorada no futuro, uma vez que j\u00e1 estejam confort\u00e1veis com recurs\u00f5es n\u00e3o otimizadas.","title":"Recurs\u00e3o de Cauda"},{"location":"refs/","text":"Tutorial completo de PF https://www.tutorialspoint.com/functional_programming/functional_programming_introduction.htm https://www.cse.chalmers.se/edu/year/2018/course/TDA555/lectures.html","title":"Refs"},{"location":"tail_recursion/","text":"Recurs\u00e3o de cauda Fibonacci pra cima 1 2 3 4 5 6 fibUp :: Integer -> Integer fibUp 0 = 0 fibUp 1 = 1 fibUp n = fibUpTo 0 1 1 n where fibUpTo prevPrev prev prevCount limit = if prevCount == limit then prev + prevPrev else fibUpTo prev ( prev + prevPrev ) ( prevCount + 1 ) limit","title":"Recurs\u00e3o de Cauda"},{"location":"tail_recursion/#recursao-de-cauda","text":"Fibonacci pra cima 1 2 3 4 5 6 fibUp :: Integer -> Integer fibUp 0 = 0 fibUp 1 = 1 fibUp n = fibUpTo 0 1 1 n where fibUpTo prevPrev prev prevCount limit = if prevCount == limit then prev + prevPrev else fibUpTo prev ( prev + prevPrev ) ( prevCount + 1 ) limit","title":"Recurs\u00e3o de cauda"},{"location":"tuples/","text":"Tuplas Nas fun\u00e7\u00f5es vistas at\u00e9 agora, todos os par\u00e2metros eram de algum tipo simples. Por exemplo, vejamos a fun\u00e7\u00e3o soma2n que soma 2 n\u00fameros: 1 2 soma2n :: Int -> Int -> Int soma2n a b = a + b Muitas vezes estes tipos simples precisam ser associados para significar algo de mais alto n\u00edvel. Por exemplo, seja a fun\u00e7\u00e3o soma2v que soma as coordenadas x e y de 2 pontos representando dois vetores. Como poder\u00edamos definir tal fun\u00e7\u00e3o, j\u00e1 que o resultado deve ter informa\u00e7\u00e3o tanto sobre a coordenada x quanto y do resultado? 1 soma2v x1 y1 x2 y2 = ? A resposta est\u00e1 no uso de tipos estruturados que agreguem outros tipos. No caso, a solu\u00e7\u00e3o ideal par ordenado na forma de uma tupla de dois elementos. Tuplas s\u00e3o geralmente representadas usando a sintaxe (Elem1, Elem2, ... , ElemN) , tanto em Haskell como em diversas outras linguagens. Assim, a fun\u00e7\u00e3o soma2v pode ser definida, incluindo o prot\u00f3tipo, como a seguir. Observe que a fun\u00e7\u00e3o define claramente quantos elementos a tupla ter\u00e1 e qual a vari\u00e1vel associada a cada uma das coordenadas de cada ponto. 1 2 soma2v :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) soma2v ( x1 , y1 ) ( x2 , y2 ) = ( x1 + x2 , y1 + y2 ) Para usar a fun\u00e7\u00e3o, podemos invoc\u00e1-la de duas formas, usando a nota\u00e7\u00e3o prefixa ou infixa, com o mesmo resultado. 1 2 soma2v ( 3 , 4 ) ( 5 , 4 ) ( 3 , 4 ) ` soma2v ` ( 5 , 4 ) Outra forma de definir a mesma fun\u00e7\u00e3o, sem especificar o nome das vari\u00e1veis, seria usando as fun\u00e7\u00f5es fst e snd do Prelude , abrevia\u00e7\u00f5es para first e second e que retornam o primeiro e o segundo elemento de uma tupla de dois elementos, um par, respectivamente. Logo, 1 2 3 4 5 6 7 8 9 10 > snd ( 1 , 2 ) 2 > fst ( 3 , 4 ) 3 > fst ( snd (( 1 , 2 , 3 ),( 4 , 5 ))) 4 > fst ( 1 , 2 , 3 ) <== Erro ! De forma simplificada, fst e snd poderiam ser definidos assim: 1 2 3 fst ( x , y ) = x snd ( x , y ) = y Mas na pr\u00e1tica, ainda de forma simplificada, s\u00e3o definidos assim 1 2 3 fst ( x , _ ) = x snd ( _ , y ) = y Observe que o _ \u00e9 usado em substitui\u00e7\u00e3o a um nome para vari\u00e1veis com as quais n\u00e3o nos importamos , isto que, que n\u00e3o ser\u00e3o usadas no dado escopo. O GHC consegue otimizar o c\u00f3digo para n\u00e3o gastar recursos com mesma. Assim, usando fst e snd , a defini\u00e7\u00e3o da soma dos vetores fica como se segue: 1 2 soma2v' :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) soma2v' p1 p2 = (( fst p1 ) + ( fst p2 ), ( snd p1 ) + ( snd p2 )) Exerc\u00edcio Considerando uma tupla de 4 elementos, defina 4 fun\u00e7\u00f5es que, aos moldes de fst e snd , extraiam cada um dos 4 elementos da tupla. N\u00e3o defina um prot\u00f3tipo. Resolu\u00e7\u00e3o 1 2 3 4 prim ( x , _ , _ , _ ) = x segu ( _ , y , _ , _ ) = y terc ( _ , _ , z , _ ) = z quar ( _ , _ , _ , w ) = w Exerc\u00edcio Escreva uma fun\u00e7\u00e3o que receba um inteiro como par\u00e2metro e retorne uma tupla como resultado onde o primeiro elemento \u00e9 um booleano que indica se o n\u00famero \u00e9 negativo, e o segundo elemento \u00e9 o valor absoluto do n\u00famero. Resolu\u00e7\u00e3o 1 2 3 4 5 \u00e9Neg :: Int -> ( Bool , Int ) \u00e9Neg x = if x < 0 then ( True , abs x ) else ( False , abs x ) \u00e9Neg' :: Int -> ( Bool , Int ) \u00e9Neg' x = ( x < 0 , abs x ) Tuplas est\u00e3o para Haskell assim como estruturas est\u00e3o para outras linguagens. Por exemplo, imagine que se queira armazenar os dados nome, telefone, CPF e endere\u00e7o de uma pessoa. Poder\u00edamos convencionar que seria usado uma tupla em que cada posi\u00e7\u00e3o corresponderia a um dos dados. Neste caso, alguns exemplos de fun\u00e7\u00f5es \u00fateis s\u00e3o mostrados a seguir. 1 2 3 4 5 6 7 8 9 10 11 fazPessoa :: String -> String -> String -> String -> ( String , String , String , String ) -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: ( String , String , String , String ) -> String pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: ( String , String , String , String ) -> String pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone :: ( String , String , String , String ) -> String -> ( String , String , String , String ) trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) 1 2 3 4 5 6 7 8 9 10 > x = fazPessoa \"jose da silva\" \"12345\" \"0003003093\" \"Av das Couves, 14\" > x => ( \"jose da silva\" , \"12345\" , \"0003003093\" , \"Av das Couves, 14\" ) > pegaNome x => \"jose da silva\" > pegaTelefone x => \"12345\" > y = trocaTelefone x \"54321\" > y => ( \"jose da silva\" , \"54321\" , \"0003003093\" , \"Av das Couves, 14\" ) Uma observa\u00e7\u00e3o a ser feita \u00e9 que, na \u00faltima fun\u00e7\u00e3o, nomear a vari\u00e1vel como _t tem o mesmo efeito que simplesmente _ para o compilador, mas deixa o c\u00f3digo mais leg\u00edvel. Outra observa\u00e7\u00e3o \u00e9 que mesmo com o uso _t , o c\u00f3digo fica rapidamente dif\u00edcil de se ler, pois o desenvolvedor deve manter em mente qual posi\u00e7\u00e3o corresponde a qual dado de uma pessoa; imagine estruturas mais complexas, contendo outros dados de cada pessoa, e v\u00e1rias outras estruturas semelhantes, como ordens de servi\u00e7o, descri\u00e7\u00e3o de invent\u00e1rios, cadastro de vendedores, etc. Uma forma de simplificar o c\u00f3digo \u00e9 definir tipos associados a cada estrutura. Tuplas como tipos Como visto anteriormente, a palavra reservada type permite que definamos apelidos para tipos no Haskell. Pois tuplas tamb\u00e9m podem ser associadas a tipos, por exemplo, podemos definir que Pessoa \u00e9 o tipo definido na se\u00e7\u00e3o anterior, i.e., uma tupla dos campos nome, telefone, CPF e endere\u00e7o. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Pessoa = ( String , String , String , String ) fazPessoa :: String -> String -> String -> String -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> String pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> String pegaTelefone ( _ , telefone , _ , _ ) = telefone pegaCPF :: Pessoa -> String pegaCPF ( _ , _ , c , _ ) = c pegaEndere\u00e7o :: Pessoa -> String pegaEndere\u00e7o ( _ , _ , _ , e ) = e trocaTelefone :: Pessoa -> String -> Pessoa trocaTelefone p novoTelefone = fazPessoa ( pegaNome p ) novoTelefone ( pegaCPF p ) ( pegaEndere\u00e7o p ) Se perguntarmos ao Haskell qual o tipo da tupla gerada pela fun\u00e7\u00e3o fazPessoa , ele responder\u00e1 Pessoa . 1 2 3 4 5 > : t fazPessoa fazPessoa :: String -> String -> String -> String -> Pessoa > p = fazPessoa \"Jose\" \"Tel\" \"CPF\" \"End\" > : t p p :: Pessoa Podemos ir al\u00e9m e definir tipos usando outros tipos estruturados. Por exemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Nome = ( String , String , String ) type Telefone = ( String , String ) type CPF = String type Endere\u00e7o = ( String , String , String ) type Pessoa = ( Nome , Telefone , CPF , Endere\u00e7o ) fazPessoa :: Nome -> Telefone -> CPF -> Endere\u00e7o -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> Nome pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> Telefone pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone :: Pessoa -> Telefone -> Pessoa trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) Neste caso 1 2 3 4 5 6 7 8 9 10 > p = fazPessoa ( \"Jos\u00e9\" , \"da\" , \"Silva\" ) ( \"ddd\" , \"numero\" ) \"CPF\" ( \"Rua da Couves\" , \"143\" , \"Brasil\" ) > p (( \"Jos \\233 \" , \"da\" , \"Silva\" ),( \"ddd\" , \"numero\" ), \"CPF\" ,( \"Rua da Couves\" , \"143\" , \"Brasil\" )) > : t p p :: Pessoa > n = pegaNome p > n ( \"Jos \\233 \" , \"da\" , \"Silva\" ) > : t n n :: Nome Vejamos outro exemplo; sejam datas, tuplas de 3 inteiros: dia, m\u00eas e ano. Assim, 25 de dezembro de 1999 \u00e9 ( 25 , 12 , 1999 ) . Dado duas datas v\u00e1lidas, uma opera\u00e7\u00e3o interessante \u00e9 testar se uma data \u00e9 menor que outra. 1 2 3 4 5 6 7 8 9 10 11 type Data = ( Int , Int , Int ) dataEhMenor :: ( Int , Int , Int ) -> ( Int , Int , Int ) -> Bool dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) dataEhMenor' :: Data -> Data -> Bool dataEhMenor' ( de , me , ae ) ( dd , md , ad ) = if ae < ad then True else if me < md then True else if de < dd then True else False Mas esta fun\u00e7\u00e3o pode ser descartada com a escolha da defini\u00e7\u00e3o de data, pois tuplas s\u00e3o naturalmente orden\u00e1veis. Data V\u00e1lida Defina um tipo para representar datas como tuplas. Defina uma fun\u00e7\u00e3o dataValida que receba uma data e retorne True se a data for v\u00e1lida e False se for inv\u00e1lida. Por exemplo, 38 de onzembro de 2021 \u00e9 uma data inv\u00e1lida, assim como 29 de fevereiro de 2017, mas dia primeiro de Janeiro de 2000 \u00e9 v\u00e1lida. Isto \u00e9, dataValida ( 38 , 13 , 2021 ) == False dataValida ( 29 , 02 , 2017 ) == False dataValida ( 1 , 1 , 2000 ) == True Resolu\u00e7\u00e3o 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 type Data = ( Int , Int , Int ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) {- >>> bissexto 3 False >>> bissexto 20 True >>> bissexto 100 False >>> bissexto 2000 True -} bissexto :: Integral a => a -> Bool bissexto x | mod x 400 == 0 = True | mod x 100 == 0 = False | otherwise = mod x 4 == 0 {- >>> dataValida (1,1,2001) True >>> dataValida (1,13,2001) False >>> dataValida (29,2,2000) True >>> dataValida (29,2,1999) -} dataValida :: ( Int , Int , Int ) -> Bool dataValida ( d , m , a ) = anoValido a && mesValido m && diaValido d m ( bissexto a ) {- >>> diaValido 2 1 False True >>> diaValido 2 1 True True >>> diaValido 29 2 False False >>> diaValido 29 2 True True -} diaValido :: Int -> Int -> Bool -> Bool diaValido d m bi = d > 0 && d <= numDias m bi {- >>> numDias 3 False 31 >>> numDias 2 True 29 >>> numDias 2 False 28 -} numDias :: Int -> Bool -> Int numDias m bi | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = if bi then 29 else 28 | otherwise = 30 {- >>> mesValido 4 True >>> mesValido 13 False -} mesValido :: Int -> Bool mesValido m = m > 0 && m < 13 {- >>> anoValido 3000 True -} anoValido :: Int -> Bool anoValido a = a > 0 Ordem entre tuplas Dado duas tuplas com mesmo tipo e, obviamente, de mesmo tamanho , elas podem se comparadas lexicogr\u00e1ficamente. Isto quer dizer que uma tupla \\(t_1\\) \u00e9 menor que uma tupla \\(t_2\\) se, considerando posi\u00e7\u00f5es da direita para a esquerda: dado uma posi\u00e7\u00e3o \\(i\\) , se \\(t_1\\) na posi\u00e7\u00e3o \\(i\\) \u00e9 menor que \\(t_2\\) na posi\u00e7\u00e3o \\(i\\) e se \\(\\forall j < i\\) , \\(t_1\\) na posi\u00e7\u00e3o \\(j\\) \u00e9 igual a \\(t_2\\) na posi\u00e7\u00e3o \\(j\\) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 > ( 1 , 2 ) < ( 1 , 3 ) True > ( 'a' , 2 ) < ( 'b' , 3 ) True > ( 'a' , 2 ) == ( 'b' , 3 ) False > ( 'a' , 2 ) > ( 'b' , 3 ) False > ( 1 , 2 ) < ( 1 , 3 , 4 ) <== Erro ! > ( 1 , 1 , 1 ) < ( 1 , 1 , 1 ) False > ( 1 , 1 , 1 ) < ( 1 , 1 , 2 ) True > ( 1 , 1 , 1 ) < ( 1 , 2 , 1 ) True > ( 1 , 1 , 1 ) < ( 2 , 1 , 1 ) True > ( 1 , 1 , 1 ) < ( 0 , 2 , 2 ) False Assim, se usarmos como data uma tupla com ano, m\u00eas e dia, nesta ordem , ent\u00e3o duas datas podem ser comparadas diretamente como compara\u00e7\u00e3o de tuplas. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 type Data = ( Int , Int , Int ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor :: Data -> Data -> Bool dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor' :: Data -> Data -> Bool dataEhMenor' ( de , me , ae ) ( dd , md , ad ) = ( ae , me , de ) < ( ad , md , dd ) A tupla vazia Por completude, \u00e9 preciso mencionar que tuplas podem ter qualquer aridade, inclusive zero. Isto \u00e9, () \u00e9 uma tupla v\u00e1lida e a \u00fanica inst\u00e2ncia de tuplas de aridade zero.","title":"Tuplas"},{"location":"tuples/#tuplas","text":"Nas fun\u00e7\u00f5es vistas at\u00e9 agora, todos os par\u00e2metros eram de algum tipo simples. Por exemplo, vejamos a fun\u00e7\u00e3o soma2n que soma 2 n\u00fameros: 1 2 soma2n :: Int -> Int -> Int soma2n a b = a + b Muitas vezes estes tipos simples precisam ser associados para significar algo de mais alto n\u00edvel. Por exemplo, seja a fun\u00e7\u00e3o soma2v que soma as coordenadas x e y de 2 pontos representando dois vetores. Como poder\u00edamos definir tal fun\u00e7\u00e3o, j\u00e1 que o resultado deve ter informa\u00e7\u00e3o tanto sobre a coordenada x quanto y do resultado? 1 soma2v x1 y1 x2 y2 = ? A resposta est\u00e1 no uso de tipos estruturados que agreguem outros tipos. No caso, a solu\u00e7\u00e3o ideal par ordenado na forma de uma tupla de dois elementos. Tuplas s\u00e3o geralmente representadas usando a sintaxe (Elem1, Elem2, ... , ElemN) , tanto em Haskell como em diversas outras linguagens. Assim, a fun\u00e7\u00e3o soma2v pode ser definida, incluindo o prot\u00f3tipo, como a seguir. Observe que a fun\u00e7\u00e3o define claramente quantos elementos a tupla ter\u00e1 e qual a vari\u00e1vel associada a cada uma das coordenadas de cada ponto. 1 2 soma2v :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) soma2v ( x1 , y1 ) ( x2 , y2 ) = ( x1 + x2 , y1 + y2 ) Para usar a fun\u00e7\u00e3o, podemos invoc\u00e1-la de duas formas, usando a nota\u00e7\u00e3o prefixa ou infixa, com o mesmo resultado. 1 2 soma2v ( 3 , 4 ) ( 5 , 4 ) ( 3 , 4 ) ` soma2v ` ( 5 , 4 ) Outra forma de definir a mesma fun\u00e7\u00e3o, sem especificar o nome das vari\u00e1veis, seria usando as fun\u00e7\u00f5es fst e snd do Prelude , abrevia\u00e7\u00f5es para first e second e que retornam o primeiro e o segundo elemento de uma tupla de dois elementos, um par, respectivamente. Logo, 1 2 3 4 5 6 7 8 9 10 > snd ( 1 , 2 ) 2 > fst ( 3 , 4 ) 3 > fst ( snd (( 1 , 2 , 3 ),( 4 , 5 ))) 4 > fst ( 1 , 2 , 3 ) <== Erro ! De forma simplificada, fst e snd poderiam ser definidos assim: 1 2 3 fst ( x , y ) = x snd ( x , y ) = y Mas na pr\u00e1tica, ainda de forma simplificada, s\u00e3o definidos assim 1 2 3 fst ( x , _ ) = x snd ( _ , y ) = y Observe que o _ \u00e9 usado em substitui\u00e7\u00e3o a um nome para vari\u00e1veis com as quais n\u00e3o nos importamos , isto que, que n\u00e3o ser\u00e3o usadas no dado escopo. O GHC consegue otimizar o c\u00f3digo para n\u00e3o gastar recursos com mesma. Assim, usando fst e snd , a defini\u00e7\u00e3o da soma dos vetores fica como se segue: 1 2 soma2v' :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) soma2v' p1 p2 = (( fst p1 ) + ( fst p2 ), ( snd p1 ) + ( snd p2 )) Exerc\u00edcio Considerando uma tupla de 4 elementos, defina 4 fun\u00e7\u00f5es que, aos moldes de fst e snd , extraiam cada um dos 4 elementos da tupla. N\u00e3o defina um prot\u00f3tipo. Resolu\u00e7\u00e3o 1 2 3 4 prim ( x , _ , _ , _ ) = x segu ( _ , y , _ , _ ) = y terc ( _ , _ , z , _ ) = z quar ( _ , _ , _ , w ) = w Exerc\u00edcio Escreva uma fun\u00e7\u00e3o que receba um inteiro como par\u00e2metro e retorne uma tupla como resultado onde o primeiro elemento \u00e9 um booleano que indica se o n\u00famero \u00e9 negativo, e o segundo elemento \u00e9 o valor absoluto do n\u00famero. Resolu\u00e7\u00e3o 1 2 3 4 5 \u00e9Neg :: Int -> ( Bool , Int ) \u00e9Neg x = if x < 0 then ( True , abs x ) else ( False , abs x ) \u00e9Neg' :: Int -> ( Bool , Int ) \u00e9Neg' x = ( x < 0 , abs x ) Tuplas est\u00e3o para Haskell assim como estruturas est\u00e3o para outras linguagens. Por exemplo, imagine que se queira armazenar os dados nome, telefone, CPF e endere\u00e7o de uma pessoa. Poder\u00edamos convencionar que seria usado uma tupla em que cada posi\u00e7\u00e3o corresponderia a um dos dados. Neste caso, alguns exemplos de fun\u00e7\u00f5es \u00fateis s\u00e3o mostrados a seguir. 1 2 3 4 5 6 7 8 9 10 11 fazPessoa :: String -> String -> String -> String -> ( String , String , String , String ) -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: ( String , String , String , String ) -> String pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: ( String , String , String , String ) -> String pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone :: ( String , String , String , String ) -> String -> ( String , String , String , String ) trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) 1 2 3 4 5 6 7 8 9 10 > x = fazPessoa \"jose da silva\" \"12345\" \"0003003093\" \"Av das Couves, 14\" > x => ( \"jose da silva\" , \"12345\" , \"0003003093\" , \"Av das Couves, 14\" ) > pegaNome x => \"jose da silva\" > pegaTelefone x => \"12345\" > y = trocaTelefone x \"54321\" > y => ( \"jose da silva\" , \"54321\" , \"0003003093\" , \"Av das Couves, 14\" ) Uma observa\u00e7\u00e3o a ser feita \u00e9 que, na \u00faltima fun\u00e7\u00e3o, nomear a vari\u00e1vel como _t tem o mesmo efeito que simplesmente _ para o compilador, mas deixa o c\u00f3digo mais leg\u00edvel. Outra observa\u00e7\u00e3o \u00e9 que mesmo com o uso _t , o c\u00f3digo fica rapidamente dif\u00edcil de se ler, pois o desenvolvedor deve manter em mente qual posi\u00e7\u00e3o corresponde a qual dado de uma pessoa; imagine estruturas mais complexas, contendo outros dados de cada pessoa, e v\u00e1rias outras estruturas semelhantes, como ordens de servi\u00e7o, descri\u00e7\u00e3o de invent\u00e1rios, cadastro de vendedores, etc. Uma forma de simplificar o c\u00f3digo \u00e9 definir tipos associados a cada estrutura.","title":"Tuplas"},{"location":"tuples/#tuplas-como-tipos","text":"Como visto anteriormente, a palavra reservada type permite que definamos apelidos para tipos no Haskell. Pois tuplas tamb\u00e9m podem ser associadas a tipos, por exemplo, podemos definir que Pessoa \u00e9 o tipo definido na se\u00e7\u00e3o anterior, i.e., uma tupla dos campos nome, telefone, CPF e endere\u00e7o. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Pessoa = ( String , String , String , String ) fazPessoa :: String -> String -> String -> String -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> String pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> String pegaTelefone ( _ , telefone , _ , _ ) = telefone pegaCPF :: Pessoa -> String pegaCPF ( _ , _ , c , _ ) = c pegaEndere\u00e7o :: Pessoa -> String pegaEndere\u00e7o ( _ , _ , _ , e ) = e trocaTelefone :: Pessoa -> String -> Pessoa trocaTelefone p novoTelefone = fazPessoa ( pegaNome p ) novoTelefone ( pegaCPF p ) ( pegaEndere\u00e7o p ) Se perguntarmos ao Haskell qual o tipo da tupla gerada pela fun\u00e7\u00e3o fazPessoa , ele responder\u00e1 Pessoa . 1 2 3 4 5 > : t fazPessoa fazPessoa :: String -> String -> String -> String -> Pessoa > p = fazPessoa \"Jose\" \"Tel\" \"CPF\" \"End\" > : t p p :: Pessoa Podemos ir al\u00e9m e definir tipos usando outros tipos estruturados. Por exemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Nome = ( String , String , String ) type Telefone = ( String , String ) type CPF = String type Endere\u00e7o = ( String , String , String ) type Pessoa = ( Nome , Telefone , CPF , Endere\u00e7o ) fazPessoa :: Nome -> Telefone -> CPF -> Endere\u00e7o -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> Nome pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> Telefone pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone :: Pessoa -> Telefone -> Pessoa trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) Neste caso 1 2 3 4 5 6 7 8 9 10 > p = fazPessoa ( \"Jos\u00e9\" , \"da\" , \"Silva\" ) ( \"ddd\" , \"numero\" ) \"CPF\" ( \"Rua da Couves\" , \"143\" , \"Brasil\" ) > p (( \"Jos \\233 \" , \"da\" , \"Silva\" ),( \"ddd\" , \"numero\" ), \"CPF\" ,( \"Rua da Couves\" , \"143\" , \"Brasil\" )) > : t p p :: Pessoa > n = pegaNome p > n ( \"Jos \\233 \" , \"da\" , \"Silva\" ) > : t n n :: Nome Vejamos outro exemplo; sejam datas, tuplas de 3 inteiros: dia, m\u00eas e ano. Assim, 25 de dezembro de 1999 \u00e9 ( 25 , 12 , 1999 ) . Dado duas datas v\u00e1lidas, uma opera\u00e7\u00e3o interessante \u00e9 testar se uma data \u00e9 menor que outra. 1 2 3 4 5 6 7 8 9 10 11 type Data = ( Int , Int , Int ) dataEhMenor :: ( Int , Int , Int ) -> ( Int , Int , Int ) -> Bool dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) dataEhMenor' :: Data -> Data -> Bool dataEhMenor' ( de , me , ae ) ( dd , md , ad ) = if ae < ad then True else if me < md then True else if de < dd then True else False Mas esta fun\u00e7\u00e3o pode ser descartada com a escolha da defini\u00e7\u00e3o de data, pois tuplas s\u00e3o naturalmente orden\u00e1veis. Data V\u00e1lida Defina um tipo para representar datas como tuplas. Defina uma fun\u00e7\u00e3o dataValida que receba uma data e retorne True se a data for v\u00e1lida e False se for inv\u00e1lida. Por exemplo, 38 de onzembro de 2021 \u00e9 uma data inv\u00e1lida, assim como 29 de fevereiro de 2017, mas dia primeiro de Janeiro de 2000 \u00e9 v\u00e1lida. Isto \u00e9, dataValida ( 38 , 13 , 2021 ) == False dataValida ( 29 , 02 , 2017 ) == False dataValida ( 1 , 1 , 2000 ) == True Resolu\u00e7\u00e3o 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 type Data = ( Int , Int , Int ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) {- >>> bissexto 3 False >>> bissexto 20 True >>> bissexto 100 False >>> bissexto 2000 True -} bissexto :: Integral a => a -> Bool bissexto x | mod x 400 == 0 = True | mod x 100 == 0 = False | otherwise = mod x 4 == 0 {- >>> dataValida (1,1,2001) True >>> dataValida (1,13,2001) False >>> dataValida (29,2,2000) True >>> dataValida (29,2,1999) -} dataValida :: ( Int , Int , Int ) -> Bool dataValida ( d , m , a ) = anoValido a && mesValido m && diaValido d m ( bissexto a ) {- >>> diaValido 2 1 False True >>> diaValido 2 1 True True >>> diaValido 29 2 False False >>> diaValido 29 2 True True -} diaValido :: Int -> Int -> Bool -> Bool diaValido d m bi = d > 0 && d <= numDias m bi {- >>> numDias 3 False 31 >>> numDias 2 True 29 >>> numDias 2 False 28 -} numDias :: Int -> Bool -> Int numDias m bi | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = if bi then 29 else 28 | otherwise = 30 {- >>> mesValido 4 True >>> mesValido 13 False -} mesValido :: Int -> Bool mesValido m = m > 0 && m < 13 {- >>> anoValido 3000 True -} anoValido :: Int -> Bool anoValido a = a > 0","title":"Tuplas como tipos"},{"location":"tuples/#ordem-entre-tuplas","text":"Dado duas tuplas com mesmo tipo e, obviamente, de mesmo tamanho , elas podem se comparadas lexicogr\u00e1ficamente. Isto quer dizer que uma tupla \\(t_1\\) \u00e9 menor que uma tupla \\(t_2\\) se, considerando posi\u00e7\u00f5es da direita para a esquerda: dado uma posi\u00e7\u00e3o \\(i\\) , se \\(t_1\\) na posi\u00e7\u00e3o \\(i\\) \u00e9 menor que \\(t_2\\) na posi\u00e7\u00e3o \\(i\\) e se \\(\\forall j < i\\) , \\(t_1\\) na posi\u00e7\u00e3o \\(j\\) \u00e9 igual a \\(t_2\\) na posi\u00e7\u00e3o \\(j\\) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 > ( 1 , 2 ) < ( 1 , 3 ) True > ( 'a' , 2 ) < ( 'b' , 3 ) True > ( 'a' , 2 ) == ( 'b' , 3 ) False > ( 'a' , 2 ) > ( 'b' , 3 ) False > ( 1 , 2 ) < ( 1 , 3 , 4 ) <== Erro ! > ( 1 , 1 , 1 ) < ( 1 , 1 , 1 ) False > ( 1 , 1 , 1 ) < ( 1 , 1 , 2 ) True > ( 1 , 1 , 1 ) < ( 1 , 2 , 1 ) True > ( 1 , 1 , 1 ) < ( 2 , 1 , 1 ) True > ( 1 , 1 , 1 ) < ( 0 , 2 , 2 ) False Assim, se usarmos como data uma tupla com ano, m\u00eas e dia, nesta ordem , ent\u00e3o duas datas podem ser comparadas diretamente como compara\u00e7\u00e3o de tuplas. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 type Data = ( Int , Int , Int ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor :: Data -> Data -> Bool dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor' :: Data -> Data -> Bool dataEhMenor' ( de , me , ae ) ( dd , md , ad ) = ( ae , me , de ) < ( ad , md , dd )","title":"Ordem entre tuplas"},{"location":"tuples/#a-tupla-vazia","text":"Por completude, \u00e9 preciso mencionar que tuplas podem ter qualquer aridade, inclusive zero. Isto \u00e9, () \u00e9 uma tupla v\u00e1lida e a \u00fanica inst\u00e2ncia de tuplas de aridade zero.","title":"A tupla vazia"},{"location":"types/","text":"Tipos Seja a fun\u00e7\u00e3o diasMes a fun\u00e7\u00e3o que calcula a quantidade de dias em um m\u00eas, dado o n\u00famero do m\u00eas, definida assim: 1 2 3 4 diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 O que acontece se voc\u00ea passar 7.2 para a fun\u00e7\u00e3o? O resultado est\u00e1 correto? Isso nos leva a perguntar como definir que uma fun\u00e7\u00e3o s\u00f3 \u00e9 aplic\u00e1vel a n\u00fameros inteiros, do tipo inteiro. Em linguagens de programa\u00e7\u00e3o, um tipo \u00e9 um nome dado a uma cole\u00e7\u00e3o de valores que tem um mesmo comportamento na linguagem. Na linguagem C, por exemplo, temos os tipos int e short , ambos associados a valores inteiros mas com n\u00famero de bits diferentes usados para represent\u00e1-los. Algumas linguagens s\u00e3o denominadas fracamente tipadas , o que quer dizer que o uso de tipos \u00e9 relaxado e pode at\u00e9 ser alterado em tempo de execu\u00e7\u00e3o. Por exemplo, no seguinte c\u00f3digo em Python a vari\u00e1vel x assume tr\u00eas tipos diferentes em momentos diferentes da execu\u00e7\u00e3o. 1 2 3 4 5 6 7 8 x = \"lala\" print ( type ( x )) x = 10 print ( type ( x )) x = 10.0 print ( type ( x )) 1 2 3 <class 'str' > <class 'int' > <class 'float' > J\u00e1 a linguagem Haskell \u00e9 o que chamamos de fortemente tipada , o que quer dizer que toda vari\u00e1vel, constante ou fun\u00e7\u00e3o tem apenas um tipo e este sempre pode ser determinado. Al\u00e9m disso, Haskell \u00e9 estaticamente tipada , ou seja, os tipos s\u00e3o determinados em tempo de compila\u00e7\u00e3o, em oposi\u00e7\u00e3o a linguagens que determinam o tipo durante a execu\u00e7\u00e3o do programa, denominadas dinamicamente tipadas. Assim como type em Python, Haskell tem a fun\u00e7\u00e3o : type para verificar o tipo de uma vari\u00e1vel. Por exemplo: 1 2 3 4 5 6 > : type 1 1 :: Num p => p > : type 1.0 1.0 :: Fractional p => p > : type \"Bom dia\" \"Bom dia\" :: [ Char ] Tipos em Haskell Forte Est\u00e1ticos Por Infer\u00eancia Finalmente, se olharmos novamente para os exemplos de fun\u00e7\u00f5es anteriores, veremos que n\u00e3o foram definidos tipos em suas declara\u00e7\u00f5es; isto \u00e9 poss\u00edvel porqu\u00ea Haskell consegue inferir os tipos dos dados de forma muito eficiente. Quando voc\u00ea explicita tipos, o faz apenas para facilitar a leitura do c\u00f3digo e para indicar sua inten\u00e7\u00e3o ao compilador que, pode-se dizer, far\u00e1 a infer\u00eancia e testar\u00e1 se voc\u00ea est\u00e1 certo. Haskell tem um n\u00famero imenso de tipos pre-definidos, organizados hierarquicamente, e que podem ser usados para definir novos tipos pelo programador. Mas por enquanto, nos foquemos nos tipos mais simples. Tipos Primitivos e Operadores Tipos num\u00e9ricos Como toda linguagem de programa\u00e7\u00e3o, Haskell tem v\u00e1rios tipos pr\u00e9-definidos para representar n\u00fameros, como mostra a seguinte tabela. Tipo Descri\u00e7\u00e3o Valores Int Inteiro de precis\u00e3o finita 4, -14, 2147483647 Integer Inteiro de precis\u00e3o arbitr\u00e1ria 30414093201713378043612608166064768844377641568960512000000000000 Float Ponto flutuante de precis\u00e3o simples 25.132742 Double Ponto flutuante de precis\u00e3o dupla 25.132741228718345 Dados os tipos num\u00e9ricos prim\u00e1rios, o pr\u00f3ximo passo \u00e9 ver alguns dos operadores que os manipulam. Operador Opera\u00e7\u00e3o + Adi\u00e7\u00e3o - Subtra\u00e7\u00e3o * Multiplica\u00e7\u00e3o / Divis\u00e3o ^ Exponencia\u00e7\u00e3o, e.g, 2^4 == 16 - Invers\u00e3o de sinal, e.g, - (-10) == 10 2 negate Invers\u00e3o de sinal, e.g, negate (-10) == 10 2 quot Divis\u00e3o inteira, truncado pro 0, i.e., quot a b \u00e9 igual a \\(\\lfloor\\frac{a}{b}\\rfloor\\) se \\(a>0\\) e \\(\\lceil\\frac{a}{b}\\rceil\\) se \\(a<0\\) , e.g, div 8 3 == 2 e div (-8) 3 == -2 rem Resto da divis\u00e3o inteira, tal que (x `quot` y)*y + (x `rem` y) == x div Resto da divis\u00e3o, truncado para baixo, i.e., div a b \u00e9 igual a \\(\\lfloor\\frac{a}{b}\\rfloor\\) , e.g, div 8 3 == 2 e div (-8) 3 == -3 mod M\u00f3dulo do inteiro, tal que ( x ` div ` y ) * y + ( x ` mod ` y ) == x Observe que alguns destes operadores s\u00e3o naturalmente infixos, e.g., + , e outros, prefixos, e.g., rem . 1 Contudo, ambos podem ser usados da outra forma, como mostrado nos seguintes exemplos. 1 2 3 4 10 + 20 ( + ) 10 20 quot 10 3 10 ` quot ` 3 Caso voc\u00ea queira ou precise especificar um tipo para um n\u00famero, pode sufix\u00e1-lo com o tipo, por exemplo, 20 :: Int ou 20 :: Double . Exerc\u00edcios Usar todos os operadores Evidenciar diferen\u00e7as entrem quot/rem e div/mod. Booleanos Finalmente, para representa\u00e7\u00e3o de valores l\u00f3gicos, Haskell define o tipo bool . Tipo Descri\u00e7\u00e3o Valores Bool Booleano True ou False Para este tipo, temos os seguintes operadores. Operador Opera\u00e7\u00e3o && E l\u00f3gico || OU l\u00f3gico not Nega\u00e7\u00e3o == Igualdade /= Diferen\u00e7a Caracteres Para a representa\u00e7\u00e3o de caracteres individuais, Haskell usa o tipo Char , e para sequ\u00eancias de caracteres, usa o tipo String , que \u00e9 um \"apelido\" para lista de Char . 3 Como lista n\u00e3o \u00e9 um tipo primitivo, ou melhor, mesmo que em Haskell listas sejam fundamentais, n\u00e3o as estudaremos agora. Ainda assim, usaremos String em alguns exemplos, mas sem entrar em detalhes da manipula\u00e7\u00e3o de listas. Exemplos dos dois tipos s\u00e3o apresentados na tabela a seguir. Tipo Descri\u00e7\u00e3o Valores Char Caractere '1'; 'a'; 'B' String Sequ\u00eancia de caracteres \"Eu\"; \"Hello\"; \"Zabumba\" Algumas fun\u00e7\u00f5es \u00fateis na manipula\u00e7\u00e3o de caracteres e strings s\u00e3o apresentadas na tabela. Operador Opera\u00e7\u00e3o Exemplo ++ Concatena\u00e7\u00e3o \"foo\" ++ \"bar\" -> \"foobar\" !! Caractere no \u00edndice \"foo bar\" !! 2 -> 'o' take Substring iniciando em 0 take 3 \"foo bar\" -> \"foo\" drop Substring come\u00e7ando em um \u00edndice drop 3 \"foo bar\" -> \" bar\" reverse String ao contr\u00e1rio reverse \"foo bar\" -> \"rab oof\" length Comprimento da string length \"foo bar\" -> 7 N\u00f3s voltaremos a falar sobre Strings uma vez que estudarmos listas. Exerc\u00edcios Defina fun\u00e7\u00e3o que retorne substring de t elementos come\u00e7ando na posi\u00e7\u00e3o i minhaFuncao \"entrada1\" 2 2 retorna \"tr\" Defina fun\u00e7\u00e3o que retorne substring com os \u00faltimos u elementos minhaFuncao \"entrada1\" 2 retorna \"a1\" Defina fun\u00e7\u00e3o que receba duas strings e retorne a resultado da concatena\u00e7\u00e3o das substrings de t elementos come\u00e7ando na posi\u00e7\u00e3o i minhaFuncao \"entrada1\" \"entrada2\" 2 2 retorna \"trtr\" Prot\u00f3tipo de fun\u00e7\u00f5es Agora que j\u00e1 conhecemos alguns tipos, podemos ver como us\u00e1-los na defini\u00e7\u00e3o de fun\u00e7\u00f5es. Para faz\u00ea-lo, devemos usar a seguinte sintaxe: 1 2 nomeFuncao :: tipo_arg1 -> ... -> tipo_argN -> tipo_saida nomeFuncao arg1 ... argN = < definicao > Por exemplo, o prot\u00f3tipo da fun\u00e7\u00e3o diaMes , isto \u00e9, a defini\u00e7\u00e3o dos tipos de entrada e sa\u00edda da fun\u00e7\u00e3o, fica assim: 1 2 3 4 5 diasMes :: Int -> Int diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 Exerc\u00edcios Defina o prot\u00f3tipo da fun\u00e7\u00e3o de convers\u00e3o de Fahrenheit para Celsius f2c x = ( x - 32 ) / 1.8 Descubra a quanto 100f corresponde em C\u00e9lsius Resolu\u00e7\u00e3o 1 2 f2c :: Float -> Float ` f2c x = ( x - 32 ) / 1.8 Defina o prot\u00f3tipo da fun\u00e7\u00e3o de media de dois n\u00fameros reais m2n a b = ( a + b ) / 2 Resolu\u00e7\u00e3o 1 2 m2n :: Float -> Float -> Float m2n a b = ( a + b ) / 2 Defina o prot\u00f3tipo da soma de dois n\u00fameros inteiros soma2int a b = a + b Aplique a fun\u00e7\u00e3o aos valores 2 e 3. Aplique a fun\u00e7\u00e3o aos valores 2.0 e 3.0. Resolu\u00e7\u00e3o 1 2 soma2int :: Int -> Int -> Int soma2int a b = a + b Defina o prot\u00f3tipo da soma de dois n\u00fameros reais soma2reais a b = a + b Aplique a fun\u00e7\u00e3o aos valores 2.0 e 3.0. Aplique a fun\u00e7\u00e3o aos valores 2 e 3. Resolu\u00e7\u00e3o 1 soma2reais :: Float -> Float -> Float Explique a diferen\u00e7a de comportamento das duas \u00faltimas fun\u00e7\u00f5es. Resolu\u00e7\u00e3o As fun\u00e7\u00f5es se comportam diferentemente, sendo que a primeira mostra um erro quando aplicada a dois n\u00fameros reais, porqu\u00ea \\(Z \\subset R\\) mas \\(R \\not\\subset Z\\) . Defini\u00e7\u00e3o de novos tipos A palavra reservada type permite que definamos apelidos para tipos no Haskell, tornando o c\u00f3digo mais leg\u00edvel. Por exemplo, podemos definir um tipo Inteiro similar ao tipo Int e fun\u00e7\u00f5es associadas ao tipo. 1 2 3 4 type Inteiro = Int somaInteiros :: Inteiro -> Inteiro -> Inteiro somaInteiros a b = a + b O uso da fun\u00e7\u00e3o \u00e9 como esperado. 1 2 3 4 * Main > somaInteiros 1 2 3 * Main > somaInteiros ( 1 :: Inteiro ) ( 2 :: Inteiro ) 3 :type e :info O GHC \u00e9 uma ferramenta poderosa no aprendizado da linguagem Haskell por possuir uma s\u00e9rie de comandos que permitem extrair informa\u00e7\u00f5es sobre tipos e fun\u00e7\u00f5es definidas. Usando o comando : info (ou simplesmente : i ), por exemplo, podemos perguntar ao ghci o que ele sabe sobre o tipo Inteiro , ao que ser\u00e1 respondido que \u00e9 o tipo inteiro \u00e9 um apelido para Int , definido no arquivo scratch.hs, no meu caso. 1 2 3 4 * Main > : i Inteiro type Inteiro :: * type Inteiro = Int -- Defined at scratch.hs:82:1 J\u00e1 o comando : type (ou : t ) pode ser usado para identificar o tipo de fun\u00e7\u00f5es, por exemplo: 1 2 3 4 5 6 * Main > somaInteiros 1 2 3 * Main > : i somaInteiros somaInteiros :: Inteiro -> Inteiro -> Inteiro * Main > : t 1 :: Inteiro 1 :: Inteiro :: Inteiro Estes comandos podem ser aplicados a quaisquer defini\u00e7\u00f5es, n\u00e3o somente \u00e0s suas. Por exemplo, podemos solicitar informa\u00e7\u00f5es sobre o tipo Num , com seguinte resultado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 * Main > : i Num type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ( - ) :: a -> a -> a ( * ) :: a -> a -> a negate :: a -> a abs :: a -> a signum :: a -> a fromInteger :: Integer -> a {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-} -- Defined in \u2018GHC.Num\u2019 instance Num Word -- Defined in \u2018GHC.Num\u2019 instance Num Integer -- Defined in \u2018GHC.Num\u2019 instance Num Int -- Defined in \u2018GHC.Num\u2019 instance Num Float -- Defined in \u2018GHC.Float\u2019 instance Num Double -- Defined in \u2018GHC.Float\u2019 Algumas das informa\u00e7\u00f5es apresentadas podem ainda n\u00e3o fazer sentido para voc\u00ea, mas de forma geral podemos resum\u00ed-las como implicando que algumas opera\u00e7\u00f5es, como + , - e abs se aplicam ao tipo Num , e que outros tipos, como Float e Integer s\u00e3o inst\u00e2ncias de Num . Se aplicarmos o mesmo comando ao operador + , descobriremos que ele \u00e9 uma fun\u00e7\u00e3o infixa por padr\u00e3o ( INFIXl ), associativo \u00e0 esquerda ( infixL ), e com prioridade 6. 1 2 3 4 5 6 7 * Main > : i ( + ) type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ... -- Defined in \u2018GHC.Num\u2019 infixl 6 + Tamb\u00e9m vemos que o estas defini\u00e7\u00f5es s\u00e3o parde do GHC.Num, mas o que \u00e9 o GHC.Num? M\u00f3dulos Como em diversas outras linguagens, Haskell usa m\u00f3dulos para organizar a defini\u00e7\u00e3o de tipos e fun\u00e7\u00f5es, colocando aquelas relacionadas no mesmo m\u00f3dulo. Por padr\u00e3o, o m\u00f3dulo prelude 5 \u00e9 carregado toda vez que executa o ghci ou compila um programa, a n\u00e3o ser que seja explicitamente indicado em contr\u00e1rio. Este m\u00f3dulo cont\u00e9m a defini\u00e7\u00e3o dos tipos e operadores b\u00e1sicos vistos anteriormente, al\u00e9m de muitos outros, e o GHC.Num \u00e9 parte do Prelude. Uma pequena mas interessante amostra de outros tipos inclu\u00eddos: Nome Defini\u00e7\u00e3o min Menor de 2 elementos orden\u00e1veis max Maior de 2 elementos orden\u00e1veis Semigroup Uma classe em que vale a associatividade Monoid Mon\u00f3ide em que h\u00e1 um elemento identidade putChar Escreve um caractere na saida padr\u00e3o putString Escreve uma string na saida padr\u00e3o getChar L\u00ea um caractere da entrada padr\u00e3o getString L\u00ea uma string da entrada padr\u00e3o Estes exemplos servem para mostrar como o m\u00f3dulo mais b\u00e1sico do Haskell \u00e9 diverso e como a sua biblioteca \u00e9 mais diversa ainda. Al\u00e9m do Prelude, centenas de outros m\u00f3dulos est\u00e3o dispon\u00edveis na Web, de compiladores a geradores de gr\u00e1ficos 3D, de transformadas r\u00e1pidas de Fourier a message brokers , em reposit\u00f3rios como o Hackage. 4 Contudo, \u00e9 preciso ter cuidado com os m\u00f3dulos que baixa. Caso voc\u00ea encontre um m\u00f3dulo que queira usar, de nome X , bastar baix\u00e1-lo e usar o import . Por exemplo, para trabalhar com n\u00fameros complexos, voce pode usar o m\u00f3dulo Data . Complex assim: 1 2 3 4 Prelude > import Data.Complex Prelude Data . Complex > let x = 1.0 :+ 0.0 Prelude Data . Complex > x 1.0 :+ 0.0 Com esta visita r\u00e1pida ao Prelude, encerramos esta introdu\u00e7\u00e3o ao Haskell e rumamos para t\u00f3picos mais universais. Isto \u00e9, mesmo que os t\u00f3picos vistos at\u00e9 agora sejam obviamente associados \u00e0 programa\u00e7\u00e3o funcional, os mesmos est\u00e3o fortemente relacionados \u00e0 sintaxe do Haskell. J\u00e1 nas pr\u00f3ximas se\u00e7\u00f5es, veremos t\u00f3picos mais independentes, i.e., mesmo que as fun\u00e7\u00f5es, tipos e construtos usados ainda sejam implementadas em Haskell, os conceitos por tr\u00e1s s\u00e3o mais universais. Operadores s\u00e3o fun\u00e7\u00f5es cujos nomes s\u00f3 contem caracteres especiais. Eles s\u00e3o naturalmente infixos. \u21a9 Observe que o o -10 est\u00e1 entre par\u00eanteses n\u00e3o porque o operador demanda, mas para deixar claro que o - faz parte do n\u00famero. \u21a9 \u21a9 Haskell define tamb\u00e9m o tipo Text, uma forma mais moderna de manipular texto, mas n\u00e3o discutiremos Text aqui. \u21a9 https://hackage.haskell.org/packages/browse \u21a9 Prelude: https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html \u21a9","title":"Tipos"},{"location":"types/#tipos","text":"Seja a fun\u00e7\u00e3o diasMes a fun\u00e7\u00e3o que calcula a quantidade de dias em um m\u00eas, dado o n\u00famero do m\u00eas, definida assim: 1 2 3 4 diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 O que acontece se voc\u00ea passar 7.2 para a fun\u00e7\u00e3o? O resultado est\u00e1 correto? Isso nos leva a perguntar como definir que uma fun\u00e7\u00e3o s\u00f3 \u00e9 aplic\u00e1vel a n\u00fameros inteiros, do tipo inteiro. Em linguagens de programa\u00e7\u00e3o, um tipo \u00e9 um nome dado a uma cole\u00e7\u00e3o de valores que tem um mesmo comportamento na linguagem. Na linguagem C, por exemplo, temos os tipos int e short , ambos associados a valores inteiros mas com n\u00famero de bits diferentes usados para represent\u00e1-los. Algumas linguagens s\u00e3o denominadas fracamente tipadas , o que quer dizer que o uso de tipos \u00e9 relaxado e pode at\u00e9 ser alterado em tempo de execu\u00e7\u00e3o. Por exemplo, no seguinte c\u00f3digo em Python a vari\u00e1vel x assume tr\u00eas tipos diferentes em momentos diferentes da execu\u00e7\u00e3o. 1 2 3 4 5 6 7 8 x = \"lala\" print ( type ( x )) x = 10 print ( type ( x )) x = 10.0 print ( type ( x )) 1 2 3 <class 'str' > <class 'int' > <class 'float' > J\u00e1 a linguagem Haskell \u00e9 o que chamamos de fortemente tipada , o que quer dizer que toda vari\u00e1vel, constante ou fun\u00e7\u00e3o tem apenas um tipo e este sempre pode ser determinado. Al\u00e9m disso, Haskell \u00e9 estaticamente tipada , ou seja, os tipos s\u00e3o determinados em tempo de compila\u00e7\u00e3o, em oposi\u00e7\u00e3o a linguagens que determinam o tipo durante a execu\u00e7\u00e3o do programa, denominadas dinamicamente tipadas. Assim como type em Python, Haskell tem a fun\u00e7\u00e3o : type para verificar o tipo de uma vari\u00e1vel. Por exemplo: 1 2 3 4 5 6 > : type 1 1 :: Num p => p > : type 1.0 1.0 :: Fractional p => p > : type \"Bom dia\" \"Bom dia\" :: [ Char ] Tipos em Haskell Forte Est\u00e1ticos Por Infer\u00eancia Finalmente, se olharmos novamente para os exemplos de fun\u00e7\u00f5es anteriores, veremos que n\u00e3o foram definidos tipos em suas declara\u00e7\u00f5es; isto \u00e9 poss\u00edvel porqu\u00ea Haskell consegue inferir os tipos dos dados de forma muito eficiente. Quando voc\u00ea explicita tipos, o faz apenas para facilitar a leitura do c\u00f3digo e para indicar sua inten\u00e7\u00e3o ao compilador que, pode-se dizer, far\u00e1 a infer\u00eancia e testar\u00e1 se voc\u00ea est\u00e1 certo. Haskell tem um n\u00famero imenso de tipos pre-definidos, organizados hierarquicamente, e que podem ser usados para definir novos tipos pelo programador. Mas por enquanto, nos foquemos nos tipos mais simples.","title":"Tipos"},{"location":"types/#tipos-primitivos-e-operadores","text":"","title":"Tipos Primitivos e Operadores"},{"location":"types/#prototipo-de-funcoes","text":"Agora que j\u00e1 conhecemos alguns tipos, podemos ver como us\u00e1-los na defini\u00e7\u00e3o de fun\u00e7\u00f5es. Para faz\u00ea-lo, devemos usar a seguinte sintaxe: 1 2 nomeFuncao :: tipo_arg1 -> ... -> tipo_argN -> tipo_saida nomeFuncao arg1 ... argN = < definicao > Por exemplo, o prot\u00f3tipo da fun\u00e7\u00e3o diaMes , isto \u00e9, a defini\u00e7\u00e3o dos tipos de entrada e sa\u00edda da fun\u00e7\u00e3o, fica assim: 1 2 3 4 5 diasMes :: Int -> Int diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 Exerc\u00edcios Defina o prot\u00f3tipo da fun\u00e7\u00e3o de convers\u00e3o de Fahrenheit para Celsius f2c x = ( x - 32 ) / 1.8 Descubra a quanto 100f corresponde em C\u00e9lsius Resolu\u00e7\u00e3o 1 2 f2c :: Float -> Float ` f2c x = ( x - 32 ) / 1.8 Defina o prot\u00f3tipo da fun\u00e7\u00e3o de media de dois n\u00fameros reais m2n a b = ( a + b ) / 2 Resolu\u00e7\u00e3o 1 2 m2n :: Float -> Float -> Float m2n a b = ( a + b ) / 2 Defina o prot\u00f3tipo da soma de dois n\u00fameros inteiros soma2int a b = a + b Aplique a fun\u00e7\u00e3o aos valores 2 e 3. Aplique a fun\u00e7\u00e3o aos valores 2.0 e 3.0. Resolu\u00e7\u00e3o 1 2 soma2int :: Int -> Int -> Int soma2int a b = a + b Defina o prot\u00f3tipo da soma de dois n\u00fameros reais soma2reais a b = a + b Aplique a fun\u00e7\u00e3o aos valores 2.0 e 3.0. Aplique a fun\u00e7\u00e3o aos valores 2 e 3. Resolu\u00e7\u00e3o 1 soma2reais :: Float -> Float -> Float Explique a diferen\u00e7a de comportamento das duas \u00faltimas fun\u00e7\u00f5es. Resolu\u00e7\u00e3o As fun\u00e7\u00f5es se comportam diferentemente, sendo que a primeira mostra um erro quando aplicada a dois n\u00fameros reais, porqu\u00ea \\(Z \\subset R\\) mas \\(R \\not\\subset Z\\) .","title":"Prot\u00f3tipo de fun\u00e7\u00f5es"},{"location":"types/#definicao-de-novos-tipos","text":"A palavra reservada type permite que definamos apelidos para tipos no Haskell, tornando o c\u00f3digo mais leg\u00edvel. Por exemplo, podemos definir um tipo Inteiro similar ao tipo Int e fun\u00e7\u00f5es associadas ao tipo. 1 2 3 4 type Inteiro = Int somaInteiros :: Inteiro -> Inteiro -> Inteiro somaInteiros a b = a + b O uso da fun\u00e7\u00e3o \u00e9 como esperado. 1 2 3 4 * Main > somaInteiros 1 2 3 * Main > somaInteiros ( 1 :: Inteiro ) ( 2 :: Inteiro ) 3","title":"Defini\u00e7\u00e3o de novos tipos"},{"location":"types/#type-e-info","text":"O GHC \u00e9 uma ferramenta poderosa no aprendizado da linguagem Haskell por possuir uma s\u00e9rie de comandos que permitem extrair informa\u00e7\u00f5es sobre tipos e fun\u00e7\u00f5es definidas. Usando o comando : info (ou simplesmente : i ), por exemplo, podemos perguntar ao ghci o que ele sabe sobre o tipo Inteiro , ao que ser\u00e1 respondido que \u00e9 o tipo inteiro \u00e9 um apelido para Int , definido no arquivo scratch.hs, no meu caso. 1 2 3 4 * Main > : i Inteiro type Inteiro :: * type Inteiro = Int -- Defined at scratch.hs:82:1 J\u00e1 o comando : type (ou : t ) pode ser usado para identificar o tipo de fun\u00e7\u00f5es, por exemplo: 1 2 3 4 5 6 * Main > somaInteiros 1 2 3 * Main > : i somaInteiros somaInteiros :: Inteiro -> Inteiro -> Inteiro * Main > : t 1 :: Inteiro 1 :: Inteiro :: Inteiro Estes comandos podem ser aplicados a quaisquer defini\u00e7\u00f5es, n\u00e3o somente \u00e0s suas. Por exemplo, podemos solicitar informa\u00e7\u00f5es sobre o tipo Num , com seguinte resultado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 * Main > : i Num type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ( - ) :: a -> a -> a ( * ) :: a -> a -> a negate :: a -> a abs :: a -> a signum :: a -> a fromInteger :: Integer -> a {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-} -- Defined in \u2018GHC.Num\u2019 instance Num Word -- Defined in \u2018GHC.Num\u2019 instance Num Integer -- Defined in \u2018GHC.Num\u2019 instance Num Int -- Defined in \u2018GHC.Num\u2019 instance Num Float -- Defined in \u2018GHC.Float\u2019 instance Num Double -- Defined in \u2018GHC.Float\u2019 Algumas das informa\u00e7\u00f5es apresentadas podem ainda n\u00e3o fazer sentido para voc\u00ea, mas de forma geral podemos resum\u00ed-las como implicando que algumas opera\u00e7\u00f5es, como + , - e abs se aplicam ao tipo Num , e que outros tipos, como Float e Integer s\u00e3o inst\u00e2ncias de Num . Se aplicarmos o mesmo comando ao operador + , descobriremos que ele \u00e9 uma fun\u00e7\u00e3o infixa por padr\u00e3o ( INFIXl ), associativo \u00e0 esquerda ( infixL ), e com prioridade 6. 1 2 3 4 5 6 7 * Main > : i ( + ) type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ... -- Defined in \u2018GHC.Num\u2019 infixl 6 + Tamb\u00e9m vemos que o estas defini\u00e7\u00f5es s\u00e3o parde do GHC.Num, mas o que \u00e9 o GHC.Num?","title":":type e :info"},{"location":"types/#modulos","text":"Como em diversas outras linguagens, Haskell usa m\u00f3dulos para organizar a defini\u00e7\u00e3o de tipos e fun\u00e7\u00f5es, colocando aquelas relacionadas no mesmo m\u00f3dulo. Por padr\u00e3o, o m\u00f3dulo prelude 5 \u00e9 carregado toda vez que executa o ghci ou compila um programa, a n\u00e3o ser que seja explicitamente indicado em contr\u00e1rio. Este m\u00f3dulo cont\u00e9m a defini\u00e7\u00e3o dos tipos e operadores b\u00e1sicos vistos anteriormente, al\u00e9m de muitos outros, e o GHC.Num \u00e9 parte do Prelude. Uma pequena mas interessante amostra de outros tipos inclu\u00eddos: Nome Defini\u00e7\u00e3o min Menor de 2 elementos orden\u00e1veis max Maior de 2 elementos orden\u00e1veis Semigroup Uma classe em que vale a associatividade Monoid Mon\u00f3ide em que h\u00e1 um elemento identidade putChar Escreve um caractere na saida padr\u00e3o putString Escreve uma string na saida padr\u00e3o getChar L\u00ea um caractere da entrada padr\u00e3o getString L\u00ea uma string da entrada padr\u00e3o Estes exemplos servem para mostrar como o m\u00f3dulo mais b\u00e1sico do Haskell \u00e9 diverso e como a sua biblioteca \u00e9 mais diversa ainda. Al\u00e9m do Prelude, centenas de outros m\u00f3dulos est\u00e3o dispon\u00edveis na Web, de compiladores a geradores de gr\u00e1ficos 3D, de transformadas r\u00e1pidas de Fourier a message brokers , em reposit\u00f3rios como o Hackage. 4 Contudo, \u00e9 preciso ter cuidado com os m\u00f3dulos que baixa. Caso voc\u00ea encontre um m\u00f3dulo que queira usar, de nome X , bastar baix\u00e1-lo e usar o import . Por exemplo, para trabalhar com n\u00fameros complexos, voce pode usar o m\u00f3dulo Data . Complex assim: 1 2 3 4 Prelude > import Data.Complex Prelude Data . Complex > let x = 1.0 :+ 0.0 Prelude Data . Complex > x 1.0 :+ 0.0 Com esta visita r\u00e1pida ao Prelude, encerramos esta introdu\u00e7\u00e3o ao Haskell e rumamos para t\u00f3picos mais universais. Isto \u00e9, mesmo que os t\u00f3picos vistos at\u00e9 agora sejam obviamente associados \u00e0 programa\u00e7\u00e3o funcional, os mesmos est\u00e3o fortemente relacionados \u00e0 sintaxe do Haskell. J\u00e1 nas pr\u00f3ximas se\u00e7\u00f5es, veremos t\u00f3picos mais independentes, i.e., mesmo que as fun\u00e7\u00f5es, tipos e construtos usados ainda sejam implementadas em Haskell, os conceitos por tr\u00e1s s\u00e3o mais universais. Operadores s\u00e3o fun\u00e7\u00f5es cujos nomes s\u00f3 contem caracteres especiais. Eles s\u00e3o naturalmente infixos. \u21a9 Observe que o o -10 est\u00e1 entre par\u00eanteses n\u00e3o porque o operador demanda, mas para deixar claro que o - faz parte do n\u00famero. \u21a9 \u21a9 Haskell define tamb\u00e9m o tipo Text, uma forma mais moderna de manipular texto, mas n\u00e3o discutiremos Text aqui. \u21a9 https://hackage.haskell.org/packages/browse \u21a9 Prelude: https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html \u21a9","title":"M\u00f3dulos"},{"location":"where_let_in/","text":"Frequentemente em nossas fun\u00e7\u00f5es, precisamos usar mais de uma vez um valor calculado por outra fun\u00e7\u00e3o. No c\u00e1lculo do \u00edndice de massa corporal a seguir, por exemplo, o valor do \u00edndice \u00e9 recalculado a cada guarda, ou seja, pode ser calculado at\u00e9 3 vezes. 1 2 3 4 imc p a | p / a ^ 2 <= 18.5 = \"Baixo\" | p / a ^ 2 <= 25.0 = \"Normal\" | p / a ^ 2 <= 30.0 = \"Alto\" Para estes casos, Haskell nos d\u00e1 o construto where , que permite fazer defini\u00e7\u00f5es \"locais\" \u00e0 fun\u00e7\u00e3o. Where 1 2 3 4 5 imc p a | imc' <= 18.5 = \"Baixo\" | imc' <= 25.0 = \"Normal\" | imc' <= 30.0 = \"Alto\" where imc' = p / a ^ 2 O c\u00f3digo fica muito mais leg\u00edvel desta forma. O where pode ser at\u00e9 usado m\u00faltiplas vezes, bastando que todas as defini\u00e7\u00f5es estejam perfeitamente indentadas. No exemplo a seguir, fica f\u00e1cil localizar e modificar as defini\u00e7\u00f5es dos v\u00e1rios n\u00edveis de IMC. Ponto para a manutenabilidade! 1 2 3 4 5 6 7 8 imc p a | imc' <= baixo = \"Baixo\" | imc' <= normal = \"Normal\" | imc' <= alto = \"Alto\" where imc' = p / a ^ 2 baixo = 18.5 normal = 25.0 alto = 30.0 where \u00e9 especialmente \u00fatil na defini\u00e7\u00e3o de fun\u00e7\u00f5es recursivas, pois permite nomear as invoca\u00e7\u00f5es, como por exemplo na defini\u00e7\u00e3o da fun\u00e7\u00e3o que calcula os termos da sequ\u00eancia de Fibonacci, com e sem o uso do construto. Sem Where 1 2 3 fib 0 = 0 fib 1 = 1 fib n = fib ( n - 1 ) + fib ( n - 2 ) Com Where 1 2 3 4 5 fib 0 = 0 fib 1 = 1 fib n = prev + prevPrev where prev = fib ( n - 1 ) prevPrev = fib ( n - 2 ) Neste caso pode-se argumentar que n\u00e3o houve ganhos com o mudan\u00e7a, dado que a fun\u00e7\u00e3o \u00e9 muito simples. Em fun\u00e7\u00f5es mais complexas, contudo, os benef\u00edcios em termos de legibilidade aumentam, como na fun\u00e7\u00e3o a seguir. 1 2 3 4 5 6 7 8 9 10 11 12 collatz :: Int -> Int -> Int collatz n i | i == 1 = n | even anterior = anterior ` div ` 2 | otherwise = anterior * 3 + 1 where anterior = collatz n ( i - 1 ) converge :: Int -> Int -> Bool converge n passo | termo == 1 = True | otherwise = converge n ( passo + 1 ) where termo = collatz n passo let-in Um outro construto interessante e com funcionalidade parecida \u00e9 o let in , em que se pode fazer algumas defini\u00e7\u00f5es no let e que ser\u00e3o vis\u00edveis no in . Por exemplo, nas seguintes defini\u00e7\u00f5es. 1 2 3 4 5 6 7 8 9 10 fib 0 = 0 fib 1 = 1 fib n = let prev = fib ( n - 1 ) prevPrev = fib ( n - 2 ) in prev + prevPrev areaCilindro r a = let areaLateral = 2 * pi * r * a areaTopo = pi * r ^ 2 in areaLateral + 2 * areaTopo Nestes exemplos, parece que where e let in s\u00e3o apenas sintaxes diferentes para o mesmo fim, criar defini\u00e7\u00f5es locais. Isso \u00e9 verdade, mas h\u00e1 algumas diferen\u00e7as fundamentais. Primeiro, enquanto o as defini\u00e7\u00f5es feitas no where s\u00e3o amarradas ao contexto da fun\u00e7\u00e3o em que est\u00e3o colocadas, podendo ser vistas em quaisquer outras partes da fun\u00e7\u00e3o, por exemplo guardas, as defini\u00e7\u00f5es feitas no let s\u00e3o muito mais localizadas, v\u00e1lidas apenas dentro do in correspondente. Segundo, let in s\u00e3o express\u00f5es e podem aparecer em qualquer lugar onde uma express\u00e3o \u00e9 esperada. Por exemplo, eles podem ser usados para definir constantes ou fun\u00e7\u00f5es 1 2 3 4 * Main > 1 * ( let um = 1 in um + 1 ) + 1 3 * Main > let quadrado x = x * x in quadrado 3 9 Em alguns contextos em que o escopo \u00e9 muito claro, podemos omitir o in da defini\u00e7\u00e3o. No GHCI, por exemplo, o fizermos, ent\u00e3o a defini\u00e7\u00e3o feita ser\u00e1 v\u00e1lida por toda a execu\u00e7\u00e3o do REPL, ou at\u00e9 que seja sobrescrita. 1 2 3 4 5 6 7 8 9 * Main > let quadrado x = x * x in quadrado 3 9 * Main > quadrado 3 < interactive >: 25 : 1 : error : Variable not in scope : quadrado :: t0 -> t * Main > let quadrado x = x * x * Main > quadrado 3 9","title":"Where e Let-In"}]}