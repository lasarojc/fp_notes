{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Notas de Aula em Programa\u00e7\u00e3o Funcional","title":"Notas de Aula em <br> Programa\u00e7\u00e3o Funcional"},{"location":"#notas-de-aula-em-programacao-funcional","text":"","title":"Notas de Aula em  Programa\u00e7\u00e3o Funcional"},{"location":"functions/","text":"Fun\u00e7\u00f5es Agora que j\u00e1 vimos exemplos extremamente simples, vejamos alguns um pouco mais interessantes, como uma fun\u00e7\u00e3o que soma os n\u00fameros de x a y , inclusive. A t\u00edtulo de compara\u00e7\u00e3o, vejamos primeiro a fun\u00e7\u00e3o em linguagem C. 1 2 3 4 5 6 7 8 int soma ( int x , int y ) { int total = 0 ; for ( int i = x ; i <= y ; i ++ ) total = total + i ; return total ; } soma ( 1 , 10 ); Em Haskell, temos diversas op\u00e7\u00f5es para obter o mesmo resultado, por exemplo, usando uma fun\u00e7\u00e3o recursiva... 1 2 3 4 5 somaDeAte x y = if x < y then x + somaDeAte ( x + 1 ) y else x somaDeAte 1 10 ... ou a fun\u00e7\u00e3o j\u00e1 existente sum , que recebe uma lista de n\u00fameros, neste caso criada pelo operador .. 1 sum [ 1 .. 10 ] Observe que a sintaxe do uso das fun\u00e7\u00f5es, contudo, \u00e9 diferente; em Haskell, usa-se o nome da fun\u00e7\u00e3o, seguido dos par\u00e2metros, com espa\u00e7o os separando. J\u00e1 a defini\u00e7\u00e3o de fun\u00e7\u00f5es segue algumas estruturas b\u00e1sicas, sendo a mais simples a defini\u00e7\u00e3o via equa\u00e7\u00e3o . Equa\u00e7\u00f5es Por exemplo, consideremos uma fun\u00e7\u00e3o que soma dois n\u00fameros. Em Haskell, ela \u00e9 definida simplesmente como soma x y = x + y e usada como soma 3 5 . Exerc\u00edcio: Soma Defina a fun\u00e7\u00e3o soma e a use, de acordo com a imagem. 1 Como outro exemplo, definamos uma fun\u00e7\u00e3o que retorna o sucessor de um inteiro como sucessor x = x + 1 . Com estas duas fun\u00e7\u00f5es, podemos inclusive compor fun\u00e7\u00f5es, no melhor estilo \\(g(f(x))\\) , por exemplo: sucessor ( soma 3 4 ) ou sucessor ( sucessor ( sucessor 4 )) . Exerc\u00edcio: Composi\u00e7\u00e3o Defina uma fun\u00e7\u00e3o que multiplique 3 n\u00fameros, isto \u00e9, dados \\(x\\) , \\(y\\) e \\(z\\) , calcule \\(x*y*z\\) . Calcule \\((1 + (3 * 2 * 3)) + (5 * 3 * 2)\\) usando as fun\u00e7\u00f5es de soma e multiplica\u00e7\u00e3o definidas. Resolu\u00e7\u00e3o Defina as fun\u00e7\u00f5es 1 2 3 soma x y = x + y mult3 x y z = x * y * z Invoque soma ( soma 1 ( mult3 3 2 3 )) ( mult3 5 3 2 ) . Observe que os par\u00eanteses s\u00e3o necess\u00e1rios para delimitar os par\u00e2metros de cada uma das invoca\u00e7\u00f5es. Exerc\u00edcio: m\u00e9dia de 3 n\u00fameros Defina uma fun\u00e7\u00e3o que calcule a m\u00e9dia de 3 n\u00fameros Resolu\u00e7\u00e3o media x y z = ( x + y + z ) / 3 Exerc\u00edcio: \u00e1rea das figuras Defina uma fun\u00e7\u00e3o o c\u00e1lculo da \u00e1rea de cada figura geom\u00e9trica. Resolu\u00e7\u00e3o 1 2 3 4 5 areaQuad a = a * a areaRet a b = a * b areaCirc r = pi * r * r areaTri a h = ( a * h ) / 2 areaTra a b h = ( a + b ) / 2 * h Se voc\u00ea se logar no Repl.it, poder\u00e1 salvar seus arquivos online e edit\u00e1-los de qualquer lugar, como no exemplo dado no exerc\u00edcio. \u21a9","title":"Fun\u00e7\u00f5es"},{"location":"functions/#funcoes","text":"Agora que j\u00e1 vimos exemplos extremamente simples, vejamos alguns um pouco mais interessantes, como uma fun\u00e7\u00e3o que soma os n\u00fameros de x a y , inclusive. A t\u00edtulo de compara\u00e7\u00e3o, vejamos primeiro a fun\u00e7\u00e3o em linguagem C. 1 2 3 4 5 6 7 8 int soma ( int x , int y ) { int total = 0 ; for ( int i = x ; i <= y ; i ++ ) total = total + i ; return total ; } soma ( 1 , 10 ); Em Haskell, temos diversas op\u00e7\u00f5es para obter o mesmo resultado, por exemplo, usando uma fun\u00e7\u00e3o recursiva... 1 2 3 4 5 somaDeAte x y = if x < y then x + somaDeAte ( x + 1 ) y else x somaDeAte 1 10 ... ou a fun\u00e7\u00e3o j\u00e1 existente sum , que recebe uma lista de n\u00fameros, neste caso criada pelo operador .. 1 sum [ 1 .. 10 ] Observe que a sintaxe do uso das fun\u00e7\u00f5es, contudo, \u00e9 diferente; em Haskell, usa-se o nome da fun\u00e7\u00e3o, seguido dos par\u00e2metros, com espa\u00e7o os separando. J\u00e1 a defini\u00e7\u00e3o de fun\u00e7\u00f5es segue algumas estruturas b\u00e1sicas, sendo a mais simples a defini\u00e7\u00e3o via equa\u00e7\u00e3o .","title":"Fun\u00e7\u00f5es"},{"location":"functions/#equacoes","text":"Por exemplo, consideremos uma fun\u00e7\u00e3o que soma dois n\u00fameros. Em Haskell, ela \u00e9 definida simplesmente como soma x y = x + y e usada como soma 3 5 . Exerc\u00edcio: Soma Defina a fun\u00e7\u00e3o soma e a use, de acordo com a imagem. 1 Como outro exemplo, definamos uma fun\u00e7\u00e3o que retorna o sucessor de um inteiro como sucessor x = x + 1 . Com estas duas fun\u00e7\u00f5es, podemos inclusive compor fun\u00e7\u00f5es, no melhor estilo \\(g(f(x))\\) , por exemplo: sucessor ( soma 3 4 ) ou sucessor ( sucessor ( sucessor 4 )) . Exerc\u00edcio: Composi\u00e7\u00e3o Defina uma fun\u00e7\u00e3o que multiplique 3 n\u00fameros, isto \u00e9, dados \\(x\\) , \\(y\\) e \\(z\\) , calcule \\(x*y*z\\) . Calcule \\((1 + (3 * 2 * 3)) + (5 * 3 * 2)\\) usando as fun\u00e7\u00f5es de soma e multiplica\u00e7\u00e3o definidas. Resolu\u00e7\u00e3o Defina as fun\u00e7\u00f5es 1 2 3 soma x y = x + y mult3 x y z = x * y * z Invoque soma ( soma 1 ( mult3 3 2 3 )) ( mult3 5 3 2 ) . Observe que os par\u00eanteses s\u00e3o necess\u00e1rios para delimitar os par\u00e2metros de cada uma das invoca\u00e7\u00f5es. Exerc\u00edcio: m\u00e9dia de 3 n\u00fameros Defina uma fun\u00e7\u00e3o que calcule a m\u00e9dia de 3 n\u00fameros Resolu\u00e7\u00e3o media x y z = ( x + y + z ) / 3 Exerc\u00edcio: \u00e1rea das figuras Defina uma fun\u00e7\u00e3o o c\u00e1lculo da \u00e1rea de cada figura geom\u00e9trica. Resolu\u00e7\u00e3o 1 2 3 4 5 areaQuad a = a * a areaRet a b = a * b areaCirc r = pi * r * r areaTri a h = ( a * h ) / 2 areaTra a b h = ( a + b ) / 2 * h Se voc\u00ea se logar no Repl.it, poder\u00e1 salvar seus arquivos online e edit\u00e1-los de qualquer lugar, como no exemplo dado no exerc\u00edcio. \u21a9","title":"Equa\u00e7\u00f5es"},{"location":"guards/","text":"Vamos definir uma fun\u00e7\u00e3o que retorne o nome do m\u00eas, dado o seu n\u00famero. Seria poss\u00edvel escreve esta fun\u00e7\u00e3o com if aninhados, assim. 1 2 3 4 5 6 nomeMes m = if m == 1 then \"JAN\" else if m == 2 then \"FEB\" else if m == 3 then \"MAR\" ... else if m == 11 then \"NOV\" else \"DEZ\" Esta estrutura, contudo, pode ser simplificada com o uso guardas , uma op\u00e7\u00e3o que faz sentido quando os par\u00e2metros de uma fun\u00e7\u00e3o podem ser classificados em grupos. Guardas tem a seguinte sintaxe, onde o otherwise \u00e9 opcional e serve para cobrir todos os outros casos . 1 2 3 4 5 6 nomeFuncao arg1 ... argN | < condicao1 > = < definicao1 > | < condicao2 > = < definicao2 > ... | < condicaoM > = < definicaoM > | [ otherwise ] = < definicaoO > Especificamente, o exemplo do c\u00e1lculo do nome dos meses ficaria assim: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 nomeMes m | m == 1 = \"JAN\" | m == 2 = \"FEV\" | m == 3 = \"MAR\" | m == 4 = \"ABR\" | m == 5 = \"MAI\" | m == 6 = \"JUN\" | m == 7 = \"JUL\" | m == 8 = \"AGO\" | m == 9 = \"SET\" | m == 10 = \"OUT\" | m == 11 = \"NOV\" | m == 12 = \"DEZ\" | m == 13 = \"ONZ\" Outras observa\u00e7\u00f5es tamb\u00e9m s\u00e3o importantes. Primeiro, as condi\u00e7\u00f5es podem ser mais complexas que um simples teste, podendo incluir m\u00faltiplos testes e computa\u00e7\u00f5es; a \u00fanica condi\u00e7\u00e3o \u00e9 que retorne um booleano. Vejamos uma fun\u00e7\u00e3o que calcula o maior entre tr\u00eas n\u00fameros. 1 2 3 4 maiorDeTres a b c | a >= b && a >= c = a | b >= c = b | otherwise = c Segundo, as condi\u00e7\u00f5es s\u00e3o testadas de cima para baixo e isso \u00e9 importante porqu\u00ea alguns par\u00e2metros podem satisfazer mais de uma condi\u00e7\u00e3o. Vejamos novamente o caso do c\u00e1lculo de anos bissextos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 {- >>>bissexto 5 False >>>bissexto 200 False >>>bissexto 2000 True >>>bissexto 1996 True >>>bissexto 1900 False -} bissexto x | mod x 4 /= 0 = False -- N\u00e3o divis\u00edveis por 4 | mod x 400 == 0 = True -- Divis\u00edveis por 4 e por 400 | mod x 100 == 0 = False -- Divis\u00edveis por 4, n\u00e3o por 400, e por 100 | otherwise = True -- Divis\u00edveis por 4, e n\u00e3o por 100 Observe que se a terceira e segunda guardas fossem invertidas, o ano 1900 seria considerado bissexto, quando na verdade ele n\u00e3o \u00e9. Exerc\u00edcio Escreva uma fun\u00e7\u00e3o que receba um n\u00famero representando um m\u00eas, um n\u00famero de 1 a 12, e retorne a quantidade de dias no m\u00eas. Assuma que fevereiro sempre tem 28 dias. Resolu\u00e7\u00e3o 1 2 3 4 diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 \u00cdndice de massa corporal O \u00edndice de massa corporal, IMC, \u00e9 calculado como o peso dividido pelo quadrado da altura. Um IMC abaixo de 18,5, inclusive, \u00e9 considerado baixo e acima de 30 \u00e9 considerado alto; aqueles no intervalo s\u00e3o considerados normais. Defina uma fun\u00e7\u00e3o que, dados peso e altura, decida se o IMC correspondente \u00e9 Baixo, Normal ou Alto. Resolu\u00e7\u00e3o 1 2 3 4 5 imc p a | p / a ^ 2 <= 18.5 = \"Baixo\" | p / a ^ 2 <= 25.0 = \"Normal\" | p / a ^ 2 <= 30.0 = \"Alto\" | otherwise otherwise \u00e9 verdade Uma curiosidade sobre o uso de guardas \u00e9 que o caso final, que pega todas as outras op\u00e7\u00f5es, poderia ser definido como um guarda em que a condi\u00e7\u00e3o \u00e9 sempre verdadeira, como no seguinte exemplo: 1 2 3 4 maiorDeTres a b c | a >= b && a >= c = a | b >= c = b | True = c De fato, se usarmos o ghci para obtermos mais informa\u00e7\u00f5es sobre otherwise , veremos que \u00e9 uma constante, cujo valor \u00e9 True . Isso serve para ilustrar o poder da linguagem, que tem um conjunto reduzido de palavras chave que \u00e9 estendida usando suas funcionalidades b\u00e1sicas. 1 2 3 4 Prelude> :i otherwise otherwise :: Bool -- Defined in \u2018GHC.Base\u2019 Prelude> otherwise True Ainda sobre guardas, quando a condi\u00e7\u00e3o testada \u00e9 de igualdade dos par\u00e2metros com algum valor, temos uma terceira forma de definir fun\u00e7\u00f5es que precisam testar v\u00e1rios casos, al\u00e9m de usar if - then - else e guardas: Casamento de padr\u00f5es .","title":"Guardas"},{"location":"haskell101/","text":"A primeira vers\u00e3o da linguagem Haskell, cujo nome \u00e9 uma homenagem ao matem\u00e1tico e l\u00f3gico Haskell B. Curry , apareceu em 1987 do esfor\u00e7o para se consolidar v\u00e1rios avan\u00e7os propostos no paradigma funcional, sendo famosa por ser uma linguagem funcional pura , de prop\u00f3sito geral e por ter caracter\u00edsticas marcantes como avalia\u00e7\u00e3o pregui\u00e7osa , e tipagem est\u00e1tica , forte e por infer\u00eancia , como discutiremos mais adiante. Mais do que uma linguagem, Haskell era uma especifica\u00e7\u00e3o, ou s\u00e9rie de especifica\u00e7\u00f5es, tendo tido v\u00e1rias implementa\u00e7\u00f5es distintas. A vers\u00e3o de 98 foi um marco da linguagem, sendo uma vers\u00e3o considerada est\u00e1vel. Nesta \u00e9poca surgiu o Glasgow Haskell Compiler (GHC), que se tornou o compilador Haskell \"padr\u00e3o\". A vers\u00e3o seguinte da linguagem come\u00e7ou a ser especificada em 2006 e anunciada em 2009, a Haskell 2010. Dentre os principais avan\u00e7os desta vers\u00e3o est\u00e1 a possibilidade de interagir com c\u00f3digo escrito em outras linguagens, via a foreign function interface (FFI). Mas chega de hist\u00f3ria e vamos colocar a m\u00e3o na massa vendo alguns exemplos extremamente simples da linguagem. Exemplos simples Para exemplos mais complexos, voc\u00ea dever\u00e1 instalar o compilador Haskell na sua m\u00e1quina, seguindo as instru\u00e7\u00f5es espec\u00edficas, 2 mas para pequenos experimentos e exerc\u00edcios, podemos usar o Repl.It 1 . Do lado direito do s\u00edtio, na \u00e1rea marcada em vermelho, digite ghci seguido de Enter . Agora digite as express\u00f5es a seguir. 1 2 3 4 5 6 7 8 9 10 11 1 + 1 True && True 100 / 10 ( 10 + 4 ) * 50 3 * ( - 2 ) 2 * - 1 Estas express\u00f5es fazem uso de operadores comuns e se comportam exatamente como voc\u00ea esperaria, depois de ter aprendido a programar em qualquer linguagem, em qualquer paradigma. Operadores s\u00e3o a\u00e7\u00facar sint\u00e1tico para fun\u00e7\u00f5es, a alma da programa\u00e7\u00e3o funcional. REPL \u00e9 o acr\u00f4nimo para Read, Evaluate, Print, Loop. \u21a9 Instru\u00e7\u00f5es de como instalar o GHC s\u00e3o espec\u00edficas para cada sistema operacional. Por isso, consulte o s\u00edtio https://www.haskell.org/platform/ para instalar o Haskell na sua m\u00e1quina. \u21a9","title":"Haskell 1+1"},{"location":"ifthenelse/","text":"Voc\u00ea como saberia calcular o maior de dois n\u00fameros \\(a\\) e \\(b\\) sem usar um teste do tipo se ent\u00e3o sen\u00e3o ? \u00c9 bem interessante; assuma \\(M\\) maior e \\(m\\) menor entre \\(a\\) e \\(b\\) . \\[\\begin{eqnarray} M &=& (M + M)/2 \\nonumber \\\\ &=& (M + m + M - m)/2 \\nonumber \\\\ &=& (M + m + (M-m))/2 \\nonumber \\\\ &=& (M + n + \\|M-m\\|)/2 \\nonumber \\\\ &=& (a + b + \\|a - b\\|)/2 \\nonumber \\end{eqnarray}\\] Em outras palavras, o maior entre dois n\u00fameros \\(a\\) e \\(b\\) \u00e9 igual \u00e0 m\u00e9dia dos n\u00fameros \\(a\\) e \\(b\\) , mais a metade da diferen\u00e7a entre \\(a\\) e \\(b\\) . Logo, em Haskell, temos 1 maior x y = ( x + y + ( abs ( x - y ))) / 2 Estou certo de que voc\u00ea concordar\u00e1 que calcular o maior entre dois n\u00fameros deveria ser muito mais simples que isso, especialmente porqu\u00ea naquele abs provavelmente h\u00e1 um if escondido. \\[ f(a,b)= \\begin{cases} a,& \\text{if } a\\geq b\\\\ b, & \\text{otherwise} \\end{cases} \\] Mas como faz\u00ea-lo em Haskell, isto \u00e9, como testar uma condi\u00e7\u00e3o sobre os valores para decidir a forma correta de computar o resultado? Usando uma express\u00e3o de sele\u00e7\u00e3o, isto \u00e9, if ... then ... else ... Veja o exemplo da escolha do maior n\u00famero. 1 2 maior x y = if x > y then x else y Observe que, diferentemente de outras linguagens em que se pode usar o if para decidir entre fazer ou n\u00e3o uma computa\u00e7\u00e3o, o if do Haskell serve para decidir entre duas computa\u00e7\u00f5es. Isto \u00e9, o if deve sempre ser seguido do then e do else . Observe tamb\u00e9m que o if pode estar em qualquer parte da express\u00e3o, porqu\u00ea este construto \u00e9 tamb\u00e9m uma express\u00e3o. Por exemplo, imagine que queira somar um n\u00famero inteiro com o valor absoluto de outro n\u00famero, sem usar o abs . 1 somaEstranha x y = x + ( if y < 0 then - y else y ) Com esta defini\u00e7\u00e3o, tanto somaEstranha 1 2 quanto somaEstranha 1 (-2) resultam em 3. Mas este exemplo \u00e9 muito estranho, ent\u00e3o pensemos em um mais \u00fatil. Exerc\u00edcio Implemente uma fun\u00e7\u00e3o que calcule se um ano \u00e9 bissexto sabendo que: Se o n\u00e3o \u00e9 m\u00faltiplo de 4, n\u00e3o \u00e9 bissexto. Se \u00e9 m\u00faltiplo de 4 e n\u00e3o \u00e9 m\u00faltiplo de 100, ent\u00e3o \u00e9 bissexto. Se \u00e9 m\u00faltiplo de 100 e n\u00e3o \u00e9 m\u00faltiplo de 400, ent\u00e3o n\u00e3o \u00e9 bissexto. Se \u00e9 m\u00faltiplo de 400, ent\u00e3o \u00e9 bissexto. Resolu\u00e7\u00e3o 1 2 3 4 bissexto x = if mod x 4 /= 0 then False else if mod x 100 /= 0 then True else if mod x 400 == 0 then True else False Aninhar if assim pode funcionar, mas leva a estruturas estranhas e dif\u00edceis de serem lidas. H\u00e1 formas melhores de se lidar com m\u00faltiplas possibilidades de computa\u00e7\u00e3o.","title":"If Then Else"},{"location":"intro/","text":"Introdu\u00e7\u00e3o Embora este curso assuma que voc\u00ea j\u00e1 saiba programar em alguma linguagem, ou exatamente por isso, \u00e9 importante que fa\u00e7amos uma revis\u00e3o de algumas ideias b\u00e1sicas de programa\u00e7\u00e3o antes de mergulharmos no paradigma funcional, para que possamos melhor posicionar este paradigma com em rela\u00e7\u00e3o aos demais. Paradigmas de Programa\u00e7\u00e3o Programar um computador consiste em comunicar ao computador instru\u00e7\u00f5es para que ele resolva problemas. E a comunica\u00e7\u00e3o entre duas entidades s\u00f3 \u00e9 poss\u00edvel se usarem uma linguagem em comum, isto \u00e9, dominada pelas duas partes. Comunica\u00e7\u00e3o A\u00e7\u00e3o ou efeito de comunicar, de transmitir ou de receber ideias, conhecimento, mensagens etc., buscando compartilhar informa\u00e7\u00f5es. 1 Comunica\u00e7\u00e3o Linguagens naturais Linguagens de programa\u00e7\u00e3o Quando humanos se comunicam, usam uma linguagens naturais , como o portugu\u00eas, libras, ou canton\u00eas. Linguagens naturais s\u00e3o altamente expressivas, cheias de nuances e depend\u00eancias do contexto, o que lhes confere grande poder, mas tamb\u00e9m a grande fraqueza de permitirem a constru\u00e7\u00e3o de mensagens amb\u00edguas. A comunica\u00e7\u00e3o entre computadores ou computares e humanos, contudo, precisa ser feita de forma precisa, e por isso linguagens naturais n\u00e3o s\u00e3o boas neste contexto, apesar do grande esfor\u00e7o dispendido e da evolu\u00e7\u00e3o do processamento de linguagens naturais, como as \"alexas\" e \"siris\" do mundo podem provar. A comunica\u00e7\u00e3o entre computadores \u00e9 feita por um protocolo de comunica\u00e7\u00e3o, assunto para outro curso. J\u00e1 a comunica\u00e7\u00e3o entre humanos e computadores, na programa\u00e7\u00e3o do computador, \u00e9 feita por meio de linguagens de programa\u00e7\u00e3o , que s\u00e3o muito mais restritas que as linguagens naturais e, por isso, n\u00e3o amb\u00edguas. Linguagem de Programa\u00e7\u00e3o A linguagem de programa\u00e7\u00e3o \u00e9 um m\u00e9todo padronizado, formado por um conjunto de regras sint\u00e1ticas e sem\u00e2nticas, de implementa\u00e7\u00e3o de um c\u00f3digo fonte - que pode ser compilado e transformado em um programa de computador, ou usado como script interpretado - que informar\u00e1 instru\u00e7\u00f5es de processamento ao computador. 2 A n\u00e3o ambiguidade das linguagens de programa\u00e7\u00e3o do fato de terem uma sintaxe e sem\u00e2nticas precisas, descritas por uma gram\u00e1tica tamb\u00e9m precisa. Sintaxe A sintaxe de uma linguagem descreve o que constitui um programa estruturalmente correto e \u00e9 definida por uma gram\u00e1tica. Sem\u00e2ntica O significado de um programa \u00e9 definido por sua sem\u00e2ntica, ou seja, por regras que definem como as instru\u00e7\u00f5es especificado devem ser interpretadas. Serem precisas n\u00e3o quer dizer que as linguagens sejam simples, como demonstra claramente a seguinte imagem, que \u00e9 um programa \u00e9 um \"hello world\" na linguagem Piet . Tamb\u00e9m n\u00e3o quer dizer que sejam limitadas. De fato, h\u00e1 milhares linguagens de programa\u00e7\u00e3o por a\u00ed, e contando, com diferentes caracter\u00edsticas que as tornam mais mais ou menos apropriadas para resolver diferentes problemas. Mas mesmo apesar de t\u00e3o grande n\u00famero, as linguagens podem ser classificadas em grandes fam\u00edlias ou paradigmas. Imperativo x Descritivo Imperativo x Descritivo Imperativo: como Descritivo: o qu\u00ea Os primeiros \"computadores\" eram m\u00e1quinas que computavam mecanicamente seus resultados. Uma segunda gera\u00e7\u00e3o, da qual destacamos o ENIAC (circa 1955), eram computadores sem parte mec\u00e2nicas, programados por conex\u00f5es el\u00e9tricas de suas diversas partes. O pr\u00f3ximo passo, foram computadores que interpretavam c\u00f3digo escrito em uma linguagem de programa\u00e7\u00e3o. Estas primeiras linguagens eram todas imperativas , no sentido de que ditavam ao computador uma sequ\u00eancia de instru\u00e7\u00f5es a serem seguidas para se chegar a um resultado. Isto \u00e9, estas linguagens permitiam ao programador dizer como realizar uma computa\u00e7\u00e3o. Imperativo leia a linha 1 do arquivo separe a linha por espa\u00e7os pegue a segunda parte da linha converta a parte para n\u00famero se o n\u00famero for maior que 15, escreva na tela leia a pr\u00f3xima linha do arquivo volte para o passo 2 Este paradigma tem suas ra\u00edzes no modelo computacional cl\u00e1ssico de von Neumann e na m\u00e1quina de Turing Em contrapartida a este modelo, surgiram mais tarde linguagens declarativas , em que o programado diz o qu\u00ea deve ser computado e o computador se encarrega de achar um \"como\". Descritivo selecione todas as linhas em que a segunda parte \u00e9 maior que 15 Com uma an\u00e1lise r\u00e1pida das linguagens mais conhecidas, voce deve reconhecer a maior parte como imperativas, por exemplo, C, Java, e Python. J\u00e1 dentre as linguagens declarativas, se destacam SQL, LINQ, e Prolog. Ortogonalmente ao foco em no \"como x o qu\u00ea\", podemos nos focar em como as estas instru\u00e7\u00f5es s\u00e3o organizadas mais em um n\u00edvel mais alto, de onde se destacam quatro paradigmas principais: procedimental , orientado a objetos , l\u00f3gico e funcional . 3 Procedimental Linguagens que usam o paradigma procedimental organizam instru\u00e7\u00f5es em blocos, denominados procedimentos, de onde vem o nome, ou fun\u00e7\u00f5es. A ideia \u00e9 que o c\u00f3digo seja modularizado para separar funcionalidades e tornar o c\u00f3digo mais compreens\u00edvel e manuten\u00edvel. Cada fun\u00e7\u00e3o deve executar uma opera\u00e7\u00e3o bem espec\u00edfica, fun\u00e7\u00f5es associadas s\u00e3o colocadas em um mesmo arquivo, e arquivos associados s\u00e3o colocados em um mesmo namespace . O c\u00f3digo seguinte, em C, mostra a fun\u00e7\u00e3o main , ponto de entrada do programa e de onde a fun\u00e7\u00e3o printf , importada de stdio.h , \u00e9 invocada. 1 2 3 4 5 #include <stdio.h> int main () { printf ( \"Hello, World!\" ); return 0 ; } Al\u00e9m da linguagem C, outros exemplos \u00f3bvios deste paradigma s\u00e3o as linguagens Pascal, Fortran e Python. Contudo, mesmo linguagens como Java e C++ podem ser consideradas procedurais, uma vez que organizam a computa\u00e7\u00e3o em m\u00e9todos, que s\u00e3o nada mais que fun\u00e7\u00f5es. Mas como m\u00e9todos est\u00e3o fortemente associados a classes e suas inst\u00e2ncias, os objetos, estas linguagens s\u00e3o melhor classificadas como orientadas a objetos. Orientado a Objetos Na orienta\u00e7\u00e3o a objetos, o foco est\u00e1 n\u00e3o na execu\u00e7\u00e3o passo a passo de fun\u00e7\u00f5es, mas na organiza\u00e7\u00e3o de dados e fun\u00e7\u00f5es associadas em objetos. Embora esta organiza\u00e7\u00e3o possa ser feita em qualquer qualquer linguagem estruturada, a sintaxe das linguagens orientadas a objeto facilita e tornam mais natural este trabalho. Dois conceitos b\u00e1sicos na orienta\u00e7\u00e3o a objetos s\u00e3o as classes e os objetos . Classes s\u00e3o abstra\u00e7\u00f5es de tipos de coisas encontrados no mundo real, ou seja, receitas de estruturas de dados e definem quais os dados devem ser considerados em conjunto para representar um objeto e quais as a\u00e7\u00f5es associadas a este objeto. Por exemplo, se no mundo real cachorros tem uma data de nascimento e um nome, e s\u00e3o capazes de latir, uma classe que represente cachorros pode ser definida assim em Java. 1 2 3 4 5 6 7 8 9 10 11 class Cachorro { int diaNascimento ; int mesNascimento ; int anoNascimento ; String nome ; void latir ( int quantidade ) { for ( int i = 0 ; i < quantidade ; i ++ ) System . out . println ( nome + \": Au!\" ); } } J\u00e1 um objeto \u00e9 uma inst\u00e2ncia de uma classe, uma representa\u00e7\u00e3o de um tipo mas de uma coisa em si. Um c\u00e3o qualquer poderia ser representado assim 1 2 Cachorro cachorro1 = new Cachorro ( 25 , 12 , 2020 , \"Napole\u00e3o\" ); cachorro1 . latir ( 3 ); e a execu\u00e7\u00e3o deste c\u00f3digo resultaria em 1 2 3 Napole\u00e3o: Au! Napole\u00e3o: Au! Napole\u00e3o: Au! Observe que o \".\" em cachorro1.latir(3) quer dizer \"executar a fun\u00e7\u00e3o latir no objeto cachorro1 \", o que leva \u00e0 string Napole\u00e3o a aparecer antes de cada latido. Duas coisas poder ser ditas sobre este \".\". Primeiro, que ele n\u00e3o \u00e9 necess\u00e1rio, o objeto em si poderia ser passado como par\u00e2metro para uma fun\u00e7\u00e3o latir que recebesse o objeto al\u00e9m da quantidade de latidos; de fato, em Python, a classe seria definida como a seguir 1 2 3 4 5 6 7 8 9 class Cachorro : diaNascimento mesNascimento anoNascimento nome def latir ( self , quantidade ): for i in range ( 0 , quantidade ): print ( self . nome + \": Au!\" ) o que implica que o \".\" \u00e9 o s\u00f3 a\u00e7\u00facar sint\u00e1tico para a execu\u00e7\u00e3o de uma fun\u00e7\u00e3o, o que nos leva ao segundo ponto. Na orienta\u00e7\u00e3o a objetos conceitual, n\u00e3o se fala em invoca\u00e7\u00e3o de fun\u00e7\u00f5es mas de sinais sendo transmitidos entre objetos: envie mensagem para o 2 \"somar-se com 3\", ao que o objeto 2 responderia com uma mensagem \"refer\u00eancia ao objeto 4\". Em Smalltalk, esta intera\u00e7\u00e3o seria escrita assim: 1 x := 2 + 3 . Grande parte do poder da orienta\u00e7\u00e3o objetos est\u00e1 no encapsulamento do como opera\u00e7\u00f5es s\u00e3o executadas, nos m\u00e9todos. Uma outra ordem de encapsulamento, de outro tipo, \u00e9 encontrada no paradigma l\u00f3gico. L\u00f3gico No paradigma l\u00f3gico, voc\u00ea declara-se fatos b\u00e1sicos e regras sobre como os fatos se relacionam e pergunta ao programa se certos fatos s\u00e3o ou n\u00e3o s\u00e3o verdade. Por exemplo, como fatos, podemos declarar 1 2 3 4 5 eh_maior_que ( gato , rato ). eh_maior_que ( leao , gato ). eh_maior_que ( elefante , leao ). eh_maior_que ( elefante , moto ). eh_maior_que ( legal , cachorro ). que vale a transitividade 1 2 3 eh_maior_que ( A , B ) :- eh_maior_que ( A , C ), eh_maior_que ( C , B ). e, finalmente, perguntar se elefante \u00e9 maior rato 1 eh_maior_que ( elefante , rato ). ao que seremos respondidos com um \"sim\". Voc\u00ea consegue imaginar quantas linhas de c\u00f3digo voc\u00ea precisaria para expressar a mesma l\u00f3gica acima em uma linguagem como C ou Java? Apesar do claro poder deste paradigma, o mesmo tem poucos representantes, como Prolog e Mercury, e mesmo que exista v\u00e1rios compiladores do primeiro, o uso comercial do paradigma \u00e9 bem limitado. Funcional A programa\u00e7\u00e3o, como indicado pelo nome, \u00e9 focada na organiza\u00e7\u00e3o do processamento em termos de fun\u00e7\u00f5es, mas de uma forma diferente da programa\u00e7\u00e3o procedimental. De forma geral, fun\u00e7\u00f5es s\u00e3o blocos de c\u00f3digo criadas essencialmente para se obter reusabilidade : uma vez definidas, as fun\u00e7\u00f5es podem ser invocadas repetidas vezes para executar a mesma tarefa sobre diferentes par\u00e2metros , sempre retornando um resultado. 4 Mas enquanto na programa\u00e7\u00e3o procedimental a invoca\u00e7\u00e3o de uma fun\u00e7\u00e3o pode retornar diferentes resultados mesmo quando os par\u00e2metros s\u00e3o os mesmos, na programa\u00e7\u00e3o funcional, fun\u00e7\u00f5es s\u00e3o como na matem\u00e1tica, isto \u00e9, mapeiam uma entrada para exatamente uma sa\u00edda, sempre. Isto \u00e9, fun\u00e7\u00f5es resolvem o problema sem se basear em nada al\u00e9m dos par\u00e2metros passados e sem efeitos colaterais. Mas e as fun\u00e7\u00f5es que tem efeitos colaterais? Estas n\u00e3o s\u00e3o fun\u00e7\u00f5es \"de verdade\" e n\u00e3o \u00e9 a toa que outro nome usado para os blocos de c\u00f3digo \u00e9 procedimento e que para discernir entre fun\u00e7\u00f5es que tem efeitos colaterais e que n\u00e3o n\u00e3o, chamamos de puras as do segundo tipo. Vejamos alguns exemplos. As fun\u00e7\u00f5es seguintes, definidas em Erlang, calculam A+B , A*C e (A+B)*(A+B) e, independentemente de quantas vezes voc\u00ea o fizer, add(2,3) sempre retornar\u00e1 5 . 1 2 3 4 5 6 7 8 add ( A , B ) -> A + B . mult ( A , B ) -> A * B . mult_add ( A , B ) -> mult ( add ( A , B ), add ( A , B )). Agora observe a fun\u00e7\u00e3o seguinte, escritas em Python; a cada invoca\u00e7\u00e3o, a vari\u00e1vel acc tem seu valor alterado e mesmo que invocada com a mesma entrada, o resultado da fun\u00e7\u00e3o \u00e9 sempre diferente. Os efeitos externos \u00e0 fun\u00e7\u00e3o, e.g., a altera\u00e7\u00e3o da vari\u00e1vel acc , \u00e9 conhecido efeito colateral . Programa\u00e7\u00e3o funcional n\u00e3o tem tem efeitos colaterais por que trata vari\u00e1veis n\u00e3o como \u00e1reas de mem\u00f3ria alter\u00e1veis, mas como inc\u00f3gnitas, como na matem\u00e1tica. Pelo menos esta \u00e9 a ideia de programa\u00e7\u00e3o funcional pura, que \u00e9 essencialmente a escrita de longu\u00edssimas equa\u00e7\u00f5es. Acontece que devido \u00e0 complexidade inerente do uso de programa\u00e7\u00e3o funcional pura, sem efeitos colaterais, i.e., sem muta\u00e7\u00e3o de estados, muitas linguagens n\u00e3o s\u00e3o puramente funcionais. A raz\u00e3o mais comum para efeitos colaterais \u00e9 a realiza\u00e7\u00e3o de Entrada/Sa\u00edda. Por exemplo, ao invocar print no Python, o terminal tem seu estado alterado, e cada nova invoca\u00e7\u00e3o altera mais o estado. Assim, podemos dividir as linguagens e funcionais puras, funcionais n\u00e3o puras e n\u00e3o funcionais, mas mesmo dentro das n\u00e3o funcionais, h\u00e1 aquelas com elementos de programa\u00e7\u00e3o funcional. \"Funcionalidades\" Muitas linguagens modernas, como Python e JavaScript, embora n\u00e3o estritamente funcionais, tem diversos elementos de programa\u00e7\u00e3o funcional, eu diretamente na linguagem ou via frameworks . Python, por exemplo, v\u00e1rias funcionalidades caracter\u00edsticas do paradigma funcional, embora seja poss\u00edvel ignor\u00e1-las por completo. Por exemplo, imagine que voc\u00ea queira criar uma lista com o quadrado de todos os n\u00fameros de 1 a x . Voc\u00ea pode optar por um for cl\u00e1ssico ... 1 2 3 4 5 def quads ( x ): lista = [] for i in range ( 1 , x ): lista . append ( i * i ) return lista ... ou uma compreens\u00e3o de listas , como nos exemplos a seguir. 1 2 def quads2 ( x ): return [ e ** 2 for e in range ( 1 , x )] Al\u00e9m disso, h\u00e1 linguagens funcionais que tamb\u00e9m se enquadram em outros paradigmas e que podem ser consideradas h\u00edbridas, ou multi-paradigma. Multi-paradigmas Muitas linguagens modernas podem ser classificadas ao mesmo tempo em muitos paradigmas, por exemplo, a linguagem Scala \u00e9 ao mesmo tempo funcional e orientada a objetos, sendo muito dif\u00edcil us\u00e1-la sem fazer uso desta caracter\u00edstica. 1 2 3 4 5 object HelloWorld { def main ( args : Array [ String ]) : Unit = { println ( \"Hello, world!\" ) } } Para cada servi\u00e7o, uma ferramenta! Em cada paradigma, encontramos vantagens e desvantagens. Como desenvolvedores de tecnologia, nada mais justo que voc\u00eas conhe\u00e7am todos os paradigmas e que possam, assim, escolher aquele paradigma e, dentro dele, aquela linguagem que permite resolver o seu problema da forma mais eficiente, isto \u00e9, rapidamente, com menor custo e com melhor qualidade. Mas quanto ao paradigma funciona, em especial, \u00e9 importante compreend\u00ea-lo pois muitas de suas funcionalidades tem sido incorporadas a outras linguagens, como compreens\u00e3o de listas em Python, fun\u00e7\u00f5es lambda em Java e C++, e processamento ass\u00edncrono pode ser visto como uma forma de avalia\u00e7\u00e3o pregui\u00e7osa em diversas linguagens. Vejamos estes outras pontos importantes do paradigma: Sem efeitos colaterais: executando um programa, de repente voc\u00ea percebe que uma certa vari\u00e1vel tem um valor estranho e fica se perguntando quem foi que atribuiu tal valor; efeitos colaterais s\u00e3o a origem de boa parte dos bugs e elimin\u00e1-los, ou ao menos reduz\u00ed-los, permite que voc\u00ea identifique rapidamente onde altera\u00e7\u00f5es poderiam ter acontecido. Camadas de abstra\u00e7\u00e3o: fun\u00e7\u00f5es podem ser compostas levando a programas verdadeiramente complexos, permitindo que abstra\u00e7\u00f5es sejam definidas em diversas camadas. Al\u00e9m disso, \u00e9 poss\u00edvel, em teoria, ser provar a corretude de fun\u00e7\u00f5es e, mesmo que na pr\u00e1tica isso n\u00e3o se realize, h\u00e1 ferramentas que conseguem usar esta ideia para lhe ajudar a encontrar bugs. Processamento paralelo eficiente: a aus\u00eancia de efeitos colaterais tamb\u00e9m implica que fun\u00e7\u00f5es sem depend\u00eancias podem ser executadas em paralelo, sem se preocupar com qualquer sincroniza\u00e7\u00e3o, isto \u00e9, sem mutexes e vari\u00e1veis de condi\u00e7\u00e3o, etc. Avalia\u00e7\u00e3o pregui\u00e7osa: fun\u00e7\u00f5es s\u00f3 precisam realmente ser executadas se seus resultados s\u00e3o necess\u00e1rios e o compilador consegue atrasar a execu\u00e7\u00e3o de fun\u00e7\u00f5es enquanto poss\u00edvel. Recurs\u00e3o de calda: alguns problemas podem ser descritos muito facilmente como uma recurs\u00e3o que com uma itera\u00e7\u00e3o, mas linguagens tradicionais tem um limite no tamanho das pilhas de fun\u00e7\u00e3o; linguagens funcionais conseguem, em certas condi\u00e7\u00f5es, usar recurs\u00e3o infinita, contornando esta limita\u00e7\u00e3o. Fun\u00e7\u00f5es de alta ordem: fun\u00e7\u00f5es podem receber outras fun\u00e7\u00f5es como par\u00e2metro e com isso podemos compor fun\u00e7\u00f5es, por exemplo para implementar orienta\u00e7\u00e3o a objetos. Escolha o seu veneno Como j\u00e1 ficou \u00f3bvio, h\u00e1 muitas, muitas linguagens de programa\u00e7\u00e3o por a\u00ed e \u00e9 poss\u00edvel escrever c\u00f3digo bom em cada um delas, assim como \u00e9 poss\u00edvel escrever c\u00f3digo ruim em cada uma delas. Tamb\u00e9m \u00e9 poss\u00edvel escrever usando orienta\u00e7\u00e3o a objetos ou funcionalmente em cada uma delas, mas embora seja poss\u00edvel , h\u00e1 aquelas linguagens que suportam melhor cada um dos paradigmas. Dentre estas, h\u00e1 diversas op\u00e7\u00f5es de linguagens que podemos usar para estudar o paradigma funcional, por exemplo: Scheme Lisp ML F# Erlang Elixir Haskell Clojure Neste curso, veremos princ\u00edpios gerais e que, em teoria, poderiam ser aplicados em qualquer destas linguagens. Contudo, como a sintaxe pode variar muito de uma linguagem para outra, precisaremos nos focar em uma \u00fanica linguagem, mesmo que, frequentemente, apresente exemplos em outras. Assim, nosso foco aqui ser\u00e1 em Haskell, uma linguagem funcional madura e est\u00e1vel. Recomenda\u00e7\u00f5es Sobre a hist\u00f3ria das linguagens de programa\u00e7\u00e3o Sobre porqu\u00ea PF n\u00e3o \u00e9 mais comum Comunica\u00e7\u00e3o \u21a9 Linguagem de Programa\u00e7\u00e3o \u21a9 Programming Language Families \u21a9 void \u00e9 simplesmente um resultado que diz que o resultado n\u00e3o importa. \u21a9","title":"Introdu\u00e7\u00e3o"},{"location":"intro/#introducao","text":"Embora este curso assuma que voc\u00ea j\u00e1 saiba programar em alguma linguagem, ou exatamente por isso, \u00e9 importante que fa\u00e7amos uma revis\u00e3o de algumas ideias b\u00e1sicas de programa\u00e7\u00e3o antes de mergulharmos no paradigma funcional, para que possamos melhor posicionar este paradigma com em rela\u00e7\u00e3o aos demais.","title":"Introdu\u00e7\u00e3o"},{"location":"intro/#paradigmas-de-programacao","text":"Programar um computador consiste em comunicar ao computador instru\u00e7\u00f5es para que ele resolva problemas. E a comunica\u00e7\u00e3o entre duas entidades s\u00f3 \u00e9 poss\u00edvel se usarem uma linguagem em comum, isto \u00e9, dominada pelas duas partes. Comunica\u00e7\u00e3o A\u00e7\u00e3o ou efeito de comunicar, de transmitir ou de receber ideias, conhecimento, mensagens etc., buscando compartilhar informa\u00e7\u00f5es. 1 Comunica\u00e7\u00e3o Linguagens naturais Linguagens de programa\u00e7\u00e3o Quando humanos se comunicam, usam uma linguagens naturais , como o portugu\u00eas, libras, ou canton\u00eas. Linguagens naturais s\u00e3o altamente expressivas, cheias de nuances e depend\u00eancias do contexto, o que lhes confere grande poder, mas tamb\u00e9m a grande fraqueza de permitirem a constru\u00e7\u00e3o de mensagens amb\u00edguas. A comunica\u00e7\u00e3o entre computadores ou computares e humanos, contudo, precisa ser feita de forma precisa, e por isso linguagens naturais n\u00e3o s\u00e3o boas neste contexto, apesar do grande esfor\u00e7o dispendido e da evolu\u00e7\u00e3o do processamento de linguagens naturais, como as \"alexas\" e \"siris\" do mundo podem provar. A comunica\u00e7\u00e3o entre computadores \u00e9 feita por um protocolo de comunica\u00e7\u00e3o, assunto para outro curso. J\u00e1 a comunica\u00e7\u00e3o entre humanos e computadores, na programa\u00e7\u00e3o do computador, \u00e9 feita por meio de linguagens de programa\u00e7\u00e3o , que s\u00e3o muito mais restritas que as linguagens naturais e, por isso, n\u00e3o amb\u00edguas. Linguagem de Programa\u00e7\u00e3o A linguagem de programa\u00e7\u00e3o \u00e9 um m\u00e9todo padronizado, formado por um conjunto de regras sint\u00e1ticas e sem\u00e2nticas, de implementa\u00e7\u00e3o de um c\u00f3digo fonte - que pode ser compilado e transformado em um programa de computador, ou usado como script interpretado - que informar\u00e1 instru\u00e7\u00f5es de processamento ao computador. 2 A n\u00e3o ambiguidade das linguagens de programa\u00e7\u00e3o do fato de terem uma sintaxe e sem\u00e2nticas precisas, descritas por uma gram\u00e1tica tamb\u00e9m precisa. Sintaxe A sintaxe de uma linguagem descreve o que constitui um programa estruturalmente correto e \u00e9 definida por uma gram\u00e1tica. Sem\u00e2ntica O significado de um programa \u00e9 definido por sua sem\u00e2ntica, ou seja, por regras que definem como as instru\u00e7\u00f5es especificado devem ser interpretadas. Serem precisas n\u00e3o quer dizer que as linguagens sejam simples, como demonstra claramente a seguinte imagem, que \u00e9 um programa \u00e9 um \"hello world\" na linguagem Piet . Tamb\u00e9m n\u00e3o quer dizer que sejam limitadas. De fato, h\u00e1 milhares linguagens de programa\u00e7\u00e3o por a\u00ed, e contando, com diferentes caracter\u00edsticas que as tornam mais mais ou menos apropriadas para resolver diferentes problemas. Mas mesmo apesar de t\u00e3o grande n\u00famero, as linguagens podem ser classificadas em grandes fam\u00edlias ou paradigmas.","title":"Paradigmas de Programa\u00e7\u00e3o"},{"location":"intro/#imperativo-x-descritivo","text":"Imperativo x Descritivo Imperativo: como Descritivo: o qu\u00ea Os primeiros \"computadores\" eram m\u00e1quinas que computavam mecanicamente seus resultados. Uma segunda gera\u00e7\u00e3o, da qual destacamos o ENIAC (circa 1955), eram computadores sem parte mec\u00e2nicas, programados por conex\u00f5es el\u00e9tricas de suas diversas partes. O pr\u00f3ximo passo, foram computadores que interpretavam c\u00f3digo escrito em uma linguagem de programa\u00e7\u00e3o. Estas primeiras linguagens eram todas imperativas , no sentido de que ditavam ao computador uma sequ\u00eancia de instru\u00e7\u00f5es a serem seguidas para se chegar a um resultado. Isto \u00e9, estas linguagens permitiam ao programador dizer como realizar uma computa\u00e7\u00e3o. Imperativo leia a linha 1 do arquivo separe a linha por espa\u00e7os pegue a segunda parte da linha converta a parte para n\u00famero se o n\u00famero for maior que 15, escreva na tela leia a pr\u00f3xima linha do arquivo volte para o passo 2 Este paradigma tem suas ra\u00edzes no modelo computacional cl\u00e1ssico de von Neumann e na m\u00e1quina de Turing Em contrapartida a este modelo, surgiram mais tarde linguagens declarativas , em que o programado diz o qu\u00ea deve ser computado e o computador se encarrega de achar um \"como\". Descritivo selecione todas as linhas em que a segunda parte \u00e9 maior que 15 Com uma an\u00e1lise r\u00e1pida das linguagens mais conhecidas, voce deve reconhecer a maior parte como imperativas, por exemplo, C, Java, e Python. J\u00e1 dentre as linguagens declarativas, se destacam SQL, LINQ, e Prolog. Ortogonalmente ao foco em no \"como x o qu\u00ea\", podemos nos focar em como as estas instru\u00e7\u00f5es s\u00e3o organizadas mais em um n\u00edvel mais alto, de onde se destacam quatro paradigmas principais: procedimental , orientado a objetos , l\u00f3gico e funcional . 3","title":"Imperativo x Descritivo"},{"location":"intro/#procedimental","text":"Linguagens que usam o paradigma procedimental organizam instru\u00e7\u00f5es em blocos, denominados procedimentos, de onde vem o nome, ou fun\u00e7\u00f5es. A ideia \u00e9 que o c\u00f3digo seja modularizado para separar funcionalidades e tornar o c\u00f3digo mais compreens\u00edvel e manuten\u00edvel. Cada fun\u00e7\u00e3o deve executar uma opera\u00e7\u00e3o bem espec\u00edfica, fun\u00e7\u00f5es associadas s\u00e3o colocadas em um mesmo arquivo, e arquivos associados s\u00e3o colocados em um mesmo namespace . O c\u00f3digo seguinte, em C, mostra a fun\u00e7\u00e3o main , ponto de entrada do programa e de onde a fun\u00e7\u00e3o printf , importada de stdio.h , \u00e9 invocada. 1 2 3 4 5 #include <stdio.h> int main () { printf ( \"Hello, World!\" ); return 0 ; } Al\u00e9m da linguagem C, outros exemplos \u00f3bvios deste paradigma s\u00e3o as linguagens Pascal, Fortran e Python. Contudo, mesmo linguagens como Java e C++ podem ser consideradas procedurais, uma vez que organizam a computa\u00e7\u00e3o em m\u00e9todos, que s\u00e3o nada mais que fun\u00e7\u00f5es. Mas como m\u00e9todos est\u00e3o fortemente associados a classes e suas inst\u00e2ncias, os objetos, estas linguagens s\u00e3o melhor classificadas como orientadas a objetos.","title":"Procedimental"},{"location":"intro/#orientado-a-objetos","text":"Na orienta\u00e7\u00e3o a objetos, o foco est\u00e1 n\u00e3o na execu\u00e7\u00e3o passo a passo de fun\u00e7\u00f5es, mas na organiza\u00e7\u00e3o de dados e fun\u00e7\u00f5es associadas em objetos. Embora esta organiza\u00e7\u00e3o possa ser feita em qualquer qualquer linguagem estruturada, a sintaxe das linguagens orientadas a objeto facilita e tornam mais natural este trabalho. Dois conceitos b\u00e1sicos na orienta\u00e7\u00e3o a objetos s\u00e3o as classes e os objetos . Classes s\u00e3o abstra\u00e7\u00f5es de tipos de coisas encontrados no mundo real, ou seja, receitas de estruturas de dados e definem quais os dados devem ser considerados em conjunto para representar um objeto e quais as a\u00e7\u00f5es associadas a este objeto. Por exemplo, se no mundo real cachorros tem uma data de nascimento e um nome, e s\u00e3o capazes de latir, uma classe que represente cachorros pode ser definida assim em Java. 1 2 3 4 5 6 7 8 9 10 11 class Cachorro { int diaNascimento ; int mesNascimento ; int anoNascimento ; String nome ; void latir ( int quantidade ) { for ( int i = 0 ; i < quantidade ; i ++ ) System . out . println ( nome + \": Au!\" ); } } J\u00e1 um objeto \u00e9 uma inst\u00e2ncia de uma classe, uma representa\u00e7\u00e3o de um tipo mas de uma coisa em si. Um c\u00e3o qualquer poderia ser representado assim 1 2 Cachorro cachorro1 = new Cachorro ( 25 , 12 , 2020 , \"Napole\u00e3o\" ); cachorro1 . latir ( 3 ); e a execu\u00e7\u00e3o deste c\u00f3digo resultaria em 1 2 3 Napole\u00e3o: Au! Napole\u00e3o: Au! Napole\u00e3o: Au! Observe que o \".\" em cachorro1.latir(3) quer dizer \"executar a fun\u00e7\u00e3o latir no objeto cachorro1 \", o que leva \u00e0 string Napole\u00e3o a aparecer antes de cada latido. Duas coisas poder ser ditas sobre este \".\". Primeiro, que ele n\u00e3o \u00e9 necess\u00e1rio, o objeto em si poderia ser passado como par\u00e2metro para uma fun\u00e7\u00e3o latir que recebesse o objeto al\u00e9m da quantidade de latidos; de fato, em Python, a classe seria definida como a seguir 1 2 3 4 5 6 7 8 9 class Cachorro : diaNascimento mesNascimento anoNascimento nome def latir ( self , quantidade ): for i in range ( 0 , quantidade ): print ( self . nome + \": Au!\" ) o que implica que o \".\" \u00e9 o s\u00f3 a\u00e7\u00facar sint\u00e1tico para a execu\u00e7\u00e3o de uma fun\u00e7\u00e3o, o que nos leva ao segundo ponto. Na orienta\u00e7\u00e3o a objetos conceitual, n\u00e3o se fala em invoca\u00e7\u00e3o de fun\u00e7\u00f5es mas de sinais sendo transmitidos entre objetos: envie mensagem para o 2 \"somar-se com 3\", ao que o objeto 2 responderia com uma mensagem \"refer\u00eancia ao objeto 4\". Em Smalltalk, esta intera\u00e7\u00e3o seria escrita assim: 1 x := 2 + 3 . Grande parte do poder da orienta\u00e7\u00e3o objetos est\u00e1 no encapsulamento do como opera\u00e7\u00f5es s\u00e3o executadas, nos m\u00e9todos. Uma outra ordem de encapsulamento, de outro tipo, \u00e9 encontrada no paradigma l\u00f3gico.","title":"Orientado a Objetos"},{"location":"intro/#logico","text":"No paradigma l\u00f3gico, voc\u00ea declara-se fatos b\u00e1sicos e regras sobre como os fatos se relacionam e pergunta ao programa se certos fatos s\u00e3o ou n\u00e3o s\u00e3o verdade. Por exemplo, como fatos, podemos declarar 1 2 3 4 5 eh_maior_que ( gato , rato ). eh_maior_que ( leao , gato ). eh_maior_que ( elefante , leao ). eh_maior_que ( elefante , moto ). eh_maior_que ( legal , cachorro ). que vale a transitividade 1 2 3 eh_maior_que ( A , B ) :- eh_maior_que ( A , C ), eh_maior_que ( C , B ). e, finalmente, perguntar se elefante \u00e9 maior rato 1 eh_maior_que ( elefante , rato ). ao que seremos respondidos com um \"sim\". Voc\u00ea consegue imaginar quantas linhas de c\u00f3digo voc\u00ea precisaria para expressar a mesma l\u00f3gica acima em uma linguagem como C ou Java? Apesar do claro poder deste paradigma, o mesmo tem poucos representantes, como Prolog e Mercury, e mesmo que exista v\u00e1rios compiladores do primeiro, o uso comercial do paradigma \u00e9 bem limitado.","title":"L\u00f3gico"},{"location":"intro/#funcional","text":"A programa\u00e7\u00e3o, como indicado pelo nome, \u00e9 focada na organiza\u00e7\u00e3o do processamento em termos de fun\u00e7\u00f5es, mas de uma forma diferente da programa\u00e7\u00e3o procedimental. De forma geral, fun\u00e7\u00f5es s\u00e3o blocos de c\u00f3digo criadas essencialmente para se obter reusabilidade : uma vez definidas, as fun\u00e7\u00f5es podem ser invocadas repetidas vezes para executar a mesma tarefa sobre diferentes par\u00e2metros , sempre retornando um resultado. 4 Mas enquanto na programa\u00e7\u00e3o procedimental a invoca\u00e7\u00e3o de uma fun\u00e7\u00e3o pode retornar diferentes resultados mesmo quando os par\u00e2metros s\u00e3o os mesmos, na programa\u00e7\u00e3o funcional, fun\u00e7\u00f5es s\u00e3o como na matem\u00e1tica, isto \u00e9, mapeiam uma entrada para exatamente uma sa\u00edda, sempre. Isto \u00e9, fun\u00e7\u00f5es resolvem o problema sem se basear em nada al\u00e9m dos par\u00e2metros passados e sem efeitos colaterais. Mas e as fun\u00e7\u00f5es que tem efeitos colaterais? Estas n\u00e3o s\u00e3o fun\u00e7\u00f5es \"de verdade\" e n\u00e3o \u00e9 a toa que outro nome usado para os blocos de c\u00f3digo \u00e9 procedimento e que para discernir entre fun\u00e7\u00f5es que tem efeitos colaterais e que n\u00e3o n\u00e3o, chamamos de puras as do segundo tipo. Vejamos alguns exemplos. As fun\u00e7\u00f5es seguintes, definidas em Erlang, calculam A+B , A*C e (A+B)*(A+B) e, independentemente de quantas vezes voc\u00ea o fizer, add(2,3) sempre retornar\u00e1 5 . 1 2 3 4 5 6 7 8 add ( A , B ) -> A + B . mult ( A , B ) -> A * B . mult_add ( A , B ) -> mult ( add ( A , B ), add ( A , B )). Agora observe a fun\u00e7\u00e3o seguinte, escritas em Python; a cada invoca\u00e7\u00e3o, a vari\u00e1vel acc tem seu valor alterado e mesmo que invocada com a mesma entrada, o resultado da fun\u00e7\u00e3o \u00e9 sempre diferente. Os efeitos externos \u00e0 fun\u00e7\u00e3o, e.g., a altera\u00e7\u00e3o da vari\u00e1vel acc , \u00e9 conhecido efeito colateral . Programa\u00e7\u00e3o funcional n\u00e3o tem tem efeitos colaterais por que trata vari\u00e1veis n\u00e3o como \u00e1reas de mem\u00f3ria alter\u00e1veis, mas como inc\u00f3gnitas, como na matem\u00e1tica. Pelo menos esta \u00e9 a ideia de programa\u00e7\u00e3o funcional pura, que \u00e9 essencialmente a escrita de longu\u00edssimas equa\u00e7\u00f5es. Acontece que devido \u00e0 complexidade inerente do uso de programa\u00e7\u00e3o funcional pura, sem efeitos colaterais, i.e., sem muta\u00e7\u00e3o de estados, muitas linguagens n\u00e3o s\u00e3o puramente funcionais. A raz\u00e3o mais comum para efeitos colaterais \u00e9 a realiza\u00e7\u00e3o de Entrada/Sa\u00edda. Por exemplo, ao invocar print no Python, o terminal tem seu estado alterado, e cada nova invoca\u00e7\u00e3o altera mais o estado. Assim, podemos dividir as linguagens e funcionais puras, funcionais n\u00e3o puras e n\u00e3o funcionais, mas mesmo dentro das n\u00e3o funcionais, h\u00e1 aquelas com elementos de programa\u00e7\u00e3o funcional.","title":"Funcional"},{"location":"intro/#multi-paradigmas","text":"Muitas linguagens modernas podem ser classificadas ao mesmo tempo em muitos paradigmas, por exemplo, a linguagem Scala \u00e9 ao mesmo tempo funcional e orientada a objetos, sendo muito dif\u00edcil us\u00e1-la sem fazer uso desta caracter\u00edstica. 1 2 3 4 5 object HelloWorld { def main ( args : Array [ String ]) : Unit = { println ( \"Hello, world!\" ) } }","title":"Multi-paradigmas"},{"location":"intro/#para-cada-servico-uma-ferramenta","text":"Em cada paradigma, encontramos vantagens e desvantagens. Como desenvolvedores de tecnologia, nada mais justo que voc\u00eas conhe\u00e7am todos os paradigmas e que possam, assim, escolher aquele paradigma e, dentro dele, aquela linguagem que permite resolver o seu problema da forma mais eficiente, isto \u00e9, rapidamente, com menor custo e com melhor qualidade. Mas quanto ao paradigma funciona, em especial, \u00e9 importante compreend\u00ea-lo pois muitas de suas funcionalidades tem sido incorporadas a outras linguagens, como compreens\u00e3o de listas em Python, fun\u00e7\u00f5es lambda em Java e C++, e processamento ass\u00edncrono pode ser visto como uma forma de avalia\u00e7\u00e3o pregui\u00e7osa em diversas linguagens. Vejamos estes outras pontos importantes do paradigma: Sem efeitos colaterais: executando um programa, de repente voc\u00ea percebe que uma certa vari\u00e1vel tem um valor estranho e fica se perguntando quem foi que atribuiu tal valor; efeitos colaterais s\u00e3o a origem de boa parte dos bugs e elimin\u00e1-los, ou ao menos reduz\u00ed-los, permite que voc\u00ea identifique rapidamente onde altera\u00e7\u00f5es poderiam ter acontecido. Camadas de abstra\u00e7\u00e3o: fun\u00e7\u00f5es podem ser compostas levando a programas verdadeiramente complexos, permitindo que abstra\u00e7\u00f5es sejam definidas em diversas camadas. Al\u00e9m disso, \u00e9 poss\u00edvel, em teoria, ser provar a corretude de fun\u00e7\u00f5es e, mesmo que na pr\u00e1tica isso n\u00e3o se realize, h\u00e1 ferramentas que conseguem usar esta ideia para lhe ajudar a encontrar bugs. Processamento paralelo eficiente: a aus\u00eancia de efeitos colaterais tamb\u00e9m implica que fun\u00e7\u00f5es sem depend\u00eancias podem ser executadas em paralelo, sem se preocupar com qualquer sincroniza\u00e7\u00e3o, isto \u00e9, sem mutexes e vari\u00e1veis de condi\u00e7\u00e3o, etc. Avalia\u00e7\u00e3o pregui\u00e7osa: fun\u00e7\u00f5es s\u00f3 precisam realmente ser executadas se seus resultados s\u00e3o necess\u00e1rios e o compilador consegue atrasar a execu\u00e7\u00e3o de fun\u00e7\u00f5es enquanto poss\u00edvel. Recurs\u00e3o de calda: alguns problemas podem ser descritos muito facilmente como uma recurs\u00e3o que com uma itera\u00e7\u00e3o, mas linguagens tradicionais tem um limite no tamanho das pilhas de fun\u00e7\u00e3o; linguagens funcionais conseguem, em certas condi\u00e7\u00f5es, usar recurs\u00e3o infinita, contornando esta limita\u00e7\u00e3o. Fun\u00e7\u00f5es de alta ordem: fun\u00e7\u00f5es podem receber outras fun\u00e7\u00f5es como par\u00e2metro e com isso podemos compor fun\u00e7\u00f5es, por exemplo para implementar orienta\u00e7\u00e3o a objetos.","title":"Para cada servi\u00e7o, uma ferramenta!"},{"location":"intro/#escolha-o-seu-veneno","text":"Como j\u00e1 ficou \u00f3bvio, h\u00e1 muitas, muitas linguagens de programa\u00e7\u00e3o por a\u00ed e \u00e9 poss\u00edvel escrever c\u00f3digo bom em cada um delas, assim como \u00e9 poss\u00edvel escrever c\u00f3digo ruim em cada uma delas. Tamb\u00e9m \u00e9 poss\u00edvel escrever usando orienta\u00e7\u00e3o a objetos ou funcionalmente em cada uma delas, mas embora seja poss\u00edvel , h\u00e1 aquelas linguagens que suportam melhor cada um dos paradigmas. Dentre estas, h\u00e1 diversas op\u00e7\u00f5es de linguagens que podemos usar para estudar o paradigma funcional, por exemplo: Scheme Lisp ML F# Erlang Elixir Haskell Clojure Neste curso, veremos princ\u00edpios gerais e que, em teoria, poderiam ser aplicados em qualquer destas linguagens. Contudo, como a sintaxe pode variar muito de uma linguagem para outra, precisaremos nos focar em uma \u00fanica linguagem, mesmo que, frequentemente, apresente exemplos em outras. Assim, nosso foco aqui ser\u00e1 em Haskell, uma linguagem funcional madura e est\u00e1vel.","title":"Escolha o seu veneno"},{"location":"intro/#recomendacoes","text":"Sobre a hist\u00f3ria das linguagens de programa\u00e7\u00e3o Sobre porqu\u00ea PF n\u00e3o \u00e9 mais comum Comunica\u00e7\u00e3o \u21a9 Linguagem de Programa\u00e7\u00e3o \u21a9 Programming Language Families \u21a9 void \u00e9 simplesmente um resultado que diz que o resultado n\u00e3o importa. \u21a9","title":"Recomenda\u00e7\u00f5es"},{"location":"lists/","text":"Listas Anteriormente n\u00f3s discutimos tuplas como uma forma de agregar m\u00faltiplas informa\u00e7\u00f5es em um \u00fanico valor. Por exemplo, definimos o tipo Data como sendo a agrega\u00e7\u00e3o de um dia, um m\u00eas e um ano. 1 2 3 4 5 6 7 8 9 10 11 12 type Data :: ( Int , Int Int ) ###### Recurs\u00e3o e Listas ``` hs maximum [] = error \"lista vazia\" maximum [ h ] = h maximum ( h : t ) = max h ( maximum t ) \\(maximum~[1,2,3] = max~1 \\left( maximum~[2,3] = max~2 \\left( maximum~[3] = 3 \\right) \\right)\\)","title":"Listas"},{"location":"lists/#listas","text":"Anteriormente n\u00f3s discutimos tuplas como uma forma de agregar m\u00faltiplas informa\u00e7\u00f5es em um \u00fanico valor. Por exemplo, definimos o tipo Data como sendo a agrega\u00e7\u00e3o de um dia, um m\u00eas e um ano. 1 2 3 4 5 6 7 8 9 10 11 12 type Data :: ( Int , Int Int ) ###### Recurs\u00e3o e Listas ``` hs maximum [] = error \"lista vazia\" maximum [ h ] = h maximum ( h : t ) = max h ( maximum t ) \\(maximum~[1,2,3] = max~1 \\left( maximum~[2,3] = max~2 \\left( maximum~[3] = 3 \\right) \\right)\\)","title":"Listas"},{"location":"observations/","text":"Observa\u00e7\u00f5es Cheat sheet https://hackage.haskell.org/package/CheatSheet-1.7/src/CheatSheet.pdf Exerc\u00edcios da Semana 2 Par\u00eanteses desnecess\u00e1rios Todo if em um then e um else Diferentemente de outras linguagens, onde o if \u00e9 usado para determinar se uma computa\u00e7\u00e3o deve acontecer e o else \u00e9 um atalho para quando h\u00e1 duas op\u00e7\u00f5es, e portanto o else n\u00e3o \u00e9 necess\u00e1rio, em Haskell o if \u00e9 usado para determinar qual computa\u00e7\u00e3o deve acontecer, ou seja, sempre h\u00e1 duas op\u00e7\u00f5es . C 1 2 if ( x > 3 ) //If sem else: compila. y = \"maior\" ; //Se x <= 3, y continua com o valor anterior, seja qual for. Haskell 1 2 let y = if x > 3 then \"maior\" -- If sem else: n\u00e3o compila! Qual o valor de `y` se `x <= 3`? Por isso o if do Haskell deve ser comparado ao operador tern\u00e1rio do C, n\u00e3o com o if . C 1 y = x > 3 ? \"maior\" : \"menor\" ; Haskell 1 let y = if x > 3 then \"maior\" else \"menor\" ((b1+b2)/2) * h -> (b1+b2)/2 * h n\u00e3o h\u00e1 d\u00favida para o compilador que a divis\u00e3o deve ocorrer primeiro, pois os operadores tem a mesma preced\u00eancia e ambos s\u00e3o associativos \u00e0 esquerda. sqrt ((b*b)+ (c*c)) -> sqrt (b*b + c*c) n\u00e3o h\u00e1 d\u00favida para o compilador que a divis\u00e3o deve ocorrer primeiro, pois os operadores tem preced\u00eancias diferentes. Informa\u00e7\u00e3o sobre preced\u00eancia e associatividade pode ser derivadas via : info . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Prelude > : info * type Num :: * -> Constraint class Num a where ... ( * ) :: a -> a -> a ... infixl 7 * -- Infixo com associatividade a esquerda (l) e Preced\u00eancia 7. Prelude > : info / type Fractional :: * -> Constraint class Num a => Fractional a where ( / ) :: a -> a -> a ... infixl 7 / -- Infixo com associatividade a esquerda (l) e Preced\u00eancia 7. Prelude > : info + type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ... infixl 6 + -- Infixo com associatividade a esquerda (l) e Preced\u00eancia 6. maiorDeTres a b c = if a > b && a > c then a else if b > a && b > c then b else c Dif\u00edcil leitura. Quebrar linhas. estaoOrdenados a b c = if ( a > b && b > c ) then True else False if < cond > then True else False -> < cond > estaoOrdenados a b c = a > b && b > c sqrt (( a ^ 2 ) + ( b ^ 2 )) Par\u00eanteses s\u00f3 s\u00e3o necess\u00e1rios para deixar expl\u00edcito o que \u00e9 par\u00e2metro. sqrt (( a ^ 2 ) + ( b ^ 2 )) Fun\u00e7\u00f5es e par\u00e2metros s\u00e3o separados por espa\u00e7o. sqrt (( a ^ 2 ) + ( b ^ 2 )) sqrt (( a ^ 2 ) + ( b ^ 2 )) Operadores tem preced\u00eancias; pot\u00eancia tem preced\u00eancia maior que adi\u00e7\u00e3o sqrt ( a ^ 2 + b ^ 2 ) sqrt a ^ 2 + b ^ 2 Fun\u00e7\u00f5es tem preced\u00eancia sobre operadores. sqrt a ^ 2 + b ^ 2 == ( sqrt a ^ 2 ) + b ^ 2","title":"Observa\u00e7\u00f5es"},{"location":"observations/#observacoes","text":"","title":"Observa\u00e7\u00f5es"},{"location":"observations/#cheat-sheet","text":"https://hackage.haskell.org/package/CheatSheet-1.7/src/CheatSheet.pdf","title":"Cheat sheet"},{"location":"observations/#exercicios-da-semana-2","text":"","title":"Exerc\u00edcios da Semana 2"},{"location":"pattern_matching/","text":"Casamento de Padr\u00f5es Na se\u00e7\u00e3o sobre tuplas , definimos uma fun\u00e7\u00e3o que somava dois pontos em um espa\u00e7o bidimensional. Vejamos uma defini\u00e7\u00e3o semelhante, melhorada. 1 2 3 4 type Ponto = ( Integer , Integer ) soma2v :: Ponto -> Ponto -> Ponto soma2v ( x1 , y1 ) ( x2 , y2 ) = ( x1 + x2 , y1 + y2 ) Agora nos foquemos no que est\u00e1 acontecendo na linha 4, onde os par\u00e2metros passados, do tipo Ponto s\u00e3o associados \u00e0s vari\u00e1veis x1, y1, x2 e y2 . O termo correto para o que est\u00e1 acontecendo ali \u00e9 casamento de padr\u00f5es , que \u00e9 o processo pelo qual os valores em uma express\u00e3o, o ponto, s\u00e3o associados aos elementos de um padr\u00e3o, (x1,x2) , por exemplo. Padr\u00e3o e Express\u00e3o sucesso/falha mesmos tipos no padrao e na expressao tipos padr\u00e3o constante casa se o valor for igual \u00e0 constante Padr\u00e3o Valor Resultado 10 10 Casa 10 20 N\u00e3o casa 10 'C' Erro True False N\u00e3o casa False False Casa padr\u00e3o vari\u00e1vel Sempre casa e a vari\u00e1vel \u00e9 associada ao valor Padr\u00e3o Valor Resultado x 10 Casa, x == 10 x 20 Casa, x == 20 x 'C' Casa, x == 'C' x False Casa, x == False x (1,2,3) Casa, x == (1,2,3) padr\u00e3o curinga Sempre casa e nenhuma associa\u00e7\u00e3o de valor \u00e9 feita Padr\u00e3o Valor Resultado _ 10 Casa _ 20 Casa _ 'C' Casa _ False Casa _ (1,2,3) Casa padr\u00e3o tupla, ou melhor, uma tupla de padr\u00f5es Casa se a tupla de padr\u00f5es tiver a mesma aridade que a tupla de valores e cada elemento da tupla de padr\u00f5es casa com o elemento correspondente da tupla de valores N\u00e3o casa se a tupla de padr\u00f5es tiver a mesma aridade que a tupla de valores e algum elemento da tupla de padr\u00f5es n\u00e3o casa com o elemento correspondente da tupla de valores Resulta em um erro de tipo se a tupla de padr\u00f5es n\u00e3o tiver a mesma aridade que a tupla de valores ou algum elemento da tupla de padr\u00f5es resultar um erro de tipo no casamento com o elemento correspondente da tupla de valores Padr\u00e3o Valor Resultado (x,y) (1,2) Casa, x == 1 e y == 2 (1,y) (1,2) Casa, y == 2 (_,y) (1,2) Casa, y == 2 ('X',y) ('X',2) Casa, y == 2 (x,y) (1,(2,3)) Casa, x == 1 e y == (2,3) (_, (_,y)) (1,(2,3)) Casa, y == 3 (x,y) (1,(2,3),3) Erro de tipo (1,y) ('x',(2,3)) Erro de tipo TODO Princ\u00edpio da linearidade Vejamos algumas aplica\u00e7\u00f5es de casamento de padr\u00f5es. Defini\u00e7\u00e3o de Fun\u00e7\u00f5es Como mencionado anteriormente , casamento de padr\u00f5es pode ser usado na defini\u00e7\u00e3o de fun\u00e7\u00f5es para simplificar testes via if-then-else e guardas nos par\u00e2metros da fun\u00e7\u00e3o. Neste caso, a fun\u00e7\u00e3o \u00e9 definida como uma sequ\u00eancia de equa\u00e7\u00f5es em que os par\u00e2metros servem de padr\u00f5es a serem casados com os valores da invoca\u00e7\u00e3o. Na invoca\u00e7\u00e3o da fun\u00e7\u00e3o, o resultado \u00e9 dado pela primeira equa\u00e7\u00e3o, na ordem da declara\u00e7\u00e3o, em que houver o casamento padr\u00f5es/valores e todas as guardas forem satisfeitas. Se n\u00e3o houver casamento ou se as guardas n\u00e3o forem satisfeitas, ocorre um erro de execu\u00e7\u00e3o . Para come\u00e7ar, vejamos uma defini\u00e7\u00e3o sem guardas, revisitando a fun\u00e7\u00e3o nomeMes . Usando casamento de padr\u00f5es, ela ficaria assim: 1 2 3 4 5 6 nomeMes 1 = \"JAN\" nomeMes 2 = \"FEB\" nomeMes 3 = \"MAR\" ... -- Isso n\u00e3o \u00e9 v\u00e1lido em Haskell nomeMes 11 = \"NOV\" nomeMes 12 = \"DEZ\" Esta fun\u00e7\u00e3o funciona especificamente para valores na faixa [1,12] e retornar\u00e1 um erro para qualquer valor fora da mesma. \u00c9 poss\u00edvel usar uma defini\u00e7\u00e3o gen\u00e9rica catch-all para casar com valores n\u00e3o espec\u00edficos. Por exemplo, a defini\u00e7\u00e3o da fun\u00e7\u00e3o fatorial tem um tratamento especial para 0 e um caso gen\u00e9rico para qualquer outro n\u00famero. 1 2 fatorial 0 = 1 fatorial n = n * fatorial ( n - 1 ) Mas esta defini\u00e7\u00e3o de fatorial tem um problema, que aparece se calcular o fatorial de n\u00fameros negativos, que s\u00e3o indefinidos. Neste caso, precisamos impedir que que n\u00fameros negativos sejam aceitos pela fun\u00e7\u00e3o. 1 2 3 4 fatorial 0 = 1 fatorial n | n > 0 = n * fatorial ( n - 1 ) | otherwise = error \"Indefinido\" Exerc\u00edcio Defina 3 fun\u00e7\u00f5es, usando if - then - else , guardas e casamento de padr\u00f5es, que calculem os n\u00fameros da s\u00e9rie de Fibonacci, a saber Fib(1) = 1 Fib(2) = 1 Fib(n) = Fib(n-1) + Fib(n-2) Resolu\u00e7\u00e3o 1 Vejamos outros exemplos, do pacote prelude do Haskell. Primeiro, a fun\u00e7\u00e3o not , que nega o valor passado. 1 2 3 not :: Bool -> Bool not True = False not False = True Vejamos agora diferentes defini\u00e7\u00f5es do operador && . Observe que como o operador \u00e9 infixo, a defini\u00e7\u00e3o das equa\u00e7\u00f5es segue esta nota\u00e7\u00e3o, mesmo que a defini\u00e7\u00e3o do prot\u00f3tipo n\u00e3o siga. A primeira defini\u00e7\u00e3o usa somente constantes como padr\u00e3o. Esta defini\u00e7\u00e3o est\u00e1 correta, mas \u00e9 mais complexa do que o necess\u00e1rio, j\u00e1 que somente a primeira equa\u00e7\u00e3o resulta em True . 1 2 3 4 5 ( && ) Bool -> Bool -> Bool True && True = True True && False = False False && True = False False && False = False Uma vers\u00e3o simplificada pelo uso de padr\u00f5es curinga, seria a seguinte. Observe como ela \u00e9 mais leg\u00edvel. 1 2 3 ( && ) Bool -> Bool -> Bool True && True = True _ && _ = False Finalmente, uma terceira vers\u00e3o que usa um padr\u00e3o vari\u00e1vel e um curinga tamb\u00e9m poderia ser usada. 1 2 3 ( && ) Bool -> Bool -> Bool True && b = b False && _ = False TODO Rever fst e snd Exerc\u00edcio Seguindo os modes da defini\u00e7\u00e3o do operador && , defina o operador l\u00f3gico ou || de tr\u00eas formas diferentes. Seguindo os modes da defini\u00e7\u00e3o do operador && , defina o operador l\u00f3gico ou || de tr\u00eas formas diferentes. case - of Esta estrutura se assemelha ao switch de linguagens como C e Java, e tem a seguinte sintaxe: 1 2 3 case expression of pattern -> result pattern -> result pattern -> result Por exemplo, vamos definir uma fun\u00e7\u00e3o que retorne o nome do m\u00eas, dado o seu n\u00famero. Seria poss\u00edvel escreve esta fun\u00e7\u00e3o com if aninhados, assim. 1 2 3 4 5 6 nome_mes m = if m == 1 then \"JAN\" else if m == 2 then \"FEB\" else if m == 3 then \"MAR\" ... else if m == 11 then \"NOV\" else \"DEZ\" Usando guardas, ficaria assim: 1 2 3 4 5 6 7 nome_mes m | m == 1 = \"JAN\" | m == 2 = \"FEB\" | m == 3 = \"MAR\" ... | m == 11 = \"NOV\" | otherwise \"DEZ\" Usando case - of , a 1 2 3 4 5 6 nome_mes m = case m of 1 -> \"JAN\" m of 2 -> \"FEB\" m of 3 -> \"MAR\" ... m of 11 -> \"NOV\" m of 12 -> \"DEZ\"","title":"Padr\u00f5es"},{"location":"pattern_matching/#casamento-de-padroes","text":"Na se\u00e7\u00e3o sobre tuplas , definimos uma fun\u00e7\u00e3o que somava dois pontos em um espa\u00e7o bidimensional. Vejamos uma defini\u00e7\u00e3o semelhante, melhorada. 1 2 3 4 type Ponto = ( Integer , Integer ) soma2v :: Ponto -> Ponto -> Ponto soma2v ( x1 , y1 ) ( x2 , y2 ) = ( x1 + x2 , y1 + y2 ) Agora nos foquemos no que est\u00e1 acontecendo na linha 4, onde os par\u00e2metros passados, do tipo Ponto s\u00e3o associados \u00e0s vari\u00e1veis x1, y1, x2 e y2 . O termo correto para o que est\u00e1 acontecendo ali \u00e9 casamento de padr\u00f5es , que \u00e9 o processo pelo qual os valores em uma express\u00e3o, o ponto, s\u00e3o associados aos elementos de um padr\u00e3o, (x1,x2) , por exemplo.","title":"Casamento de Padr\u00f5es"},{"location":"pattern_matching/#padrao-e-expressao","text":"sucesso/falha mesmos tipos no padrao e na expressao tipos padr\u00e3o constante casa se o valor for igual \u00e0 constante Padr\u00e3o Valor Resultado 10 10 Casa 10 20 N\u00e3o casa 10 'C' Erro True False N\u00e3o casa False False Casa padr\u00e3o vari\u00e1vel Sempre casa e a vari\u00e1vel \u00e9 associada ao valor Padr\u00e3o Valor Resultado x 10 Casa, x == 10 x 20 Casa, x == 20 x 'C' Casa, x == 'C' x False Casa, x == False x (1,2,3) Casa, x == (1,2,3) padr\u00e3o curinga Sempre casa e nenhuma associa\u00e7\u00e3o de valor \u00e9 feita Padr\u00e3o Valor Resultado _ 10 Casa _ 20 Casa _ 'C' Casa _ False Casa _ (1,2,3) Casa padr\u00e3o tupla, ou melhor, uma tupla de padr\u00f5es Casa se a tupla de padr\u00f5es tiver a mesma aridade que a tupla de valores e cada elemento da tupla de padr\u00f5es casa com o elemento correspondente da tupla de valores N\u00e3o casa se a tupla de padr\u00f5es tiver a mesma aridade que a tupla de valores e algum elemento da tupla de padr\u00f5es n\u00e3o casa com o elemento correspondente da tupla de valores Resulta em um erro de tipo se a tupla de padr\u00f5es n\u00e3o tiver a mesma aridade que a tupla de valores ou algum elemento da tupla de padr\u00f5es resultar um erro de tipo no casamento com o elemento correspondente da tupla de valores Padr\u00e3o Valor Resultado (x,y) (1,2) Casa, x == 1 e y == 2 (1,y) (1,2) Casa, y == 2 (_,y) (1,2) Casa, y == 2 ('X',y) ('X',2) Casa, y == 2 (x,y) (1,(2,3)) Casa, x == 1 e y == (2,3) (_, (_,y)) (1,(2,3)) Casa, y == 3 (x,y) (1,(2,3),3) Erro de tipo (1,y) ('x',(2,3)) Erro de tipo TODO Princ\u00edpio da linearidade Vejamos algumas aplica\u00e7\u00f5es de casamento de padr\u00f5es.","title":"Padr\u00e3o e Express\u00e3o"},{"location":"pattern_matching/#definicao-de-funcoes","text":"Como mencionado anteriormente , casamento de padr\u00f5es pode ser usado na defini\u00e7\u00e3o de fun\u00e7\u00f5es para simplificar testes via if-then-else e guardas nos par\u00e2metros da fun\u00e7\u00e3o. Neste caso, a fun\u00e7\u00e3o \u00e9 definida como uma sequ\u00eancia de equa\u00e7\u00f5es em que os par\u00e2metros servem de padr\u00f5es a serem casados com os valores da invoca\u00e7\u00e3o. Na invoca\u00e7\u00e3o da fun\u00e7\u00e3o, o resultado \u00e9 dado pela primeira equa\u00e7\u00e3o, na ordem da declara\u00e7\u00e3o, em que houver o casamento padr\u00f5es/valores e todas as guardas forem satisfeitas. Se n\u00e3o houver casamento ou se as guardas n\u00e3o forem satisfeitas, ocorre um erro de execu\u00e7\u00e3o . Para come\u00e7ar, vejamos uma defini\u00e7\u00e3o sem guardas, revisitando a fun\u00e7\u00e3o nomeMes . Usando casamento de padr\u00f5es, ela ficaria assim: 1 2 3 4 5 6 nomeMes 1 = \"JAN\" nomeMes 2 = \"FEB\" nomeMes 3 = \"MAR\" ... -- Isso n\u00e3o \u00e9 v\u00e1lido em Haskell nomeMes 11 = \"NOV\" nomeMes 12 = \"DEZ\" Esta fun\u00e7\u00e3o funciona especificamente para valores na faixa [1,12] e retornar\u00e1 um erro para qualquer valor fora da mesma. \u00c9 poss\u00edvel usar uma defini\u00e7\u00e3o gen\u00e9rica catch-all para casar com valores n\u00e3o espec\u00edficos. Por exemplo, a defini\u00e7\u00e3o da fun\u00e7\u00e3o fatorial tem um tratamento especial para 0 e um caso gen\u00e9rico para qualquer outro n\u00famero. 1 2 fatorial 0 = 1 fatorial n = n * fatorial ( n - 1 ) Mas esta defini\u00e7\u00e3o de fatorial tem um problema, que aparece se calcular o fatorial de n\u00fameros negativos, que s\u00e3o indefinidos. Neste caso, precisamos impedir que que n\u00fameros negativos sejam aceitos pela fun\u00e7\u00e3o. 1 2 3 4 fatorial 0 = 1 fatorial n | n > 0 = n * fatorial ( n - 1 ) | otherwise = error \"Indefinido\" Exerc\u00edcio Defina 3 fun\u00e7\u00f5es, usando if - then - else , guardas e casamento de padr\u00f5es, que calculem os n\u00fameros da s\u00e9rie de Fibonacci, a saber Fib(1) = 1 Fib(2) = 1 Fib(n) = Fib(n-1) + Fib(n-2) Resolu\u00e7\u00e3o 1 Vejamos outros exemplos, do pacote prelude do Haskell. Primeiro, a fun\u00e7\u00e3o not , que nega o valor passado. 1 2 3 not :: Bool -> Bool not True = False not False = True Vejamos agora diferentes defini\u00e7\u00f5es do operador && . Observe que como o operador \u00e9 infixo, a defini\u00e7\u00e3o das equa\u00e7\u00f5es segue esta nota\u00e7\u00e3o, mesmo que a defini\u00e7\u00e3o do prot\u00f3tipo n\u00e3o siga. A primeira defini\u00e7\u00e3o usa somente constantes como padr\u00e3o. Esta defini\u00e7\u00e3o est\u00e1 correta, mas \u00e9 mais complexa do que o necess\u00e1rio, j\u00e1 que somente a primeira equa\u00e7\u00e3o resulta em True . 1 2 3 4 5 ( && ) Bool -> Bool -> Bool True && True = True True && False = False False && True = False False && False = False Uma vers\u00e3o simplificada pelo uso de padr\u00f5es curinga, seria a seguinte. Observe como ela \u00e9 mais leg\u00edvel. 1 2 3 ( && ) Bool -> Bool -> Bool True && True = True _ && _ = False Finalmente, uma terceira vers\u00e3o que usa um padr\u00e3o vari\u00e1vel e um curinga tamb\u00e9m poderia ser usada. 1 2 3 ( && ) Bool -> Bool -> Bool True && b = b False && _ = False TODO Rever fst e snd Exerc\u00edcio Seguindo os modes da defini\u00e7\u00e3o do operador && , defina o operador l\u00f3gico ou || de tr\u00eas formas diferentes. Seguindo os modes da defini\u00e7\u00e3o do operador && , defina o operador l\u00f3gico ou || de tr\u00eas formas diferentes.","title":"Defini\u00e7\u00e3o de Fun\u00e7\u00f5es"},{"location":"preface/","text":"Pref\u00e1cio O paradigma de funcional \u00e9 um dos muitos paradigmas de programa\u00e7\u00e3o dispon\u00edveis e, uma vez que voc\u00ea tenha sido \"contaminado\" pelos outros, certamente n\u00e3o \u00e9 o mais simples de se entender. Ainda assim, \u00e9 um paradigma que deve ser estudado pois seus pontos fortes tem sido incorporados cada vez mais frequentemente em frameworks e linguagens n\u00e3o necessariamente reconhecidos como funcionais. Por isso, neste curso estudaremos o paradigma funcional de uma forma pr\u00e1tica, tentando sempre que poss\u00edvel mostrar diversas aplica\u00e7\u00f5es das ideias apresentadas no mundo da programa\u00e7\u00e3o moderna. Tamb\u00e9m ser\u00e1 foco deste curso, destacar e demonstrar como o uso do paradigma funcional traz vantagens no desenvolvimento de sistemas paralelos e distribu\u00eddos. Agradecimentos Antes de come\u00e7armos nosso estudo, deixo aqui o meu agradecimento aos professores que forneceram o material sobre o qual estas notas de aula s\u00e3o baseadas, Profa. Gina Maira B. Oliveira, Profa. Maria Adriana Vidigal de Lima, e Prof. Henrique Fernandes, da Faculdade de Computa\u00e7\u00e3o da UFU. Conven\u00e7\u00f5es Neste documento, usamos diversos recursos visuais com diferentes prop\u00f3sitos. it\u00e1lico indica termos em outras l\u00ednguas, como framework ou middleware . Alguns termos, contudo, s\u00e3o t\u00e3o corriqueiramente usados que me escapam quando escrevendo e acabam n\u00e3o grafados corretamente. negrito indica a introdu\u00e7\u00e3o de termos e conceitos importantes, como escalabilidade e falha . Apontadores indicam um s\u00edtio relacionado ao termo, por exemplo, como criar um reposit\u00f3rio no Github , e cuja leitura \u00e9 sugerida ao final da aula. Notas de rodap\u00e9, indicam uma observa\u00e7\u00e3o importante sobre o que est\u00e1 sendo apresentado, cuja leitura \u00e9 sugerida ao final do par\u00e1grafo. 1 Estas notas incluem referenciais te\u00f3ricos importantes, com detalhes da publica\u00e7\u00e3o e apontadores para onde a publica\u00e7\u00e3o pode ser lida. Imagens n\u00e3o autorais s\u00e3o tamb\u00e9m apontadores para onde s\u00e3o encontradas e tem como texto alternativo as informa\u00e7\u00f5es da autoria. Caixas alinhadas \u00e0 esquerda s\u00e3o usadas para v\u00e1rias finalidades. Por exemplo, para apresentar exerc\u00edcios, destacar especifica\u00e7\u00f5es, apontar tarefas a serem executas por mim. Os diversos usos s\u00e3o indicados nos \u00edcones e cores das caixas. Exerc\u00edcio Isso \u00e9 um exerc\u00edcio! Resposta Esta \u00e9 a resposta do exerc\u00edcio. Resumo Elementos visuais Aviso! Este material est\u00e1 em constante evolu\u00e7\u00e3o. Caixas alinhadas \u00e0 direita podem ser vistas como um sum\u00e1rio executivo do que est\u00e1 sendo apresentado no texto adjacente. Exemplo de nota de rodap\u00e9. \u21a9","title":"Pref\u00e1cio"},{"location":"preface/#prefacio","text":"O paradigma de funcional \u00e9 um dos muitos paradigmas de programa\u00e7\u00e3o dispon\u00edveis e, uma vez que voc\u00ea tenha sido \"contaminado\" pelos outros, certamente n\u00e3o \u00e9 o mais simples de se entender. Ainda assim, \u00e9 um paradigma que deve ser estudado pois seus pontos fortes tem sido incorporados cada vez mais frequentemente em frameworks e linguagens n\u00e3o necessariamente reconhecidos como funcionais. Por isso, neste curso estudaremos o paradigma funcional de uma forma pr\u00e1tica, tentando sempre que poss\u00edvel mostrar diversas aplica\u00e7\u00f5es das ideias apresentadas no mundo da programa\u00e7\u00e3o moderna. Tamb\u00e9m ser\u00e1 foco deste curso, destacar e demonstrar como o uso do paradigma funcional traz vantagens no desenvolvimento de sistemas paralelos e distribu\u00eddos.","title":"Pref\u00e1cio"},{"location":"preface/#agradecimentos","text":"Antes de come\u00e7armos nosso estudo, deixo aqui o meu agradecimento aos professores que forneceram o material sobre o qual estas notas de aula s\u00e3o baseadas, Profa. Gina Maira B. Oliveira, Profa. Maria Adriana Vidigal de Lima, e Prof. Henrique Fernandes, da Faculdade de Computa\u00e7\u00e3o da UFU.","title":"Agradecimentos"},{"location":"preface/#convencoes","text":"Neste documento, usamos diversos recursos visuais com diferentes prop\u00f3sitos. it\u00e1lico indica termos em outras l\u00ednguas, como framework ou middleware . Alguns termos, contudo, s\u00e3o t\u00e3o corriqueiramente usados que me escapam quando escrevendo e acabam n\u00e3o grafados corretamente. negrito indica a introdu\u00e7\u00e3o de termos e conceitos importantes, como escalabilidade e falha . Apontadores indicam um s\u00edtio relacionado ao termo, por exemplo, como criar um reposit\u00f3rio no Github , e cuja leitura \u00e9 sugerida ao final da aula. Notas de rodap\u00e9, indicam uma observa\u00e7\u00e3o importante sobre o que est\u00e1 sendo apresentado, cuja leitura \u00e9 sugerida ao final do par\u00e1grafo. 1 Estas notas incluem referenciais te\u00f3ricos importantes, com detalhes da publica\u00e7\u00e3o e apontadores para onde a publica\u00e7\u00e3o pode ser lida. Imagens n\u00e3o autorais s\u00e3o tamb\u00e9m apontadores para onde s\u00e3o encontradas e tem como texto alternativo as informa\u00e7\u00f5es da autoria. Caixas alinhadas \u00e0 esquerda s\u00e3o usadas para v\u00e1rias finalidades. Por exemplo, para apresentar exerc\u00edcios, destacar especifica\u00e7\u00f5es, apontar tarefas a serem executas por mim. Os diversos usos s\u00e3o indicados nos \u00edcones e cores das caixas. Exerc\u00edcio Isso \u00e9 um exerc\u00edcio! Resposta Esta \u00e9 a resposta do exerc\u00edcio. Resumo Elementos visuais Aviso! Este material est\u00e1 em constante evolu\u00e7\u00e3o. Caixas alinhadas \u00e0 direita podem ser vistas como um sum\u00e1rio executivo do que est\u00e1 sendo apresentado no texto adjacente. Exemplo de nota de rodap\u00e9. \u21a9","title":"Conven\u00e7\u00f5es"},{"location":"prova/","text":"Prova. Escreva uma fun\u00e7\u00e3o que receba um n\u00famero representando um m\u00eas, um n\u00famero de 1 a 12, e retorne a quantidade de dias no m\u00eas. Lembre-se que fevereiro tem 28 dias normalmente, mas 29 em anos bissextos.","title":"Prova"},{"location":"quickcheck/","text":"Agora que nossas fun\u00e7\u00f5es est\u00e3o ficando mais complexas, precisamos gastar um pouco mais de esfor\u00e7o nos certificando de que est\u00e3o corretas. Uma ferramenta que nos ajuda a fazer isso \u00e9 a biblioteca QuickCheck . Para entender como usar a QuickCheck, considere as duas seguintes fun\u00e7\u00f5es. 1 2 3 celsius2fahrenheit c = c * 9 / 5 + 32 fahrenheit2celsius f = ( f - 32 ) * 5 / 9 Elas s\u00e3o obviamente inversas uma da outra, o que quer dizer que se eu aplicar um valor qualquer \u00e0 primeira fun\u00e7\u00e3o e ent\u00e3o aplicar resultado na segunda, eu deveria recuperar o valor original. Por exemplo, se o valor qualquer \u00e9 100, 100 == fahrenheit2celsius ( celsius2fahrenheit 100 ) . Pois a QuickCheck nos permite escrever exatamente este tipo de afirma\u00e7\u00e3o e t\u00ea-la testada automaticamente para um conjunto de valores aleat\u00f3rios. Obviamente, mesmo se o c\u00f3digo passar nos testes gerados pelo QuickCheck, n\u00e3o quer dizer que outros valores n\u00e3o resultariam em erros. Contudo, nossa confian\u00e7a na corretude aumentaria. Para testar as fun\u00e7\u00f5es acima escrever\u00edamos ent\u00e3o a propriedade como uma fun\u00e7\u00e3o que retorna um booleano. A propriedade tem um nome iniciado em prop_ , mas isso \u00e9 apenas uma conven\u00e7\u00e3o. A defini\u00e7\u00e3o recebe como par\u00e2metro um valor c , converte para Celcius e de volta para Fahrenheit, e confere se o valor resultante \u00e9 igual ao valor de entrada. Observe que o resultado da fun\u00e7\u00e3o \u00e9 o resultado da compara\u00e7\u00e3o com o valor inicial, o que \u00e9 equivalente mas muito mais limpo do que fazer um teste do tipo if Condi\u00e7\u00e3o then True else False . 1 prop_C2f2C c = fahrenheit2celsius ( celsius2fahrenheit c ) == c Para usar a biblioteca, precisamos import\u00e1-la, no in\u00edcio do arquivo, com um import Test.QuickCheck . Assim, o arquivo ficar\u00e1 assim. 1 2 3 4 5 6 7 import Test.QuickCheck celsius2fahrenheit c = c * 9 / 5 + 32 fahrenheit2celsius f = ( f - 32 ) * 5 / 9 prop_C2f2C c = fahrenheit2celsius ( celsius2fahrenheit c ) == c Para testar o c\u00f3digo, execute o ghci carregando o QuickCheck. A forma mais simples de faz\u00ea-lo \u00e9 usando stack: stack ghci --package QuickCheck . Agora carregue seu programa, usando :l f2c2f no meu caso e execute o teste 1 2 3 *Main> quickCheck prop_C2f2C *** Failed! Falsified (after 2 tests and 4 shrinks): -0.1 Ooops! O teste falhou para o valor -0.1. Mas por qu\u00ea? Vejamos cada fun\u00e7\u00e3o isoladamente. 1 2 3 4 *Main> celsius2fahrenheit (-0.1) 31.82 *Main> fahrenheit2celsius 31.82 -9.999999999999984e-2 Os valores s\u00e3o pr\u00f3ximos, mas n\u00e3o s\u00e3o iguais, por causa de problemas de arredondamento causados pela imprecis\u00e3o dos tipos utilizados. O problema est\u00e1 no teste, pois \u00e9 imposs\u00edvel para o computador representar certos valores e estes erros de aproxima\u00e7\u00e3o ocorrer\u00e3o. Assim, uma estrat\u00e9gia melhor \u00e9 definir um operador quase igual , para comparar valores com pequenos erros. 1 2 3 4 5 6 7 8 9 10 import Test.QuickCheck celsius2fahrenheit c = c * 9 / 5 + 32 fahrenheit2celsius f = ( f - 32 ) * 5 / 9 prop_C2f2C c = fahrenheit2celsius ( celsius2fahrenheit c ) ~== c l ~== r = abs ( l - r ) < \u03b5 where \u03b5 = 10e-10 Com esta nova defini\u00e7\u00e3o, nosso teste agora passa com sucesso. 1 2 *Main> quickCheck prop_C2f2C +++ OK, passed 100 tests.","title":"QuickCheck"},{"location":"recursion/","text":"Uma fun\u00e7\u00e3o \u00e9 dita recursiva quando ela \u00e9 definida em termos de si mesma . A matem\u00e1tica \u00e9 rica em exemplo de fun\u00e7\u00f5es recursivas, tamb\u00e9m conhecidas como recorr\u00eancias . Dois exemplos bem conhecidos s\u00e3o o fatorial de um n\u00famero... \\[ n! = \\begin{cases} 1 & \\text{se } n = 0\\\\ n * (n-1)! & \\text{se } n >= 0 \\end{cases} \\] ... e a sequ\u00eancia de Fibonacci. \\[ F_n = \\begin{cases} 1 & \\text{se } n = 1\\\\ 1 & \\text{se } n = 2\\\\ F_{n-1} + F_{n_2} & \\text{se } n > 2 \\end{cases} \\] A recurs\u00e3o \u00e9 muito importante na computa\u00e7\u00e3o pois \u00e9 uma estrat\u00e9gia de resolu\u00e7\u00e3o de problemas, pois possibilita resolver um problema pouco a pouco. Mas al\u00e9m disso, ela \u00e9 especialmente importante na programa\u00e7\u00e3o funcional, onde n\u00e3o h\u00e1 instru\u00e7\u00f5es de itera\u00e7\u00e3o como for (;;) e while () , comuns nas linguagens imperativas.","title":"Recurs\u00e3o"},{"location":"refs/","text":"Tutorial completo de PF https://www.tutorialspoint.com/functional_programming/functional_programming_introduction.htm https://www.cse.chalmers.se/edu/year/2018/course/TDA555/lectures.html","title":"Refs"},{"location":"tuples/","text":"Tuplas Nas fun\u00e7\u00f5es vistas at\u00e9 agora, todos os par\u00e2metros eram de algum tipo simples. Por exemplo, vejamos a fun\u00e7\u00e3o soma2n que soma 2 n\u00fameros: 1 2 soma2n :: Int -> Int -> Int soma2n a b = a + b Muitas vezes estes tipos simples precisam ser associados para significar algo de mais alto n\u00edvel. Por exemplo, seja a fun\u00e7\u00e3o soma2v que soma as coordenadas x e y de 2 pontos representando dois vetores. Como poder\u00edamos definir tal fun\u00e7\u00e3o, j\u00e1 que o resultado deve ter informa\u00e7\u00e3o tanto sobre a coordenada x quanto y do resultado? 1 soma2v x1 y1 x2 y2 = ? A resposta est\u00e1 no uso de tipos estruturados que agreguem outros tipos. No caso, a solu\u00e7\u00e3o ideal par ordenado na forma de uma tupla de dois elementos. Tuplas s\u00e3o geralmente representadas usando a sintaxe (Elem1, Elem2, ... , ElemN) , tanto em Haskell como em diversas outras linguagens. Assim, a fun\u00e7\u00e3o soma2v pode ser definida, incluindo o prot\u00f3tipo, como a seguir. Observe que a fun\u00e7\u00e3o define claramente quantos elementos a tupla ter\u00e1 e qual a vari\u00e1vel associada a cada uma das coordenadas de cada ponto. 1 2 soma2v :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) soma2v ( x1 , y1 ) ( x2 , y2 ) = ( x1 + x2 , y1 + y2 ) Para usar a fun\u00e7\u00e3o, podemos invoc\u00e1-la de duas formas, usando a nota\u00e7\u00e3o prefixa ou infixa, com o mesmo resultado. 1 2 soma2v ( 3 , 4 ) ( 5 , 4 ) ( 3 , 4 ) ` soma2v ` ( 5 , 4 ) Outra forma de definir a mesma fun\u00e7\u00e3o, sem especificar o nome das vari\u00e1veis, seria usando as fun\u00e7\u00f5es fst e snd do Prelude , abrevia\u00e7\u00f5es para first e second e que retornam o primeiro e o segundo elemento de uma tupla de dois elementos, um par, respectivamente. Logo, 1 2 3 4 5 6 7 8 9 10 > snd ( 1 , 2 ) 2 > fst ( 3 , 4 ) 3 > fst ( snd (( 1 , 2 , 3 ),( 4 , 5 ))) 4 > fst ( 1 , 2 , 3 ) <== Erro ! De forma simplificada, fst e snd poderiam ser definidos assim: 1 2 3 fst ( x , y ) = x snd ( x , y ) = y Mas na pr\u00e1tica, ainda de forma simplificada, s\u00e3o definidos assim 1 2 3 fst ( x , _ ) = x snd ( _ , y ) = y Observe que o _ \u00e9 usado em substitui\u00e7\u00e3o a um nome para vari\u00e1veis com as quais n\u00e3o nos importamos , isto que, que n\u00e3o ser\u00e3o usadas no dado escopo. O GHC consegue otimizar o c\u00f3digo para n\u00e3o gastar recursos com mesma. Assim, usando fst e snd , a defini\u00e7\u00e3o da soma dos vetores fica como se segue: 1 2 soma2v' :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) soma2v' p1 p2 = (( fst p1 ) + ( fst p2 ), ( snd p1 ) + ( snd p2 )) Exerc\u00edcio Considerando uma tupla de 4 elementos, defina 4 fun\u00e7\u00f5es que, aos moldes de fst e snd , extraiam cada um dos 4 elementos da tupla. N\u00e3o defina um prot\u00f3tipo. Resolu\u00e7\u00e3o 1 2 3 4 prim ( x , _ , _ , _ ) = x segu ( _ , y , _ , _ ) = y terc ( _ , _ , z , _ ) = z quar ( _ , _ , _ , w ) = w Exerc\u00edcio Escreva uma fun\u00e7\u00e3o que receba um inteiro como par\u00e2metro e retorne uma tupla como resultado onde o primeiro elemento \u00e9 um booleano que indica se o n\u00famero \u00e9 negativo, e o segundo elemento \u00e9 o valor absoluto do n\u00famero. Resolu\u00e7\u00e3o 1 2 3 4 5 \u00e9Neg :: Int -> ( Bool , Int ) \u00e9Neg x = if x < 0 then ( True , abs x ) else ( False , abs x ) \u00e9Neg' :: Int -> ( Bool , Int ) \u00e9Neg' x = ( x < 0 , abs x ) Tuplas est\u00e3o para Haskell assim como estruturas est\u00e3o para outras linguagens. Por exemplo, imagine que se queira armazenar os dados nome, telefone, CPF e endere\u00e7o de uma pessoa. Poder\u00edamos convencionar que seria usado uma tupla em que cada posi\u00e7\u00e3o corresponderia a um dos dados. Neste caso, alguns exemplos de fun\u00e7\u00f5es \u00fateis s\u00e3o mostrados a seguir. 1 2 3 4 5 6 7 8 9 10 11 fazPessoa :: String -> String -> String -> String -> ( String , String , String , String ) -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: ( String , String , String , String ) -> String pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: ( String , String , String , String ) -> String pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone :: ( String , String , String , String ) -> String -> ( String , String , String , String ) trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) 1 2 3 4 5 6 7 8 9 10 > x = fazPessoa \"jose da silva\" \"12345\" \"0003003093\" \"Av das Couves, 14\" > x => ( \"jose da silva\" , \"12345\" , \"0003003093\" , \"Av das Couves, 14\" ) > pegaNome x => \"jose da silva\" > pegaTelefone x => \"12345\" > y = trocaTelefone x \"54321\" > y => ( \"jose da silva\" , \"54321\" , \"0003003093\" , \"Av das Couves, 14\" ) Uma observa\u00e7\u00e3o a ser feita \u00e9 que, na \u00faltima fun\u00e7\u00e3o, nomear a vari\u00e1vel como _t tem o mesmo efeito que simplesmente _ para o compilador, mas deixa o c\u00f3digo mais leg\u00edvel. Outra observa\u00e7\u00e3o \u00e9 que mesmo com o uso _t , o c\u00f3digo fica rapidamente dif\u00edcil de se ler, pois o desenvolvedor deve manter em mente qual posi\u00e7\u00e3o corresponde a qual dado de uma pessoa; imagine estruturas mais complexas, contendo outros dados de cada pessoa, e v\u00e1rias outras estruturas semelhantes, como ordens de servi\u00e7o, descri\u00e7\u00e3o de invent\u00e1rios, cadastro de vendedores, etc. Uma forma de simplificar o c\u00f3digo \u00e9 definir tipos associados a cada estrutura. Tuplas como tipos Como visto anteriormente, a palavra reservada type permite que definamos apelidos para tipos no Haskell. Pois tuplas tamb\u00e9m podem ser associadas a tipos, por exemplo, podemos definir que Pessoa \u00e9 o tipo definido na se\u00e7\u00e3o anterior, i.e., uma tupla dos campos nome, telefone, CPF e endere\u00e7o. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Pessoa = ( String , String , String , String ) fazPessoa :: String -> String -> String -> String -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> String pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> String pegaTelefone ( _ , telefone , _ , _ ) = telefone pegaCPF :: Pessoa -> String pegaCPF ( _ , _ , c , _ ) = c pegaEndere\u00e7o :: Pessoa -> String pegaEndere\u00e7o ( _ , _ , _ , e ) = e trocaTelefone :: Pessoa -> String -> Pessoa trocaTelefone p novoTelefone = fazPessoa ( pegaNome p ) novoTelefone ( pegaCPF p ) ( pegaEndere\u00e7o p ) Se perguntarmos ao Haskell qual o tipo da tupla gerada pela fun\u00e7\u00e3o fazPessoa , ele responder\u00e1 Pessoa . 1 2 3 4 5 > : t fazPessoa fazPessoa :: String -> String -> String -> String -> Pessoa > p = fazPessoa \"Jose\" \"Tel\" \"CPF\" \"End\" > : t p p :: Pessoa Podemos ir al\u00e9m e definir tipos usando outros tipos estruturados. Por exemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Nome = ( String , String , String ) type Telefone = ( String , String ) type CPF = String type Endere\u00e7o = ( String , String , String ) type Pessoa = ( Nome , Telefone , CPF , Endere\u00e7o ) fazPessoa :: Nome -> Telefone -> CPF -> Endere\u00e7o -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> Nome pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> Telefone pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone :: Pessoa -> Telefone -> Pessoa trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) Neste caso 1 2 3 4 5 6 7 8 9 10 > p = fazPessoa ( \"Jos\u00e9\" , \"da\" , \"Silva\" ) ( \"ddd\" , \"numero\" ) \"CPF\" ( \"Rua da Couves\" , \"143\" , \"Brasil\" ) > p (( \"Jos \\233 \" , \"da\" , \"Silva\" ),( \"ddd\" , \"numero\" ), \"CPF\" ,( \"Rua da Couves\" , \"143\" , \"Brasil\" )) > : t p p :: Pessoa > n = pegaNome p > n ( \"Jos \\233 \" , \"da\" , \"Silva\" ) > : t n n :: Nome Vejamos outro exemplo; sejam datas, tuplas de 3 inteiros: dia, m\u00eas e ano. Assim, 25 de dezembro de 1999 \u00e9 ( 25 , 12 , 1999 ) . Dado duas datas v\u00e1lidas, uma opera\u00e7\u00e3o interessante \u00e9 testar se uma data \u00e9 menor que outra. 1 2 3 4 5 6 7 8 9 10 11 type Data = ( Int , Int , Int ) dataEhMenor :: ( Int , Int , Int ) -> ( Int , Int , Int ) -> Bool dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) dataEhMenor' :: Data -> Data -> Bool dataEhMenor' ( de , me , ae ) ( dd , md , ad ) = if ae < ad then True else if me < md then True else if de < dd then True else False Mas esta fun\u00e7\u00e3o pode ser descartada com a escolha da defini\u00e7\u00e3o de data, pois tuplas s\u00e3o naturalmente orden\u00e1veis. Data V\u00e1lida Defina um tipo para representar datas como tuplas. Defina uma fun\u00e7\u00e3o dataValida que receba uma data e retorne True se a data for v\u00e1lida e False se for inv\u00e1lida. Por exemplo, 38 de onzembro de 2021 \u00e9 uma data inv\u00e1lida, assim como 29 de fevereiro de 2017, mas dia primeiro de Janeiro de 2000 \u00e9 v\u00e1lida. Isto \u00e9, dataValida ( 38 , 13 , 2021 ) == False dataValida ( 29 , 02 , 2017 ) == False dataValida ( 1 , 1 , 2000 ) == True Resolu\u00e7\u00e3o 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 type Data = ( Int , Int , Int ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) {- >>> bissexto 3 False >>> bissexto 20 True >>> bissexto 100 False >>> bissexto 2000 True -} bissexto :: Integral a => a -> Bool bissexto x | mod x 400 == 0 = True | mod x 100 == 0 = False | otherwise = mod x 4 == 0 {- >>> dataValida (1,1,2001) True >>> dataValida (1,13,2001) False >>> dataValida (29,2,2000) True >>> dataValida (29,2,1999) -} dataValida :: ( Int , Int , Int ) -> Bool dataValida ( d , m , a ) = anoValido a && mesValido m && diaValido d m ( bissexto a ) {- >>> diaValido 2 1 False True >>> diaValido 2 1 True True >>> diaValido 29 2 False False >>> diaValido 29 2 True True -} diaValido :: Int -> Int -> Bool -> Bool diaValido d m bi = d > 0 && d <= numDias m bi {- >>> numDias 3 False 31 >>> numDias 2 True 29 >>> numDias 2 False 28 -} numDias :: Int -> Bool -> Int numDias m bi | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = if bi then 29 else 28 | otherwise = 30 {- >>> mesValido 4 True >>> mesValido 13 False -} mesValido :: Int -> Bool mesValido m = m > 0 && m < 13 {- >>> anoValido 3000 True -} anoValido :: Int -> Bool anoValido a = a > 0 Ordem entre tuplas Dado duas tuplas com mesmo tipo e, obviamente, de mesmo tamanho , elas podem se comparadas lexicogr\u00e1ficamente. Isto quer dizer que uma tupla \\(t_1\\) \u00e9 menor que uma tupla \\(t_2\\) se, considerando posi\u00e7\u00f5es da direita para a esquerda: dado uma posi\u00e7\u00e3o \\(i\\) , se \\(t_1\\) na posi\u00e7\u00e3o \\(i\\) \u00e9 menor que \\(t_2\\) na posi\u00e7\u00e3o \\(i\\) e se \\(\\forall j < i\\) , \\(t_1\\) na posi\u00e7\u00e3o \\(j\\) \u00e9 igual a \\(t_2\\) na posi\u00e7\u00e3o \\(j\\) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 > ( 1 , 2 ) < ( 1 , 3 ) True > ( 'a' , 2 ) < ( 'b' , 3 ) True > ( 'a' , 2 ) == ( 'b' , 3 ) False > ( 'a' , 2 ) > ( 'b' , 3 ) False > ( 1 , 2 ) < ( 1 , 3 , 4 ) <== Erro ! > ( 1 , 1 , 1 ) < ( 1 , 1 , 1 ) False > ( 1 , 1 , 1 ) < ( 1 , 1 , 2 ) True > ( 1 , 1 , 1 ) < ( 1 , 2 , 1 ) True > ( 1 , 1 , 1 ) < ( 2 , 1 , 1 ) True > ( 1 , 1 , 1 ) < ( 0 , 2 , 2 ) False Assim, se usarmos como data uma tupla com ano, m\u00eas e dia, nesta ordem , ent\u00e3o duas datas podem ser comparadas diretamente como compara\u00e7\u00e3o de tuplas. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 type Data = ( Int , Int , Int ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor :: Data -> Data -> Bool dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor' :: Data -> Data -> Bool dataEhMenor' ( de , me , ae ) ( dd , md , ad ) = ( ae , me , de ) < ( ad , md , dd ) A tupla vazia Por completude, \u00e9 preciso mencionar que tuplas podem ter qualquer aridade, inclusive zero. Isto \u00e9, () \u00e9 uma tupla v\u00e1lida e a \u00fanica inst\u00e2ncia de tuplas de aridade zero.","title":"Tuplas"},{"location":"tuples/#tuplas","text":"Nas fun\u00e7\u00f5es vistas at\u00e9 agora, todos os par\u00e2metros eram de algum tipo simples. Por exemplo, vejamos a fun\u00e7\u00e3o soma2n que soma 2 n\u00fameros: 1 2 soma2n :: Int -> Int -> Int soma2n a b = a + b Muitas vezes estes tipos simples precisam ser associados para significar algo de mais alto n\u00edvel. Por exemplo, seja a fun\u00e7\u00e3o soma2v que soma as coordenadas x e y de 2 pontos representando dois vetores. Como poder\u00edamos definir tal fun\u00e7\u00e3o, j\u00e1 que o resultado deve ter informa\u00e7\u00e3o tanto sobre a coordenada x quanto y do resultado? 1 soma2v x1 y1 x2 y2 = ? A resposta est\u00e1 no uso de tipos estruturados que agreguem outros tipos. No caso, a solu\u00e7\u00e3o ideal par ordenado na forma de uma tupla de dois elementos. Tuplas s\u00e3o geralmente representadas usando a sintaxe (Elem1, Elem2, ... , ElemN) , tanto em Haskell como em diversas outras linguagens. Assim, a fun\u00e7\u00e3o soma2v pode ser definida, incluindo o prot\u00f3tipo, como a seguir. Observe que a fun\u00e7\u00e3o define claramente quantos elementos a tupla ter\u00e1 e qual a vari\u00e1vel associada a cada uma das coordenadas de cada ponto. 1 2 soma2v :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) soma2v ( x1 , y1 ) ( x2 , y2 ) = ( x1 + x2 , y1 + y2 ) Para usar a fun\u00e7\u00e3o, podemos invoc\u00e1-la de duas formas, usando a nota\u00e7\u00e3o prefixa ou infixa, com o mesmo resultado. 1 2 soma2v ( 3 , 4 ) ( 5 , 4 ) ( 3 , 4 ) ` soma2v ` ( 5 , 4 ) Outra forma de definir a mesma fun\u00e7\u00e3o, sem especificar o nome das vari\u00e1veis, seria usando as fun\u00e7\u00f5es fst e snd do Prelude , abrevia\u00e7\u00f5es para first e second e que retornam o primeiro e o segundo elemento de uma tupla de dois elementos, um par, respectivamente. Logo, 1 2 3 4 5 6 7 8 9 10 > snd ( 1 , 2 ) 2 > fst ( 3 , 4 ) 3 > fst ( snd (( 1 , 2 , 3 ),( 4 , 5 ))) 4 > fst ( 1 , 2 , 3 ) <== Erro ! De forma simplificada, fst e snd poderiam ser definidos assim: 1 2 3 fst ( x , y ) = x snd ( x , y ) = y Mas na pr\u00e1tica, ainda de forma simplificada, s\u00e3o definidos assim 1 2 3 fst ( x , _ ) = x snd ( _ , y ) = y Observe que o _ \u00e9 usado em substitui\u00e7\u00e3o a um nome para vari\u00e1veis com as quais n\u00e3o nos importamos , isto que, que n\u00e3o ser\u00e3o usadas no dado escopo. O GHC consegue otimizar o c\u00f3digo para n\u00e3o gastar recursos com mesma. Assim, usando fst e snd , a defini\u00e7\u00e3o da soma dos vetores fica como se segue: 1 2 soma2v' :: ( Int , Int ) -> ( Int , Int ) -> ( Int , Int ) soma2v' p1 p2 = (( fst p1 ) + ( fst p2 ), ( snd p1 ) + ( snd p2 )) Exerc\u00edcio Considerando uma tupla de 4 elementos, defina 4 fun\u00e7\u00f5es que, aos moldes de fst e snd , extraiam cada um dos 4 elementos da tupla. N\u00e3o defina um prot\u00f3tipo. Resolu\u00e7\u00e3o 1 2 3 4 prim ( x , _ , _ , _ ) = x segu ( _ , y , _ , _ ) = y terc ( _ , _ , z , _ ) = z quar ( _ , _ , _ , w ) = w Exerc\u00edcio Escreva uma fun\u00e7\u00e3o que receba um inteiro como par\u00e2metro e retorne uma tupla como resultado onde o primeiro elemento \u00e9 um booleano que indica se o n\u00famero \u00e9 negativo, e o segundo elemento \u00e9 o valor absoluto do n\u00famero. Resolu\u00e7\u00e3o 1 2 3 4 5 \u00e9Neg :: Int -> ( Bool , Int ) \u00e9Neg x = if x < 0 then ( True , abs x ) else ( False , abs x ) \u00e9Neg' :: Int -> ( Bool , Int ) \u00e9Neg' x = ( x < 0 , abs x ) Tuplas est\u00e3o para Haskell assim como estruturas est\u00e3o para outras linguagens. Por exemplo, imagine que se queira armazenar os dados nome, telefone, CPF e endere\u00e7o de uma pessoa. Poder\u00edamos convencionar que seria usado uma tupla em que cada posi\u00e7\u00e3o corresponderia a um dos dados. Neste caso, alguns exemplos de fun\u00e7\u00f5es \u00fateis s\u00e3o mostrados a seguir. 1 2 3 4 5 6 7 8 9 10 11 fazPessoa :: String -> String -> String -> String -> ( String , String , String , String ) -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: ( String , String , String , String ) -> String pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: ( String , String , String , String ) -> String pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone :: ( String , String , String , String ) -> String -> ( String , String , String , String ) trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) 1 2 3 4 5 6 7 8 9 10 > x = fazPessoa \"jose da silva\" \"12345\" \"0003003093\" \"Av das Couves, 14\" > x => ( \"jose da silva\" , \"12345\" , \"0003003093\" , \"Av das Couves, 14\" ) > pegaNome x => \"jose da silva\" > pegaTelefone x => \"12345\" > y = trocaTelefone x \"54321\" > y => ( \"jose da silva\" , \"54321\" , \"0003003093\" , \"Av das Couves, 14\" ) Uma observa\u00e7\u00e3o a ser feita \u00e9 que, na \u00faltima fun\u00e7\u00e3o, nomear a vari\u00e1vel como _t tem o mesmo efeito que simplesmente _ para o compilador, mas deixa o c\u00f3digo mais leg\u00edvel. Outra observa\u00e7\u00e3o \u00e9 que mesmo com o uso _t , o c\u00f3digo fica rapidamente dif\u00edcil de se ler, pois o desenvolvedor deve manter em mente qual posi\u00e7\u00e3o corresponde a qual dado de uma pessoa; imagine estruturas mais complexas, contendo outros dados de cada pessoa, e v\u00e1rias outras estruturas semelhantes, como ordens de servi\u00e7o, descri\u00e7\u00e3o de invent\u00e1rios, cadastro de vendedores, etc. Uma forma de simplificar o c\u00f3digo \u00e9 definir tipos associados a cada estrutura.","title":"Tuplas"},{"location":"tuples/#tuplas-como-tipos","text":"Como visto anteriormente, a palavra reservada type permite que definamos apelidos para tipos no Haskell. Pois tuplas tamb\u00e9m podem ser associadas a tipos, por exemplo, podemos definir que Pessoa \u00e9 o tipo definido na se\u00e7\u00e3o anterior, i.e., uma tupla dos campos nome, telefone, CPF e endere\u00e7o. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Pessoa = ( String , String , String , String ) fazPessoa :: String -> String -> String -> String -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> String pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> String pegaTelefone ( _ , telefone , _ , _ ) = telefone pegaCPF :: Pessoa -> String pegaCPF ( _ , _ , c , _ ) = c pegaEndere\u00e7o :: Pessoa -> String pegaEndere\u00e7o ( _ , _ , _ , e ) = e trocaTelefone :: Pessoa -> String -> Pessoa trocaTelefone p novoTelefone = fazPessoa ( pegaNome p ) novoTelefone ( pegaCPF p ) ( pegaEndere\u00e7o p ) Se perguntarmos ao Haskell qual o tipo da tupla gerada pela fun\u00e7\u00e3o fazPessoa , ele responder\u00e1 Pessoa . 1 2 3 4 5 > : t fazPessoa fazPessoa :: String -> String -> String -> String -> Pessoa > p = fazPessoa \"Jose\" \"Tel\" \"CPF\" \"End\" > : t p p :: Pessoa Podemos ir al\u00e9m e definir tipos usando outros tipos estruturados. Por exemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Nome = ( String , String , String ) type Telefone = ( String , String ) type CPF = String type Endere\u00e7o = ( String , String , String ) type Pessoa = ( Nome , Telefone , CPF , Endere\u00e7o ) fazPessoa :: Nome -> Telefone -> CPF -> Endere\u00e7o -> Pessoa -- (1) Defini\u00e7\u00e3o da fun\u00e7\u00e3o. fazPessoa nome telefone cpf endere\u00e7o = ( nome , telefone , cpf , endere\u00e7o ) pegaNome :: Pessoa -> Nome pegaNome ( nome , _ , _ , _ ) = nome pegaTelefone :: Pessoa -> Telefone pegaTelefone ( _ , telefone , _ , _ ) = telefone trocaTelefone :: Pessoa -> Telefone -> Pessoa trocaTelefone ( n , _t , c , e ) novoTelefone = ( n , novoTelefone , c , e ) Neste caso 1 2 3 4 5 6 7 8 9 10 > p = fazPessoa ( \"Jos\u00e9\" , \"da\" , \"Silva\" ) ( \"ddd\" , \"numero\" ) \"CPF\" ( \"Rua da Couves\" , \"143\" , \"Brasil\" ) > p (( \"Jos \\233 \" , \"da\" , \"Silva\" ),( \"ddd\" , \"numero\" ), \"CPF\" ,( \"Rua da Couves\" , \"143\" , \"Brasil\" )) > : t p p :: Pessoa > n = pegaNome p > n ( \"Jos \\233 \" , \"da\" , \"Silva\" ) > : t n n :: Nome Vejamos outro exemplo; sejam datas, tuplas de 3 inteiros: dia, m\u00eas e ano. Assim, 25 de dezembro de 1999 \u00e9 ( 25 , 12 , 1999 ) . Dado duas datas v\u00e1lidas, uma opera\u00e7\u00e3o interessante \u00e9 testar se uma data \u00e9 menor que outra. 1 2 3 4 5 6 7 8 9 10 11 type Data = ( Int , Int , Int ) dataEhMenor :: ( Int , Int , Int ) -> ( Int , Int , Int ) -> Bool dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) dataEhMenor' :: Data -> Data -> Bool dataEhMenor' ( de , me , ae ) ( dd , md , ad ) = if ae < ad then True else if me < md then True else if de < dd then True else False Mas esta fun\u00e7\u00e3o pode ser descartada com a escolha da defini\u00e7\u00e3o de data, pois tuplas s\u00e3o naturalmente orden\u00e1veis. Data V\u00e1lida Defina um tipo para representar datas como tuplas. Defina uma fun\u00e7\u00e3o dataValida que receba uma data e retorne True se a data for v\u00e1lida e False se for inv\u00e1lida. Por exemplo, 38 de onzembro de 2021 \u00e9 uma data inv\u00e1lida, assim como 29 de fevereiro de 2017, mas dia primeiro de Janeiro de 2000 \u00e9 v\u00e1lida. Isto \u00e9, dataValida ( 38 , 13 , 2021 ) == False dataValida ( 29 , 02 , 2017 ) == False dataValida ( 1 , 1 , 2000 ) == True Resolu\u00e7\u00e3o 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 type Data = ( Int , Int , Int ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) {- >>> bissexto 3 False >>> bissexto 20 True >>> bissexto 100 False >>> bissexto 2000 True -} bissexto :: Integral a => a -> Bool bissexto x | mod x 400 == 0 = True | mod x 100 == 0 = False | otherwise = mod x 4 == 0 {- >>> dataValida (1,1,2001) True >>> dataValida (1,13,2001) False >>> dataValida (29,2,2000) True >>> dataValida (29,2,1999) -} dataValida :: ( Int , Int , Int ) -> Bool dataValida ( d , m , a ) = anoValido a && mesValido m && diaValido d m ( bissexto a ) {- >>> diaValido 2 1 False True >>> diaValido 2 1 True True >>> diaValido 29 2 False False >>> diaValido 29 2 True True -} diaValido :: Int -> Int -> Bool -> Bool diaValido d m bi = d > 0 && d <= numDias m bi {- >>> numDias 3 False 31 >>> numDias 2 True 29 >>> numDias 2 False 28 -} numDias :: Int -> Bool -> Int numDias m bi | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = if bi then 29 else 28 | otherwise = 30 {- >>> mesValido 4 True >>> mesValido 13 False -} mesValido :: Int -> Bool mesValido m = m > 0 && m < 13 {- >>> anoValido 3000 True -} anoValido :: Int -> Bool anoValido a = a > 0","title":"Tuplas como tipos"},{"location":"tuples/#ordem-entre-tuplas","text":"Dado duas tuplas com mesmo tipo e, obviamente, de mesmo tamanho , elas podem se comparadas lexicogr\u00e1ficamente. Isto quer dizer que uma tupla \\(t_1\\) \u00e9 menor que uma tupla \\(t_2\\) se, considerando posi\u00e7\u00f5es da direita para a esquerda: dado uma posi\u00e7\u00e3o \\(i\\) , se \\(t_1\\) na posi\u00e7\u00e3o \\(i\\) \u00e9 menor que \\(t_2\\) na posi\u00e7\u00e3o \\(i\\) e se \\(\\forall j < i\\) , \\(t_1\\) na posi\u00e7\u00e3o \\(j\\) \u00e9 igual a \\(t_2\\) na posi\u00e7\u00e3o \\(j\\) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 > ( 1 , 2 ) < ( 1 , 3 ) True > ( 'a' , 2 ) < ( 'b' , 3 ) True > ( 'a' , 2 ) == ( 'b' , 3 ) False > ( 'a' , 2 ) > ( 'b' , 3 ) False > ( 1 , 2 ) < ( 1 , 3 , 4 ) <== Erro ! > ( 1 , 1 , 1 ) < ( 1 , 1 , 1 ) False > ( 1 , 1 , 1 ) < ( 1 , 1 , 2 ) True > ( 1 , 1 , 1 ) < ( 1 , 2 , 1 ) True > ( 1 , 1 , 1 ) < ( 2 , 1 , 1 ) True > ( 1 , 1 , 1 ) < ( 0 , 2 , 2 ) False Assim, se usarmos como data uma tupla com ano, m\u00eas e dia, nesta ordem , ent\u00e3o duas datas podem ser comparadas diretamente como compara\u00e7\u00e3o de tuplas. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 type Data = ( Int , Int , Int ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor :: Data -> Data -> Bool dataEhMenor ( de , me , ae ) ( dd , md , ad ) = ( ae < ad ) || ( ae == ad && me < md ) || ( ae == ad && me == md && de < dd ) {- >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,01,2000) False >>> dataEhMenor (01,01,2000) (02,01,2000) True >>> dataEhMenor (05,01,2000) (02,02,2000) True >>> dataEhMenor (05,05,2000) (02,02,2001) True -} dataEhMenor' :: Data -> Data -> Bool dataEhMenor' ( de , me , ae ) ( dd , md , ad ) = ( ae , me , de ) < ( ad , md , dd )","title":"Ordem entre tuplas"},{"location":"tuples/#a-tupla-vazia","text":"Por completude, \u00e9 preciso mencionar que tuplas podem ter qualquer aridade, inclusive zero. Isto \u00e9, () \u00e9 uma tupla v\u00e1lida e a \u00fanica inst\u00e2ncia de tuplas de aridade zero.","title":"A tupla vazia"},{"location":"types/","text":"Tipos Seja a fun\u00e7\u00e3o diasMes a fun\u00e7\u00e3o que calcula a quantidade de dias em um m\u00eas, dado o n\u00famero do m\u00eas, definida assim: 1 2 3 4 diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 O que acontece se voc\u00ea passar 7.2 para a fun\u00e7\u00e3o? O resultado est\u00e1 correto? Isso nos leva a perguntar como definir que uma fun\u00e7\u00e3o s\u00f3 \u00e9 aplic\u00e1vel a n\u00fameros inteiros, do tipo inteiro. Em linguagens de programa\u00e7\u00e3o, um tipo \u00e9 um nome dado a uma cole\u00e7\u00e3o de valores que tem um mesmo comportamento na linguagem. Na linguagem C, por exemplo, temos os tipos int e short , ambos associados a valores inteiros mas com n\u00famero de bits diferentes usados para represent\u00e1-los. Algumas linguagens s\u00e3o denominadas fracamente tipadas , o que quer dizer que o uso de tipos \u00e9 relaxado e pode at\u00e9 ser alterado em tempo de execu\u00e7\u00e3o. Por exemplo, no seguinte c\u00f3digo em Python a vari\u00e1vel x assume tr\u00eas tipos diferentes em momentos diferentes da execu\u00e7\u00e3o. 1 2 3 4 5 6 7 8 x = \"lala\" print ( type ( x )) x = 10 print ( type ( x )) x = 10.0 print ( type ( x )) 1 2 3 <class 'str' > <class 'int' > <class 'float' > J\u00e1 a linguagem Haskell \u00e9 o que chamamos de fortemente tipada , o que quer dizer que toda vari\u00e1vel, constante ou fun\u00e7\u00e3o tem apenas um tipo e este sempre pode ser determinado. Al\u00e9m disso, Haskell \u00e9 estaticamente tipada , ou seja, os tipos s\u00e3o determinados em tempo de compila\u00e7\u00e3o, em oposi\u00e7\u00e3o a linguagens que determinam o tipo durante a execu\u00e7\u00e3o do programa, denominadas dinamicamente tipadas. Assim como type em Python, Haskell tem a fun\u00e7\u00e3o : type para verificar o tipo de uma vari\u00e1vel. Por exemplo: 1 2 3 4 5 6 > : type 1 1 :: Num p => p > : type 1.0 1.0 :: Fractional p => p > : type \"Bom dia\" \"Bom dia\" :: [ Char ] Tipos em Haskell Forte Est\u00e1ticos Por Infer\u00eancia Finalmente, se olharmos novamente para os exemplos de fun\u00e7\u00f5es anteriores, veremos que n\u00e3o foram definidos tipos em suas declara\u00e7\u00f5es; isto \u00e9 poss\u00edvel porqu\u00ea Haskell consegue inferir os tipos dos dados de forma muito eficiente. Quando voc\u00ea explicita tipos, o faz apenas para facilitar a leitura do c\u00f3digo e para indicar sua inten\u00e7\u00e3o ao compilador que, pode-se dizer, far\u00e1 a infer\u00eancia e testar\u00e1 se voc\u00ea est\u00e1 certo. Haskell tem um n\u00famero imenso de tipos pre-definidos, organizados hierarquicamente, e que podem ser usados para definir novos tipos pelo programador. Mas por enquanto, nos foquemos nos tipos mais simples. Tipos Primitivos e Operadores Tipos num\u00e9ricos Como toda linguagem de programa\u00e7\u00e3o, Haskell tem v\u00e1rios tipos pr\u00e9-definidos para representar n\u00fameros, como mostra a seguinte tabela. Tipo Descri\u00e7\u00e3o Valores Int Inteiro de precis\u00e3o finita 4, -14, 2147483647 Integer Inteiro de precis\u00e3o arbitr\u00e1ria 30414093201713378043612608166064768844377641568960512000000000000 Float Ponto flutuante de precis\u00e3o simples 25.132742 Double Ponto flutuante de precis\u00e3o dupla 25.132741228718345 Dados os tipos num\u00e9ricos prim\u00e1rios, o pr\u00f3ximo passo \u00e9 ver alguns dos operadores que os manipulam. Operador Opera\u00e7\u00e3o + Adi\u00e7\u00e3o - Subtra\u00e7\u00e3o * Multiplica\u00e7\u00e3o / Divis\u00e3o ^ Exponencia\u00e7\u00e3o, e.g, 2^4 == 16 - Invers\u00e3o de sinal, e.g, - (-10) == 10 2 negate Invers\u00e3o de sinal, e.g, negate (-10) == 10 2 quot Divis\u00e3o inteira, truncado pro 0, i.e., quot a b \u00e9 igual a \\(\\lfloor\\frac{a}{b}\\rfloor\\) se \\(a>0\\) e \\(\\lceil\\frac{a}{b}\\rceil\\) se \\(a<0\\) , e.g, div 8 3 == 2 e div (-8) 3 == -2 rem Resto da divis\u00e3o inteira, tal que (x `quot` y)*y + (x `rem` y) == x div Resto da divis\u00e3o, truncado para baixo, i.e., div a b \u00e9 igual a \\(\\lfloor\\frac{a}{b}\\rfloor\\) , e.g, div 8 3 == 2 e div (-8) 3 == -3 mod M\u00f3dulo do inteiro, tal que ( x ` div ` y ) * y + ( x ` mod ` y ) == x Observe que alguns destes operadores s\u00e3o naturalmente infixos, e.g., + , e outros, prefixos, e.g., rem . 1 Contudo, ambos podem ser usados da outra forma, como mostrado nos seguintes exemplos. 1 2 3 4 10 + 20 ( + ) 10 20 quot 10 3 10 ` quot ` 3 Caso voc\u00ea queira ou precise especificar um tipo para um n\u00famero, pode sufix\u00e1-lo com o tipo, por exemplo, 20 :: Int ou 20 :: Double . Exerc\u00edcios Usar todos os operadores Evidenciar diferen\u00e7as entrem quot/rem e div/mod. Booleanos Finalmente, para representa\u00e7\u00e3o de valores l\u00f3gicos, Haskell define o tipo bool . Tipo Descri\u00e7\u00e3o Valores Bool Booleano True ou False Para este tipo, temos os seguintes operadores. Operador Opera\u00e7\u00e3o && E l\u00f3gico || OU l\u00f3gico not Nega\u00e7\u00e3o == Igualdade /= Diferen\u00e7a Caracteres Para a representa\u00e7\u00e3o de caracteres individuais, Haskell usa o tipo Char , e para sequ\u00eancias de caracteres, usa o tipo String , que \u00e9 um \"apelido\" para lista de Char . 3 Como lista n\u00e3o \u00e9 um tipo primitivo, ou melhor, mesmo que em Haskell listas sejam fundamentais, n\u00e3o as estudaremos agora. Ainda assim, usaremos String em alguns exemplos, mas sem entrar em detalhes da manipula\u00e7\u00e3o de listas. Exemplos dos dois tipos s\u00e3o apresentados na tabela a seguir. Tipo Descri\u00e7\u00e3o Valores Char Caractere '1'; 'a'; 'B' String Sequ\u00eancia de caracteres \"Eu\"; \"Hello\"; \"Zabumba\" Algumas fun\u00e7\u00f5es \u00fateis na manipula\u00e7\u00e3o de caracteres e strings s\u00e3o apresentadas na tabela. Operador Opera\u00e7\u00e3o Exemplo ++ Concatena\u00e7\u00e3o \"foo\" ++ \"bar\" -> \"foobar\" !! Caractere no \u00edndice \"foo bar\" !! 2 -> 'o' take Substring iniciando em 0 take 3 \"foo bar\" -> \"foo\" drop Substring come\u00e7ando em um \u00edndice drop 3 \"foo bar\" -> \" bar\" reverse String ao contr\u00e1rio reverse \"foo bar\" -> \"rab oof\" length Comprimento da string length \"foo bar\" -> 7 N\u00f3s voltaremos a falar sobre Strings uma vez que estudarmos listas. Exerc\u00edcios Defina fun\u00e7\u00e3o que retorne substring de t elementos come\u00e7ando na posi\u00e7\u00e3o i minhaFuncao \"entrada1\" 2 2 retorna \"tr\" Defina fun\u00e7\u00e3o que retorne substring com os \u00faltimos u elementos minhaFuncao \"entrada1\" 2 retorna \"a1\" Defina fun\u00e7\u00e3o que receba duas strings e retorne a resultado da concatena\u00e7\u00e3o das substrings de t elementos come\u00e7ando na posi\u00e7\u00e3o i minhaFuncao \"entrada1\" \"entrada2\" 2 2 retorna \"trtr\" Prot\u00f3tipo de fun\u00e7\u00f5es Agora que j\u00e1 conhecemos alguns tipos, podemos ver como us\u00e1-los na defini\u00e7\u00e3o de fun\u00e7\u00f5es. Para faz\u00ea-lo, devemos usar a seguinte sintaxe: 1 2 nomeFuncao :: tipo_arg1 -> ... -> tipo_argN -> tipo_saida nomeFuncao arg1 ... argN = < definicao > Por exemplo, o prot\u00f3tipo da fun\u00e7\u00e3o diaMes , isto \u00e9, a defini\u00e7\u00e3o dos tipos de entrada e sa\u00edda da fun\u00e7\u00e3o, fica assim: 1 2 3 4 5 diasMes :: Int -> Int diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 Exerc\u00edcios Defina o prot\u00f3tipo da fun\u00e7\u00e3o de convers\u00e3o de Fahrenheit para Celsius f2c x = ( x - 32 ) / 1.8 Descubra a quanto 100f corresponde em C\u00e9lsius Resolu\u00e7\u00e3o 1 2 f2c :: Float -> Float ` f2c x = ( x - 32 ) / 1.8 Defina o prot\u00f3tipo da fun\u00e7\u00e3o de media de dois n\u00fameros reais m2n a b = ( a + b ) / 2 Resolu\u00e7\u00e3o 1 2 m2n :: Float -> Float -> Float m2n a b = ( a + b ) / 2 Defina o prot\u00f3tipo da soma de dois n\u00fameros inteiros soma2int a b = a + b Aplique a fun\u00e7\u00e3o aos valores 2 e 3. Aplique a fun\u00e7\u00e3o aos valores 2.0 e 3.0. Resolu\u00e7\u00e3o 1 2 soma2int :: Int -> Int -> Int soma2int a b = a + b Defina o prot\u00f3tipo da soma de dois n\u00fameros reais soma2reais a b = a + b Aplique a fun\u00e7\u00e3o aos valores 2.0 e 3.0. Aplique a fun\u00e7\u00e3o aos valores 2 e 3. Resolu\u00e7\u00e3o 1 soma2reais :: Float -> Float -> Float Explique a diferen\u00e7a de comportamento das duas \u00faltimas fun\u00e7\u00f5es. Resolu\u00e7\u00e3o As fun\u00e7\u00f5es se comportam diferentemente, sendo que a primeira mostra um erro quando aplicada a dois n\u00fameros reais, porqu\u00ea \\(Z \\subset R\\) mas \\(R \\not\\subset Z\\) . Defini\u00e7\u00e3o de novos tipos A palavra reservada type permite que definamos apelidos para tipos no Haskell, tornando o c\u00f3digo mais leg\u00edvel. Por exemplo, podemos definir um tipo Inteiro similar ao tipo Int e fun\u00e7\u00f5es associadas ao tipo. 1 2 3 4 type Inteiro = Int somaInteiros :: Inteiro -> Inteiro -> Inteiro somaInteiros a b = a + b O uso da fun\u00e7\u00e3o \u00e9 como esperado. 1 2 3 4 * Main > somaInteiros 1 2 3 * Main > somaInteiros ( 1 :: Inteiro ) ( 2 :: Inteiro ) 3 :type e :info O GHC \u00e9 uma ferramenta poderosa no aprendizado da linguagem Haskell por possuir uma s\u00e9rie de comandos que permitem extrair informa\u00e7\u00f5es sobre tipos e fun\u00e7\u00f5es definidas. Usando o comando : info (ou simplesmente : i ), por exemplo, podemos perguntar ao ghci o que ele sabe sobre o tipo Inteiro , ao que ser\u00e1 respondido que \u00e9 o tipo inteiro \u00e9 um apelido para Int , definido no arquivo scratch.hs, no meu caso. 1 2 3 4 * Main > : i Inteiro type Inteiro :: * type Inteiro = Int -- Defined at scratch.hs:82:1 J\u00e1 o comando : type (ou : t ) pode ser usado para identificar o tipo de fun\u00e7\u00f5es, por exemplo: 1 2 3 4 5 6 * Main > somaInteiros 1 2 3 * Main > : i somaInteiros somaInteiros :: Inteiro -> Inteiro -> Inteiro * Main > : t 1 :: Inteiro 1 :: Inteiro :: Inteiro Estes comandos podem ser aplicados a quaisquer defini\u00e7\u00f5es, n\u00e3o somente \u00e0s suas. Por exemplo, podemos solicitar informa\u00e7\u00f5es sobre o tipo Num , com seguinte resultado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 * Main > : i Num type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ( - ) :: a -> a -> a ( * ) :: a -> a -> a negate :: a -> a abs :: a -> a signum :: a -> a fromInteger :: Integer -> a {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-} -- Defined in \u2018GHC.Num\u2019 instance Num Word -- Defined in \u2018GHC.Num\u2019 instance Num Integer -- Defined in \u2018GHC.Num\u2019 instance Num Int -- Defined in \u2018GHC.Num\u2019 instance Num Float -- Defined in \u2018GHC.Float\u2019 instance Num Double -- Defined in \u2018GHC.Float\u2019 Algumas das informa\u00e7\u00f5es apresentadas podem ainda n\u00e3o fazer sentido para voc\u00ea, mas de forma geral podemos resum\u00ed-las como implicando que algumas opera\u00e7\u00f5es, como + , - e abs se aplicam ao tipo Num , e que outros tipos, como Float e Integer s\u00e3o inst\u00e2ncias de Num . Se aplicarmos o mesmo comando ao operador + , descobriremos que ele \u00e9 uma fun\u00e7\u00e3o infixa por padr\u00e3o ( INFIXl ), associativo \u00e0 esquerda ( infixL ), e com prioridade 6. 1 2 3 4 5 6 7 * Main > : i ( + ) type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ... -- Defined in \u2018GHC.Num\u2019 infixl 6 + Tamb\u00e9m vemos que o estas defini\u00e7\u00f5es s\u00e3o parde do GHC.Num, mas o que \u00e9 o GHC.Num? M\u00f3dulos Como em diversas outras linguagens, Haskell usa m\u00f3dulos para organizar a defini\u00e7\u00e3o de tipos e fun\u00e7\u00f5es, colocando aquelas relacionadas no mesmo m\u00f3dulo. Por padr\u00e3o, o m\u00f3dulo prelude 5 \u00e9 carregado toda vez que executa o ghci ou compila um programa, a n\u00e3o ser que seja explicitamente indicado em contr\u00e1rio. Este m\u00f3dulo cont\u00e9m a defini\u00e7\u00e3o dos tipos e operadores b\u00e1sicos vistos anteriormente, al\u00e9m de muitos outros, e o GHC.Num \u00e9 parte do Prelude. Uma pequena mas interessante amostra de outros tipos inclu\u00eddos: Nome Defini\u00e7\u00e3o min Menor de 2 elementos orden\u00e1veis max Maior de 2 elementos orden\u00e1veis Semigroup Uma classe em que vale a associatividade Monoid Mon\u00f3ide em que h\u00e1 um elemento identidade putChar Escreve um caractere na saida padr\u00e3o putString Escreve uma string na saida padr\u00e3o getChar L\u00ea um caractere da entrada padr\u00e3o getString L\u00ea uma string da entrada padr\u00e3o Estes exemplos servem para mostrar como o m\u00f3dulo mais b\u00e1sico do Haskell \u00e9 diverso e como a sua biblioteca \u00e9 mais diversa ainda. Al\u00e9m do Prelude, centenas de outros m\u00f3dulos est\u00e3o dispon\u00edveis na Web, de compiladores a geradores de gr\u00e1ficos 3D, de transformadas r\u00e1pidas de Fourier a message brokers , em reposit\u00f3rios como o Hackage. 4 Contudo, \u00e9 preciso ter cuidado com os m\u00f3dulos que baixa. Caso voc\u00ea encontre um m\u00f3dulo que queira usar, de nome X , bastar baix\u00e1-lo e usar o import . Por exemplo, para trabalhar com n\u00fameros complexos, voce pode usar o m\u00f3dulo Data . Complex assim: 1 2 3 4 Prelude > import Data.Complex Prelude Data . Complex > let x = 1.0 :+ 0.0 Prelude Data . Complex > x 1.0 :+ 0.0 Com esta visita r\u00e1pida ao Prelude, encerramos esta introdu\u00e7\u00e3o ao Haskell e rumamos para t\u00f3picos mais universais. Isto \u00e9, mesmo que os t\u00f3picos vistos at\u00e9 agora sejam obviamente associados \u00e0 programa\u00e7\u00e3o funcional, os mesmos est\u00e3o fortemente relacionados \u00e0 sintaxe do Haskell. J\u00e1 nas pr\u00f3ximas se\u00e7\u00f5es, veremos t\u00f3picos mais independentes, i.e., mesmo que as fun\u00e7\u00f5es, tipos e construtos usados ainda sejam implementadas em Haskell, os conceitos por tr\u00e1s s\u00e3o mais universais. Operadores s\u00e3o fun\u00e7\u00f5es cujos nomes s\u00f3 contem caracteres especiais. Eles s\u00e3o naturalmente infixos. \u21a9 Observe que o o -10 est\u00e1 entre par\u00eanteses n\u00e3o porque o operador demanda, mas para deixar claro que o - faz parte do n\u00famero. \u21a9 \u21a9 Haskell define tamb\u00e9m o tipo Text, uma forma mais moderna de manipular texto, mas n\u00e3o discutiremos Text aqui. \u21a9 https://hackage.haskell.org/packages/browse \u21a9 Prelude: https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html \u21a9","title":"Tipos"},{"location":"types/#tipos","text":"Seja a fun\u00e7\u00e3o diasMes a fun\u00e7\u00e3o que calcula a quantidade de dias em um m\u00eas, dado o n\u00famero do m\u00eas, definida assim: 1 2 3 4 diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 O que acontece se voc\u00ea passar 7.2 para a fun\u00e7\u00e3o? O resultado est\u00e1 correto? Isso nos leva a perguntar como definir que uma fun\u00e7\u00e3o s\u00f3 \u00e9 aplic\u00e1vel a n\u00fameros inteiros, do tipo inteiro. Em linguagens de programa\u00e7\u00e3o, um tipo \u00e9 um nome dado a uma cole\u00e7\u00e3o de valores que tem um mesmo comportamento na linguagem. Na linguagem C, por exemplo, temos os tipos int e short , ambos associados a valores inteiros mas com n\u00famero de bits diferentes usados para represent\u00e1-los. Algumas linguagens s\u00e3o denominadas fracamente tipadas , o que quer dizer que o uso de tipos \u00e9 relaxado e pode at\u00e9 ser alterado em tempo de execu\u00e7\u00e3o. Por exemplo, no seguinte c\u00f3digo em Python a vari\u00e1vel x assume tr\u00eas tipos diferentes em momentos diferentes da execu\u00e7\u00e3o. 1 2 3 4 5 6 7 8 x = \"lala\" print ( type ( x )) x = 10 print ( type ( x )) x = 10.0 print ( type ( x )) 1 2 3 <class 'str' > <class 'int' > <class 'float' > J\u00e1 a linguagem Haskell \u00e9 o que chamamos de fortemente tipada , o que quer dizer que toda vari\u00e1vel, constante ou fun\u00e7\u00e3o tem apenas um tipo e este sempre pode ser determinado. Al\u00e9m disso, Haskell \u00e9 estaticamente tipada , ou seja, os tipos s\u00e3o determinados em tempo de compila\u00e7\u00e3o, em oposi\u00e7\u00e3o a linguagens que determinam o tipo durante a execu\u00e7\u00e3o do programa, denominadas dinamicamente tipadas. Assim como type em Python, Haskell tem a fun\u00e7\u00e3o : type para verificar o tipo de uma vari\u00e1vel. Por exemplo: 1 2 3 4 5 6 > : type 1 1 :: Num p => p > : type 1.0 1.0 :: Fractional p => p > : type \"Bom dia\" \"Bom dia\" :: [ Char ] Tipos em Haskell Forte Est\u00e1ticos Por Infer\u00eancia Finalmente, se olharmos novamente para os exemplos de fun\u00e7\u00f5es anteriores, veremos que n\u00e3o foram definidos tipos em suas declara\u00e7\u00f5es; isto \u00e9 poss\u00edvel porqu\u00ea Haskell consegue inferir os tipos dos dados de forma muito eficiente. Quando voc\u00ea explicita tipos, o faz apenas para facilitar a leitura do c\u00f3digo e para indicar sua inten\u00e7\u00e3o ao compilador que, pode-se dizer, far\u00e1 a infer\u00eancia e testar\u00e1 se voc\u00ea est\u00e1 certo. Haskell tem um n\u00famero imenso de tipos pre-definidos, organizados hierarquicamente, e que podem ser usados para definir novos tipos pelo programador. Mas por enquanto, nos foquemos nos tipos mais simples.","title":"Tipos"},{"location":"types/#tipos-primitivos-e-operadores","text":"","title":"Tipos Primitivos e Operadores"},{"location":"types/#prototipo-de-funcoes","text":"Agora que j\u00e1 conhecemos alguns tipos, podemos ver como us\u00e1-los na defini\u00e7\u00e3o de fun\u00e7\u00f5es. Para faz\u00ea-lo, devemos usar a seguinte sintaxe: 1 2 nomeFuncao :: tipo_arg1 -> ... -> tipo_argN -> tipo_saida nomeFuncao arg1 ... argN = < definicao > Por exemplo, o prot\u00f3tipo da fun\u00e7\u00e3o diaMes , isto \u00e9, a defini\u00e7\u00e3o dos tipos de entrada e sa\u00edda da fun\u00e7\u00e3o, fica assim: 1 2 3 4 5 diasMes :: Int -> Int diasMes m | m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12 = 31 | m == 2 = 28 | otherwise = 30 Exerc\u00edcios Defina o prot\u00f3tipo da fun\u00e7\u00e3o de convers\u00e3o de Fahrenheit para Celsius f2c x = ( x - 32 ) / 1.8 Descubra a quanto 100f corresponde em C\u00e9lsius Resolu\u00e7\u00e3o 1 2 f2c :: Float -> Float ` f2c x = ( x - 32 ) / 1.8 Defina o prot\u00f3tipo da fun\u00e7\u00e3o de media de dois n\u00fameros reais m2n a b = ( a + b ) / 2 Resolu\u00e7\u00e3o 1 2 m2n :: Float -> Float -> Float m2n a b = ( a + b ) / 2 Defina o prot\u00f3tipo da soma de dois n\u00fameros inteiros soma2int a b = a + b Aplique a fun\u00e7\u00e3o aos valores 2 e 3. Aplique a fun\u00e7\u00e3o aos valores 2.0 e 3.0. Resolu\u00e7\u00e3o 1 2 soma2int :: Int -> Int -> Int soma2int a b = a + b Defina o prot\u00f3tipo da soma de dois n\u00fameros reais soma2reais a b = a + b Aplique a fun\u00e7\u00e3o aos valores 2.0 e 3.0. Aplique a fun\u00e7\u00e3o aos valores 2 e 3. Resolu\u00e7\u00e3o 1 soma2reais :: Float -> Float -> Float Explique a diferen\u00e7a de comportamento das duas \u00faltimas fun\u00e7\u00f5es. Resolu\u00e7\u00e3o As fun\u00e7\u00f5es se comportam diferentemente, sendo que a primeira mostra um erro quando aplicada a dois n\u00fameros reais, porqu\u00ea \\(Z \\subset R\\) mas \\(R \\not\\subset Z\\) .","title":"Prot\u00f3tipo de fun\u00e7\u00f5es"},{"location":"types/#definicao-de-novos-tipos","text":"A palavra reservada type permite que definamos apelidos para tipos no Haskell, tornando o c\u00f3digo mais leg\u00edvel. Por exemplo, podemos definir um tipo Inteiro similar ao tipo Int e fun\u00e7\u00f5es associadas ao tipo. 1 2 3 4 type Inteiro = Int somaInteiros :: Inteiro -> Inteiro -> Inteiro somaInteiros a b = a + b O uso da fun\u00e7\u00e3o \u00e9 como esperado. 1 2 3 4 * Main > somaInteiros 1 2 3 * Main > somaInteiros ( 1 :: Inteiro ) ( 2 :: Inteiro ) 3","title":"Defini\u00e7\u00e3o de novos tipos"},{"location":"types/#type-e-info","text":"O GHC \u00e9 uma ferramenta poderosa no aprendizado da linguagem Haskell por possuir uma s\u00e9rie de comandos que permitem extrair informa\u00e7\u00f5es sobre tipos e fun\u00e7\u00f5es definidas. Usando o comando : info (ou simplesmente : i ), por exemplo, podemos perguntar ao ghci o que ele sabe sobre o tipo Inteiro , ao que ser\u00e1 respondido que \u00e9 o tipo inteiro \u00e9 um apelido para Int , definido no arquivo scratch.hs, no meu caso. 1 2 3 4 * Main > : i Inteiro type Inteiro :: * type Inteiro = Int -- Defined at scratch.hs:82:1 J\u00e1 o comando : type (ou : t ) pode ser usado para identificar o tipo de fun\u00e7\u00f5es, por exemplo: 1 2 3 4 5 6 * Main > somaInteiros 1 2 3 * Main > : i somaInteiros somaInteiros :: Inteiro -> Inteiro -> Inteiro * Main > : t 1 :: Inteiro 1 :: Inteiro :: Inteiro Estes comandos podem ser aplicados a quaisquer defini\u00e7\u00f5es, n\u00e3o somente \u00e0s suas. Por exemplo, podemos solicitar informa\u00e7\u00f5es sobre o tipo Num , com seguinte resultado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 * Main > : i Num type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ( - ) :: a -> a -> a ( * ) :: a -> a -> a negate :: a -> a abs :: a -> a signum :: a -> a fromInteger :: Integer -> a {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-} -- Defined in \u2018GHC.Num\u2019 instance Num Word -- Defined in \u2018GHC.Num\u2019 instance Num Integer -- Defined in \u2018GHC.Num\u2019 instance Num Int -- Defined in \u2018GHC.Num\u2019 instance Num Float -- Defined in \u2018GHC.Float\u2019 instance Num Double -- Defined in \u2018GHC.Float\u2019 Algumas das informa\u00e7\u00f5es apresentadas podem ainda n\u00e3o fazer sentido para voc\u00ea, mas de forma geral podemos resum\u00ed-las como implicando que algumas opera\u00e7\u00f5es, como + , - e abs se aplicam ao tipo Num , e que outros tipos, como Float e Integer s\u00e3o inst\u00e2ncias de Num . Se aplicarmos o mesmo comando ao operador + , descobriremos que ele \u00e9 uma fun\u00e7\u00e3o infixa por padr\u00e3o ( INFIXl ), associativo \u00e0 esquerda ( infixL ), e com prioridade 6. 1 2 3 4 5 6 7 * Main > : i ( + ) type Num :: * -> Constraint class Num a where ( + ) :: a -> a -> a ... -- Defined in \u2018GHC.Num\u2019 infixl 6 + Tamb\u00e9m vemos que o estas defini\u00e7\u00f5es s\u00e3o parde do GHC.Num, mas o que \u00e9 o GHC.Num?","title":":type e :info"},{"location":"types/#modulos","text":"Como em diversas outras linguagens, Haskell usa m\u00f3dulos para organizar a defini\u00e7\u00e3o de tipos e fun\u00e7\u00f5es, colocando aquelas relacionadas no mesmo m\u00f3dulo. Por padr\u00e3o, o m\u00f3dulo prelude 5 \u00e9 carregado toda vez que executa o ghci ou compila um programa, a n\u00e3o ser que seja explicitamente indicado em contr\u00e1rio. Este m\u00f3dulo cont\u00e9m a defini\u00e7\u00e3o dos tipos e operadores b\u00e1sicos vistos anteriormente, al\u00e9m de muitos outros, e o GHC.Num \u00e9 parte do Prelude. Uma pequena mas interessante amostra de outros tipos inclu\u00eddos: Nome Defini\u00e7\u00e3o min Menor de 2 elementos orden\u00e1veis max Maior de 2 elementos orden\u00e1veis Semigroup Uma classe em que vale a associatividade Monoid Mon\u00f3ide em que h\u00e1 um elemento identidade putChar Escreve um caractere na saida padr\u00e3o putString Escreve uma string na saida padr\u00e3o getChar L\u00ea um caractere da entrada padr\u00e3o getString L\u00ea uma string da entrada padr\u00e3o Estes exemplos servem para mostrar como o m\u00f3dulo mais b\u00e1sico do Haskell \u00e9 diverso e como a sua biblioteca \u00e9 mais diversa ainda. Al\u00e9m do Prelude, centenas de outros m\u00f3dulos est\u00e3o dispon\u00edveis na Web, de compiladores a geradores de gr\u00e1ficos 3D, de transformadas r\u00e1pidas de Fourier a message brokers , em reposit\u00f3rios como o Hackage. 4 Contudo, \u00e9 preciso ter cuidado com os m\u00f3dulos que baixa. Caso voc\u00ea encontre um m\u00f3dulo que queira usar, de nome X , bastar baix\u00e1-lo e usar o import . Por exemplo, para trabalhar com n\u00fameros complexos, voce pode usar o m\u00f3dulo Data . Complex assim: 1 2 3 4 Prelude > import Data.Complex Prelude Data . Complex > let x = 1.0 :+ 0.0 Prelude Data . Complex > x 1.0 :+ 0.0 Com esta visita r\u00e1pida ao Prelude, encerramos esta introdu\u00e7\u00e3o ao Haskell e rumamos para t\u00f3picos mais universais. Isto \u00e9, mesmo que os t\u00f3picos vistos at\u00e9 agora sejam obviamente associados \u00e0 programa\u00e7\u00e3o funcional, os mesmos est\u00e3o fortemente relacionados \u00e0 sintaxe do Haskell. J\u00e1 nas pr\u00f3ximas se\u00e7\u00f5es, veremos t\u00f3picos mais independentes, i.e., mesmo que as fun\u00e7\u00f5es, tipos e construtos usados ainda sejam implementadas em Haskell, os conceitos por tr\u00e1s s\u00e3o mais universais. Operadores s\u00e3o fun\u00e7\u00f5es cujos nomes s\u00f3 contem caracteres especiais. Eles s\u00e3o naturalmente infixos. \u21a9 Observe que o o -10 est\u00e1 entre par\u00eanteses n\u00e3o porque o operador demanda, mas para deixar claro que o - faz parte do n\u00famero. \u21a9 \u21a9 Haskell define tamb\u00e9m o tipo Text, uma forma mais moderna de manipular texto, mas n\u00e3o discutiremos Text aqui. \u21a9 https://hackage.haskell.org/packages/browse \u21a9 Prelude: https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html \u21a9","title":"M\u00f3dulos"},{"location":"code/where_let_in/","text":"where \u00e9 usado em fib2.hs let?","title":"Where let in"}]}